
Alas, where there is no OS, there can be no loader or dynamic imports.
Execution is constrained to opcodes found in the IDB.
This precludes emulating routines that call imported string functions or memory allocators.
Tom Bennett’s flare-emu ships with emulated versions of these, but for off-the-cuff analysis (especially when I don’t know if there will be a payoff), I prefer interactively examining registers and memory to adjust my tactics ad hoc.
What if I could bring my own imported functions to Bochs like flare-emu does?
I’ve devised such a technique, and I call it code grafting.
In this post I’ll discuss the particulars of statically linking stand-ins for common functions into an IDB to get more mileage out of Bochs.
I’ll demonstrate using this on an EVILNEST sample to unpack and dump next-stage payloads from emulated memory.
I’ll also show how I copied a tricky call sequence from one IDB to another IDB
so I could keep the unpacking process all in a single Bochs debug session.