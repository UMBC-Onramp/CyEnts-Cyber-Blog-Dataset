
In the VirtualAlloc entry, the symbolic constant string PAGE_EXECUTE_READWRITE replaces the value 0x40 .
In the GetModuleFileNameA and CreateFileA entries, pointer values are replaced with a file path.
KERNEL32.VirtualAlloc(0x0, 0x2b400, 0x3000, \"PAGE_EXECUTE_READWRITE\") -> 0x7c000 KERNEL32.GetModuleFileNameA(0x0, \"C:\\\\Windows\\\\system32\\\\sample.exe\", 0x104) -> 0x58 KERNEL32.CreateFileA(\"C:\\\\Windows\\\\system32\\\\sample.exe\", \"GENERIC_READ\", 0x1, 0x0, \"OPEN_EXISTING\", 0x80, 0x0) -> 0x84 Figure 7: Speakeasy API logs Saving the Unpacked Code Address Packed samples often use functions such as VirtualAlloc to allocate memory used to store the unpacked sample.
An effective approach for capturing the location and size of the unpacked code is to first hook the memory allocation function used by the unpacking stub.
Figure 8 shows an example of hooking VirtualAlloc to capture the virtual address and amount of memory being allocated by the API call.
1: def virtualalloc_hook(self, emu, api_name, func, params): 2:     ''' 3:     LPVOID VirtualAlloc( 4:        LPVOID lpAddress, 5:        SIZE_T dwSize, 6:        DWORD  flAllocationType, 7:        DWORD  flProtect 8:      ); 9:     ''' 10:    PAGE_EXECUTE_READWRITE = 0x40 11:    lpAddress, dwSize, flAllocationType, flProtect = params 12:    rv = func(params) 13:    if lpAddress == 0