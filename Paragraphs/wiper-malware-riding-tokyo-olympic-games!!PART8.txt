
For example, the non-wiper (July 17 th ) sample includes the following code.
Essentially, what this means is that for certain functions, such as Enum_Procs, Check_Debuggers, and Check_VMX (seen in the above screenshot), the malware checks the first 5 bytes to see if it contains the “0xCC” opcode.
This x86 assembly instruction stands for INT3, which tells debuggers to temporarily stop a running program.
This method works as another anti-debug check because it detects to see if this function has been disabled.
The wiper (July 20 th ) version of this malware goes a step further.
Aside from checking for “0xCC”, it also checks for others such as “0xEB” (call), “0xE8” (jmp), and “0xE9” (jmp).
These instructions divert program flow away from the intended flow created by the original programmer.
One reason to divert program flow is to hook and monitor Windows APIs.
An API monitor can report what a program is doing while it is running, saving researchers a lot of reverse engineering time and effort.
However, if any of this code has been modified to enable monitoring, the wiper exits without performing any malicious activities.