
This index seems rather large and leads to the crash.
Why does it crash the program?
Further parsing the file, we find the names of the two indexes: Debugging With a debugger attached, we can see that first program calls the function “msrd3x40!operator new.”
This allocates memory that stores the memory pointer address in eax: After the memory is allocated, the program creates the new index: This index number is used later in the execution.
The function msrd3x40!Index::Restore copies that index number to the index address + 24h.
This process is repeated in a loop for all indexes.
First it calls the “new” operator, which allocates the memory.
It then creates an index on that address and moves the index number to the base address of the index +24h.
We see this move in the following code, which shows the malicious index value copied to newly created index: Once successfully moved, the function msrd3x40!NamedObject::Rename is called and copies the index name value to the index address +40h:
If we look at the esi register, we see it points to the address of the index.
The ecx register has a value of [esi+24h], which is the index number: