
api_addresses = self.get_dyn_imports() Figure 13: Retrieving dynamic imports Otherwise, you can query the emulator class to retrieve its symbol information by calling the get_symbols function as shown in Figure 14.
symbols = self.get_symbols() Figure 14:
Retrieve symbol information from emulator class This data can be used to discover the IAT of the unpacked PE and fix or reconstruct its import related tables.
Putting It All Together Writing a Speakeasy script to unpack a malware sample can be broken down into the following steps: Reverse engineer the unpacking stub to identify: 1) where the unpacked code will reside or where its memory is allocated, 2) where execution is transferred to the unpacked code, and 3) any problematic code that may introduce issues such as unsupported APIs, slow emulation, or anti-analysis checks.
If necessary, set hooks to bypass problematic code.
Set a hook to identify the virtual address and, optionally, the size of the unpacked binary.
Set a hook to stop emulation at, or after, execution of the original entry point of the unpacked code.
Collect virtual addresses of Windows APIs and reconstruct the PE’s import table.
Fix the PE’s headers (if applicable) and write the bytes to a file for further analysis.
For an example of a script that unpacks UPX samples, check out the UPX unpacking script in the Speakeasy repository.
Conclusion The Speakeasy framework provides an easy-to-use, flexible, and powerful programming interface that enables analysts to solve complex problems such as unpacking malware.
Using Speakeasy to automate these solutions allows them to be performed at scale.
I hope you enjoyed this introduction to automating the Speakeasy framework and are inspired to begin using it to implement your own malware analysis solutions!
Subscribe to Blogs Get email updates as new blog posts are added.


