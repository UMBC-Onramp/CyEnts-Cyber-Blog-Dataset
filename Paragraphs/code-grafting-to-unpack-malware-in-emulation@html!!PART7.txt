
Figure 7 shows the result of patching these functions and data into the IDB and naming each location (stub functions are prefixed with stub_ ).
Figure 7:
Data and code injected into IDB The script then iterates all the relevant calls in the binary and patches them with calls to their stub implementations in the newly added segment.
As shown in Figure 8, IDAPythonâ€™s Assemble function saved the effort of calculating the offset for the call operand manually.
Note that the Assemble function worked well here, but for bigger tasks, Hex-Rays recommends a dedicated assembler such as Keystone Engine and its Keypatch plugin for IDA Pro.