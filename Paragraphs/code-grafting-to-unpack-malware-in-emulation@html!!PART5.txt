
The nonstandard function opcodes at the bottom of the figure were hand-assembled as tersely as possible to generically return specific values and manipulate the stack (or not) in conformance with calling conventions.
Figure 4: Extracted function opcodes On top of simple functions like memcpy , I implemented a memory allocator.
The allocator referenced global state data, meaning I couldn’t just inject it into an IDB and expect it to work.
I read the disassembly to find references to global operands and templatize them for use with Python’s format method.
Figure 5 shows an example for malloc .
Figure 5: HeapAlloc template code I organized the stubs by name as shown in Figure 6 both to call out functions I would need to patch, and to conveniently add more function stubs as I encounter use cases for them.