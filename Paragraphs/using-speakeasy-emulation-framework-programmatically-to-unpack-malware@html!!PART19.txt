
The self.module attribute was previously set in the example code shown in Figure 2.
It being subclassed from the PE class of pefile allows us to access useful functions such as get_rva_from_offset() on line 3.
This line also includes an example of using self.module.get_base() to retrieve the module's base virtual address.
Finally, on line 4, the instruction pointer is changed using the set_pc function and emulation continues at the unpacking code.
The code snippets in Figure 10 and Figure 11 allowed us to redirect execution to the unpacking code after the C-runtime initialization completed and avoid MFC initialization code.
Dumping and Fixing Unpacked PEs Once emulation has reached the original entry point of the unpacked sample, it is time to dump the PE and fix it up.
Typically, a hook would save the base address of the unpacked PE in an attribute of the class as illustrated on line 15 of Figure 8.
If the unpacked PE does not contain the correct entry point in its PE headers, the true entry point may also need to be captured during emulation.
Figure 12 shows an example of how to dump emulator memory to a file.
with open(self.output_path, \"wb\") as up: mm = self.get_address_map(self.dump_addr) up.write(self.mem_read(mm.get_base(), mm.get_size()))